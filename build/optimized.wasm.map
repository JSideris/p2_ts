{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","assembly/index.ts","assembly/math/vec2.ts","assembly/utils/utils.ts","assembly/equations/equation.ts","assembly/solver/solver.ts","assembly/material/material.ts","assembly/shapes/shape.ts","assembly/equations/contact-equation.ts","~lib/arraybuffer.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/typedarray.ts","assembly/material/contact-material.ts","assembly/collision/broadphase.ts","assembly/shapes/circle.ts","assembly/shapes/convex.ts","assembly/shapes/capsule.ts","assembly/shapes/plane.ts","assembly/material/Material.ts","assembly/shapes/line.ts","assembly/shapes/heightfield.ts","assembly/collision/narrowphase.ts","~lib/rt.ts","~lib/array.ts","~lib/math.ts","assembly/math/polyk.ts","assembly/constraints/constraint.ts","assembly/world/world.ts","assembly/events/event-emitter.ts","assembly/shapes/Convex.ts","assembly/math/poly-decomp.ts","assembly/objects/body.ts","assembly/collision/ray.ts","assembly/equations/Equation.ts","assembly/constraints/distance-constraint.ts","assembly/objects/linear-spring.ts","assembly/collision/aabb.ts","~lib/number.ts","assembly/equations/angle-lock-equation.ts","~lib/string.ts","assembly/collision/raycast-result.ts","~lib/map.ts","~lib/util/hash.ts","assembly/utils/contact-equation-pool.ts","assembly/equations/distance-equation.ts","assembly/equations/friction-equation.ts","assembly/utils/friction-equation-pool.ts","assembly/solver/gs-solver.ts","~lib/util/sort.ts","~lib/builtins.ts","assembly/utils/tuple-dictionary.ts","assembly/shapes/box.ts","assembly/collision/naive-broadphase.ts","assembly/shapes/particle.ts","assembly/shapes/Box.ts","assembly/equations/rotational-velocity-equation.ts","assembly/collision/sap-broadphase.ts","assembly/objects/spring.ts","assembly/objects/rotational-spring.ts","assembly/world/union-find.ts","assembly/utils/overlap-keeper.ts","assembly/utils/overlap-keeper-record-pool.ts","assembly/utils/overlap-keeper-record.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n//  Common block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -16\n// \n//                            GC info                              -12\n// \n//                           runtime id                            -8\n// \n//                          runtime size                           -4\n// \n//                               ...                               ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\nimport { TypeinfoFlags } from \"shared/typeinfo\";\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\n\n// === A Pure Reference Counting Garbage Collector ===\n// see: https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\n\n//  GC Info structure \n//   3                   2                   1                    \n// 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n// \n// Bcolor                     refCount                          \n// \n// B: buffered\n\n// @ts-ignore: decorator\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\n// @ts-ignore: decorator\n@inline const COLOR_BITS = 3;\n// @ts-ignore: decorator\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\n// @ts-ignore: decorator\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\n\n//  Colors \n//  Color   Meaning                                              \n// \n//  BLACK   In use or free                                       \n//  GRAY    Possible member of cycle                             \n//  WHITE   Member of garbage cycle                              \n//  PURPLE  Possible root of cycle                               \n//  RED     Candidate cycle undergoing -computation *concurrent \n//  ORANGE  Candidate cycle awaiting epoch boundary  *concurrent \n// \n// Acyclic detection has been decoupled, hence no GREEN.\n\n// @ts-ignore: decorator\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\n// @ts-ignore: decorator\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\n// @ts-ignore: decorator\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\n\n// @ts-ignore: decorator\n@inline const VISIT_DECREMENT = 1; // guard 0\n// @ts-ignore: decorator\n@inline const VISIT_MARKGRAY = 2;\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 3;\n// @ts-ignore: decorator\n@inline const VISIT_SCANBLACK = 4;\n// @ts-ignore: decorator\n@inline const VISIT_COLLECTWHITE = 5;\n\n// @ts-ignore: decorator\n@global @unsafe @lazy\nfunction __visit(ref: usize, cookie: i32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  if (ref < __heap_base) return;\n  if (isDefined(__GC_ALL_ACYCLIC)) {\n    if (DEBUG) assert(cookie == VISIT_DECREMENT);\n    decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\n  } else {\n    let s = changetype<Block>(ref - BLOCK_OVERHEAD);\n    switch (cookie) {\n      case VISIT_DECREMENT: {\n        decrement(s);\n        break;\n      }\n      case VISIT_MARKGRAY: {\n        if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\n        s.gcInfo = s.gcInfo - 1;\n        markGray(s);\n        break;\n      }\n      case VISIT_SCAN: {\n        scan(s);\n        break;\n      }\n      case VISIT_SCANBLACK: {\n        let info = s.gcInfo;\n        assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n        s.gcInfo = info + 1;\n        if ((info & COLOR_MASK) != COLOR_BLACK) {\n          scanBlack(s);\n        }\n        break;\n      }\n      case VISIT_COLLECTWHITE: {\n        collectWhite(s);\n        break;\n      }\n      default: if (DEBUG) assert(false);\n    }\n  }\n}\n\n/** Increments the reference count of the specified block by one.*/\nfunction increment(s: Block): void {\n  var info = s.gcInfo;\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\n  s.gcInfo = info + 1;\n  if (isDefined(ASC_RTRACE)) onincrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n}\n\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\n// @ts-ignore: decorator\n@lazy\nfunction decrement(s: Block): void {\n  var info = s.gcInfo;\n  var rc = info & REFCOUNT_MASK;\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\n  if (rc == 1) {\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      if (DEBUG) assert(!(info & BUFFERED_MASK));\n      finalize(s);\n    } else {\n      if (!(info & BUFFERED_MASK)) {\n        finalize(s);\n      } else {\n        s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\n      }\n    }\n  } else {\n    if (DEBUG) assert(rc > 0);\n    if (isDefined(__GC_ALL_ACYCLIC)) {\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n    } else {\n      if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\n        s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\n        if (!(info & BUFFERED_MASK)) {\n          appendRoot(s);\n        }\n      } else {\n        s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\n      }\n    }\n  }\n}\n\n/** Finalizes the specified block, giving it back to the memory manager. */\nfunction finalize(s: Block): void {\n  if (isDefined(__finalize)) {\n    __finalize(changetype<usize>(s) + BLOCK_OVERHEAD);\n  }\n  freeBlock(ROOT, s);\n}\n\n/** Buffer of possible roots. */\n// @ts-ignore: decorator\n@lazy var ROOTS: usize;\n/** Current absolute offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var CUR: usize = 0;\n/** Current absolute end offset into the `ROOTS` buffer. */\n// @ts-ignore: decorator\n@lazy var END: usize = 0;\n\n/** Appends a block to possible roots. */\nfunction appendRoot(s: Block): void {\n  var cur = CUR;\n  if (cur >= END) {\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\n    cur = CUR;\n  }\n  store<Block>(cur, s);\n  CUR = cur + sizeof<usize>();\n}\n\n/** Grows the roots buffer if it ran full. */\nfunction growRoots(): void {\n  var oldRoots = ROOTS;\n  var oldSize = CUR - oldRoots;\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\n  var newRoots = __alloc(newSize, 0);\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n  memory.copy(newRoots, oldRoots, oldSize);\n  if (oldRoots) {\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\n    __free(oldRoots);\n  }\n  ROOTS = newRoots;\n  CUR = newRoots + oldSize;\n  END = newRoots + newSize;\n}\n\n/** Collects cyclic garbage. */\n// @ts-ignore: decorator\n@global @unsafe @lazy\nexport function __collect(): void {\n  if (isDefined(__GC_ALL_ACYCLIC)) return;\n\n  // markRoots\n  var roots = ROOTS;\n  var cur = roots;\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    let info = s.gcInfo;\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\n      markGray(s);\n      store<Block>(cur, s);\n      cur += sizeof<usize>();\n    } else {\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\n        finalize(s);\n      } else {\n        s.gcInfo = info & ~BUFFERED_MASK;\n      }\n    }\n  }\n  CUR = cur;\n\n  // scanRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    scan(load<Block>(pos));\n  }\n\n  // collectRoots\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\n    let s = load<Block>(pos);\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\n    collectWhite(s);\n  }\n  CUR = roots;\n}\n\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\nfunction markGray(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\n  }\n}\n\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\nfunction scan(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\n    if ((info & REFCOUNT_MASK) > 0) {\n      scanBlack(s);\n    } else {\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\n    }\n  }\n}\n\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\nfunction scanBlack(s: Block): void {\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\n}\n\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\nfunction collectWhite(s: Block): void {\n  var info = s.gcInfo;\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\n    finalize(s);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ptr: usize): usize {\n  if (ptr > __heap_base) increment(changetype<Block>(ptr - BLOCK_OVERHEAD));\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ptr: usize): void {\n  if (ptr > __heap_base) decrement(changetype<Block>(ptr - BLOCK_OVERHEAD));\n}\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\nimport { onfree, onalloc, onrealloc } from \"./rtrace\";\nimport { REFCOUNT_MASK } from \"./pure\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//  overhead   \n//                           size                           0LF  info\n//    \n//                                                                   \n//                ... additional runtime overhead ...                \n//                                                                   \n//           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                      = 0\n//    \n//                         if free: back                          \n//  payload   >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, right);\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\n      right = GETRIGHT(block);\n      rightInfo = right.mmInfo;\n      // 'back' is set below\n    }\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\n    if (newSize < BLOCK_MAXSIZE) {\n      removeBlock(root, left);\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\n      block = left;\n      // 'back' is set below\n    }\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    fl = inv - clz<usize>(size);\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) {\n    assert(\n      start <= end &&       // must be valid\n      !(start & AL_MASK) && // must be aligned\n      !(end & AL_MASK)      // must be aligned\n    );\n  }\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\n      start -= BLOCK_OVERHEAD;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\n}\n\n/** Initilizes the root structure. */\nexport function maybeInitialize(): Root {\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    root = changetype<Root>(rootOffset);\n    root.flMap = 0;\n    SETTAIL(root, changetype<Block>(0));\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      SETSL(root, fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        SETHEAD(root, fl, sl, null);\n      }\n    }\n    let memStart = (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK;\n    if (ASC_LOW_MEMORY_LIMIT) {\n      const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n      if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n      else unreachable(); // low memory limit already exceeded\n    } else {\n      addMemory(root, memStart, memory.size() << 16);\n    }\n    ROOT = root;\n  }\n  return root;\n}\n\n// @ts-ignore: decorator\n@lazy var collectLock: bool = false;\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize, id: u32): Block {\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    if (gc.auto) {\n      if (DEBUG) collectLock = true;\n      __collect();\n      if (DEBUG) collectLock = false;\n      block = searchBlock(root, payloadSize);\n      if (!block) {\n        growMemory(root, payloadSize);\n        block = changetype<Block>(searchBlock(root, payloadSize));\n        if (DEBUG) assert(block); // must be found now\n      }\n    } else {\n      growMemory(root, payloadSize);\n      block = changetype<Block>(searchBlock(root, payloadSize));\n      if (DEBUG) assert(block); // must be found now\n    }\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  block.gcInfo = 0; // RC=0\n  block.rtId = id;\n  block.rtSize = <u32>size;\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\n    prepareBlock(root, block, payloadSize);\n    block.rtSize = <u32>size;\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\n      // is immediately split though. does this trigger any assertions / issues?\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      block.rtSize = <u32>size;\n      prepareBlock(root, block, payloadSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  var newBlock = allocateBlock(root, size, block.rtId); // may invalidate cached blockInfo\n  newBlock.gcInfo = block.gcInfo; // keep RC\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onrealloc(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  block.mmInfo = blockInfo | FREE;\n  insertBlock(root, block);\n  if (isDefined(ASC_RTRACE)) onfree(block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ref: usize): Block {\n  var block = changetype<Block>(ref - BLOCK_OVERHEAD);\n  assert(\n    ref != 0 && !(ref & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE) &&        // must be used\n    !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize, id: u32): usize {\n  return changetype<usize>(\n    allocateBlock(maybeInitialize(), size, id)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ref: usize, size: usize): usize {\n  return changetype<usize>(\n    reallocateBlock(maybeInitialize(), checkUsedBlock(ref), size)\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ref: usize): void {\n  freeBlock(maybeInitialize(), checkUsedBlock(ref));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\n/** Garbage collector interface. */\nexport namespace gc {\n\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\n  export var auto: bool = true;\n\n  /** Performs a full garbage collection cycle. */\n  export function collect(): void {\n    __collect();\n  }\n}\n","\r\nconst version = \"0.0.1\";\r\n\r\nimport AABB from                          \"./collision/aabb\";\r\nimport AngleLockEquation from             \"./equations/angle-lock-equation\";\r\nimport Body from                          \"./objects/body\";\r\nimport Broadphase from                    \"./collision/broadphase\";\r\nimport Capsule from                       \"./shapes/capsule\";\r\nimport Circle from                        \"./shapes/circle\";\r\nimport Constraint from                    \"./constraints/constraint\";\r\nimport ContactEquation from               \"./equations/contact-equation\";\r\nimport ContactEquationPool from           \"./utils/contact-equation-pool\";\r\nimport ContactMaterial from               \"./material/contact-material\";\r\nimport Convex from                        \"./shapes/convex\";\r\nimport DistanceConstraint from            \"./constraints/distance-constraint\";\r\nimport Equation from                      \"./equations/equation\";\r\nimport EventEmitter from                  \"./events/event-emitter\";\r\nimport FrictionEquation from              \"./equations/friction-equation\";\r\nimport FrictionEquationPool from          \"./utils/friction-equation-pool\";\r\n//import GearConstraint from                \"./constraints/gear-constraint\";\r\nimport GSSolver from                      \"./solver/gs-solver\";\r\nimport Heightfield from                   \"./shapes/heightfield\";\r\nimport Line from                          \"./shapes/line\";\r\n//import LockConstraint from                \"./constraints/lock-constraint\";\r\nimport Material from                      \"./material/material\";\r\nimport Narrowphase from                   \"./collision/narrowphase\";\r\nimport NaiveBroadphase from               \"./collision/naive-broadphase\";\r\nimport Particle from                      \"./shapes/particle\";\r\nimport Plane from                         \"./shapes/plane\";\r\n//import Pool from                          \"./utils/pool\";\r\n//import RevoluteConstraint from            \"./constraints/revolute-constraint\";\r\n//import PrismaticConstraint from           \"./constraints/prismatic-constraint\";\r\nimport Ray from                           \"./collision/ray\";\r\nimport RaycastResult from                 \"./collision/raycast-result\";\r\nimport Box from                           \"./shapes/Box\";\r\nimport RotationalVelocityEquation from    \"./equations/rotational-velocity-equation\";\r\nimport SAPBroadphase from                 \"./collision/sap-broadphase\";\r\nimport Shape from                         \"./shapes/shape\";\r\nimport Solver from                        \"./solver/solver\";\r\nimport Spring from                        \"./objects/spring\";\r\n//import TopDownVehicle from                \"./objects/top-down-vehicle\";\r\nimport LinearSpring from                  \"./objects/linear-spring\";\r\nimport RotationalSpring from              \"./objects/rotational-spring\";\r\nimport Utils from                         \"./utils/utils\";\r\nimport World from                         \"./world/world\";\r\nimport vec2 from                          \"./math/vec2\";\r\nimport DistanceEquation from \"./equations/distance-equation\";\r\n\r\nexport {\r\n    AABB,\r\n    AngleLockEquation,\r\n//     Body,\r\n    Broadphase,\r\n    Capsule,\r\n    Circle,\r\n    Constraint,\r\n    ContactEquation,\r\n    ContactEquationPool,\r\n    ContactMaterial,\r\n    Convex,\r\n    DistanceConstraint,\r\n    Equation,\r\n    EventEmitter,\r\n    FrictionEquation,\r\n    DistanceEquation,\r\n    FrictionEquationPool,\r\n//     //GearConstraint,\r\n    GSSolver,\r\n    Heightfield,\r\n    Line,\r\n//     //LockConstraint,\r\n    Material,\r\n    Narrowphase,\r\n    NaiveBroadphase,\r\n    Particle,\r\n    Plane,\r\n//     //RevoluteConstraint,\r\n//     //PrismaticConstraint,\r\n    Ray,\r\n    RaycastResult,\r\n    Box,\r\n    RotationalVelocityEquation,\r\n    SAPBroadphase,\r\n    Shape,\r\n    Solver,\r\n    Spring,\r\n//     //TopDownVehicle,\r\n    LinearSpring,\r\n    RotationalSpring,\r\n    Utils,\r\n    World,\r\n    vec2,\r\n    version,\r\n};\r\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.\n * @class vec2\n */\n\nclass Vec2\n{\n\t/**\n\t * Make a cross product and only return the z component\n\t * @method crossLength\n\t * @static\n\t * @param  {Array} a\n\t * @param  {Array} b\n\t * @return {Number}\n\t */\n\tcrossLength(a:Float32Array,b:Float32Array):f32{\n\t\treturn a[0] * b[1] - a[1] * b[0];\n\t};\n\n\t/**\n\t * Cross product between a vector and the Z component of a vector\n\t * @method crossVZ\n\t * @static\n\t * @param  {Array} out\n\t * @param  {Array} vec\n\t * @param  {Number} zcomp\n\t * @return {Array}\n\t */\n\tcrossVZ(out:Float32Array, vec:Float32Array, zcomp:f32):Float32Array{\n\t\tthis.rotate(out,vec,-Mathf.PI/2);// Rotate according to the right hand rule\n\t\tthis.scale(out,out,zcomp);      // Scale with z\n\t\treturn out;\n\t};\n\n\t/**\n\t * Cross product between a vector and the Z component of a vector\n\t * @method crossZV\n\t * @static\n\t * @param  {Array} out\n\t * @param  {Number} zcomp\n\t * @param  {Array} vec\n\t * @return {Array}\n\t */\n\tcrossZV(out:Float32Array, zcomp:f32, vec:Float32Array):Float32Array{\n\t\tthis.rotate(out,vec,Mathf.PI/2); // Rotate according to the right hand rule\n\t\tthis.scale(out,out,zcomp);      // Scale with z\n\t\treturn out;\n\t};\n\n\t/**\n\t * Rotate a vector by an angle\n\t * @method rotate\n\t * @static\n\t * @param  {Array} out\n\t * @param  {Array} a\n\t * @param  {Number} angle\n\t * @return {Array}\n\t */\n\trotate(out:Float32Array,a:Float32Array,angle:f32):Float32Array{\n\t\tif(angle !== 0){\n\t\t\tvar c = Mathf.cos(angle),\n\t\t\t\ts = Mathf.sin(angle),\n\t\t\t\tx = a[0],\n\t\t\t\ty = a[1];\n\t\t\tout[0] = c*x -s*y;\n\t\t\tout[1] = s*x +c*y;\n\t\t} else {\n\t\t\tout[0] = a[0];\n\t\t\tout[1] = a[1];\n\t\t}\n\t\treturn out;\n\t};\n\n\t/**\n\t * Rotate a vector 90 degrees clockwise\n\t * @method rotate90cw\n\t * @static\n\t * @param  {Array} out\n\t * @param  {Array} a\n\t * @return {Array}\n\t */\n\trotate90cw(out:Float32Array, a:Float32Array):Float32Array {\n\t\tvar x = a[0];\n\t\tvar y = a[1];\n\t\tout[0] = y;\n\t\tout[1] = -x;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Transform a point position to local frame.\n\t * @method toLocalFrame\n\t * @param  {Array} out\n\t * @param  {Array} worldPoint\n\t * @param  {Array} framePosition\n\t * @param  {Number} frameAngle\n\t * @return {Array}\n\t */\n\ttoLocalFrame(out:Float32Array, worldPoint:Float32Array, framePosition:Float32Array, frameAngle:f32):Float32Array{\n\t\tvar c = Mathf.cos(-frameAngle),\n\t\t\ts = Mathf.sin(-frameAngle),\n\t\t\tx = worldPoint[0] - framePosition[0],\n\t\t\ty = worldPoint[1] - framePosition[1];\n\t\tout[0] = c * x - s * y;\n\t\tout[1] = s * x + c * y;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Transform a point position to global frame.\n\t * @method toGlobalFrame\n\t * @param  {Array} out\n\t * @param  {Array} localPoint\n\t * @param  {Array} framePosition\n\t * @param  {Number} frameAngle\n\t */\n\ttoGlobalFrame(out:Float32Array, localPoint:Float32Array, framePosition:Float32Array, frameAngle:f32): void{\n\t\tvar c = Mathf.cos(frameAngle),\n\t\t\ts = Mathf.sin(frameAngle),\n\t\t\tx = localPoint[0],\n\t\t\ty = localPoint[1],\n\t\t\taddX = framePosition[0],\n\t\t\taddY = framePosition[1];\n\t\tout[0] = c * x - s * y + addX;\n\t\tout[1] = s * x + c * y + addY;\n\t};\n\n\t/**\n\t * Transform a vector to local frame.\n\t * @method vectorToLocalFrame\n\t * @param  {Array} out\n\t * @param  {Array} worldVector\n\t * @param  {Number} frameAngle\n\t * @return {Array}\n\t */\n\tvectorToLocalFrame(out:Float32Array, worldVector:Float32Array, frameAngle:f32):Float32Array{\n\t\tvar c = Mathf.cos(-frameAngle),\n\t\t\ts = Mathf.sin(-frameAngle),\n\t\t\tx = worldVector[0],\n\t\t\ty = worldVector[1];\n\t\tout[0] = c*x -s*y;\n\t\tout[1] = s*x +c*y;\n\t\treturn out;\n\t};\n\n\t/*\n\t * Transform a vector to global frame.\n\t * @method vectorToGlobalFrame\n\t * @param  {Array} out\n\t * @param  {Array} localVector\n\t * @param  {Number} frameAngle\n\t */\n\t//vectorToGlobalFrame = vec2.rotate;\n\n\t/**\n\t * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php\n\t * @method centroid\n\t * @static\n\t * @param  {Array} out\n\t * @param  {Array} a\n\t * @param  {Array} b\n\t * @param  {Array} c\n\t * @return  {Array} The \"out\" vector.\n\t */\n\tcentroid(out:Float32Array, a:Float32Array, b:Float32Array, c:Float32Array):Float32Array{\n\t\tthis.add(out, a, b);\n\t\tthis.add(out, out, c);\n\t\tthis.scale(out, out, 1/3);\n\t\treturn out;\n\t};\n\n\t/**\n\t * Creates a new, empty vec2\n\t * @static\n\t * @method create\n\t * @return {Array} a new 2D vector\n\t */\n\tcreate():Float32Array {\n\t\tvar out = new Float32Array(2);\n\t\tout[0] = 0;\n\t\tout[1] = 0;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Creates a new vec2 initialized with values from an existing vector\n\t * @static\n\t * @method clone\n\t * @param {Array} a vector to clone\n\t * @return {Array} a new 2D vector\n\t */\n\tclone(a:Float32Array): Float32Array {\n\t\tvar out = new Float32Array(2);\n\t\tout[0] = a[0];\n\t\tout[1] = a[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Creates a new vec2 initialized with the given values\n\t * @static\n\t * @method fromValues\n\t * @param {Number} x X component\n\t * @param {Number} y Y component\n\t * @return {Array} a new 2D vector\n\t */\n\tfromValues(x:f32, y:f32):Float32Array {\n\t\tvar out = new Float32Array(2);\n\t\tout[0] = x;\n\t\tout[1] = y;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Copy the values from one vec2 to another\n\t * @static\n\t * @method copy\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the source vector\n\t * @return {Array} out\n\t */\n\tcopy(out:Float32Array, a:Float32Array):Float32Array {\n\t\tout[0] = a[0];\n\t\tout[1] = a[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Set the components of a vec2 to the given values\n\t * @static\n\t * @method set\n\t * @param {Array} out the receiving vector\n\t * @param {Number} x X component\n\t * @param {Number} y Y component\n\t * @return {Array} out\n\t */\n\tset(out:Float32Array, x:f32, y:f32):Float32Array {\n\t\tout[0] = x;\n\t\tout[1] = y;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Adds two vec2's\n\t * @static\n\t * @method add\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Array} out\n\t */\n\tadd(out:Float32Array, a:Float32Array, b:Float32Array):Float32Array {\n\t\tout[0] = a[0] + b[0];\n\t\tout[1] = a[1] + b[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Subtracts two vec2's\n\t * @static\n\t * @method subtract\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Array} out\n\t */\n\tsubtract(out:Float32Array, a:Float32Array, b:Float32Array):Float32Array {\n\t\tout[0] = a[0] - b[0];\n\t\tout[1] = a[1] - b[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Multiplies two vec2's\n\t * @static\n\t * @method multiply\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Array} out\n\t */\n\tmultiply(out:Float32Array, a:Float32Array, b:Float32Array):Float32Array {\n\t\tout[0] = a[0] * b[0];\n\t\tout[1] = a[1] * b[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Divides two vec2's\n\t * @static\n\t * @method divide\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Array} out\n\t */\n\tdivide(out:Float32Array, a:Float32Array, b:Float32Array):Float32Array {\n\t\tout[0] = a[0] / b[0];\n\t\tout[1] = a[1] / b[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Scales a vec2 by a scalar number\n\t * @static\n\t * @method scale\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a the vector to scale\n\t * @param {Number} b amount to scale the vector by\n\t * @return {Array} out\n\t */\n\tscale(out:Float32Array, a:Float32Array, b:f32):Float32Array {\n\t\tout[0] = a[0] * b;\n\t\tout[1] = a[1] * b;\n\t\treturn out;\n\t};\n\n\t/**\n\t * Calculates the euclidian distance between two vec2's\n\t * @static\n\t * @method distance\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Number} distance between a and b\n\t */\n\tdistance(a:Float32Array, b:Float32Array):f32 {\n\t\tvar x = b[0] - a[0],\n\t\t\ty = b[1] - a[1];\n\t\treturn Mathf.sqrt(x*x + y*y);\n\t};\n\n\t/**\n\t * Calculates the squared euclidian distance between two vec2's\n\t * @static\n\t * @method squaredDistance\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Number} squared distance between a and b\n\t */\n\tsquaredDistance(a:Float32Array, b:Float32Array):f32 {\n\t\tvar x = b[0] - a[0],\n\t\t\ty = b[1] - a[1];\n\t\treturn x*x + y*y;\n\t};\n\n\t/**\n\t * Calculates the length of a vec2\n\t * @static\n\t * @method length\n\t * @param {Array} a vector to calculate length of\n\t * @return {Number} length of a\n\t */\n\tlength (a:Float32Array):f32 {\n\t\tvar x = a[0],\n\t\t\ty = a[1];\n\t\treturn Mathf.sqrt(x*x + y*y);\n\t};\n\n\t/**\n\t * Calculates the squared length of a vec2\n\t * @static\n\t * @method squaredLength\n\t * @param {Array} a vector to calculate squared length of\n\t * @return {Number} squared length of a\n\t */\n\tsquaredLength (a:Float32Array):f32 {\n\t\tvar x = a[0],\n\t\t\ty = a[1];\n\t\treturn x*x + y*y;\n\t};\n\n\t/**\n\t * Negates the components of a vec2\n\t * @static\n\t * @method negate\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a vector to negate\n\t * @return {Array} out\n\t */\n\tnegate(out:Float32Array, a:Float32Array):Float32Array {\n\t\tout[0] = -a[0];\n\t\tout[1] = -a[1];\n\t\treturn out;\n\t};\n\n\t/**\n\t * Normalize a vec2\n\t * @static\n\t * @method normalize\n\t * @param {Array} out the receiving vector\n\t * @param {Array} a vector to normalize\n\t * @return {Array} out\n\t */\n\tnormalize(out:Float32Array, a:Float32Array):Float32Array {\n\t\tvar x = a[0],\n\t\t\ty = a[1];\n\t\tvar len = x*x + y*y;\n\t\tif (len > 0) {\n\t\t\t//TODO: evaluate use of glm_invsqrt here?\n\t\t\tlen = 1 / Mathf.sqrt(len);\n\t\t\tout[0] = a[0] * len;\n\t\t\tout[1] = a[1] * len;\n\t\t}\n\t\treturn out;\n\t};\n\n\t/**\n\t * Calculates the dot product of two vec2's\n\t * @static\n\t * @method dot\n\t * @param {Array} a the first operand\n\t * @param {Array} b the second operand\n\t * @return {Number} dot product of a and b\n\t */\n\tdot (a:Float32Array, b:Float32Array):f32 {\n\t\treturn a[0] * b[0] + a[1] * b[1];\n\t};\n\n\t/**\n\t * Returns a string representation of a vector\n\t * @static\n\t * @method str\n\t * @param {Array} vec vector to represent as a string\n\t * @return {String} string representation of the vector\n\t */\n\tstr (a:Float32Array):string {\n\t\tthrow \"vec2.str is not supported in the typescript version of p2.\";\n\t\treturn 'vec2(' + a[0] + ', ' + a[1] + ')';\n\t};\n\n\t/**\n\t * Linearly interpolate/mix two vectors.\n\t * @static\n\t * @method lerp\n\t * @param {Array} out\n\t * @param {Array} a First vector\n\t * @param {Array} b Second vector\n\t * @param {number} t Lerp factor\n\t * @return {array}\n\t */\n\tlerp (out:Float32Array, a:Float32Array, b:Float32Array, t:f32):Float32Array {\n\t\tvar ax = a[0],\n\t\t\tay = a[1];\n\t\tout[0] = ax + t * (b[0] - ax);\n\t\tout[1] = ay + t * (b[1] - ay);\n\t\treturn out;\n\t};\n\n\t/**\n\t * Reflect a vector along a normal.\n\t * @static\n\t * @method reflect\n\t * @param {Array} out\n\t * @param {Array} vector\n\t * @param {Array} normal\n\t */\n\treflect(out:Float32Array, vector:Float32Array, normal:Float32Array): void{\n\t\tvar dot = vector[0] * normal[0] + vector[1] * normal[1];\n\t\tout[0] = vector[0] - 2 * normal[0] * dot;\n\t\tout[1] = vector[1] - 2 * normal[1] * dot;\n\t};\n\n\t/**\n\t * Get the intersection point between two line segments.\n\t * @static\n\t * @method getLineSegmentsIntersection\n\t * @param  {Array} out\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @return {boolean} True if there was an intersection, otherwise false.\n\t */\n\tgetLineSegmentsIntersection(out:Float32Array, p0:Float32Array, p1:Float32Array, p2:Float32Array, p3:Float32Array):boolean {\n\t\tvar t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);\n\t\tif(t < 0){\n\t\t\treturn false;\n\t\t} else {\n\t\t\tout[0] = p0[0] + (t * (p1[0] - p0[0]));\n\t\t\tout[1] = p0[1] + (t * (p1[1] - p0[1]));\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)\n\t * @static\n\t * @method getLineSegmentsIntersectionFraction\n\t * @param  {Array} p0\n\t * @param  {Array} p1\n\t * @param  {Array} p2\n\t * @param  {Array} p3\n\t * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.\n\t */\n\tgetLineSegmentsIntersectionFraction(p0:Float32Array, p1:Float32Array, p2:Float32Array, p3:Float32Array):f32 {\n\t\tvar s1_x = p1[0] - p0[0];\n\t\tvar s1_y = p1[1] - p0[1];\n\t\tvar s2_x = p3[0] - p2[0];\n\t\tvar s2_y = p3[1] - p2[1];\n\n\t\tvar s: f32, t: f32;\n\t\ts = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n\t\tt = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n\t\tif (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected\n\t\t\treturn t;\n\t\t}\n\t\treturn -1; // No collision\n\t}\n\n}\n\nconst vec2 = new Vec2();\n\nexport default vec2;\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n/* global P2_ARRAY_TYPE */\n\n/**\n * Misc utility functions\n */\nclass _Utils{\n\n\t/**\n\t * Append the values in array b to the array a. See <a href=\"http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131\">this</a> for an explanation.\n\t * @method appendArray\n\t * @static\n\t * @param  {Array} a\n\t * @param  {Array} b\n\t */\n\tappendArray<T>(a:Array<T>,b:Array<T>): void{\n\t\tfor (let i = 0, len = b.length; i !== len; ++i) {\n\t\t\ta.push(b[i]);\n\t\t}\n\t}\n\n\t/**\n\t * Garbage free Array.splice(). Does not allocate a new array.\n\t * @method splice\n\t * @static\n\t * @param  {Array} array\n\t * @param  {Number} index\n\t * @param  {Number} howmany\n\t */\n\tsplice<T>(array: Array<T>, index: i32, howmany: i32): void{\n\t\thowmany = howmany || 1;\n\t\tlet len: i32 = array.length-howmany;\n\t\tfor (let i: i32 = index; i < len; i++){\n\t\t\tarray[i] = array[i + howmany];\n\t\t}\n\t\tarray.length = len;\n\t}\n\n\t/**\n\t * Remove an element from an array, if the array contains the element.\n\t * @method arrayRemove\n\t * @static\n\t * @param  {Array} array\n\t * @param  {Number} element\n\t */\n\tarrayRemove<T>(array: Array<T>, element: T): void{\n\t\tlet idx = array.indexOf(element);\n\t\tif(idx!==-1){\n\t\t\tthis.splice(array, idx, 1);\n\t\t}\n\t}\n\n\t// /**\n\t//  * Extend an object with the properties of another\n\t//  * @static\n\t//  * @method extend\n\t//  * @param  {object} a\n\t//  * @param  {object} b\n\t//  */\n\t// extend(a: any,b: any): void{\n\t// \tfor(let key in b){\n\t// \t\ta[key] = b[key];\n\t// \t}\n\t// }\n\n\t// /**\n\t//  * Shallow clone an object. Returns a new object instance with the same properties as the input instance.\n\t//  * @static\n\t//  * @method shallowClone\n\t//  * @param  {object} obj\n\t//  */\n\t// shallowClone(obj: any): any{ // Might not be used anymore.\n\t// \tlet newObj = {};\n\t// \tthis.extend(newObj, obj);\n\t// \treturn newObj;\n\t// }\n\n\t// /**\n\t//  * Extend an options object with default values.\n\t//  * @deprecated Not used internally, will be removed.\n\t//  * @static\n\t//  * @method defaults\n\t//  * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.\n\t//  * @param  {object} defaults An object containing default values.\n\t//  * @return {object} The modified options object.\n\t//  */\n\t// defaults(options, defaults){\n\t// \tconsole.warn('Utils.defaults is deprecated.');\n\t// \toptions = options || {};\n\t// \tfor(let key in defaults){\n\t// \t\tif(!(key in options)){\n\t// \t\t\toptions[key] = defaults[key];\n\t// \t\t}\n\t// \t}\n\t// \treturn options;\n\t// }\n}\n\n// const vec2 = new Vec2();\n\n// export default vec2;\n\n\nconst Utils = new _Utils();\nexport default Utils;","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"../objects/body\";\nimport vec2 from \"../math/vec2\";\nimport Utils from \"../utils/utils\";\n\nexport default class Equation{\n\n\t/**\n\t * Minimum force to apply when solving.\n\t * @property minForce\n\t * @type {Number}\n\t */\n\tpublic minForce: f32;\n\n\t/**\n\t * Max force to apply when solving.\n\t * @property maxForce\n\t * @type {Number}\n\t */\n\tpublic maxForce: f32;\n\n\t/**\n\t * Cap the constraint violation (G*q) to this value.\n\t * @property maxBias\n\t * @type {Number}\n\t */\n\tpublic maxBias: f32 = Infinity;\n\n\t/**\n\t * First body participating in the constraint\n\t * @property bodyA\n\t * @type {Body}\n\t */\n\tpublic bodyA: Body|null;\n\n\t/**\n\t * Second body participating in the constraint\n\t * @property bodyB\n\t * @type {Body}\n\t */\n\tpublic bodyB: Body|null;\n\n\t/**\n\t * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n\t * @property stiffness\n\t * @type {Number}\n\t */\n\tpublic stiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\n\t/**\n\t * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n\t * @property relaxation\n\t * @type {Number}\n\t */\n\tpublic relaxation: f32 = Equation.DEFAULT_RELAXATION;\n\n\t/**\n\t * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n\t * @property G\n\t * @type {Array}\n\t */\n\tpublic G: Float32Array;\n\n\tpublic offset: f32 = 0;\n\n\tpublic a: f32 = 0;\n\tpublic b: f32 = 0;\n\tpublic epsilon: f32 = 0;\n\tpublic timeStep: f32 = 1/60;\n\n\t/**\n\t * Indicates if stiffness or relaxation was changed.\n\t * @property {boolean} needsUpdate\n\t */\n\tpublic needsUpdate: boolean = true;\n\n\t/**\n\t * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n\t * @property multiplier\n\t * @type {Number}\n\t */\n\tpublic multiplier: f32 = 0;\n\n\t/**\n\t * Relative velocity.\n\t * @property {Number} relativeVelocity\n\t */\n\tpublic relativeVelocity: f32 = 0;\n\n\t/**\n\t * Whether this equation is enabled or not. If true, it will be added to the solver.\n\t * @property {boolean} enabled\n\t */\n\tpublic enabled: boolean = true;\n\n\t// Temp stuff\n\tmaxForceDt: f32 = 0;\n\tminForceDt: f32 = 0;\n\tinvC: f32 = 0;\n\tB: f32 = 0;\n\tlambda: f32 = 0;\n\tindex: i32 = -1;\n\n\t/**\n\t * Base class for constraint equations.\n\t * @class Equation\n\t * @constructor\n\t * @param {Body} bodyA First body participating in the equation\n\t * @param {Body} bodyB Second body participating in the equation\n\t * @param {number} minForce Minimum force to apply. Default: -Infinity\n\t * @param {number} maxForce Maximum force to apply. Default: Infinity\n\t */\n\tconstructor(bodyA: Body|null, bodyB: Body|null, minForce: f32, maxForce: f32){\n\n\t\t// f32 is not nullable in assemblyscript.....\n\t\t// this.minForce = minForce == null ? -Infinity : minForce;\n\t\t// this.maxForce = maxForce == null ? Infinity : maxForce;\n\t\tthis.minForce = minForce;\n\t\tthis.maxForce = maxForce;\n\t\tthis.maxBias = Infinity;\n\t\tthis.bodyA = bodyA || null;\n\t\tthis.bodyB = bodyB || null;\n\t\tthis.stiffness = Equation.DEFAULT_STIFFNESS;\n\t\tthis.relaxation = Equation.DEFAULT_RELAXATION;\n\t\tthis.G = new Float32Array(6);\n\t\tfor(let i: u16 = 0; i < 6; i++){\n\t\t\tthis.G[i] = 0;\n\t\t}\n\t}\n\n\tcomputeGq(): f32 {\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar ai = bi.angle,\n\t\t\taj = bj.angle;\n\t\n\t\tvar qi = vec2.create(),\n\t\t\tqj = vec2.create()\n\t\treturn this.gmult(G, qi, ai, qj, aj) + this.offset;\n\t}\n\n\t/**\n\t * The default stiffness when creating a new Equation.\n\t * @static\n\t * @property {Number} DEFAULT_STIFFNESS\n\t * @default 1e6\n\t */\n\tstatic DEFAULT_STIFFNESS:f32 = 1e6;\n\n\t/**\n\t * The default relaxation when creating a new Equation.\n\t * @static\n\t * @property {Number} DEFAULT_RELAXATION\n\t * @default 4\n\t */\n\tstatic DEFAULT_RELAXATION:f32 = 4;\n\n\n\t/**\n\t * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href=\"http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\">SPOOK notes</a>.\n\t * @method update\n\t */\n\tupdate(): void{\n\t\tvar k = this.stiffness,\n\t\t\td = this.relaxation,\n\t\t\th = this.timeStep;\n\n\t\tthis.a = 4 / (h * (1 + 4 * d));\n\t\tthis.b = (4 * d) / (1 + 4 * d);\n\t\tthis.epsilon = 4 / (h * h * k * (1 + 4 * d));\n\n\t\tthis.needsUpdate = false;\n\t}\n\n\t/**\n\t * Multiply a jacobian entry with corresponding positions or velocities\n\t * @method gmult\n\t * @return {Number}\n\t */\n\tgmult(G: Float32Array,vi: Float32Array,wi: f32,vj: Float32Array,wj: f32): f32{\n\t\treturn  G[0] * vi[0] +\n\t\t\t\tG[1] * vi[1] +\n\t\t\t\tG[2] * wi +\n\t\t\t\tG[3] * vj[0] +\n\t\t\t\tG[4] * vj[1] +\n\t\t\t\tG[5] * wj;\n\t}\n\n\t/**\n\t * Computes the RHS of the SPOOK equation\n\t * @method computeB\n\t * @return {Number}\n\t */\n\tcomputeB(a: f32,b: f32,h: f32): f32{\n\t\tlet GW: f32 = this.computeGW();\n\t\tlet Gq: f32 = this.computeGq();\n\t\tlet maxBias = this.maxBias;\n\t\tif(Math.abs(Gq) > maxBias){\n\t\t\tGq = Gq > 0 ? maxBias : -maxBias;\n\t\t}\n\t\tlet GiMf = this.computeGiMf();\n\t\tlet B = - Gq * a - GW * b - GiMf * h;\n\t\treturn B;\n\t}\n\n\t/**\n\t * Computes G\\*W, where W are the body velocities\n\t * @method computeGW\n\t * @return {Number}\n\t */\n\tcomputeGW(): f32{\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar vi = bi.velocity,\n\t\t\tvj = bj.velocity,\n\t\t\twi = bi.angularVelocity,\n\t\t\twj = bj.angularVelocity;\n\t\treturn this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;\n\t}\n\n\t/**\n\t * Computes G\\*Wlambda, where W are the body velocities\n\t * @method computeGWlambda\n\t * @return {Number}\n\t */\n\tcomputeGWlambda(): f32{\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar vi = bi.vlambda,\n\t\t\tvj = bj.vlambda,\n\t\t\twi = bi.wlambda,\n\t\t\twj = bj.wlambda;\n\t\treturn this.gmult(G,vi,wi,vj,wj);\n\t}\n\n\t/**\n\t * Computes G\\*inv(M)\\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n\t * @method computeGiMf\n\t * @return {Number}\n\t */\n\tcomputeGiMf(): f32{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar fi = bi.force,\n\t\t\tti = bi.angularForce,\n\t\t\tfj = bj.force,\n\t\t\ttj = bj.angularForce,\n\t\t\tinvMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\tvar iMfi = vec2.create(),\n\t\t\tiMfj = vec2.create();\n\n\t\tvec2.scale(iMfi, fi, invMassi);\n\t\tvec2.multiply(iMfi, bi.massMultiplier, iMfi);\n\t\tvec2.scale(iMfj, fj,invMassj);\n\t\tvec2.multiply(iMfj, bj.massMultiplier, iMfj);\n\n\t\treturn this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);\n\t}\n\n\t/**\n\t * Computes G\\*inv(M)\\*G'\n\t * @method computeGiMGt\n\t * @return {Number}\n\t */\n\tcomputeGiMGt(): f32{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar invMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\treturn  G[0] * G[0] * invMassi * bi.massMultiplier[0] +\n\t\t\t\tG[1] * G[1] * invMassi * bi.massMultiplier[1] +\n\t\t\t\tG[2] * G[2] *    invIi +\n\t\t\t\tG[3] * G[3] * invMassj * bj.massMultiplier[0] +\n\t\t\t\tG[4] * G[4] * invMassj * bj.massMultiplier[1] +\n\t\t\t\tG[5] * G[5] *    invIj;\n\t}\n\n\tupdateJacobian(): void{};\n\n\t/**\n\t * Add constraint velocity to the bodies.\n\t * @method addToWlambda\n\t * @param {Number} deltalambda\n\t */\n\taddToWlambda(deltalambda: f32): void{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return;\n\t\tvar invMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\t// v_lambda = G * inv(M) * delta_lambda\n\n\t\taddToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);\n\t\tbi.wlambda += invIi * G[2] * deltalambda;\n\n\t\taddToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);\n\t\tbj.wlambda += invIj * G[5] * deltalambda;\n\t}\n\n\t/**\n\t * Compute the denominator part of the SPOOK equation: C = G\\*inv(M)\\*G' + eps\n\t * @method computeInvC\n\t * @param  {Number} eps\n\t * @return {Number}\n\t */\n\tcomputeInvC(eps: f32): f32{\n\t\tvar invC: f32 = 1.0 / (this.computeGiMGt() + eps);\n\t\treturn invC;\n\t}\n\n}\n\nfunction addToVLambda(vlambda: Float32Array, Gx: f32, Gy: f32, invMass: f32, deltalambda: f32, massMultiplier: Float32Array): void{\n\tvlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];\n\tvlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport EventEmitter from \"../events/event-emitter\";\nimport Equation from \"../equations/equation\";\nimport World from \"../world/world\";\n\nexport class SolverOptions{\n\tequationSortFunction: (a: Equation, b: Equation) => i32;\n}\n\nexport default abstract class Solver extends EventEmitter{\n\ttype: u16 = 0;\n\tequations: Equation[];\n\tequationSortFunction: ((a: Equation, b: Equation) => i32)|null = null;\n\n\t/**\n\t * Base class for constraint solvers.\n\t * @class Solver\n\t * @constructor\n\t * @extends EventEmitter\n\t */\n\tconstructor(options: SolverOptions|null, type: u16){\n\t\tsuper();\n\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * Current equations in the solver.\n\t\t *\n\t\t * @property equations\n\t\t * @type {Array}\n\t\t */\n\t\tthis.equations = [];\n\n\t\t/**\n\t\t * Function that is used to sort all equations before each solve.\n\t\t * @property equationSortFunction\n\t\t * @type {function|boolean}\n\t\t */\n\t\tif(options) this.equationSortFunction = options.equationSortFunction;\n\t}\n\n\t/**\n\t * Method to be implemented in each subclass\n\t * @method solve\n\t * @param  {Number} dt\n\t * @param  {World} world\n\t */\n\tabstract solve(h: f32, world: World): void;\n\n\t/**\n\t * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.\n\t * @method sortEquations\n\t */\n\tsortEquations(): void{\n\t\tif(this.equationSortFunction){\n\t\t\tthis.equations.sort(this.equationSortFunction!);\n\t\t}\n\t};\n\n\t/**\n\t * Add an equation to be solved.\n\t *\n\t * @method addEquation\n\t * @param {Equation} eq\n\t */\n\taddEquation(eq: Equation): void{\n\t\tif(eq.enabled){\n\t\t\tthis.equations.push(eq);\n\t\t}\n\t};\n\n\t/**\n\t * Add equations. Same as .addEquation, but this time the argument is an array of Equations\n\t *\n\t * @method addEquations\n\t * @param {Array} eqs\n\t */\n\taddEquations(eqs: Equation[]): void{\n\t\tfor(let i: u16 = 0, N: u16 = (eqs.length as u16); i < N; i++){\n\t\t\tlet eq = eqs[i];\n\t\t\tif(eq.enabled){\n\t\t\t\tthis.equations.push(eq);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Remove an equation.\n\t *\n\t * @method removeEquation\n\t * @param {Equation} eq\n\t */\n\tremoveEquation(eq: Equation): void{\n\t\tlet i = this.equations.indexOf(eq);\n\t\tif(i !== -1){\n\t\t\tthis.equations.splice(i,1);\n\t\t}\n\t};\n\n\t/**\n\t * Remove all currently added equations.\n\t *\n\t * @method removeAllEquations\n\t */\n\tremoveAllEquations(): void{\n\t\tthis.equations.length=0;\n\t};\n\n\t/**\n\t * Gauss-Seidel solver.\n\t * @property GS\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic GS: u16 = 1;\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nexport default class Material{\n\n\tstatic idCounter: u32 = 0;\n\t\n\tpublic id: u32;\n\n\t/**\n\t * Defines a physics material. To be used with {{#crossLink \"ContactMaterial\"}}{{/crossLink}}.\n\t * @class Material\n\t * @constructor\n\t * @author schteppe\n\t * @example\n\t *     // Create a wooden box\n\t *     var woodMaterial = new Material();\n\t *     var boxShape = new Box({\n\t *         material: woodMaterial\n\t *     });\n\t *     body.addShape(boxShape);\n\t */\n\tconstructor(){\n\n\t\t/**\n\t\t * The material identifier. Read only.\n\t\t * @readonly\n\t\t * @property id\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = ++Material.idCounter;\n\t}\n\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Body from \"../objects/body\";\nimport AABB from \"../collision/aabb\";\nimport Ray from \"../collision/ray\";\nimport Material from \"../material/material\";\nimport RaycastResult from \"../collision/raycast-result\";\n\nexport class ShapeOptions{\n\tposition: Float32Array|null = null;\n\tangle: f32 = 0;\n\tcollisionGroup: i16 = 1;\n\tcollisionResponse: boolean = true;\n\tcollisionMask: i16 = 1;\n\tmaterial: Material|null = null;\n\tsensor: boolean = false;\n}\n\nexport default abstract class Shape\n{\n\n\tstatic idCounter: u32 = 0;\n\n\t/**\n\t * The body this shape is attached to. A shape can only be attached to a single body.\n\t * @property {Body} body\n\t */\n\tpublic body: Body|null = null;\n\n\t/**\n\t * Body-local position of the shape.\n\t * @property {Array} position\n\t */\n\tpublic position: Float32Array = vec2.create();\n\n\t/**\n\t * Body-local angle of the shape.\n\t * @property {number} angle\n\t */\n\tpublic angle: f32 = 0;\n\n\t\n\t/**\n\t * The type of the shape. One of:\n\t *\n\t * <ul>\n\t * <li><a href=\"Shape.html#property_CIRCLE\">Shape.CIRCLE</a></li>\n\t * <li><a href=\"Shape.html#property_PARTICLE\">Shape.PARTICLE</a></li>\n\t * <li><a href=\"Shape.html#property_PLANE\">Shape.PLANE</a></li>\n\t * <li><a href=\"Shape.html#property_CONVEX\">Shape.CONVEX</a></li>\n\t * <li><a href=\"Shape.html#property_LINE\">Shape.LINE</a></li>\n\t * <li><a href=\"Shape.html#property_BOX\">Shape.BOX</a></li>\n\t * <li><a href=\"Shape.html#property_CAPSULE\">Shape.CAPSULE</a></li>\n\t * <li><a href=\"Shape.html#property_HEIGHTFIELD\">Shape.HEIGHTFIELD</a></li>\n\t * </ul>\n\t *\n\t * @property {number} type\n\t */\n\tpublic type: u16 = 0;\n\n\t/**\n\t * Shape object identifier. Read only.\n\t * @readonly\n\t * @type {Number}\n\t * @property id\n\t */\n\tpublic id: u32 = 0;\n\n\t/**\n\t * Bounding circle radius of this shape\n\t * @readonly\n\t * @property boundingRadius\n\t * @type {Number}\n\t */\n\tpublic boundingRadius: f32 = 0;\n\n\t/**\n\t * Collision group that this shape belongs to (bit mask). See <a href=\"http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/\">this tutorial</a>.\n\t * @property collisionGroup\n\t * @type {Number}\n\t * @example\n\t *     // Setup bits for each available group\n\t *     var PLAYER = Math.pow(2,0),\n\t *         ENEMY =  Math.pow(2,1),\n\t *         GROUND = Math.pow(2,2)\n\t *\n\t *     // Put shapes into their groups\n\t *     player1Shape.collisionGroup = PLAYER;\n\t *     player2Shape.collisionGroup = PLAYER;\n\t *     enemyShape  .collisionGroup = ENEMY;\n\t *     groundShape .collisionGroup = GROUND;\n\t *\n\t *     // Assign groups that each shape collide with.\n\t *     // Note that the players can collide with ground and enemies, but not with other players.\n\t *     player1Shape.collisionMask = ENEMY | GROUND;\n\t *     player2Shape.collisionMask = ENEMY | GROUND;\n\t *     enemyShape  .collisionMask = PLAYER | GROUND;\n\t *     groundShape .collisionMask = PLAYER | ENEMY;\n\t *\n\t * @example\n\t *     // How collision check is done\n\t *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){\n\t *         // The shapes will collide\n\t *     }\n\t */\n\tpublic collisionGroup: i16 = 1;\n\n\t/**\n\t * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.\n\t * @property {boolean} collisionResponse\n\t */\n\tpublic collisionResponse: boolean;\n\n\t/**\n\t * Collision mask of this shape. See .collisionGroup.\n\t * @property collisionMask\n\t * @type {Number}\n\t */\n\tpublic collisionMask: i16 = 1;\n\n\t/**\n\t * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.\n\t * @property material\n\t * @type {Material}\n\t */\n\tpublic material: Material|null;\n\n\t/**\n\t * Area of this shape.\n\t * @property area\n\t * @type {Number}\n\t */\n\tpublic area: f32 = 0;\n\n\t/**\n\t * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.\n\t * @property {boolean} sensor\n\t */\n\tpublic sensor: boolean = false;\n\n\t/**\n\t * Base class for shapes. Not to be used directly.\n\t * @class Shape\n\t * @constructor\n\t * @param {object} [options]\n\t * @param {number} [options.angle=0]\n\t * @param {number} [options.collisionGroup=1]\n\t * @param {number} [options.collisionMask=1]\n\t * @param {number} [options.id] Optional - specify an ID for this shape. Possibly useful for replacing shapes. Careful to avoid duplicates!\n\t * @param {boolean} [options.collisionResponse=true]\n\t * @param {Material} [options.material=null]\n\t * @param {array} [options.position]\n\t * @param {boolean} [options.sensor=false]\n\t * @param {object} [options.type=0]\n\t */\n\tconstructor(\n\t\ttype: u16,\n\t\toptions: ShapeOptions|null\n\t){\n\t\t\n\t\tif(options){\n\t\t\tlet pos = options.position;\n\t\t\tif(pos != null){\n\t\t\t\tvec2.copy(this.position, pos);\n\t\t\t}\n\t\t\tthis.angle = options.angle;\n\t\t\tthis.type = type;\n\t\t\tthis.collisionGroup = options.collisionGroup;\n\t\t\tthis.collisionResponse = options.collisionResponse;\n\t\t\tthis.collisionMask = options.collisionMask;\n\t\t\tthis.material = options.material;\n\t\t\tthis.sensor = options.sensor;\n\t\t}\n\t\tthis.id = ++Shape.idCounter;\n\n\t\tif(this.type){\n\t\t\tthis.updateBoundingRadius();\n\t\t}\n\n\t\tthis.updateArea();\n\t}\n\n\t/**\n\t * @static\n\t * @property {Number} CIRCLE\n\t */\n\tstatic CIRCLE:u16 =      1;\n\n\t/**\n\t * @static\n\t * @property {Number} PARTICLE\n\t */\n\tstatic PARTICLE:u16 =    2;\n\n\t/**\n\t * @static\n\t * @property {Number} PLANE\n\t */\n\tstatic PLANE:u16 =       4;\n\n\t/**\n\t * @static\n\t * @property {Number} CONVEX\n\t */\n\tstatic CONVEX:u16 =      8;\n\n\t/**\n\t * @static\n\t * @property {Number} LINE\n\t */\n\tstatic LINE:u16 =        16;\n\n\t/**\n\t * @static\n\t * @property {Number} BOX\n\t */\n\tstatic BOX:u16 =   32;\n\n\t/**\n\t * @static\n\t * @property {Number} CAPSULE\n\t */\n\tstatic CAPSULE:u16 = 64;\n\n\t/**\n\t * @static\n\t * @property {Number} HEIGHTFIELD\n\t */\n\tstatic HEIGHTFIELD:u16 = 128;\n\n\t/**\n\t * @static\n\t * @property {Number} HEIGHTFIELD\n\t */\n\tstatic AXISALIGNEDBOX:u16 = 256;\n\n\t/**\n\t * Should return the moment of inertia around the Z axis of the body. See <a href=\"http://en.wikipedia.org/wiki/List_of_moments_of_inertia\">Wikipedia's list of moments of inertia</a>.\n\t * @method computeMomentOfInertia\n\t * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.\n\t */\n\tabstract computeMomentOfInertia(): f32;\n\n\t/**\n\t * Returns the bounding circle radius of this shape.\n\t * @method updateBoundingRadius\n\t * @return {Number}\n\t */\n\tabstract updateBoundingRadius(): f32\n\n\t/**\n\t * Update the .area property of the shape.\n\t * @method updateArea\n\t */\n\tabstract updateArea(): f32;\n\n\t/**\n\t * Compute the world axis-aligned bounding box (AABB) of this shape.\n\t * @method computeAABB\n\t * @param  {AABB} out The resulting AABB.\n\t * @param  {Array} position World position of the shape.\n\t * @param  {Number} angle World angle of the shape.\n\t */\n\tabstract computeAABB(out: AABB, position: Float32Array, angle: f32): void;\n\n\t/**\n\t * Perform raycasting on this shape.\n\t * @method raycast\n\t * @param  {RayResult} result Where to store the resulting data.\n\t * @param  {Ray} ray The Ray that you want to use for raycasting.\n\t * @param  {array} position World position of the shape (the .position property will be ignored).\n\t * @param  {number} angle World angle of the shape (the .angle property will be ignored).\n\t */\n\tabstract raycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void;\n\n\t/**\n\t * Test if a point is inside this shape.\n\t * @method pointTest\n\t * @param {array} localPoint\n\t * @return {boolean}\n\t */\n\tpointTest(localPoint: Float32Array): boolean { return false; }\n\n\t/**\n\t * Transform a world point to local shape space (assumed the shape is transformed by both itself and the body).\n\t * @method worldPointToLocal\n\t * @param {array} out\n\t * @param {array} worldPoint\n\t */\n\tworldPointToLocal(out: Float32Array, worldPoint: Float32Array): void{\n\t\tvar shapeWorldPosition = vec2.create();\n\t\tvar body = this.body;\n\t\tif(!body) return;\n\n\t\tvec2.rotate(shapeWorldPosition, this.position, body.angle);\n\t\tvec2.add(shapeWorldPosition, shapeWorldPosition, body.position);\n\n\t\tvec2.toLocalFrame(out, worldPoint, shapeWorldPosition, body.angle + this.angle);\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"../objects/body\";\nimport Equation from \"./equation\";\nimport Shape from \"../shapes/shape\";\nimport vec2 from \"../math/vec2\";\n\n\n\nfunction addSubSub(out:Float32Array, a:Float32Array, b:Float32Array, c:Float32Array, d:Float32Array): void{\n\tout[0] = a[0] + b[0] - c[0] - d[0];\n\tout[1] = a[1] + b[1] - c[1] - d[1];\n}\n\n\nvar vi = vec2.create();\nvar vj = vec2.create();\nvar relVel = vec2.create();\n\nexport default class ContactEquation extends Equation{\n\n\t\t/**\n\t\t * Vector from body i center of mass to the contact point.\n\t\t * @property contactPointA\n\t\t * @type {Array}\n\t\t */\n\t\tcontactPointA: Float32Array = vec2.create();\n\t\tpenetrationVec: Float32Array = vec2.create();\n\n\t\t/**\n\t\t * World-oriented vector from body A center of mass to the contact point.\n\t\t * @property contactPointB\n\t\t * @type {Array}\n\t\t */\n\t\tcontactPointB: Float32Array = vec2.create();\n\n\t\t/**\n\t\t * The normal vector, pointing out of body i\n\t\t * @property normalA\n\t\t * @type {Array}\n\t\t */\n\t\tnormalA: Float32Array = vec2.create();\n\n\t\t/**\n\t\t * The restitution to use (0=no bounciness, 1=max bounciness).\n\t\t * @property restitution\n\t\t * @type {Number}\n\t\t */\n\t\trestitution: f32 = 0;\n\n\t\t/**\n\t\t * This property is set to true if this is the first impact between the bodies (not persistant contact).\n\t\t * @property firstImpact\n\t\t * @type {boolean}\n\t\t * @readOnly\n\t\t */\n\t\tfirstImpact: boolean = false;\n\n\t\t/**\n\t\t * The shape in body i that triggered this contact.\n\t\t * @property shapeA\n\t\t * @type {Shape}\n\t\t */\n\t\tshapeA: Shape|null = null;\n\n\t\t/**\n\t\t * The shape in body j that triggered this contact.\n\t\t * @property shapeB\n\t\t * @type {Shape}\n\t\t */\n\t\tshapeB: Shape|null = null;\n\n\t/**\n\t * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.\n\t *\n\t * @class ContactEquation\n\t * @constructor\n\t * @extends Equation\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t */\n\tconstructor(bodyA: Body|null, bodyB: Body|null){\n\t\tsuper(bodyA, bodyB, 0, Infinity);\n\t}\n\n\tcomputeB(a: f32, b: f32, h: f32): f32{\n\t\tlet bi = this.bodyA,\n\t\t\tbj = this.bodyB,\n\t\t\tri = this.contactPointA,\n\t\t\trj = this.contactPointB,\n\t\t\txi = bi ? bi.position : new Float32Array(2),\n\t\t\txj = bj ? bj.position : new Float32Array(2);\n\n\t\tlet n = this.normalA,\n\t\t\tG = this.G;\n\n\t\t// Caluclate cross products\n\t\tlet rixn = vec2.crossLength(ri,n),\n\t\t\trjxn = vec2.crossLength(rj,n);\n\n\t\t// G = [-n -rixn n rjxn]\n\t\tG[0] = -n[0];\n\t\tG[1] = -n[1];\n\t\tG[2] = -rixn;\n\t\tG[3] = n[0];\n\t\tG[4] = n[1];\n\t\tG[5] = rjxn;\n\n\n\t\t// Compute iteration\n\t\tlet GW: f32, Gq: f32;\n\t\tif(this.firstImpact && this.restitution !== 0){\n\t\t\tGq = 0;\n\t\t\tGW = (1/b)*(1+this.restitution) * this.computeGW();\n\t\t} else {\n\t\t\t// Calculate q = xj+rj -(xi+ri) i.e. the penetration vector\n\t\t\tlet penetrationVec = this.penetrationVec;\n\t\t\taddSubSub(penetrationVec,xj,rj,xi,ri);\n\t\t\tGq = vec2.dot(n,penetrationVec) + this.offset;\n\t\t\tGW = this.computeGW();\n\t\t}\n\n\t\tlet GiMf = this.computeGiMf();\n\t\tlet B = - Gq * a - GW * b - h*GiMf;\n\n\t\treturn B;\n\t};\n\n\t/**\n\t * Get the relative velocity along the normal vector.\n\t * @method getVelocityAlongNormal\n\t * @return {number}\n\t */\n\tgetVelocityAlongNormal(): f32{\n\n\n\t\tthis.bodyA!.getVelocityAtPoint(vi, this.contactPointA);\n\t\tthis.bodyB!.getVelocityAtPoint(vj, this.contactPointB);\n\n\t\tvec2.subtract(relVel, vi, vj);\n\n\t\treturn vec2.dot(this.normalA, relVel);\n\t};\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n - 4;\n    store<u8>(dest, c);\n    store<u8>(dend, c, 3);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend, c, 2);\n    store<u8>(dend, c, 1);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n - 28;\n    store<u32>(dest, c32);\n    store<u32>(dend, c32, 24);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend, c32, 16);\n    store<u32>(dend, c32, 20);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend, c32);\n    store<u32>(dend, c32, 4);\n    store<u32>(dend, c32, 8);\n    store<u32>(dend, c32, 12);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: usize = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_dec_core(out, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: usize = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_dec_core(out, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_hex_core(out, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, val32, decimals, radix);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: usize = 0;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = __alloc(decimals << 1, idof<String>());\n      utoa32_dec_core(out, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = __alloc(decimals << 1, idof<String>());\n      utoa64_dec_core(out, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: usize = 0;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = __alloc(decimals << 1, idof<String>());\n      utoa32_dec_core(out, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = __alloc(decimals << 1, idof<String>());\n      utoa64_dec_core(out, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10)); // retains\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10)); // retains\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10)); // retains\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10)); // retains\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    ); // retains\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      result + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return changetype<string>(result); // retains\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var len = array.length;\n  if (len <= 1) return array;\n  var base = array.dataStart;\n  if (len == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, len, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  store<usize>(out, __retain(changetype<usize>(array.buffer)), offsetof<TArray>(\"buffer\"));\n  store<usize>(out, array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(out, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    dataStart + (<usize>to << alignof<T>()),\n    dataStart + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  var buffer = __alloc(byteLength, idof<ArrayBuffer>());\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      buffer + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(out, __retain(buffer), offsetof<TArray>(\"buffer\"));\n  store<usize>(out, buffer, offsetof<TArray>(\"dataStart\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  var buffer = __alloc(len << alignof<T>(), idof<ArrayBuffer>());\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        buffer + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __realloc(buffer, byteLength);\n  store<usize>(out, __retain(data), offsetof<TArray>(\"buffer\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(out, data, offsetof<TArray>(\"dataStart\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let length: isize = array.length;\n    if (length == 0 || index >= length) return false;\n    if (index < 0) index = max(length + index, 0);\n    let dataStart = array.dataStart;\n    while (index < length) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (length < 0) {\n    if (length == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = __alloc(offsetof<TArray>(), idof<TArray>());\n  store<usize>(out, __retain(changetype<usize>(buffer)), offsetof<TArray>(\"buffer\"));\n  store<u32>(out, byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(out, changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return changetype<TArray>(out); // retains\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(target: TArray, source: UArray, offset: i32 = 0): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : 0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Material from \"./material\";\nimport Equation from \"../equations/equation\";\n\nexport class ContactMaterialOptions{\n\tfriction: f32 = 0.3;\n\trestitution: f32 = 0;\n\tstiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\trelaxation: f32 = Equation.DEFAULT_RELAXATION;\n\tfrictionStiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\tfrictionRelaxation: f32 = Equation.DEFAULT_RELAXATION;\n\tsurfaceVelocity: f32 = 0;\n}\n\nexport default class ContactMaterial{\n\n\t/**\n\t * The contact material identifier. Read only.\n\t * @readonly\n\t * @property id\n\t * @type {Number}\n\t */\n\tpublic id: u32;\n\n\t/**\n\t * First material participating in the contact material\n\t * @property materialA\n\t * @type {Material}\n\t */\n\tpublic materialA: Material;\n\n\t/**\n\t * Second material participating in the contact material\n\t * @property materialB\n\t * @type {Material}\n\t */\n\tpublic materialB: Material;\n\n\t/**\n\t * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.\n\t * @property friction\n\t * @type {Number}\n\t * @default 0.3\n\t */\n\tpublic friction: f32 = 0.3;\n\n\t/**\n\t * Restitution, or \"bounciness\" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.\n\t * @property restitution\n\t * @type {Number}\n\t * @default 0\n\t */\n\tpublic restitution: f32 = 0;\n\n\t/**\n\t * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n\t * @property stiffness\n\t * @type {Number}\n\t */\n\tpublic stiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\n\t/**\n\t * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n\t * @property relaxation\n\t * @type {Number}\n\t */\n\tpublic relaxation: f32 = Equation.DEFAULT_RELAXATION;\n\n\t/**\n\t * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n\t * @property frictionStiffness\n\t * @type {Number}\n\t */\n\tpublic frictionStiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\n\t/**\n\t * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n\t * @property frictionRelaxation\n\t * @type {Number}\n\t */\n\tpublic frictionRelaxation: f32 = Equation.DEFAULT_RELAXATION;\n\n\t/**\n\t * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n\t * @property {Number} surfaceVelocity\n\t * @default 0\n\t */\n\tpublic surfaceVelocity: f32 = 0;\n\n\t/**\n\t * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka \"cure for nervous contacts\".\n\t * @property contactSkinSize\n\t * @type {Number}\n\t */\n\tpublic contactSkinSize: f32 = 0.005;\n\n\t/**\n\t * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters. Also see {{#crossLink \"Material\"}}{{/crossLink}}.\n\t * @class ContactMaterial\n\t * @constructor\n\t * @param {Material} materialA\n\t * @param {Material} materialB\n\t * @param {Object}   [options]\n\t * @param {Number}   [options.friction=0.3]       Friction coefficient.\n\t * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.\n\t * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.\n\t * @param {Number}   [options.relaxation]         ContactEquation relaxation.\n\t * @param {Number}   [options.restitution=0]      Restitution coefficient aka \"bounciness\".\n\t * @param {Number}   [options.stiffness]          ContactEquation stiffness.\n\t * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.\n\t * @author schteppe\n\t * @example\n\t *     var ice = new Material();\n\t *     var wood = new Material();\n\t *     var iceWoodContactMaterial = new ContactMaterial(ice, wood, {\n\t *         friction: 0.2,\n\t *         restitution: 0.3\n\t *     });\n\t *     world.addContactMaterial(iceWoodContactMaterial);\n\t */\n\tconstructor(materialA: Material, materialB: Material, options: ContactMaterialOptions|null){\n\t\tif(!(materialA instanceof Material) || !(materialB instanceof Material)){\n\t\t\tthrow new Error(\"First two arguments must be Material instances.\");\n\t\t}\n\n\t\tthis.id = ++ContactMaterial.idCounter;\n\t\tthis.materialA = materialA;\n\t\tthis.materialB = materialB;\n\n\t\tif(options){\n\t\t\tthis.friction = options.friction;\n\t\t\tthis.restitution = options.restitution;\n\t\t\tthis.stiffness = options.stiffness;\n\t\t\tthis.relaxation = options.relaxation;\n\t\t\tthis.frictionStiffness = options.frictionStiffness;\n\t\t\tthis.frictionRelaxation = options.frictionRelaxation;\n\t\t\tthis.surfaceVelocity = options.surfaceVelocity;\n\t\t}\n\t}\n\n\tstatic idCounter: u32 = 0;\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Body from \"../objects/body\";\nimport World from \"../world/world\";\nimport AABB from \"./aabb\";\n\n// TODO: I think this is supposed to be abstract.\nexport default class Broadphase extends Object{\n\tpublic type: u16;\n\n\t/**\n\t * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().\n\t * @property result\n\t * @type {Array}\n\t */\n\tpublic result: Array<Body> = [];\n\n\t/**\n\t * The world to search for collision pairs in. To change it, use .setWorld()\n\t * @property world\n\t * @type {World}\n\t * @readOnly\n\t */\n\tpublic world: World|null = null;\n\t\n\t/**\n\t * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.\n\t * @property {Number} boundingVolumeType\n\t */\n\tpublic boundingVolumeType: u16 = Broadphase.AABB;\n\n\t/**\n\t * Base class for broadphase implementations. Don't use this class directly.\n\t * @class Broadphase\n\t * @constructor\n\t */\n\tconstructor(type: u16){\n\t\tsuper();\n\t\tthis.type = type || 1;\n\t}\n\n\t\n\n\t/**\n\t * Set the world that we are searching for collision pairs in.\n\t * @method setWorld\n\t * @param  {World} world\n\t */\n\t// TODO: move to constructor!\n\tsetWorld(world: World): void{\n\t\tthis.world = world;\n\t};\n\n\t/*\n\t * Get all potential intersecting body pairs.\n\t * @method getCollisionPairs\n\t * @param  {World} world The world to search in.\n\t * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).\n\t */\n\tgetCollisionPairs():Body[]{\n\t\t// I guess this should be overridden?\n\t\t// TODO: possible abstract method.\n\t\treturn [];\n\n\t};\n\n\t/**\n\t * Check whether the bounding radius of two bodies overlap.\n\t * @method  boundingRadiusCheck\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tstatic boundingRadiusCheck (bodyA: Body, bodyB: Body): boolean{\n\t\tvar d2 = vec2.squaredDistance(bodyA.position, bodyB.position),\n\t\t\tr = bodyA.boundingRadius + bodyB.boundingRadius;\n\t\treturn d2 <= r*r;\n\t};\n\n\t/**\n\t * Check whether the AABB of two bodies overlap.\n\t * @method  aabbCheck\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tstatic aabbCheck(bodyA: Body, bodyB: Body): boolean{\n\t\treturn bodyA.getAABB().overlaps(bodyB.getAABB());\n\t};\n\n\t/**\n\t * Check whether the bounding volumes of two bodies overlap.\n\t * @method  boundingVolumeCheck\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tboundingVolumeCheck(bodyA: Body, bodyB: Body): boolean{\n\t\tvar result: boolean;\n\n\t\tswitch(this.boundingVolumeType){\n\t\tcase Broadphase.BOUNDING_CIRCLE:\n\t\t\tresult =  Broadphase.boundingRadiusCheck(bodyA,bodyB);\n\t\t\tbreak;\n\t\tcase Broadphase.AABB:\n\t\t\tresult = Broadphase.aabbCheck(bodyA,bodyB);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Bounding volume type not recognized: '+this.boundingVolumeType.toString());\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Check whether two bodies are allowed to collide at all.\n\t * @method  canCollide\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tstatic canCollide(bodyA: Body, bodyB: Body): boolean{\n\t\tvar KINEMATIC = Body.KINEMATIC;\n\t\tvar STATIC = Body.STATIC;\n\t\tvar typeA = bodyA.type;\n\t\tvar typeB = bodyB.type;\n\n\t\t// Cannot collide static bodies\n\t\tif(typeA === STATIC && typeB === STATIC){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot collide static vs kinematic bodies\n\t\tif( (typeA === KINEMATIC && typeB === STATIC) ||\n\t\t\t(typeA === STATIC    && typeB === KINEMATIC)){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot collide kinematic vs kinematic\n\t\tif(typeA === KINEMATIC && typeB === KINEMATIC){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot collide both sleeping bodies\n\t\tif(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cannot collide if one is static and the other is sleeping\n\t\tif( (bodyA.sleepState === Body.SLEEPING && typeB === STATIC) ||\n\t\t\t(bodyB.sleepState === Body.SLEEPING && typeA === STATIC)){\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\t/**\n\t * Returns all the bodies within an AABB.\n\t * @method aabbQuery\n\t * @param  {World} world\n\t * @param  {AABB} aabb\n\t * @param {array} result An array to store resulting bodies in.\n\t * @return {array}\n\t */\n\taabbQuery(aabb: AABB, result: Body[]): void{\n\t\t// To be implemented in subclasses\n\t};\n\n\t// Mode:\n\tstatic NAIVE: u16 = 1;\n\tstatic SAP: u16 = 2;\n\n\t// Bounding box:\n\t/**\n\t * Axis aligned bounding box type.\n\t * @static\n\t * @property {Number} AABB\n\t */\n\tstatic AABB: u16 = 1;\n\n\t/**\n\t * Bounding circle type.\n\t * @static\n\t * @property {Number} BOUNDING_CIRCLE\n\t */\n\tstatic BOUNDING_CIRCLE: u16 = 2;\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// var Shape = require('./Shape')\n// ,    vec2 = require('../math/vec2')\n// ,    shallowClone = require('../utils/Utils').shallowClone;\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nvar Ray_intersectSphere_intersectionPoint = vec2.create();\nvar Ray_intersectSphere_normal = vec2.create();\n\nexport class CircleOptions extends ShapeOptions{\n\tradius: f32 = 1\n}\n\nexport default class Circle extends Shape{\n\tradius: f32 = 1;\n\n\t/**\n\t * Circle shape class.\n\t * @class Circle\n\t * @extends Shape\n\t * @constructor\n\t * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {number} [options.radius=1] The radius of this circle\n\t *\n\t * @example\n\t *     var body = new Body({ mass: 1 });\n\t *     var circleShape = new Circle({\n\t *         radius: 1\n\t *     });\n\t *     body.addShape(circleShape);\n\t */\n\tconstructor(options:CircleOptions|null){\n\t\tsuper(Shape.CIRCLE, options); // Just make sure this has the radius in it (if required).\n\n\t\tif(options)\n\t\t\tthis.radius = options.radius;\n\n\t}\n\n\t/**\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\tvar r = this.radius;\n\t\treturn r * r / 2;\n\t}\n\n\t/**\n\t * @method updateBoundingRadius\n\t * @return {Number}\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = this.radius;\n\t\treturn this.boundingRadius;\n\t}\n\n\t/**\n\t * @method updateArea\n\t * @return {Number}\n\t */\n\tupdateArea(): f32{\n\t\tthis.area = Mathf.PI * this.radius * this.radius;\n\t\treturn this.area;\n\t}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tvar r = this.radius;\n\t\tvec2.set(out.upperBound,  r,  r);\n\t\tvec2.set(out.lowerBound, -r, -r);\n\t\tif(position){\n\t\t\tvec2.add(out.lowerBound, out.lowerBound, position);\n\t\t\tvec2.add(out.upperBound, out.upperBound, position);\n\t\t}\n\t}\n\n\n\t/**\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\t\tlet from: Float32Array = ray.from,\n\t\t\tto: Float32Array = ray.to,\n\t\t\tr: f32 = this.radius;\n\n\t\tlet a: f32 = Mathf.pow(to[0] - from[0], 2) + Mathf.pow(to[1] - from[1], 2);\n\t\tlet b: f32 = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));\n\t\tlet c: f32 = Mathf.pow(from[0] - position[0], 2) + Mathf.pow(from[1] - position[1], 2) - Mathf.pow(r, 2);\n\t\tlet delta: f32 = Mathf.pow(b, 2) - 4 * a * c;\n\n\t\tlet intersectionPoint: Float32Array = Ray_intersectSphere_intersectionPoint;\n\t\tlet normal: Float32Array = Ray_intersectSphere_normal;\n\n\t\tif(delta < 0){\n\t\t\t// No intersection\n\t\t\treturn;\n\n\t\t} else if(delta === 0){\n\t\t\t// single intersection point\n\t\t\tvec2.lerp(intersectionPoint, from, to, delta);\n\n\t\t\tvec2.subtract(normal, intersectionPoint, position);\n\t\t\tvec2.normalize(normal,normal);\n\n\t\t\tray.reportIntersection(result, delta, normal, -1);\n\n\t\t} else {\n\t\t\tlet sqrtDelta: f32 = Mathf.sqrt(delta);\n\t\t\tlet inv2a: f32 = 1.0 / (2.0 * a);\n\t\t\tlet d1: f32 = (- b - sqrtDelta) * inv2a;\n\t\t\tlet d2: f32 = (- b + sqrtDelta) * inv2a;\n\n\t\t\tif(d1 >= 0 && d1 <= 1){\n\t\t\t\tvec2.lerp(intersectionPoint, from, to, d1);\n\n\t\t\t\tvec2.subtract(normal, intersectionPoint, position);\n\t\t\t\tvec2.normalize(normal,normal);\n\n\t\t\t\tray.reportIntersection(result, d1, normal, -1);\n\n\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(d2 >= 0 && d2 <= 1){\n\t\t\t\tvec2.lerp(intersectionPoint, from, to, d2);\n\n\t\t\t\tvec2.subtract(normal, intersectionPoint, position);\n\t\t\t\tvec2.normalize(normal,normal);\n\n\t\t\t\tray.reportIntersection(result, d2, normal, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpointTest(localPoint: Float32Array): boolean{\n\t\tvar radius = this.radius;\n\t\treturn vec2.squaredLength(localPoint) <= radius * radius;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\n\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nimport {Triangulate} from \"../math/polyk\";\n\nvar updateCenterOfMass_centroid = vec2.create(),\n\tupdateCenterOfMass_centroid_times_mass = vec2.create(),\n\tupdateCenterOfMass_a = vec2.create(),\n\tupdateCenterOfMass_b = vec2.create(),\n\tupdateCenterOfMass_c = vec2.create();\n\nvar tmpVec1 = vec2.create();\n\nvar intersectConvex_rayStart = vec2.create();\nvar intersectConvex_rayEnd = vec2.create();\nvar intersectConvex_normal = vec2.create();\n\nvar pic_r0 = vec2.create();\nvar pic_r1 = vec2.create();\n\nvar tmpVec2 = vec2.create();\nvar worldAxis = tmpVec2;\n\nexport class ConvexOptions extends ShapeOptions{}\n\nexport default class Convex extends Shape {\n\n\t// TODO: this would be more efficient if I didn't use float32array[]s. Just convert to a big float32array with double the size.\n\t// Let's get this working first then switch it.\n\t\n\t/**\n\t * Vertices defined in the local frame.\n\t * @property vertices\n\t * @type {Array}\n\t */\n\tpublic vertices: Float32Array[] = [];\n\n\t/**\n\t * Edge normals defined in the local frame, pointing out of the shape.\n\t * @property normals\n\t * @type {Array}\n\t */\n\tpublic normals: Float32Array[] = [];\n\n\t/**\n\t * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n\t * @property triangles\n\t * @type {Array}\n\t */\n\tpublic triangles: Uint16Array[] = [];\n\n\t/**\n\t * The center of mass of the Convex\n\t * @property centerOfMass\n\t * @type {Array}\n\t */\n\tpublic centerOfMass: Float32Array = vec2.create();\n\n\t/**\n\t * Convex shape class.\n\t * @class Convex\n\t * @constructor\n\t * @extends Shape\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];\n\t *     let convexShape = new Convex({\n\t *         vertices: vertices\n\t *     });\n\t *     body.addShape(convexShape);\n\t */\n\tconstructor(type: u16, vertices: Array<Float32Array>|null, options: ShapeOptions|null){\n\t\tsuper(type || Shape.CONVEX, options); \n\n\t\t// Copy the verts\n\t\tlet newVertices: Array<Float32Array>;\n\t\tif(vertices != null) newVertices = vertices;\n\t\telse newVertices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tfor(let i: i32 = 0; i < newVertices.length; i++){\n\t\t\tthis.vertices.push(vec2.clone(newVertices[i]));\n\t\t\tthis.normals.push(vec2.create());\n\t\t}\n\n\t\t// These are called in the shape constructor, but need to call again here because verts weren't set up yet!\n\t\tthis.updateBoundingRadius();\n\t\tthis.updateArea();\n\n\t\tthis.updateNormals();\n\n\t\tthis.triangles = [];\n\n\t\tif(this.vertices.length){\n\t\t\tthis.updateTriangles();\n\t\t\tthis.updateCenterOfMass();\n\t\t}\n\n\t\t/**\n\t\t * The bounding radius of the convex\n\t\t * @property boundingRadius\n\t\t * @type {Number}\n\t\t */\n\t\tthis.boundingRadius = 0;\n\n\t\tthis.updateBoundingRadius();\n\t\tthis.updateArea();\n\t\tif(this.area < 0){\n\t\t\tthrow new Error(\"Convex vertices must be given in counter-clockwise winding.\");\n\t\t}\n\t}\n\n\t\n\tupdateNormals(): void{\n\t\tlet vertices = this.vertices;\n\t\tlet normals = this.normals;\n\n\t\tfor(let i: i32 = 0; i < vertices.length; i++){\n\t\t\tlet worldPoint0 = vertices[i];\n\t\t\tlet worldPoint1 = vertices[(i+1) % vertices.length];\n\n\t\t\tlet normal = normals[i];\n\t\t\tvec2.subtract(normal, worldPoint1, worldPoint0);\n\n\t\t\t// Get normal - just rotate 90 degrees since vertices are given in CCW\n\t\t\tvec2.rotate90cw(normal, normal);\n\t\t\tvec2.normalize(normal, normal);\n\t\t}\n\t}\n\n\t/**\n\t * Project a Convex onto a world-oriented axis\n\t * @method projectOntoAxis\n\t * @static\n\t * @param  {Array} offset\n\t * @param  {Array} localAxis\n\t * @param  {Array} result\n\t */\n\tprojectOntoLocalAxis(localAxis: Float32Array, result: Float32Array): void{\n\n\t\tlet max: f32 = -Infinity,\n\t\t\tmin: f32 = Infinity,\n\t\t\tv: Float32Array|null,\n\t\t\tvalue: f32 = 0;\n\t\t//localAxis = tmpVec1; // TODO: this makes no sense. However, it comes from source: https://github.com/schteppe/p2.js/blob/master/src/shapes/Convex.js#L122\n\n\t\t// Get projected position of all vertices\n\t\tfor(let i: u16 = 0; i < (this.vertices.length as u16); i++){\n\t\t\tv = this.vertices[i];\n\t\t\tvalue = vec2.dot(v, localAxis);\n\t\t\tif(value > max){\n\t\t\t\tmax = value;\n\t\t\t}\n\t\t\tif(value < min){\n\t\t\t\tmin = value;\n\t\t\t}\n\t\t}\n\n\t\tif(min > max){\n\t\t\tlet t = min;\n\t\t\tmin = max;\n\t\t\tmax = t;\n\t\t}\n\n\t\tvec2.set(result, min, max);\n\t}\n\n\tConvexprojectOntoWorldAxis(localAxis: Float32Array, shapeOffset: Float32Array, shapeAngle: f32, result: Float32Array): void{\n\n\t\tthis.projectOntoLocalAxis(localAxis, result);\n\n\t\t// Project the position of the body onto the axis - need to add this to the result\n\t\tif(shapeAngle !== 0){\n\t\t\tvec2.rotate(worldAxis, localAxis, shapeAngle);\n\t\t} else {\n\t\t\tworldAxis = localAxis;\n\t\t}\n\t\tlet offset = vec2.dot(shapeOffset, worldAxis);\n\n\t\tvec2.set(result, result[0] + offset, result[1] + offset);\n\t}\n\n\n\t/**\n\t * Update the .triangles property\n\t * @method updateTriangles\n\t */\n\tupdateTriangles(): void{\n\n\t\tthis.triangles.length = 0;\n\n\t\t// Rewrite on polyk notation, array of numbers\n\t\tlet polykVerts:f32[] = [];\n\t\tfor(let i:u16=0; i < (this.vertices.length as u16); i++){\n\t\t\tlet v = this.vertices[i];\n\t\t\tpolykVerts.push(v[0]);\n\t\t\tpolykVerts.push(v[1]);\n\t\t}\n\n\t\t// Triangulate\n\t\tlet triangles = Triangulate(polykVerts);\n\n\t\t// Loop over all triangles, add their inertia contributions to I\n\t\tfor(let i:u16=0; i < (triangles.length as u16); i+=3){\n\t\t\tlet id1:u16 = triangles[i] as u16,\n\t\t\t\tid2:u16 = triangles[i+1] as u16,\n\t\t\t\tid3:u16 = triangles[i+2] as u16;\n\n\t\t\t// Add to triangles\n\t\t\tlet T = new Uint16Array(3);\n\t\t\tT[0] = id1;\n\t\t\tT[1] = id2;\n\t\t\tT[2] = id3;\n\t\t\tthis.triangles.push(T);\n\t\t}\n\t}\n\n\t/**\n\t * Update the .centerOfMass property.\n\t * @method updateCenterOfMass\n\t */\n\tupdateCenterOfMass(): void{\n\n\n\t\tlet triangles = this.triangles,\n\t\t\t\tverts = this.vertices,\n\t\t\t\tcm = this.centerOfMass,\n\t\t\t\tcentroid = updateCenterOfMass_centroid,\n\t\t\t\ta = updateCenterOfMass_a,\n\t\t\t\tb = updateCenterOfMass_b,\n\t\t\t\tc = updateCenterOfMass_c,\n\t\t\t\tcentroid_times_mass = updateCenterOfMass_centroid_times_mass;\n\n\t\tvec2.set(cm,0,0);\n\t\tlet totalArea: f32 = 0;\n\n\t\tfor(let i: u16 = 0; i < (triangles.length as u16); i++){\n\t\t\tlet t = triangles[i],\n\t\t\t\tva = verts[t[0]],\n\t\t\t\tvb = verts[t[1]],\n\t\t\t\tvc = verts[t[2]];\n\n\t\t\tvec2.centroid(centroid,va,vb,vc);\n\n\t\t\t// Get mass for the triangle (density=1 in this case)\n\t\t\t// http://Mathf.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n\t\t\tlet m = Convex.triangleArea(va,vb,vc);\n\t\t\ttotalArea += m;\n\n\t\t\t// Add to center of mass\n\t\t\tvec2.scale(centroid_times_mass, centroid, m);\n\t\t\tvec2.add(cm, cm, centroid_times_mass);\n\t\t}\n\n\t\tvec2.scale(cm,cm,1/totalArea);\n\t}\n\n\t/**\n\t * Compute the moment of inertia of the Convex.\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\tlet denom: f32 = 0.0,\n\t\t\tnumer: f32 = 0.0,\n\t\t\tN: i32 = this.vertices.length;\n\t\tfor(let j: i32 = N-1, i = 0; i < N; j = i, i ++){\n\t\t\tlet p0 = this.vertices[j];\n\t\t\tlet p1 = this.vertices[i];\n\t\t\tlet a = Mathf.abs(vec2.crossLength(p0,p1));\n\t\t\tlet b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);\n\t\t\tdenom += a * b;\n\t\t\tnumer += a;\n\t\t}\n\t\treturn (1.0 / 6.0) * (denom / numer);\n\t}\n\n\t/**\n\t * Updates the .boundingRadius property\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tlet verts = this.vertices,\n\t\t\tr2: f32 = 0;\n\t\tif(!verts || verts.length == 0) return 0;\n\t\tfor(let i:u16 = 0; i!==verts.length; i++){\n\t\t\tlet l2: f32 = vec2.squaredLength(verts[i]);\n\t\t\tif(l2 > r2){\n\t\t\t\tr2 = l2;\n\t\t\t}\n\t\t}\n\n\t\tthis.boundingRadius = Mathf.sqrt(r2);\n\t\t\n\t\treturn this.boundingRadius;\n\t}\n\n\t/**\n\t * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.\n\t * @static\n\t * @method triangleArea\n\t * @param {Array} a\n\t * @param {Array} b\n\t * @param {Array} c\n\t * @return {Number}\n\t * @deprecated\n\t */\n\tstatic triangleArea(a: Float32Array, b: Float32Array, c: Float32Array): f32{\n\t\treturn (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;\n\t}\n\n\t/**\n\t * Update the .area\n\t * @method updateArea\n\t */\n\tupdateArea(): f32{\n\t\tif(!this.vertices) return 0;\n\t\tthis.updateTriangles();\n\t\tthis.area = 0;\n\n\t\tlet triangles = this.triangles,\n\t\t\tverts = this.vertices;\n\t\tfor(let i: i32 = 0; i!==triangles.length; i++){\n\t\t\tlet t = triangles[i],\n\t\t\t\ta = verts[t[0]],\n\t\t\t\tb = verts[t[1]],\n\t\t\t\tc = verts[t[2]];\n\n\t\t\t// Get mass for the triangle (density=1 in this case)\n\t\t\tlet m = Convex.triangleArea(a,b,c);\n\t\t\tthis.area += m;\n\t\t}\n\n\t\treturn this.area;\n\t}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t * @todo: approximate with a local AABB?\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tout.setFromPoints(this.vertices, position, angle, 0);\n\t}\n\n\n\t/**\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\t\tlet rayStart = intersectConvex_rayStart;\n\t\tlet rayEnd = intersectConvex_rayEnd;\n\t\tlet normal = intersectConvex_normal;\n\t\tlet vertices = this.vertices;\n\n\t\t// Transform to local shape space\n\t\tvec2.toLocalFrame(rayStart, ray.from, position, angle);\n\t\tvec2.toLocalFrame(rayEnd, ray.to, position, angle);\n\n\t\tlet n = vertices.length;\n\n\t\tfor (let i = 0; i < n && !result.shouldStop(ray); i++) {\n\t\t\tlet q1 = vertices[i];\n\t\t\tlet q2 = vertices[(i+1) % n];\n\t\t\tlet delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);\n\n\t\t\tif(delta >= 0){\n\t\t\t\tvec2.subtract(normal, q2, q1);\n\t\t\t\tvec2.rotate(normal, normal, -Mathf.PI / 2 + angle);\n\t\t\t\tvec2.normalize(normal, normal);\n\t\t\t\tray.reportIntersection(result, delta, normal, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpointTest(localPoint: Float32Array): boolean{\n\n\t\tlet r0: Float32Array = pic_r0,\n\t\t\tr1: Float32Array = pic_r1,\n\t\t\tverts: Float32Array[] = this.vertices,\n\t\t\tlastCross: f32 = -1,\n\t\t\tnumVerts: u16 = verts.length as u16;\n\n\t\tfor(let i: u16 = 0; i < numVerts + 1; i++){\n\t\t\tlet v0 = verts[i % numVerts],\n\t\t\t\tv1 = verts[(i + 1) % numVerts];\n\n\t\t\tvec2.subtract(r0, v0, localPoint);\n\t\t\tvec2.subtract(r1, v1, localPoint);\n\n\t\t\tlet cross: f32 = vec2.crossLength(r0,r1);\n\n\t\t\tif(lastCross === -1){\n\t\t\t\tlastCross = cross;\n\t\t\t}\n\n\t\t\t// If we got a different sign of the distance vector, the point is out of the polygon\n\t\t\tif(cross * lastCross < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlastCross = cross;\n\t\t}\n\t\treturn true;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// let Shape = require('./Shape')\n// ,   shallowClone = require('../utils/Utils').shallowClone\n// ,   vec2 = require('../math/vec2');\n\nimport vec2 from \"../math/vec2\";\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\n\nfunction boxI(w: f32, h: f32): f32 {\n\treturn w * h * (Mathf.pow(w, 2) + Mathf.pow(h, 2)) / 12;\n}\nfunction semiA(r: f32): f32 {\n\treturn Mathf.PI * Mathf.pow(r, 2) / 2;\n}\n// http://www.efunda.com/math/areas/CircleHalf.cfm\nfunction semiI(r: f32): f32 {\n\treturn ((Mathf.PI / 4) - (8 / (9 * Mathf.PI))) * Mathf.pow(r, 4);\n}\nfunction semiC(r: f32): f32 {\n\treturn (4 * r) / (3 * Mathf.PI);\n}\n// https://en.wikipedia.org/wiki/Second_moment_of_area#Parallel_axis_theorem\nfunction capsuleA(l: f32, r: f32): f32 {\n\treturn l * 2 * r + Mathf.PI * Mathf.pow(r, 2);\n}\nfunction capsuleI(l: f32, r: f32): f32 {\n\tlet d = l / 2 + semiC(r);\n\treturn boxI(l, 2 * r) + 2 * (semiI(r) + semiA(r) * Mathf.pow(d, 2));\n}\n\nvar intersectCapsule_hitPointWorld = vec2.create();\nvar intersectCapsule_normal = vec2.create();\nvar intersectCapsule_l0 = vec2.create();\nvar intersectCapsule_l1 = vec2.create();\nvar intersectCapsule_unit_y = vec2.fromValues(0,1);\n\nexport class CapsuleOptions extends ShapeOptions{\n\tlength: f32 = 1;\n\tradius: f32 = 1;\n}\n\nexport default class Capsule extends Shape{\n\t/**\n\t * The distance between the end points.\n\t * @property {Number} length\n\t */\n\tlength: f32 = 1;\n\n\t/**\n\t * The radius of the capsule.\n\t * @property {Number} radius\n\t */\n\tradius: f32 = 1;\n\n\t/**\n\t * Capsule shape.\n\t * @class Capsule\n\t * @constructor\n\t * @extends Shape\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Number} [options.length=1] The distance between the end points, extends along the X axis.\n\t * @param {Number} [options.radius=1] Radius of the capsule.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let capsuleShape = new Capsule({\n\t *         length: 1,\n\t *         radius: 2\n\t *     });\n\t *     body.addShape(capsuleShape);\n\t */\n\tconstructor(options: CapsuleOptions|null){\n\t\tsuper(Shape.CAPSULE, options);\n\t\tif(options){\n\t\t\tthis.length = options.length;\n\t\t\tthis.radius = options.radius;\n\t\t}\n\t}\n\n\t/**\n\t * Compute the mass moment of inertia of the Capsule.\n\t * @method conputeMomentOfInertia\n\t * @return {Number}\n\t * @todo\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\t// http://www.efunda.com/math/areas/rectangle.cfm\n\t\tlet r = this.radius,\n\t\t\tl = this.length,\n\t\t\tarea = capsuleA(l, r);\n\t\treturn (area > 0) ? capsuleI(l, r) / area : 0;\n\t}\n\n\t/**\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = this.radius + this.length/2;\n\t\treturn this.boundingRadius;\n\t}\n\n\t/**\n\t * @method updateArea\n\t */\n\tupdateArea(): f32{\n\t\tthis.area = Mathf.PI * this.radius * this.radius + this.radius * 2 * this.length;\n\t\treturn this.area;\n\t}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\n\t\tlet r = vec2.create();\n\t\tlet radius = this.radius;\n\n\t\t// Compute center position of one of the the circles, world oriented, but with local offset\n\t\tvec2.set(r,this.length / 2,0);\n\t\tif(angle !== 0){\n\t\t\tvec2.rotate(r,r,angle);\n\t\t}\n\n\t\t// Get bounds\n\t\tvec2.set(out.upperBound,  Mathf.max(r[0]+radius, -r[0]+radius),\n\t\t\t\t\t\t\t\tMathf.max(r[1]+radius, -r[1]+radius));\n\t\tvec2.set(out.lowerBound,  Mathf.min(r[0]-radius, -r[0]-radius),\n\t\t\t\t\t\t\t\tMathf.min(r[1]-radius, -r[1]-radius));\n\n\t\t// Add offset\n\t\tvec2.add(out.lowerBound, out.lowerBound, position);\n\t\tvec2.add(out.upperBound, out.upperBound, position);\n\t}\n\n\n\t/**\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\n\t\tlet from = ray.from;\n\t\tlet to = ray.to;\n\n\t\tlet hitPointWorld = intersectCapsule_hitPointWorld;\n\t\tlet normal = intersectCapsule_normal;\n\t\tlet l0 = intersectCapsule_l0;\n\t\tlet l1 = intersectCapsule_l1;\n\n\t\t// The sides\n\t\tlet halfLen = this.length / 2;\n\t\tfor(let i: f32 = 0; i < 2; i++){\n\n\t\t\t// get start and end of the line\n\t\t\tlet y: f32 = this.radius * (i * 2 - 1);\n\t\t\tvec2.set(l0, -halfLen, y);\n\t\t\tvec2.set(l1, halfLen, y);\n\t\t\tvec2.toGlobalFrame(l0, l0, position, angle);\n\t\t\tvec2.toGlobalFrame(l1, l1, position, angle);\n\n\t\t\tlet delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);\n\t\t\tif(delta >= 0){\n\t\t\t\tvec2.rotate(normal, intersectCapsule_unit_y, angle);\n\t\t\t\tvec2.scale(normal, normal, (i*2-1));\n\t\t\t\tray.reportIntersection(result, delta, normal, -1);\n\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Circles\n\t\tlet diagonalLengthSquared = Mathf.pow(this.radius, 2) + Mathf.pow(halfLen, 2);\n\t\tfor(let i: f32 = 0; i < 2; i++){\n\t\t\tvec2.set(l0, halfLen * (i * 2 - 1), 0);\n\t\t\tvec2.toGlobalFrame(l0, l0, position, angle);\n\n\t\t\tlet dfl0 = from[0] - l0[0];\n\t\t\tlet dfl1 = from[1] - l0[1];\n\t\t\tlet dl0 = to[0] - from[0];\n\t\t\tlet dl1 = to[1] - from[1];\n\t\t\tlet a: f32 = dl0 + dl1 * dl1;\n\t\t\tlet b: f32 = 2.0 * (dl0*dfl0 + dl1*dfl1);\n\t\t\tlet c: f32 = dfl0*dfl0 + dfl1*dfl1 - this.radius*this.radius;\n\t\t\tlet delta: f32 = b*b - 4 * a * c;\n\n\t\t\tif(delta < 0){\n\t\t\t\t// No intersection\n\t\t\t\tcontinue;\n\n\t\t\t} else if(delta === 0){\n\t\t\t\t// single intersection point\n\t\t\t\tvec2.lerp(hitPointWorld, from, to, delta);\n\n\t\t\t\tif(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n\t\t\t\t\tvec2.subtract(normal, hitPointWorld, l0);\n\t\t\t\t\tvec2.normalize(normal,normal);\n\t\t\t\t\tray.reportIntersection(result, delta, normal, -1);\n\t\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tlet sqrtDelta: f32 = Mathf.sqrt(delta);\n\t\t\t\tlet inv2a: f32 = 1.0 / (2.0 * a);\n\t\t\t\tlet d1: f32 = (- b - sqrtDelta) * inv2a;\n\t\t\t\tlet d2: f32 = (- b + sqrtDelta) * inv2a;\n\n\t\t\t\tif(d1 >= 0 && d1 <= 1){\n\t\t\t\t\tvec2.lerp(hitPointWorld, from, to, d1);\n\t\t\t\t\tif(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n\t\t\t\t\t\tvec2.subtract(normal, hitPointWorld, l0);\n\t\t\t\t\t\tvec2.normalize(normal,normal);\n\t\t\t\t\t\tray.reportIntersection(result, d1, normal, -1);\n\t\t\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(d2 >= 0 && d2 <= 1){\n\t\t\t\t\tvec2.lerp(hitPointWorld, from, to, d2);\n\t\t\t\t\tif(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n\t\t\t\t\t\tvec2.subtract(normal, hitPointWorld, l0);\n\t\t\t\t\t\tvec2.normalize(normal,normal);\n\t\t\t\t\t\tray.reportIntersection(result, d2, normal, -1);\n\t\t\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpointTest(localPoint: Float32Array): boolean{\n\t\tlet radius = this.radius;\n\t\tlet halfLength = this.length * 0.5;\n\n\t\tif((Mathf.abs(localPoint[0]) <= halfLength && Mathf.abs(localPoint[1]) <= radius)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif(Mathf.pow(localPoint[0] - halfLength, 2) + Mathf.pow(localPoint[1], 2) <= radius * radius){\n\t\t\treturn true;\n\t\t}\n\n\t\tif(Mathf.pow(localPoint[0] + halfLength, 2) + Mathf.pow(localPoint[1], 2) <= radius * radius){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nvar intersectPlane_planePointToFrom = vec2.create();\nvar intersectPlane_normal = vec2.create();\nvar intersectPlane_len = vec2.create();\n\nexport class PlaneOptions extends ShapeOptions{}\n\nexport default class Plane extends Shape{\n\n\t/**\n\t * Plane shape class. The plane is facing in the Y direction.\n\t * @class Plane\n\t * @extends Shape\n\t * @constructor\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @example\n\t *     var body = new Body();\n\t *     var shape = new Plane();\n\t *     body.addShape(shape);\n\t */\n\tconstructor(options: ShapeOptions|null){\n\t\tsuper(Shape.PLANE, options);\n\t}\n\n\t/**\n\t * Compute moment of inertia\n\t * @method computeMomentOfInertia\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\treturn 0; // Plane is infinite. The inertia should therefore be infinity but by convention we set 0 here\n\t}\n\n\t/**\n\t * Update the bounding radius\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = Infinity;\n\t\treturn Infinity;\n\t}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tvar a = angle % (2.0 * Mathf.PI);\n\t\tvar max: f32 = 1e7;\n\t\tvar lowerBound = out.lowerBound;\n\t\tvar upperBound = out.upperBound;\n\n\t\t// Set max bounds\n\t\tvec2.set(lowerBound, -max, -max);\n\t\tvec2.set(upperBound,  max,  max);\n\n\t\tif(a === 0){\n\t\t\t// y goes from -inf to 0\n\t\t\tupperBound[1] = position[1];\n\n\t\t} else if(a === Math.PI / 2){\n\n\t\t\t// x goes from 0 to inf\n\t\t\tlowerBound[0] = position[0];\n\n\t\t} else if(a === Math.PI){\n\n\t\t\t// y goes from 0 to inf\n\t\t\tlowerBound[1] = position[1];\n\n\t\t} else if(a === 3*Math.PI/2){\n\n\t\t\t// x goes from -inf to 0\n\t\t\tupperBound[0] = position[0];\n\n\t\t}\n\t}\n\n\tupdateArea(): f32{\n\t\tthis.area = Infinity;\n\t\treturn Infinity;\n\t}\n\n\n\t/**\n\t * @method raycast\n\t * @param  {RayResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\n\t\tvar from = ray.from;\n\t\tvar to = ray.to;\n\t\tvar direction = ray.direction;\n\t\tvar planePointToFrom = intersectPlane_planePointToFrom;\n\t\tvar normal = intersectPlane_normal;\n\t\tvar len = intersectPlane_len;\n\n\t\t// Get plane normal\n\t\tvec2.set(normal, 0, 1);\n\t\tvec2.rotate(normal, normal, angle);\n\n\t\tvec2.subtract(len, from, position);\n\t\tvar planeToFrom = vec2.dot(len, normal);\n\t\tvec2.subtract(len, to, position);\n\t\tvar planeToTo = vec2.dot(len, normal);\n\n\t\tif(planeToFrom * planeToTo > 0){\n\t\t\t// \"from\" and \"to\" are on the same side of the plane... bail out\n\t\t\treturn;\n\t\t}\n\n\t\tif(vec2.squaredDistance(from, to) < planeToFrom * planeToFrom){\n\t\t\treturn;\n\t\t}\n\n\t\tvar n_dot_dir = vec2.dot(normal, direction);\n\n\t\tvec2.subtract(planePointToFrom, from, position);\n\t\tvar t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;\n\n\t\tray.reportIntersection(result, t, normal, -1);\n\t};\n\n\tpointTest(localPoint: Float32Array): boolean{\n\t\treturn localPoint[1] <= 0;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nexport default class Material{\n\n\tstatic idCounter: u32 = 0;\n\t\n\tpublic id: u32;\n\n\t/**\n\t * Defines a physics material. To be used with {{#crossLink \"ContactMaterial\"}}{{/crossLink}}.\n\t * @class Material\n\t * @constructor\n\t * @author schteppe\n\t * @example\n\t *     // Create a wooden box\n\t *     var woodMaterial = new Material();\n\t *     var boxShape = new Box({\n\t *         material: woodMaterial\n\t *     });\n\t *     body.addShape(boxShape);\n\t */\n\tconstructor(){\n\n\t\t/**\n\t\t * The material identifier. Read only.\n\t\t * @readonly\n\t\t * @property id\n\t\t * @type {Number}\n\t\t */\n\t\tthis.id = ++Material.idCounter;\n\t}\n\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// var Shape = require('./Shape')\n// ,   shallowClone = require('../utils/Utils').shallowClone\n// ,   vec2 = require('../math/vec2');\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport AABB from \"../collision/aabb\";\nimport Material from \"../material/Material\";\nimport vec2 from \"../math/vec2\";\n\nvar raycast_normal = vec2.create();\nvar raycast_l0 = vec2.create();\nvar raycast_l1 = vec2.create();\nvar raycast_unit_y = vec2.fromValues(0,1);\n\nexport class LineOptions extends ShapeOptions{\n\tlength: f32 = 1\n}\n\nexport default class Line extends Shape{\n\t/**\n\t * Length of this line\n\t * @property {Number} length\n\t * @default 1\n\t */\n\tlength: f32 = 1;\n\n\t/**\n\t * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n\t * @class Line\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Number} [options.length=1] The total length of the line\n\t * @extends Shape\n\t * @constructor\n\t * @example\n\t *     var body = new Body();\n\t *     var lineShape = new Line({\n\t *         length: 1\n\t *     });\n\t *     body.addShape(lineShape);\n\t */\n\tconstructor(options: LineOptions){\n\t\tsuper(Shape.LINE, options);\n\n\t\tif(options){\n\t\t\tthis.length = options.length;\n\t\t}\n\t}\n\n\tcomputeMomentOfInertia(): f32{\n\t\treturn Mathf.pow(this.length,2) / 12;\n\t};\n\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = this.length/2;\n\t\treturn this.boundingRadius;\n\t};\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\n\t\tvar points = [vec2.create(),vec2.create()];\n\n\t\tvar l2 = this.length / 2;\n\t\tvec2.set(points[0], -l2,  0);\n\t\tvec2.set(points[1],  l2,  0);\n\t\tout.setFromPoints(points,position,angle,0);\n\t};\n\n\tupdateArea(): f32 { return 0}\n\n\t/**\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @param  {number} angle\n\t * @param  {array} position\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\n\t\tvar from = ray.from;\n\t\tvar to = ray.to;\n\n\t\tvar l0 = raycast_l0;\n\t\tvar l1 = raycast_l1;\n\n\t\t// get start and end of the line\n\t\tvar halfLen = this.length / 2;\n\t\tvec2.set(l0, -halfLen, 0);\n\t\tvec2.set(l1, halfLen, 0);\n\t\tvec2.toGlobalFrame(l0, l0, position, angle);\n\t\tvec2.toGlobalFrame(l1, l1, position, angle);\n\n\t\tvar fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);\n\t\tif(fraction >= 0){\n\t\t\tvar normal = raycast_normal;\n\t\t\tvec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from\n\t\t\tray.reportIntersection(result, fraction, normal, -1);\n\t\t}\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// let Shape = require('./Shape')\n// ,    vec2 = require('../math/vec2')\n// ,    shallowClone = require('../utils/Utils').shallowClone;\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nvar intersectHeightfield_worldNormal = vec2.create();\nvar intersectHeightfield_l0 = vec2.create();\nvar intersectHeightfield_l1 = vec2.create();\nvar intersectHeightfield_localFrom = vec2.create();\nvar intersectHeightfield_localTo = vec2.create();\n\nexport class HeightfieldOptions extends ShapeOptions{\n\theights: Array<f32> = []; // TODO: switch to f32array.\n\telementWidth: f32 = 0.1;\n}\n\nexport default class Heightfield extends Shape{\n\n\t/**\n\t * An array of numbers, or height values, that are spread out along the x axis.\n\t * @property {array} heights\n\t */\n\theights: Array<f32> = [];\n\n\t/**\n\t * Max value of the heights\n\t * @property {number} maxValue\n\t */\n\tmaxValue: f32 = 0;\n\n\t/**\n\t * Max value of the heights\n\t * @property {number} minValue\n\t */\n\tminValue: f32 = 0;\n\n\t/**\n\t * The width of each element\n\t * @property {number} elementWidth\n\t */\n\telementWidth: f32 = 0.1;\n\n\t/**\n\t * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance \"elementWidth\".\n\t * @class Heightfield\n\t * @extends Shape\n\t * @constructor\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.\n\t * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.\n\t * @param {Number} [options.maxValue] Maximum value.\n\t * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.\n\t *\n\t * @example\n\t *     // Generate some height data (y-values).\n\t *     let heights = [];\n\t *     for(let i: i32 = 0; i < 1000; i++){\n\t *         let y = 0.5 * Mathf.cos(0.2 * i);\n\t *         heights.push(y);\n\t *     }\n\t *\n\t *     // Create the heightfield shape\n\t *     let shape = new Heightfield({\n\t *         heights: heights,\n\t *         elementWidth: 1 // Distance between the data points in X direction\n\t *     });\n\t *     let body = new Body();\n\t *     body.addShape(shape);\n\t *     world.addBody(body);\n\t *\n\t * @todo Should use a scale property with X and Y direction instead of just elementWidth\n\t */\n\tconstructor(options: HeightfieldOptions|null){\n\n\t\tsuper(Shape.HEIGHTFIELD, options); \n\n\t\tif(options){\n\t\t\tthis.heights = options.heights.slice(0);\n\t\t\tthis.elementWidth = options.elementWidth;\n\t\t}\n\n\t\tthis.updateArea();\n\t\tthis.updateMaxMinValues();\n\t}\n\n\t/**\n\t * Update the .minValue and the .maxValue\n\t * @method updateMaxMinValues\n\t */\n\tupdateMaxMinValues(): void{\n\t\tlet data = this.heights;\n\t\tlet maxValue = data[0];\n\t\tlet minValue = data[0];\n\t\tfor(let i: u16 = 0; i < (data.length as u16); i++){\n\t\t\tlet v = data[i];\n\t\t\tif(v > maxValue){\n\t\t\t\tmaxValue = v;\n\t\t\t}\n\t\t\tif(v < minValue){\n\t\t\t\tminValue = v;\n\t\t\t}\n\t\t}\n\t\tthis.maxValue = maxValue;\n\t\tthis.minValue = minValue;\n\t}\n\n\t/**\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\treturn Infinity;\n\t}\n\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = Infinity;\n\t\treturn this.boundingRadius;\n\t}\n\n\tupdateArea(): f32{\n\t\tlet data = this.heights,\n\t\t\tarea: f32 = 0;\n\t\tif(!data) return 0;\n\t\tfor(let i: i32 = 0; i<data.length - 1; i++){\n\t\t\tarea += (data[i]+data[i+1]) / 2.0 * this.elementWidth;\n\t\t}\n\t\tthis.area = area;\n\n\t\treturn this.area;\n\t}\n\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tlet points = [\n\t\t\tvec2.create(),\n\t\t\tvec2.create(),\n\t\t\tvec2.create(),\n\t\t\tvec2.create()\n\t\t] as Float32Array[];\n\n\t\tvec2.set(points[0], 0, this.maxValue);\n\t\tvec2.set(points[1], this.elementWidth * (this.heights.length as f32), this.maxValue);\n\t\tvec2.set(points[2], this.elementWidth * (this.heights.length as f32), this.minValue);\n\t\tvec2.set(points[3], 0, this.minValue);\n\t\tout.setFromPoints(points, position, angle);\n\t}\n\n\t/**\n\t * Get a line segment in the heightfield\n\t * @method getLineSegment\n\t * @param  {array} start Where to store the resulting start point\n\t * @param  {array} end Where to store the resulting end point\n\t * @param  {number} i\n\t */\n\tgetLineSegment(start: Float32Array, end: Float32Array, i: i32): void{\n\t\tlet data = this.heights;\n\t\tlet width = this.elementWidth;\n\t\tvec2.set(start, (i as f32) * width, data[i]);\n\t\tvec2.set(end, ((i as f32) + 1.0) * width, data[i + 1]);\n\t}\n\n\tgetSegmentIndex(position: Float32Array): i32{\n\t\treturn Mathf.floor(position[0] / this.elementWidth) as i32;\n\t}\n\n\tgetClampedSegmentIndex(position: Float32Array): i32{\n\t\tlet i: i32 = this.getSegmentIndex(position);\n\t\tif(i < 0) i = 0;\n\t\tif(i > this.heights.length) i = this.heights.length;\n\t\treturn i;\n\t}\n\n\t/**\n\t * @method raycast\n\t * @param  {RayResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\n\t\tlet from = ray.from;\n\t\tlet to = ray.to;\n\n\t\tlet worldNormal = intersectHeightfield_worldNormal;\n\t\tlet l0 = intersectHeightfield_l0;\n\t\tlet l1 = intersectHeightfield_l1;\n\t\tlet localFrom = intersectHeightfield_localFrom;\n\t\tlet localTo = intersectHeightfield_localTo;\n\n\t\t// get local ray start and end\n\t\tvec2.toLocalFrame(localFrom, from, position, angle);\n\t\tvec2.toLocalFrame(localTo, to, position, angle);\n\n\t\t// Get the segment range\n\t\tlet i0 = this.getClampedSegmentIndex(localFrom);\n\t\tlet i1 = this.getClampedSegmentIndex(localTo);\n\t\tif(i0 > i1){\n\t\t\tlet tmp = i0;\n\t\t\ti0 = i1;\n\t\t\ti1 = tmp;\n\t\t}\n\n\t\t// The segments\n\t\tfor(let i: i32 = 0; i<this.heights.length - 1; i++){\n\t\t\tthis.getLineSegment(l0, l1, i);\n\t\t\tlet t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);\n\t\t\tif(t >= 0){\n\t\t\t\tvec2.subtract(worldNormal, l1, l0);\n\t\t\t\tvec2.rotate(worldNormal, worldNormal, angle + Mathf.PI / 2);\n\t\t\t\tvec2.normalize(worldNormal, worldNormal);\n\t\t\t\tray.reportIntersection(result, t, worldNormal, -1);\n\t\t\t\tif(result.shouldStop(ray)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\n\nimport Circle from \"../shapes/circle\";\nimport { CircleOptions } from \"../shapes/circle\";\nimport Convex from \"../shapes/convex\";\nimport Shape from \"../shapes/shape\";\nimport Box from \"../shapes/box\";\nimport { BoxOptions } from \"../shapes/box\";\nimport ContactMaterial from \"../material/contact-material\";\nimport Body from \"../objects/body\";\nimport Equation from \"../equations/equation\";\nimport ContactEquation from \"../equations/contact-equation\";\nimport Capsule from \"../shapes/capsule\";\nimport Plane from \"../shapes/plane\";\nimport Line from \"../shapes/line\";\nimport Particle from \"../shapes/particle\";\nimport Heightfield from \"../shapes/heightfield\";\nimport ContactEquationPool from \"../utils/contact-equation-pool\";\nimport FrictionEquationPool from \"../utils/friction-equation-pool\";\nimport TupleDictionary from \"../utils/tuple-dictionary\";\nimport FrictionEquation from \"../equations/friction-equation\";\n\nvar yAxis = vec2.fromValues(0,1);\nvar tmp1 = vec2.create()\n,   tmp2 = vec2.create()\n,   tmp3 = vec2.create()\n,   tmp4 = vec2.create()\n,   tmp5 = vec2.create()\n,   tmp6 = vec2.create()\n,   tmp7 = vec2.create()\n,   tmp8 = vec2.create()\n,   tmp9 = vec2.create()\n,   tmp10 = vec2.create()\n,   tmp11 = vec2.create()\n,   tmp12 = vec2.create()\n,   tmp13 = vec2.create()\n,   tmp14 = vec2.create()\n,   tmp15 = vec2.create()\n,   tmpArray: Array<Float32Array> = [];\n\n\nvar findMaxSeparation_n = vec2.create();\nvar findMaxSeparation_v1 = vec2.create();\nvar findMaxSeparation_tmp = vec2.create();\nvar findMaxSeparation_tmp2 = vec2.create();\n\nvar findIncidentEdge_normal1 = vec2.create();\n\nvar collidePolygons_tempVec = vec2.create();\nvar collidePolygons_tmpVec = vec2.create();\nvar collidePolygons_localTangent = vec2.create();\nvar collidePolygons_localNormal = vec2.create();\nvar collidePolygons_planePoint = vec2.create();\nvar collidePolygons_tangent = vec2.create();\nvar collidePolygons_normal = vec2.create();\nvar collidePolygons_negativeTangent = vec2.create();\nvar collidePolygons_v11 = vec2.create();\nvar collidePolygons_v12 = vec2.create();\nvar collidePolygons_dist = vec2.create();\nvar collidePolygons_clipPoints1 = [vec2.create(), vec2.create()];\nvar collidePolygons_clipPoints2 = [vec2.create(), vec2.create()];\nvar collidePolygons_incidentEdge = [vec2.create(), vec2.create()];\n\nvar pic_localPoint = vec2.create(),\n\tpic_r0 = vec2.create(),\n\tpic_r1 = vec2.create();\n\nvar bodiesOverlap_shapePositionA = vec2.create(),\n\tbodiesOverlap_shapePositionB = vec2.create();\n\nvar capsuleCapsule_tempVec1 = vec2.create(),\n\tcapsuleCapsule_tempVec2 = vec2.create();\n\nvar convexCapsule_tempVec = vec2.create();\n\nvar planeCapsule_tmp1 = vec2.create(), \n\tplaneCapsule_tmp2 = vec2.create();\n\nvar circleHeightfield_candidate = vec2.create(),\n\tcircleHeightfield_dist = vec2.create(),\n\tcircleHeightfield_v0 = vec2.create(),\n\tcircleHeightfield_v1 = vec2.create(),\n\tcircleHeightfield_minCandidate = vec2.create(),\n\tcircleHeightfield_worldNormal = vec2.create(),\n\tcircleHeightfield_minCandidateNormal = vec2.create();\n\nvar convexHeightfield_v0 = vec2.create(),\n\tconvexHeightfield_v1 = vec2.create(),\n\tconvexHeightfield_tilePos = vec2.create(),\n\tconvexHeightfield_tempConvexShape = new Convex(0, [vec2.create(),vec2.create(),vec2.create(),vec2.create()], null );\n\nfunction setConvexToCapsuleShapeMiddle(convexShape: Box, capsuleShape: Capsule): void{\n\tlet capsuleRadius = capsuleShape.radius;\n\tlet halfCapsuleLength = capsuleShape.length * 0.5;\n\tlet verts = convexShape.vertices;\n\tvec2.set(verts[0], -halfCapsuleLength, -capsuleRadius);\n\tvec2.set(verts[1],  halfCapsuleLength, -capsuleRadius);\n\tvec2.set(verts[2],  halfCapsuleLength,  capsuleRadius);\n\tvec2.set(verts[3], -halfCapsuleLength,  capsuleRadius);\n}\n\n/*\n* Check if a point is in a polygon\n*/\nfunction pointInConvex(worldPoint: Float32Array, convexShape: Convex, convexOffset: Float32Array, convexAngle: f32): boolean{\n\n\n\n\tlet localPoint = pic_localPoint,\n\t\tr0 = pic_r0,\n\t\tr1 = pic_r1,\n\t\tverts = convexShape.vertices,\n\t\tlastCross: f32 = -1;\n\n\tvec2.toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);\n\n\tfor(let i: i32 =0, numVerts=verts.length; i!==numVerts+1; i++){\n\t\tlet v0: Float32Array = verts[i % numVerts],\n\t\t\tv1: Float32Array = verts[(i+1) % numVerts];\n\n\t\tvec2.subtract(r0, v0, localPoint);\n\t\tvec2.subtract(r1, v1, localPoint);\n\n\t\tlet cross: f32 = vec2.crossLength(r0,r1);\n\n\t\tif(lastCross == -1){\n\t\t\tlastCross = cross;\n\t\t}\n\n\t\t// If we got a different sign of the distance vector, the point is out of the polygon\n\t\tif(cross*lastCross < 0){\n\t\t\treturn false;\n\t\t}\n\t\tlastCross = cross;\n\t}\n\treturn true;\n}\n\n/*\n* Check if a point is in a polygon\n*/\nfunction pointInConvexLocal(localPoint: Float32Array, convexShape: Convex): boolean{\n\tlet r0: Float32Array = pic_r0,\n\t\tr1: Float32Array = pic_r1,\n\t\tverts: Float32Array[] = convexShape.vertices,\n\t\tlastCross: f32 = -1,\n\t\tnumVerts: i32 = verts.length;\n\n\tfor(let i: i32 = 0; i < numVerts + 1; i++){\n\t\tlet v0 = verts[i % numVerts],\n\t\t\tv1 = verts[(i + 1) % numVerts];\n\n\t\tvec2.subtract(r0, v0, localPoint);\n\t\tvec2.subtract(r1, v1, localPoint);\n\n\t\tlet cross = vec2.crossLength(r0,r1);\n\n\t\tif(lastCross == -1){\n\t\t\tlastCross = cross;\n\t\t}\n\n\t\t// If we got a different sign of the distance vector, the point is out of the polygon\n\t\tif(cross * lastCross < 0){\n\t\t\treturn false;\n\t\t}\n\t\tlastCross = cross;\n\t}\n\treturn true;\n}\n\nfunction addSub(out: Float32Array, a: Float32Array, b: Float32Array, c: Float32Array): void{\n\tout[0] = a[0] + b[0] - c[0];\n\tout[1] = a[1] + b[1] - c[1];\n}\n\nfunction findMaxSeparation(maxSeparationOut: Float32Array, poly1: Convex, position1: Float32Array, angle1: f32, poly2: Convex, position2: Float32Array, angle2: f32): u32\n{\n\t// Find the max separation between poly1 and poly2 using edge normals from poly1.\n\n\tlet count1 = poly1.vertices.length;\n\tlet count2 = poly2.vertices.length;\n\tlet n1s = poly1.normals;\n\tlet v1s = poly1.vertices;\n\tlet v2s = poly2.vertices;\n\n\tlet n = findMaxSeparation_n;\n\tlet v1 = findMaxSeparation_v1;\n\tlet tmp = findMaxSeparation_tmp;\n\tlet tmp2 = findMaxSeparation_tmp2;\n\n\tlet angle: f32 = angle1 - angle2;\n\n\tlet bestIndex: u32 = 0;\n\tlet maxSeparation: f32 = -Infinity;\n\tfor (let i = 0; i < count1; ++i)\n\t{\n\t\t// Get poly1 normal in frame2.\n\t\tvec2.rotate(n, n1s[i], angle);\n\n\t\t// Get poly1 vertex in frame2\n\t\tvec2.toGlobalFrame(tmp2, v1s[i], position1, angle1);\n\t\tvec2.toLocalFrame(v1, tmp2, position2, angle2);\n\n\t\t// Find deepest point for normal i.\n\t\tlet si: f32 = Infinity;\n\t\tfor (let j = 0; j < count2; ++j)\n\t\t{\n\t\t\tvec2.subtract(tmp, v2s[j], v1);\n\t\t\tlet sij = vec2.dot(n, tmp);\n\t\t\tif (sij < si)\n\t\t\t{\n\t\t\t\tsi = sij;\n\t\t\t}\n\t\t}\n\n\t\tif (si > maxSeparation)\n\t\t{\n\t\t\tmaxSeparation = si;\n\t\t\tbestIndex = i;\n\t\t}\n\t}\n\n\t// Use a vec2 for storing the float value and always return int, for perf\n\tmaxSeparationOut[0] = maxSeparation;\n\n\treturn bestIndex;\n}\n\nfunction findIncidentEdge(clipVerticesOut: Float32Array[], poly1: Convex, position1: Float32Array, angle1: f32, edge1: u32, poly2: Convex, position2: Float32Array, angle2: f32): void\n{\n\t\n\tlet normals1 = poly1.normals;\n\tlet count2 = poly2.vertices.length;\n\tlet vertices2 = poly2.vertices;\n\tlet normals2 = poly2.normals;\n\n\t// Get the normal of the reference edge in poly2's frame.\n\tlet normal1 = findIncidentEdge_normal1;\n\tvec2.rotate(normal1, normals1[edge1], angle1 - angle2);\n\n\t// Find the incident edge on poly2.\n\tlet index = 0;\n\tlet minDot = Infinity;\n\tfor (let i = 0; i < count2; ++i)\n\t{\n\t\tlet dot = vec2.dot(normal1, normals2[i]);\n\t\tif (dot < minDot)\n\t\t{\n\t\t\tminDot = dot;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\t// Build the clip vertices for the incident edge.\n\tlet i1 = index;\n\tlet i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n\tvec2.toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);\n\tvec2.toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);\n}\n\nfunction clipSegmentToLine(vOut: Float32Array[], vIn: Float32Array[], normal: Float32Array, offset: f32): u16\n{\n\t// Start with no output points\n\tlet numOut: u16 = 0;\n\n\t// Calculate the distance of end points to the line\n\tlet distance0 = vec2.dot(normal, vIn[0]) - offset;\n\tlet distance1 = vec2.dot(normal, vIn[1]) - offset;\n\n\t// If the points are behind the plane\n\tif (distance0 <= 0.0){\n\t\tvec2.copy(vOut[numOut++], vIn[0]);\n\t}\n\tif (distance1 <= 0.0){\n\t\tvec2.copy(vOut[numOut++], vIn[1]);\n\t}\n\n\t// If the points are on different sides of the plane\n\tif (distance0 * distance1 < 0.0)\n\t{\n\t\t// Find intersection point of edge and plane\n\t\tlet interp = distance0 / (distance0 - distance1);\n\t\tlet v = vOut[numOut];\n\t\tvec2.subtract(v, vIn[1], vIn[0]);\n\t\tvec2.scale(v, v, interp);\n\t\tvec2.add(v, v, vIn[0]);\n\t\t++numOut;\n\t}\n\n\treturn numOut;\n}\n\nexport default class Narrowphase{\n\n\t/**\n\t * @property contactEquations\n\t * @type {Array}\n\t */\n\tcontactEquations: Array<ContactEquation> = [];\n\n\t/**\n\t * @property frictionEquations\n\t * @type {Array}\n\t */\n\tfrictionEquations: Array<FrictionEquation> = [];\n\n\t/**\n\t * Whether to make friction equations in the upcoming contacts.\n\t * @property enableFriction\n\t * @type {boolean}\n\t */\n\tenableFriction: boolean = true;\n\n\t/**\n\t * Whether to make equations enabled in upcoming contacts.\n\t * @property enabledEquations\n\t * @type {boolean}\n\t */\n\tenabledEquations: boolean = true;\n\n\t/**\n\t * The friction slip force to use when creating friction equations.\n\t * @property slipForce\n\t * @type {Number}\n\t */\n\tslipForce: f32 = 10.0;\n\n\t/**\n\t * Keeps track of the allocated ContactEquations.\n\t * @property {ContactEquationPool} contactEquationPool\n\t *\n\t * @example\n\t *\n\t *     // Allocate a few equations before starting the simulation.\n\t *     // This way, no contact objects need to be created on the fly in the game loop.\n\t *     world.narrowphase.contactEquationPool.resize(1024);\n\t *     world.narrowphase.frictionEquationPool.resize(1024);\n\t */\n\tcontactEquationPool: ContactEquationPool = new ContactEquationPool(32);\n\n\t/**\n\t * Keeps track of the allocated ContactEquations.\n\t * @property {FrictionEquationPool} frictionEquationPool\n\t */\n\tfrictionEquationPool: FrictionEquationPool = new FrictionEquationPool(64);\n\n\t/**\n\t * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.\n\t * @property enableFrictionReduction\n\t * @type {boolean}\n\t * @deprecated This flag will be removed when the feature is stable enough.\n\t * @default true\n\t */\n\tenableFrictionReduction: boolean = true;\n\n\t/**\n\t * Keeps track of the colliding bodies last step.\n\t * @private\n\t * @property collidingBodiesLastStep\n\t * @type {TupleDictionary}\n\t */\n\tcollidingBodiesLastStep: TupleDictionary<u32> = new TupleDictionary();\n\n\t/**\n\t * @property currentContactMaterial\n\t * @type {ContactMaterial}\n\t */\n\tcurrentContactMaterial: ContactMaterial|null = null;\n\n\n\t/**\n\t * Narrowphase. Creates contacts and friction given shapes and transforms.\n\t * @class Narrowphase\n\t * @constructor\n\t */\n\tconstructor(){\n\t}\n\n\t/**\n\t * @method bodiesOverlap\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @param  {boolean} [checkCollisionMasks=false]\n\t * @return {boolean}\n\t */\n\tbodiesOverlap(bodyA: Body, bodyB: Body, checkCollisionMasks: boolean = false): boolean{\n\n\t\tlet shapePositionA = bodiesOverlap_shapePositionA;\n\t\tlet shapePositionB = bodiesOverlap_shapePositionB;\n\n\t\t// Loop over all shapes of bodyA\n\t\tfor(let k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){\n\t\t\tlet shapeA = bodyA.shapes[k];\n\n\t\t\t// All shapes of body j\n\t\t\tfor(let l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){\n\t\t\t\tlet shapeB = bodyB.shapes[l];\n\n\t\t\t\t// Check collision groups and masks\n\t\t\t\tif(checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tbodyA.toWorldFrame(shapePositionA, shapeA.position);\n\t\t\t\tbodyB.toWorldFrame(shapePositionB, shapeB.position);\n\n\t\t\t\tlet result = this.testContact(bodyA, shapeA, shapePositionA, bodyB, shapeB, shapePositionB, true);\n\n\t\t\t\tif(result) return true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Check if the bodies were in contact since the last reset().\n\t * @method collidedLastStep\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tcollidedLastStep(bodyA: Body, bodyB: Body): boolean{\n\t\tlet id1: u32 = bodyA.id,\n\t\t\tid2: u32 = bodyB.id;\n\t\treturn !!this.collidingBodiesLastStep.get(id1, id2);\n\t};\n\n\t/**\n\t * Throws away the old equations and gets ready to create new\n\t * @method reset\n\t */\n\treset(): void{\n\t\tthis.collidingBodiesLastStep.reset();\n\n\t\tlet eqs = this.contactEquations;\n\t\tlet l = eqs.length;\n\t\twhile(l--){\n\t\t\tlet eq = eqs[l],\n\t\t\t\tid1 = eq.bodyA!.id,\n\t\t\t\tid2 = eq.bodyB!.id;\n\t\t\tthis.collidingBodiesLastStep.set(id1, id2, 1);\n\t\t}\n\n\t\tlet ce = this.contactEquations,\n\t\t\tfe = this.frictionEquations;\n\t\tfor(let i: i32 = 0; i<ce.length; i++){\n\t\t\tthis.contactEquationPool.release(ce[i]);\n\t\t}\n\t\tfor(let i: i32 = 0; i<fe.length; i++){\n\t\t\tthis.frictionEquationPool.release(fe[i]);\n\t\t}\n\n\t\t// Reset\n\t\tthis.contactEquations.length = this.frictionEquations.length = 0;\n\t};\n\n\t/**\n\t * Creates a ContactEquation, either by reusing an existing object or creating a new one.\n\t * @method createContactEquation\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {ContactEquation}\n\t */\n\tcreateContactEquation(bodyA: Body, bodyB: Body, shapeA: Shape, shapeB: Shape): ContactEquation{\n\t\tlet c = this.contactEquationPool.get();\n\t\tlet currentContactMaterial = this.currentContactMaterial!;\n\t\tc.bodyA = bodyA;\n\t\tc.bodyB = bodyB;\n\t\tc.shapeA = shapeA;\n\t\tc.shapeB = shapeB;\n\t\tc.enabled = this.enabledEquations;\n\t\tc.firstImpact = !this.collidedLastStep(bodyA,bodyB);\n\n\t\tc.restitution = currentContactMaterial.restitution;\n\t\tc.stiffness = currentContactMaterial.stiffness;\n\t\tc.relaxation = currentContactMaterial.relaxation;\n\t\tc.offset = currentContactMaterial.contactSkinSize;\n\n\t\tc.needsUpdate = true;\n\n\t\treturn c;\n\t};\n\n\t/**\n\t * Creates a FrictionEquation, either by reusing an existing object or creating a new one.\n\t * @method createFrictionEquation\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {FrictionEquation}\n\t */\n\tcreateFrictionEquation(bodyA: Body, bodyB: Body, shapeA: Shape, shapeB: Shape): FrictionEquation{\n\t\tlet c = this.frictionEquationPool.get();\n\t\tlet currentContactMaterial = this.currentContactMaterial!;\n\t\tc.bodyA = bodyA;\n\t\tc.bodyB = bodyB;\n\t\tc.shapeA = shapeA;\n\t\tc.shapeB = shapeB;\n\t\tc.setSlipForce(this.slipForce);\n\t\tc.enabled = this.enabledEquations;\n\n\t\tc.frictionCoefficient = currentContactMaterial.friction;\n\t\tc.relativeVelocity = currentContactMaterial.surfaceVelocity;\n\t\tc.stiffness = currentContactMaterial.frictionStiffness;\n\t\tc.relaxation = currentContactMaterial.frictionRelaxation;\n\t\tc.needsUpdate = true;\n\n\t\tc.contactEquations.length = 0;\n\t\treturn c;\n\t};\n\n\t/**\n\t * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.\n\t * @method createFrictionFromContact\n\t * @param  {ContactEquation} contactEquation\n\t * @return {FrictionEquation}\n\t */\n\tcreateFrictionFromContact(c: ContactEquation): FrictionEquation{\n\t\tlet eq = this.createFrictionEquation(c.bodyA!, c.bodyB!, c.shapeA!, c.shapeB!);\n\t\tvec2.copy(eq.contactPointA, c.contactPointA);\n\t\tvec2.copy(eq.contactPointB, c.contactPointB);\n\t\tvec2.rotate90cw(eq.t, c.normalA);\n\t\teq.contactEquations.push(c);\n\t\treturn eq;\n\t};\n\n\t// Take the average N latest contact point on the plane.\n\tcreateFrictionFromAverage(numContacts: i32): FrictionEquation{\n\t\tlet c = this.contactEquations[this.contactEquations.length - 1];\n\t\tlet eq = this.createFrictionEquation(c.bodyA!, c.bodyB!, c.shapeA!, c.shapeB!);\n\t\tlet bodyA = c.bodyA;\n\t\tvec2.set(eq.contactPointA, 0, 0);\n\t\tvec2.set(eq.contactPointB, 0, 0);\n\t\tvec2.set(eq.t, 0, 0);\n\t\tfor(let i: i32 = 0; i < numContacts; i++){\n\t\t\tc = this.contactEquations[this.contactEquations.length - 1 - i];\n\t\t\tif(c.bodyA === bodyA){\n\t\t\t\tvec2.add(eq.t, eq.t, c.normalA);\n\t\t\t\tvec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n\t\t\t\tvec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);\n\t\t\t} else {\n\t\t\t\tvec2.subtract(eq.t, eq.t, c.normalA);\n\t\t\t\tvec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);\n\t\t\t\tvec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);\n\t\t\t}\n\t\t\teq.contactEquations.push(c);\n\t\t}\n\n\t\tlet invNumContacts: f32 = 1.0/(numContacts as f32);\n\t\tvec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);\n\t\tvec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);\n\t\tvec2.normalize(eq.t, eq.t);\n\t\tvec2.rotate90cw(eq.t, eq.t);\n\t\treturn eq;\n\t};\n\n\ttestContact(\n\t\tbodyA: Body,\n\t\tshapeA: Shape,\n\t\toffsetA: Float32Array,\n\t\tbodyB: Body,\n\t\tshapeB: Shape,\n\t\toffsetB: Float32Array,\n\t\tjustTest: boolean\n\t\t// meta?: {\n\t\t// \tradiusA?: f32,\n\t\t// \tradiusB?: f32\n\t\t// }\n\t): u16{\n\t\tlet result: u16 = 0;\n\n\t\tif(shapeA.type > shapeB.type)\n\t\t{\n\t\t\tlet bTmp = bodyB;\n\t\t\tbodyB = bodyA;\n\t\t\tbodyA = bTmp;\n\n\t\t\tlet sTmp = shapeB;\n\t\t\tshapeB = shapeA;\n\t\t\tshapeA = sTmp;\n\n\t\t\tlet pTmp = offsetB;\n\t\t\toffsetB = offsetA;\n\t\t\toffsetA = pTmp;\n\t\t}\n\n\t\tlet sa: Shape = shapeA;\n\t\tlet sb: Shape = shapeB;\n\n\t\tswitch(shapeA.type | shapeB.type){\n\t\t\tcase 0b1:{ // Circle/circle\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Circle){\n\t\t\t\t\t\tlet sb2 = sb as Circle;\n\t\t\t\t\t\tresult = this.circleCircle(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, \n\t\t\t\t\t\t\tjustTest, sa2.radius, sb2.radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b11:{ // Particle/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Particle){\n\t\t\t\t\t\tlet sb2 = sb as Particle;\n\t\t\t\t\t\tresult = this.circleParticle(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b101:{ // Plane/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Plane){\n\t\t\t\t\t\tlet sb2 = sb as Plane;\n\t\t\t\t\t\tresult = this.circlePlane(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b100001: // Box/circle.\n\t\t\tcase 0b1001:{ // Convex/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Convex){\n\t\t\t\t\t\tlet sb2 = sb as Convex;\n\t\t\t\t\t\tresult = this.circleConvex(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest, sa2.radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b10001:{ // Line/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Line){\n\t\t\t\t\t\tlet sb2 = sb as Line;\n\t\t\t\t\t\tresult = this.circleLine(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest, 0, sa2.radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1000001:{ // Capsule/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Capsule){\n\t\t\t\t\t\tlet sb2 = sb as Capsule;\n\t\t\t\t\t\tresult = this.circleCapsule(bodyA, sa2, offsetA,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b10000001:{ // Heightfield/circle.\n\t\t\t\tif(sa instanceof Circle){\n\t\t\t\t\tlet sa2 = sa as Circle;\n\t\t\t\t\tif(sb instanceof Heightfield){\n\t\t\t\t\t\tlet sb2 = sb as Heightfield;\n\t\t\t\t\t\tresult = this.circleHeightfield(bodyA, sa2, offsetA,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, \n\t\t\t\t\t\t\tjustTest, sa2.radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b110:{ // Plane/particle.\n\t\t\t\t\n\t\t\t\tif(sa instanceof Particle){\n\t\t\t\t\tlet sa2 = sa as Particle;\n\t\t\t\t\tif(sb instanceof Plane){\n\t\t\t\t\t\tlet sb2 = sb as Plane;\n\t\t\t\t\t\tresult = this.particlePlane(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b100010: // Box/particle.\n\t\t\tcase 0b1010:{ // Convex/particle.\n\t\t\t\tif(sa instanceof Particle){\n\t\t\t\t\tlet sa2 = sa as Particle;\n\t\t\t\t\tif(sb instanceof Convex){\n\t\t\t\t\t\tlet sb2 = sb as Convex;\n\t\t\t\t\t\tresult = this.particleConvex(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1010:{ // Capsule/particle.\n\t\t\t\tif(sa instanceof Particle){\n\t\t\t\t\tlet sa2 = sa as Particle;\n\t\t\t\t\tif(sb instanceof Capsule){\n\t\t\t\t\t\tlet sb2 = sb as Capsule;\n\t\t\t\t\t\tresult = this.particleCapsule(bodyA, sa2, offsetA, \n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b100100: // Box/plane.\n\t\t\tcase 0b1100:{ // Convex/plane.\n\t\t\t\tif(sa instanceof Plane){\n\t\t\t\t\tlet sa2 = sa as Plane;\n\t\t\t\t\tif(sb instanceof Convex){\n\t\t\t\t\t\tlet sb2 = sb as Convex;\n\t\t\t\t\t\tresult = this.planeConvex(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b10100:{ // Line/plane.\n\t\t\t\tif(sa instanceof Plane){\n\t\t\t\t\tlet sa2 = sa as Plane;\n\t\t\t\t\tif(sb instanceof Line){\n\t\t\t\t\t\tlet sb2 = sb as Line;\n\t\t\t\t\t\tresult = this.planeLine(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1000100:{ // Capsule/plane.\n\t\t\t\tif(sa instanceof Plane){\n\t\t\t\t\tlet sa2 = sa as Plane;\n\t\t\t\t\tif(sb instanceof Capsule){\n\t\t\t\t\t\tlet sb2 = sb as Capsule;\n\t\t\t\t\t\tresult = this.planeCapsule(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b100000: // Box/box.\n\t\t\tcase 0b101000: // Box/convex.\n\t\t\tcase 0b1000:{ // Convex/convex.\n\t\t\t\tif(sa instanceof Convex){\n\t\t\t\t\tlet sa2 = sa as Convex;\n\t\t\t\t\tif(sb instanceof Convex){\n\t\t\t\t\t\tlet sb2 = sb as Convex;\n\t\t\t\t\t\tresult = this.convexConvex(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b11000:{ // Line/convex.\n\t\t\t\t// let sa = sa as Convex;\n\t\t\t\t// let sb = sb as Line;\n\t\t\t\t// NOT SUPPORTED!\n\t\t\t\t// result = this.convexLine(bodyA, sa, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t// \tbodyB, sb, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t// \tjustTest);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1001000:{ // Capsule/convex.\n\t\t\t\tif(sa instanceof Convex){\n\t\t\t\t\tlet sa2 = sa as Convex;\n\t\t\t\t\tif(sb instanceof Capsule){\n\t\t\t\t\t\tlet sb2 = sb as Capsule;\n\t\t\t\t\t\tresult = this.convexCapsule(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b10001000:{ // Heightfield/convex.\n\t\t\t\tif(sa instanceof Convex){\n\t\t\t\t\tlet sa2 = sa as Convex;\n\t\t\t\t\tif(sb instanceof Heightfield){\n\t\t\t\t\t\tlet sb2 = sb as Heightfield;\n\t\t\t\t\t\tresult = this.convexHeightfield(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB,\n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b10000:{ // Line/line.\n\t\t\t\t// let sa = sa as Line;\n\t\t\t\t// let sb = sb as Line;\n\t\t\t\t// NOT SUPPORTED!\n\t\t\t\t// result = this.lineLine(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,\n\t\t\t\t// \tbodyB, sb, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t// \tjustTest);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b110000:{ // Box/line.\n\t\t\t\t// let sa = sa as Line;\n\t\t\t\t// let sb = sb as Box;\n\t\t\t\t// NOT SUPPORTED!\n\t\t\t\t// result = this.lineBox(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,\n\t\t\t\t// \tbodyB, sb, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t// \tjustTest);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1010000:{ // Capsule/line.\n\t\t\t\t// let sa = sa as Line;\n\t\t\t\t// let sb = sb as Capsule;\n\t\t\t\t// NOT SUPPORTED!\n\t\t\t\t// result = this.lineCapsule(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,\n\t\t\t\t// \tbodyB, sb, offsetB, bodyB.angle + sb.angle,\n\t\t\t\t// \tjustTest);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 0b1000000:{ // Capsule/capsule.\n\t\t\t\tif(sa instanceof Capsule){\n\t\t\t\t\tlet sa2 = sa as Capsule;\n\t\t\t\t\tif(sb instanceof Capsule){\n\t\t\t\t\t\tlet sb2 = sb as Capsule;\n\t\t\t\t\t\tresult = this.capsuleCapsule(bodyA, sa2, offsetA, bodyA.angle + sa.angle,\n\t\t\t\t\t\t\tbodyB, sb2, offsetB, bodyB.angle + sb.angle, \n\t\t\t\t\t\t\tjustTest);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Convex/line narrowphase\n\t * @method convexLine\n\t * @param  {Body}       convexBody\n\t * @param  {Convex}     convexShape\n\t * @param  {Array}      convexOffset\n\t * @param  {Number}     convexAngle\n\t * @param  {Body}       lineBody\n\t * @param  {Line}       lineShape\n\t * @param  {Array}      lineOffset\n\t * @param  {Number}     lineAngle\n\t * @param {boolean}     justTest\n\t * @return {number}\n\t * @todo Implement me!\n\t */\n\t//Narrowphase.prototype[Shape.CONVEX | Shape.LINE] =\n\tconvexLine(\n\t\t/*\n\t\tconvexBody,\n\t\tconvexShape,\n\t\tconvexOffset,\n\t\tconvexAngle,\n\t\tlineBody,\n\t\tlineShape,\n\t\tlineOffset,\n\t\tlineAngle,\n\t\tjustTest\n\t\t*/\n\t): u32{\n\t\t// TODO\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Line/box narrowphase\n\t * @method lineBox\n\t * @param  {Body}       lineBody\n\t * @param  {Line}       lineShape\n\t * @param  {Array}      lineOffset\n\t * @param  {Number}     lineAngle\n\t * @param  {Body}       boxBody\n\t * @param  {Box}  boxShape\n\t * @param  {Array}      boxOffset\n\t * @param  {Number}     boxAngle\n\t * @param  {boolean}    justTest\n\t * @return {number}\n\t * @todo Implement me!\n\t */\n\t//Narrowphase.prototype[Shape.LINE | Shape.BOX] =\n\tlineBox(\n\t\t/*\n\t\tlineBody,\n\t\tlineShape,\n\t\tlineOffset,\n\t\tlineAngle,\n\t\tboxBody,\n\t\tboxShape,\n\t\tboxOffset,\n\t\tboxAngle,\n\t\tjustTest\n\t\t*/\n\t): u32{\n\t\t// TODO\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Convex/capsule narrowphase\n\t * @method convexCapsule\n\t * @param  {Body}       convexBody\n\t * @param  {Convex}     convexShape\n\t * @param  {Array}      convexPosition\n\t * @param  {Number}     convexAngle\n\t * @param  {Body}       capsuleBody\n\t * @param  {Capsule}    capsuleShape\n\t * @param  {Array}      capsulePosition\n\t * @param  {Number}     capsuleAngle\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CONVEX | Shape.CAPSULE] =\n\t//Narrowphase.prototype[Shape.BOX | Shape.CAPSULE] =\n\tconvexCapsule(\n\t\tconvexBody: Body,\n\t\tconvexShape: Convex,\n\t\tconvexPosition: Float32Array,\n\t\tconvexAngle: f32,\n\t\tcapsuleBody: Body,\n\t\tcapsuleShape: Capsule,\n\t\tcapsulePosition: Float32Array,\n\t\tcapsuleAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\n\t\tlet convexCapsule_tempRect = new Box(null);\n\n\t\t// Check the circles\n\t\t// Add offsets!\n\t\tlet circlePos = convexCapsule_tempVec;\n\t\tlet halfLength = capsuleShape.length / 2;\n\t\tvec2.set(circlePos, halfLength, 0);\n\t\tvec2.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);\n\t\tlet result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n\t\tvec2.set(circlePos,-halfLength, 0);\n\t\tvec2.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);\n\t\tlet result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n\t\tif(justTest && (result1 + result2) !== 0){\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Check center rect\n\t\tlet r = convexCapsule_tempRect;\n\t\tsetConvexToCapsuleShapeMiddle(r,capsuleShape);\n\t\tlet result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);\n\n\t\treturn result + result1 + result2;\n\t};\n\n\t/**\n\t * Capsule/line narrowphase\n\t * @method lineCapsule\n\t * @param  {Body}       lineBody\n\t * @param  {Line}       lineShape\n\t * @param  {Array}      linePosition\n\t * @param  {Number}     lineAngle\n\t * @param  {Body}       capsuleBody\n\t * @param  {Capsule}    capsuleShape\n\t * @param  {Array}      capsulePosition\n\t * @param  {Number}     capsuleAngle\n\t * @return {number}\n\t * @todo Implement me!\n\t */\n\t//Narrowphase.prototype[Shape.LINE | Shape.CAPSULE] =\n\tlineCapsule(\n\t\t/*\n\t\tlineBody,\n\t\tlineShape,\n\t\tlinePosition,\n\t\tlineAngle,\n\t\tcapsuleBody,\n\t\tcapsuleShape,\n\t\tcapsulePosition,\n\t\tcapsuleAngle,\n\t\tjustTest\n\t\t*/\n\t): u32{\n\t\t// TODO\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Capsule/capsule narrowphase\n\t * @method capsuleCapsule\n\t * @param  {Body}       bi\n\t * @param  {Capsule}    si\n\t * @param  {Array}      xi\n\t * @param  {Number}     ai\n\t * @param  {Body}       bj\n\t * @param  {Capsule}    sj\n\t * @param  {Array}      xj\n\t * @param  {Number}     aj\n\t */\n\t//Narrowphase.prototype[Shape.CAPSULE] =\n\tcapsuleCapsule(bi: Body, si: Capsule, xi: Float32Array, ai: f32, bj: Body, sj: Capsule, xj: Float32Array, aj: f32, justTest: boolean): u16{\n\t\tthrow \"Capsule-capsule collisions are not currently supported.\";\n\t\treturn 0;\n\n\n\t\t// let capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });\n\n\t\t// let enableFrictionBefore: boolean = false;\n\n\t\t// // Check the circles\n\t\t// // Add offsets!\n\t\t// let circlePosi = capsuleCapsule_tempVec1,\n\t\t// \tcirclePosj = capsuleCapsule_tempVec2;\n\n\t\t// let numContacts = 0;\n\n\t\t// // Need 4 circle checks, between all\n\t\t// for(let i: i32 = 0; i<2; i++){\n\n\t\t// \tvec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);\n\t\t// \tvec2.toGlobalFrame(circlePosi, circlePosi, xi, ai);\n\n\t\t// \tfor(let j: i32 =0; j<2; j++){\n\n\t\t// \t\tvec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);\n\t\t// \t\tvec2.toGlobalFrame(circlePosj, circlePosj, xj, aj);\n\n\t\t// \t\t// Temporarily turn off friction\n\t\t// \t\tif(this.enableFrictionReduction){\n\t\t// \t\t\tenableFrictionBefore = this.enableFriction;\n\t\t// \t\t\tthis.enableFriction = false;\n\t\t// \t\t}\n\n\t\t// \t\tlet result = this.circleCircle(bi,si,circlePosi, bj,sj,circlePosj, justTest, si.radius, sj.radius);\n\n\t\t// \t\tif(this.enableFrictionReduction){\n\t\t// \t\t\tthis.enableFriction = enableFrictionBefore;\n\t\t// \t\t}\n\n\t\t// \t\tif(justTest && result !== 0){\n\t\t// \t\t\treturn 1;\n\t\t// \t\t}\n\n\t\t// \t\tnumContacts += result;\n\t\t// \t}\n\t\t// }\n\n\t\t// if(this.enableFrictionReduction){\n\t\t// \t// Temporarily turn off friction\n\t\t// \tenableFrictionBefore = this.enableFriction;\n\t\t// \tthis.enableFriction = false;\n\t\t// }\n\n\t\t// // Check circles against the center boxs\n\t\t// let rect = capsuleCapsule_tempRect1;\n\t\t// setConvexToCapsuleShapeMiddle(rect,si);\n\t\t// let result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);\n\n\t\t// if(this.enableFrictionReduction){\n\t\t// \tthis.enableFriction = enableFrictionBefore;\n\t\t// }\n\n\t\t// if(justTest && result1 !== 0){\n\t\t// \treturn 1;\n\t\t// }\n\t\t// numContacts += result1;\n\n\t\t// if(this.enableFrictionReduction){\n\t\t// \t// Temporarily turn off friction\n\t\t// \tlet enableFrictionBefore = this.enableFriction;\n\t\t// \tthis.enableFriction = false;\n\t\t// }\n\n\t\t// setConvexToCapsuleShapeMiddle(rect,sj);\n\t\t// let result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);\n\n\t\t// if(this.enableFrictionReduction){\n\t\t// \tthis.enableFriction = enableFrictionBefore;\n\t\t// }\n\n\t\t// if(justTest && result2 !== 0){\n\t\t// \treturn 1;\n\t\t// }\n\t\t// numContacts += result2;\n\n\t\t// if(this.enableFrictionReduction){\n\t\t// \tif(numContacts && this.enableFriction){\n\t\t// \t\tthis.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n\t\t// \t}\n\t\t// }\n\n\t\t// return numContacts;\n\t};\n\n\t/**\n\t * Line/line narrowphase\n\t * @method lineLine\n\t * @param  {Body}       bodyA\n\t * @param  {Line}       shapeA\n\t * @param  {Array}      positionA\n\t * @param  {Number}     angleA\n\t * @param  {Body}       bodyB\n\t * @param  {Line}       shapeB\n\t * @param  {Array}      positionB\n\t * @param  {Number}     angleB\n\t * @return {number}\n\t * @todo Implement me!\n\t */\n\t//Narrowphase.prototype[Shape.LINE] =\n\tlineLine(\n\t/* bodyA,\n\t\tshapeA,\n\t\tpositionA,\n\t\tangleA,\n\t\tbodyB,\n\t\tshapeB,\n\t\tpositionB,\n\t\tangleB,\n\t\tjustTest*/\n\t): u32{\n\t\t// TODO\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Plane/line Narrowphase\n\t * @method planeLine\n\t * @param  {Body}   planeBody\n\t * @param  {Plane}  planeShape\n\t * @param  {Array}  planeOffset\n\t * @param  {Number} planeAngle\n\t * @param  {Body}   lineBody\n\t * @param  {Line}   lineShape\n\t * @param  {Array}  lineOffset\n\t * @param  {Number} lineAngle\n\t */\n\t//Narrowphase.prototype[Shape.PLANE | Shape.LINE] =\n\tplaneLine(planeBody: Body, planeShape: Plane, planeOffset: Float32Array, planeAngle: f32,\n\t\t\t  lineBody: Body,  lineShape: Line,  lineOffset: Float32Array,  lineAngle: f32, justTest: boolean): u16{\n\t\tlet worldVertex0 = tmp1,\n\t\t\tworldVertex1 = tmp2,\n\t\t\tworldVertex01 = tmp3,\n\t\t\tworldVertex11 = tmp4,\n\t\t\tworldEdge = tmp5,\n\t\t\tworldEdgeUnit = tmp6,\n\t\t\tdist = tmp7,\n\t\t\tworldNormal = tmp8,\n\t\t\tworldTangent = tmp9,\n\t\t\tverts = tmpArray,\n\t\t\tnumContacts:u16 = 0;\n\n\t\t// Get start and end points\n\t\tvec2.set(worldVertex0, -lineShape.length/2, 0);\n\t\tvec2.set(worldVertex1,  lineShape.length/2, 0);\n\n\t\t// Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n\t\tvec2.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);\n\t\tvec2.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);\n\n\t\tvec2.copy(worldVertex0,worldVertex01);\n\t\tvec2.copy(worldVertex1,worldVertex11);\n\n\t\t// Get vector along the line\n\t\tvec2.subtract(worldEdge, worldVertex1, worldVertex0);\n\t\tvec2.normalize(worldEdgeUnit, worldEdge);\n\n\t\t// Get tangent to the edge.\n\t\tvec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n\t\tvec2.rotate(worldNormal, yAxis, planeAngle);\n\n\t\t// Check line ends\n\t\tverts[0] = worldVertex0;\n\t\tverts[1] = worldVertex1;\n\t\tfor(let i: i32 = 0; i<verts.length; i++){\n\t\t\tlet v = verts[i];\n\n\t\t\tvec2.subtract(dist, v, planeOffset);\n\n\t\t\tlet d = vec2.dot(dist,worldNormal);\n\n\t\t\tif(d < 0){\n\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tlet c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);\n\t\t\t\tnumContacts++;\n\n\t\t\t\tvec2.copy(c.normalA, worldNormal);\n\t\t\t\tvec2.normalize(c.normalA,c.normalA);\n\n\t\t\t\t// distance vector along plane normal\n\t\t\t\tvec2.scale(dist, worldNormal, d);\n\n\t\t\t\t// Vector from plane center to contact\n\t\t\t\tvec2.subtract(c.contactPointA, v, dist);\n\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, planeBody.position);\n\n\t\t\t\t// From line center to contact\n\t\t\t\tvec2.subtract(c.contactPointB, v,    lineOffset);\n\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, lineOffset);\n\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, lineBody.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(!this.enableFrictionReduction){\n\t\t\t\t\tif(this.enableFriction){\n\t\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(justTest){\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(!this.enableFrictionReduction){\n\t\t\tif(numContacts && this.enableFriction){\n\t\t\t\tthis.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n\t\t\t}\n\t\t}\n\n\t\treturn numContacts;\n\t};\n\n\t//Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =\n\tparticleCapsule(\n\t\tparticleBody: Body,\n\t\tparticleShape: Particle,\n\t\tparticlePosition: Float32Array,\n\t\tcapsuleBody: Body,\n\t\tcapsuleShape: Capsule,\n\t\tcapsulePosition: Float32Array,\n\t\tcapsuleAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tthrow \"NOT SUPPORTED\";\n\t\t//return this.circleLine(particleBody,particleShape,particlePosition, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);\n\t};\n\n\t/**\n\t * Circle/line Narrowphase\n\t * @method circleLine\n\t * @param  {Body} circleBody\n\t * @param  {Circle} circleShape\n\t * @param  {Array} circleOffset\n\t * @param  {Body} lineBody\n\t * @param  {Line} lineShape\n\t * @param  {Array} lineOffset\n\t * @param  {Number} lineAngle\n\t * @param {boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.\n\t * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.\n\t * @param {Number} circleRadius If set, this value overrides the circle shape radius.\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =\n\tcircleLine(\n\t\tcircleBody: Body,\n\t\tcircleShape: Shape,\n\t\tcircleOffset: Float32Array,\n\t\t//circleAngle: f32,\n\t\tlineBody: Body,\n\t\tlineShape: Line,\n\t\tlineOffset: Float32Array,\n\t\tlineAngle: f32,\n\t\tjustTest: boolean,\n\t\tlineRadius: f32,\n\t\tcircleRadius: f32\n\t): u16{\n\t\tlineRadius = lineRadius;\n\n\t\tlet orthoDist = tmp1;\n\t\tlet lineToCircleOrthoUnit = tmp2;\n\t\tlet projectedPoint = tmp3;\n\t\tlet centerDist = tmp4;\n\t\tlet worldTangent = tmp5;\n\t\tlet worldEdge = tmp6;\n\t\tlet worldEdgeUnit = tmp7;\n\t\tlet worldVertex0 = tmp8;\n\t\tlet worldVertex1 = tmp9;\n\t\tlet worldVertex01 = tmp10;\n\t\tlet worldVertex11 = tmp11;\n\t\tlet dist = tmp12;\n\t\tlet lineToCircle = tmp13;\n\t\tlet lineEndToLineRadius = tmp14;\n\n\t\tlet verts = tmpArray;\n\n\t\tlet halfLineLength = lineShape.length / 2;\n\n\t\t// Get start and end points\n\t\tvec2.set(worldVertex0, -halfLineLength, 0);\n\t\tvec2.set(worldVertex1,  halfLineLength, 0);\n\n\t\t// Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n\t\tvec2.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);\n\t\tvec2.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);\n\n\t\tvec2.copy(worldVertex0,worldVertex01);\n\t\tvec2.copy(worldVertex1,worldVertex11);\n\n\t\t// Get vector along the line\n\t\tvec2.subtract(worldEdge, worldVertex1, worldVertex0);\n\t\tvec2.normalize(worldEdgeUnit, worldEdge);\n\n\t\t// Get tangent to the edge.\n\t\tvec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n\t\t// Check distance from the plane spanned by the edge vs the circle\n\t\tvec2.subtract(dist, circleOffset, worldVertex0);\n\t\tlet d = vec2.dot(dist, worldTangent); // Distance from center of line to circle center\n\t\tvec2.subtract(centerDist, worldVertex0, lineOffset);\n\n\t\tvec2.subtract(lineToCircle, circleOffset, lineOffset);\n\n\t\tlet radiusSum = circleRadius + lineRadius;\n\n\t\tif(Mathf.abs(d) < radiusSum){\n\n\t\t\t// Now project the circle onto the edge\n\t\t\tvec2.scale(orthoDist, worldTangent, d);\n\t\t\tvec2.subtract(projectedPoint, circleOffset, orthoDist);\n\n\t\t\t// Add the missing line radius\n\t\t\tvec2.scale(lineToCircleOrthoUnit, worldTangent, vec2.dot(worldTangent, lineToCircle));\n\t\t\tvec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);\n\t\t\tvec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);\n\t\t\tvec2.add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);\n\n\t\t\t// Check if the point is within the edge span\n\t\t\tlet pos =  vec2.dot(worldEdgeUnit, projectedPoint);\n\t\t\tlet pos0 = vec2.dot(worldEdgeUnit, worldVertex0);\n\t\t\tlet pos1 = vec2.dot(worldEdgeUnit, worldVertex1);\n\n\t\t\tif(pos > pos0 && pos < pos1){\n\t\t\t\t// We got contact!\n\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tlet c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n\t\t\t\tvec2.scale(c.normalA, orthoDist, -1);\n\t\t\t\tvec2.normalize(c.normalA, c.normalA);\n\n\t\t\t\tvec2.scale( c.contactPointA, c.normalA,  circleRadius);\n\t\t\t\tvec2.add(c.contactPointA, c.contactPointA, circleOffset);\n\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, circleBody.position);\n\n\t\t\t\tvec2.subtract(c.contactPointB, projectedPoint, lineOffset);\n\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, lineOffset);\n\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, lineBody.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(this.enableFriction){\n\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t}\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\t// Add corner\n\t\tverts[0] = worldVertex0;\n\t\tverts[1] = worldVertex1;\n\n\t\tfor(let i: i32 = 0; i<verts.length; i++){\n\t\t\tlet v = verts[i];\n\n\t\t\tvec2.subtract(dist, v, circleOffset);\n\n\t\t\tif(vec2.squaredLength(dist) < Mathf.pow(radiusSum, 2)){\n\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tlet c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n\t\t\t\tvec2.copy(c.normalA, dist);\n\t\t\t\tvec2.normalize(c.normalA,c.normalA);\n\n\t\t\t\t// Vector from circle to contact point is the normal times the circle radius\n\t\t\t\tvec2.scale(c.contactPointA, c.normalA, circleRadius);\n\t\t\t\tvec2.add(c.contactPointA, c.contactPointA, circleOffset);\n\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, circleBody.position);\n\n\t\t\t\tvec2.subtract(c.contactPointB, v, lineOffset);\n\t\t\t\tvec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);\n\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, lineEndToLineRadius);\n\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, lineOffset);\n\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, lineBody.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(this.enableFriction){\n\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t}\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Circle/capsule Narrowphase\n\t * @method circleCapsule\n\t * @param  {Body}   bi\n\t * @param  {Circle} si\n\t * @param  {Array}  xi\n\t * @param  {Body}   bj\n\t * @param  {Line}   sj\n\t * @param  {Array}  xj\n\t * @param  {Number} aj\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =\n\t// TODO:\n\tcircleCapsule(bi: Body, si: Circle ,xi: Float32Array, bj: Body, sj: Capsule, xj: Float32Array, aj: f32, justTest: boolean): u16{\n\t\tthrow \"NOT SUPPORTED!\";\n\t\t//return this.circleLine(bi,si,xi, bj,sj,xj,aj, justTest, 0, si.radius);\n\t};\n\n\t/**\n\t * Circle/convex Narrowphase.\n\t * @method circleConvex\n\t * @param  {Body} circleBody\n\t * @param  {Circle} circleShape\n\t * @param  {Array} circleOffset\n\t * @param  {Body} convexBody\n\t * @param  {Convex} convexShape\n\t * @param  {Array} convexOffset\n\t * @param  {Number} convexAngle\n\t * @param  {boolean} justTest\n\t * @param  {Number} circleRadius\n\t * @return {number}\n\t * @todo Should probably do a separating axis test like https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2CollideCircle.cpp#L62\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =\n\tcircleConvex(\n\t\tcircleBody: Body,\n\t\tcircleShape: Shape,\n\t\tcircleOffset: Float32Array,\n\t\tconvexBody: Body,\n\t\tconvexShape: Convex,\n\t\tconvexOffset: Float32Array,\n\t\tconvexAngle: f32,\n\t\tjustTest: boolean,\n\t\tcircleRadius: f32\n\t): u16{\n\n\t\tlet worldVertex0: Float32Array = tmp1,\n\t\t\tworldVertex1: Float32Array = tmp2,\n\t\t\tedge: Float32Array = tmp3,\n\t\t\tedgeUnit: Float32Array = tmp4,\n\t\t\tnormal: Float32Array = tmp5,\n\t\t\tzero: Float32Array = tmp6,\n\t\t\tlocalCirclePosition: Float32Array = tmp7,\n\t\t\tr: Float32Array = tmp8,\n\t\t\tdist: Float32Array = tmp10,\n\t\t\tworldVertex: Float32Array = tmp11,\n\t\t\tclosestEdgeProjectedPoint: Float32Array = tmp13,\n\t\t\tcandidate: Float32Array = tmp14,\n\t\t\tcandidateDist: Float32Array = tmp15,\n\t\t\tfound: i32 = -1,\n\t\t\tminCandidateDistance: f32 = Infinity;\n\n\t\tvec2.set(zero, 0, 0);\n\n\t\t// New algorithm:\n\t\t// 1. Check so center of circle is not inside the polygon. If it is, this wont work...\n\t\t// 2. For each edge\n\t\t// 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n\t\t// 2. 2. Check if point is inside.\n\n\t\tvec2.toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);\n\n\t\tlet vertices = convexShape.vertices;\n\t\tlet normals = convexShape.normals;\n\t\tlet numVertices = vertices.length;\n\t\tlet normalIndex = -1;\n\n\t\t// Find the min separating edge.\n\t\tlet separation = -Infinity;\n\t\tlet radius = convexShape.boundingRadius + circleRadius;\n\n\t\tfor (let i = 0; i < numVertices; i++){\n\t\t\tvec2.subtract(r, localCirclePosition, vertices[i]);\n\t\t\tlet s = vec2.dot(normals[i], r);\n\n\t\t\tif (s > radius){\n\t\t\t\t// Early out.\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (s > separation){\n\t\t\t\tseparation = s;\n\t\t\t\tnormalIndex = i;\n\t\t\t}\n\t\t}\n\n\t\t// Check edges first\n\t\tfor(let i: i32 = normalIndex + numVertices - 1; i < normalIndex + numVertices + 2; i++){\n\t\t\tlet v0 = vertices[i % numVertices],\n\t\t\t\tn = normals[i % numVertices];\n\n\t\t\t// Get point on circle, closest to the convex\n\t\t\tvec2.scale(candidate, n, -circleRadius);\n\t\t\tvec2.add(candidate,candidate,localCirclePosition);\n\n\t\t\tif(pointInConvexLocal(candidate,convexShape)){\n\n\t\t\t\tvec2.subtract(candidateDist,v0,candidate);\n\t\t\t\tlet candidateDistance = Mathf.abs(vec2.dot(candidateDist, n));\n\n\t\t\t\tif(candidateDistance < minCandidateDistance){\n\t\t\t\t\tminCandidateDistance = candidateDistance;\n\t\t\t\t\tfound = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(found !== -1){\n\n\t\t\tif(justTest){\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlet v0 = vertices[found % numVertices],\n\t\t\t\tv1 = vertices[(found+1) % numVertices];\n\n\t\t\tvec2.toGlobalFrame(worldVertex0, v0, convexOffset, convexAngle);\n\t\t\tvec2.toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);\n\n\t\t\tvec2.subtract(edge, worldVertex1, worldVertex0);\n\n\t\t\tvec2.normalize(edgeUnit, edge);\n\n\t\t\t// Get tangent to the edge. Points out of the Convex\n\t\t\tvec2.rotate90cw(normal, edgeUnit);\n\n\t\t\t// Get point on circle, closest to the convex\n\t\t\tvec2.scale(candidate, normal, -circleRadius);\n\t\t\tvec2.add(candidate,candidate,circleOffset);\n\n\t\t\tvec2.scale(closestEdgeProjectedPoint, normal, minCandidateDistance);\n\t\t\tvec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);\n\n\t\t\tlet c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n\t\t\tvec2.subtract(c.normalA, candidate, circleOffset);\n\t\t\tvec2.normalize(c.normalA, c.normalA);\n\n\t\t\tvec2.scale(c.contactPointA,  c.normalA, circleRadius);\n\t\t\tvec2.add(c.contactPointA, c.contactPointA, circleOffset);\n\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, circleBody.position);\n\n\t\t\tvec2.subtract(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n\t\t\tvec2.add(c.contactPointB, c.contactPointB, convexOffset);\n\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, convexBody.position);\n\n\t\t\tthis.contactEquations.push(c);\n\n\t\t\tif(this.enableFriction){\n\t\t\t\tthis.frictionEquations.push( this.createFrictionFromContact(c) );\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Check closest vertices\n\t\tif(circleRadius > 0 && normalIndex !== -1){\n\t\t\tfor(let i: i32 = normalIndex + numVertices; i < normalIndex + numVertices + 2; i++){\n\t\t\t\tlet localVertex = vertices[i % numVertices];\n\n\t\t\t\tvec2.subtract(dist, localVertex, localCirclePosition);\n\n\t\t\t\tif(vec2.squaredLength(dist) < circleRadius * circleRadius){\n\n\t\t\t\t\tif(justTest){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tvec2.toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);\n\t\t\t\t\tvec2.subtract(dist, worldVertex, circleOffset);\n\n\t\t\t\t\tlet c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n\n\t\t\t\t\tvec2.copy(c.normalA, dist);\n\t\t\t\t\tvec2.normalize(c.normalA,c.normalA);\n\n\t\t\t\t\t// Vector from circle to contact point is the normal times the circle radius\n\t\t\t\t\tvec2.scale(c.contactPointA, c.normalA, circleRadius);\n\t\t\t\t\tvec2.add(c.contactPointA, c.contactPointA, circleOffset);\n\t\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, circleBody.position);\n\n\t\t\t\t\tvec2.subtract(c.contactPointB, worldVertex, convexOffset);\n\t\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, convexOffset);\n\t\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, convexBody.position);\n\n\t\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\t\tif(this.enableFriction){\n\t\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Particle/convex Narrowphase\n\t * @method particleConvex\n\t * @param  {Body} particleBody\n\t * @param  {Particle} particleShape\n\t * @param  {Array} particleOffset\n\t * @param  {Number} particleAngle\n\t * @param  {Body} convexBody\n\t * @param  {Convex} convexShape\n\t * @param  {Array} convexOffset\n\t * @param  {Number} convexAngle\n\t * @param {boolean} justTest\n\t * @return {number}\n\t * @todo use pointInConvex and code more similar to circleConvex\n\t * @todo don't transform each vertex, but transform the particle position to convex-local instead\n\t */\n\t//Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =\n\t//Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =\n\tparticleConvex(\n\t\tparticleBody: Body,\n\t\tparticleShape: Particle,\n\t\tparticleOffset: Float32Array,\n\t\tconvexBody: Body,\n\t\tconvexShape: Convex,\n\t\tconvexOffset: Float32Array,\n\t\tconvexAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet worldVertex0 = tmp1,\n\t\t\tworldVertex1 = tmp2,\n\t\t\tworldEdge = tmp3,\n\t\t\tworldEdgeUnit = tmp4,\n\t\t\tworldTangent = tmp5,\n\t\t\tcenterDist = tmp6,\n\t\t\tconvexToparticle = tmp7,\n\t\t\tclosestEdgeProjectedPoint = tmp13,\n\t\t\tcandidateDist = tmp14,\n\t\t\tminEdgeNormal = tmp15,\n\t\t\tminCandidateDistance = Infinity,\n\t\t\tfound = false,\n\t\t\tverts = convexShape.vertices;\n\n\t\t// Check if the particle is in the polygon at all\n\t\tif(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(justTest){\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Check edges first\n\t\tfor(let i: i32 = 0, numVerts=verts.length; i!==numVerts+1; i++){\n\t\t\tlet v0 = verts[i%numVerts],\n\t\t\t\tv1 = verts[(i+1)%numVerts];\n\n\t\t\t// Transform vertices to world\n\t\t\t// @todo transform point to local space instead\n\t\t\tvec2.rotate(worldVertex0, v0, convexAngle);\n\t\t\tvec2.rotate(worldVertex1, v1, convexAngle);\n\t\t\tvec2.add(worldVertex0, worldVertex0, convexOffset);\n\t\t\tvec2.add(worldVertex1, worldVertex1, convexOffset);\n\n\t\t\t// Get world edge\n\t\t\tvec2.subtract(worldEdge, worldVertex1, worldVertex0);\n\t\t\tvec2.normalize(worldEdgeUnit, worldEdge);\n\n\t\t\t// Get tangent to the edge. Points out of the Convex\n\t\t\tvec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n\t\t\t// Check distance from the infinite line (spanned by the edge) to the particle\n\t\t\t//vec2.subtract(dist, particleOffset, worldVertex0);\n\t\t\t//let d = vec2.dot(dist, worldTangent);\n\t\t\tvec2.subtract(centerDist, worldVertex0, convexOffset);\n\n\t\t\tvec2.subtract(convexToparticle, particleOffset, convexOffset);\n\n\t\t\tvec2.subtract(candidateDist,worldVertex0,particleOffset);\n\t\t\tlet candidateDistance = Mathf.abs(vec2.dot(candidateDist,worldTangent));\n\n\t\t\tif(candidateDistance < minCandidateDistance){\n\t\t\t\tminCandidateDistance = candidateDistance;\n\t\t\t\tvec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);\n\t\t\t\tvec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);\n\t\t\t\tvec2.copy(minEdgeNormal,worldTangent);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\n\t\tif(found){\n\t\t\tlet c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);\n\n\t\t\tvec2.scale(c.normalA, minEdgeNormal, -1);\n\t\t\tvec2.normalize(c.normalA, c.normalA);\n\n\t\t\t// Particle has no extent to the contact point\n\t\t\tvec2.set(c.contactPointA,  0, 0);\n\t\t\tvec2.add(c.contactPointA, c.contactPointA, particleOffset);\n\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, particleBody.position);\n\n\t\t\t// From convex center to point\n\t\t\tvec2.subtract(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n\t\t\tvec2.add(c.contactPointB, c.contactPointB, convexOffset);\n\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, convexBody.position);\n\n\t\t\tthis.contactEquations.push(c);\n\n\t\t\tif(this.enableFriction){\n\t\t\t\tthis.frictionEquations.push( this.createFrictionFromContact(c) );\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\n\n\t\treturn 0;\n\t};\n\n\t/**\n\t * Circle/circle Narrowphase\n\t * @method circleCircle\n\t * @param  {Body} bodyA\n\t * @param  {Circle} shapeA\n\t * @param  {Array} offsetA\n\t * @param  {Body} bodyB\n\t * @param  {Circle} shapeB\n\t * @param  {Array} offsetB\n\t * @param {boolean} justTest\n\t * @param {Number} [radiusA] Optional radius to use for shapeA\n\t * @param {Number} [radiusB] Optional radius to use for shapeB\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE] =\n\tcircleCircle(\n\t\tbodyA: Body,\n\t\tshapeA: Circle,\n\t\toffsetA: Float32Array,\n\t\tbodyB: Body,\n\t\tshapeB: Circle,\n\t\toffsetB: Float32Array,\n\t\tjustTest: boolean,\n\t\tradiusA: f32,\n\t\tradiusB: f32\n\t): u16{\n\n\t\tlet dist = tmp1;\n\n\t\tvec2.subtract(dist,offsetA,offsetB);\n\t\tlet r = radiusA + radiusB;\n\t\tif(vec2.squaredLength(dist) > r*r){\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(justTest){\n\t\t\treturn 1;\n\t\t}\n\n\t\tlet c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n\t\tlet cpA = c.contactPointA;\n\t\tlet cpB = c.contactPointB;\n\t\tlet normalA = c.normalA;\n\n\t\tvec2.subtract(normalA, offsetB, offsetA);\n\t\tvec2.normalize(normalA,normalA);\n\n\t\tvec2.scale( cpA, normalA,  radiusA);\n\t\tvec2.scale( cpB, normalA, -radiusB);\n\n\t\taddSub(cpA, cpA, offsetA, bodyA.position);\n\t\taddSub(cpB, cpB, offsetB, bodyB.position);\n\n\t\tthis.contactEquations.push(c);\n\n\t\tif(this.enableFriction){\n\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t}\n\t\treturn 1;\n\t};\n\n\t/**\n\t * Plane/Convex Narrowphase\n\t * @method planeConvex\n\t * @param  {Body} planeBody\n\t * @param  {Plane} planeShape\n\t * @param  {Array} planeOffset\n\t * @param  {Number} planeAngle\n\t * @param  {Body} convexBody\n\t * @param  {Convex} convexShape\n\t * @param  {Array} convexOffset\n\t * @param  {Number} convexAngle\n\t * @param {boolean} justTest\n\t * @return {number}\n\t * @todo only use the deepest contact point + the contact point furthest away from it\n\t */\n\t//Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =\n\t//Narrowphase.prototype[Shape.PLANE | Shape.BOX] =\n\tplaneConvex(\n\t\tplaneBody: Body,\n\t\tplaneShape: Plane,\n\t\tplaneOffset: Float32Array,\n\t\tplaneAngle: f32,\n\t\tconvexBody: Body,\n\t\tconvexShape: Convex,\n\t\tconvexOffset: Float32Array,\n\t\tconvexAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet worldVertex = tmp1,\n\t\t\tworldNormal = tmp2,\n\t\t\tdist = tmp3,\n\t\t\tlocalPlaneOffset = tmp4,\n\t\t\tlocalPlaneNormal = tmp5,\n\t\t\tlocalDist = tmp6;\n\n\t\tlet numReported: u16 = 0;\n\t\tvec2.rotate(worldNormal, yAxis, planeAngle);\n\n\t\t// Get convex-local plane offset and normal\n\t\tvec2.vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);\n\t\tvec2.toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);\n\n\t\tlet vertices = convexShape.vertices;\n\t\tfor(let i: i32 = 0, numVerts=vertices.length; i!==numVerts; i++){\n\t\t\tlet v = vertices[i];\n\n\t\t\tvec2.subtract(localDist, v, localPlaneOffset);\n\n\t\t\tif(vec2.dot(localDist,localPlaneNormal) <= 0){\n\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tvec2.toGlobalFrame(worldVertex, v, convexOffset, convexAngle);\n\n\t\t\t\tvec2.subtract(dist, worldVertex, planeOffset);\n\n\t\t\t\t// Found vertex\n\t\t\t\tnumReported++;\n\n\t\t\t\tlet c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);\n\n\t\t\t\tvec2.subtract(dist, worldVertex, planeOffset);\n\n\t\t\t\tvec2.copy(c.normalA, worldNormal);\n\n\t\t\t\tlet d = vec2.dot(dist, c.normalA);\n\t\t\t\tvec2.scale(dist, c.normalA, d);\n\n\t\t\t\t// rj is from convex center to contact\n\t\t\t\tvec2.subtract(c.contactPointB, worldVertex, convexBody.position);\n\n\t\t\t\t// ri is from plane center to contact\n\t\t\t\tvec2.subtract( c.contactPointA, worldVertex, dist);\n\t\t\t\tvec2.subtract( c.contactPointA, c.contactPointA, planeBody.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(!this.enableFrictionReduction){\n\t\t\t\t\tif(this.enableFriction){\n\t\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.enableFrictionReduction){\n\t\t\tif(this.enableFriction && numReported){\n\t\t\t\tthis.frictionEquations.push(this.createFrictionFromAverage(numReported));\n\t\t\t}\n\t\t}\n\n\t\treturn numReported;\n\t};\n\n\t/**\n\t * Narrowphase for particle vs plane\n\t * @method particlePlane\n\t * @param  {Body}       particleBody\n\t * @param  {Particle}   particleShape\n\t * @param  {Array}      particleOffset\n\t * @param  {Body}       planeBody\n\t * @param  {Plane}      planeShape\n\t * @param  {Array}      planeOffset\n\t * @param  {Number}     planeAngle\n\t * @param {boolean}     justTest\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =\n\tparticlePlane(\n\t\tparticleBody: Body,\n\t\tparticleShape: Particle,\n\t\tparticleOffset: Float32Array,\n\t\tplaneBody: Body,\n\t\tplaneShape: Plane,\n\t\tplaneOffset: Float32Array,\n\t\tplaneAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet dist = tmp1,\n\t\t\tworldNormal = tmp2;\n\n\t\tplaneAngle = planeAngle || 0;\n\n\t\tvec2.subtract(dist, particleOffset, planeOffset);\n\t\tvec2.rotate(worldNormal, yAxis, planeAngle);\n\n\t\tlet d = vec2.dot(dist, worldNormal);\n\n\t\tif(d > 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(justTest){\n\t\t\treturn 1;\n\t\t}\n\n\t\tlet c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);\n\n\t\tvec2.copy(c.normalA, worldNormal);\n\t\tvec2.scale( dist, c.normalA, d );\n\t\t// dist is now the distance vector in the normal direction\n\n\t\t// ri is the particle position projected down onto the plane, from the plane center\n\t\tvec2.subtract( c.contactPointA, particleOffset, dist);\n\t\tvec2.subtract( c.contactPointA, c.contactPointA, planeBody.position);\n\n\t\t// rj is from the body center to the particle center\n\t\tvec2.subtract( c.contactPointB, particleOffset, particleBody.position );\n\n\t\tthis.contactEquations.push(c);\n\n\t\tif(this.enableFriction){\n\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t}\n\t\treturn 1;\n\t};\n\n\t/**\n\t * Circle/Particle Narrowphase\n\t * @method circleParticle\n\t * @param  {Body} circleBody\n\t * @param  {Circle} circleShape\n\t * @param  {Array} circleOffset\n\t * @param  {Body} particleBody\n\t * @param  {Particle} particleShape\n\t * @param  {Array} particleOffset\n\t * @param  {boolean} justTest\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =\n\tcircleParticle(\n\t\tcircleBody: Body,\n\t\tcircleShape: Circle,\n\t\tcircleOffset: Float32Array,\n\t\tparticleBody: Body,\n\t\tparticleShape: Particle,\n\t\tparticleOffset: Float32Array,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet dist = tmp1;\n\t\tlet circleRadius = circleShape.radius;\n\n\t\tvec2.subtract(dist, particleOffset, circleOffset);\n\t\tif(vec2.squaredLength(dist) > circleRadius*circleRadius){\n\t\t\treturn 0;\n\t\t}\n\t\tif(justTest){\n\t\t\treturn 1;\n\t\t}\n\n\t\tlet c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);\n\t\tlet normalA = c.normalA;\n\t\tlet contactPointA = c.contactPointA;\n\t\tlet contactPointB = c.contactPointB;\n\n\t\tvec2.copy(normalA, dist);\n\t\tvec2.normalize(normalA, normalA);\n\n\t\t// Vector from circle to contact point is the normal times the circle radius\n\t\tvec2.scale(contactPointA, normalA, circleRadius);\n\t\tvec2.add(contactPointA, contactPointA, circleOffset);\n\t\tvec2.subtract(contactPointA, contactPointA, circleBody.position);\n\n\t\t// Vector from particle center to contact point is zero\n\t\tvec2.subtract(contactPointB, particleOffset, particleBody.position);\n\n\t\tthis.contactEquations.push(c);\n\n\t\tif(this.enableFriction){\n\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t}\n\n\t\treturn 1;\n\t};\n\n\t/**\n\t * @method planeCapsule\n\t * @param  {Body} planeBody\n\t * @param  {Circle} planeShape\n\t * @param  {Array} planeOffset\n\t * @param  {Number} planeAngle\n\t * @param  {Body} capsuleBody\n\t * @param  {Particle} capsuleShape\n\t * @param  {Array} capsuleOffset\n\t * @param  {Number} capsuleAngle\n\t * @param {boolean} justTest\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =\n\tplaneCapsule(\n\t\tplaneBody: Body,\n\t\tplaneShape: Plane,\n\t\tplaneOffset: Float32Array,\n\t\tplaneAngle: f32,\n\t\tcapsuleBody: Body,\n\t\tcapsuleShape: Capsule,\n\t\tcapsuleOffset: Float32Array,\n\t\tcapsuleAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\n\t\tlet circleOptions = new CircleOptions();\n\t\tcircleOptions.radius = 1;\n\t\tlet planeCapsule_tmpCircle = new Circle(circleOptions);\n\n\t\tlet end1 = planeCapsule_tmp1,\n\t\t\tend2 = planeCapsule_tmp2,\n\t\t\tcircle = planeCapsule_tmpCircle,\n\t\t\thalfLength = capsuleShape.length / 2;\n\n\t\t// Compute world end positions\n\t\tvec2.set(end1, -halfLength, 0);\n\t\tvec2.set(end2, halfLength, 0);\n\t\tvec2.toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);\n\t\tvec2.toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);\n\n\t\tcircle.radius = capsuleShape.radius;\n\n\t\tlet enableFrictionBefore: boolean = this.enableFriction;\n\n\t\t// Temporarily turn off friction\n\t\tif(this.enableFrictionReduction){\n\t\t\tthis.enableFriction = false;\n\t\t}\n\n\t\t// Do Narrowphase as two circles\n\t\tlet numContacts1 = this.circlePlane(capsuleBody,circle,end1,planeBody,planeShape,planeOffset,planeAngle, justTest),\n\t\t\tnumContacts2 = this.circlePlane(capsuleBody,circle,end2,planeBody,planeShape,planeOffset,planeAngle, justTest);\n\n\t\t// Restore friction\n\t\tif(this.enableFrictionReduction){\n\t\t\tthis.enableFriction = enableFrictionBefore;\n\t\t}\n\n\t\tif(justTest){\n\t\t\treturn numContacts1 + numContacts2;\n\t\t} else {\n\t\t\tlet numTotal = numContacts1 + numContacts2;\n\t\t\tif(this.enableFrictionReduction){\n\t\t\t\tif(numTotal){\n\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromAverage(numTotal));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn numTotal;\n\t\t}\n\t};\n\n\t/**\n\t * @method circlePlane\n\t * @param  {Body}    circleBody\n\t * @param  {Circle}  circleShape\n\t * @param  {Array}   circleOffset\n\t * @param  {Body}    planeBody\n\t * @param  {Plane}   planeShape\n\t * @param  {Array}   planeOffset\n\t * @param  {Number}  planeAngle\n\t * @param  {boolean} justTest\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =\n\tcirclePlane(\n\t\tcircleBody: Body,\n\t\tcircleShape: Circle,\n\t\tcircleOffset: Float32Array,\n\t\tplaneBody: Body,\n\t\tplaneShape: Plane,\n\t\tplaneOffset: Float32Array,\n\t\tplaneAngle: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet circleRadius = circleShape.radius;\n\n\t\t// Vector from plane to circle\n\t\tlet planeToCircle = tmp1,\n\t\t\tworldNormal = tmp2,\n\t\t\ttemp = tmp3;\n\n\t\tvec2.subtract(planeToCircle, circleOffset, planeOffset);\n\n\t\t// World plane normal\n\t\tvec2.rotate(worldNormal, yAxis, planeAngle);\n\n\t\t// Normal direction distance\n\t\tlet d = vec2.dot(worldNormal, planeToCircle);\n\n\t\tif(d > circleRadius){\n\t\t\treturn 0; // No overlap. Abort.\n\t\t}\n\n\t\tif(justTest){\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Create contact\n\t\tlet contact = this.createContactEquation(planeBody,circleBody,planeShape,circleShape);\n\n\t\t// ni is the plane world normal\n\t\tvec2.copy(contact.normalA, worldNormal);\n\n\t\t// rj is the vector from circle center to the contact point\n\t\tlet cpB = contact.contactPointB;\n\t\tvec2.scale(cpB, contact.normalA, -circleRadius);\n\t\tvec2.add(cpB, cpB, circleOffset);\n\t\tvec2.subtract(cpB, cpB, circleBody.position);\n\n\t\t// ri is the distance from plane center to contact.\n\t\tlet cpA = contact.contactPointA;\n\t\tvec2.scale(temp, contact.normalA, d);\n\t\tvec2.subtract(cpA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector\n\t\tvec2.add(cpA, cpA, planeOffset);\n\t\tvec2.subtract(cpA, cpA, planeBody.position);\n\n\t\tthis.contactEquations.push(contact);\n\n\t\tif(this.enableFriction){\n\t\t\tthis.frictionEquations.push( this.createFrictionFromContact(contact) );\n\t\t}\n\n\t\treturn 1;\n\t};\n\n\t// Find edge normal of max separation on A - return if separating axis is found\n\t// Find edge normal of max separation on B - return if separation axis is found\n\t// Choose reference edge as min(minA, minB)\n\t// Find incident edge\n\t// Clip\n\t// The normal points from 1 to 2\n\n\t/*function collidePolygons(\n\t\tmanifold,\n\t\tpolyA, positionA, angleA,\n\t\tpolyB, positionB, angleB,\n\t\tincidentEdge\n\t) {*/\n\n\t/**\n\t * Convex/convex Narrowphase.See <a href=\"http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\">this article</a> for more info.\n\t * @method convexConvex\n\t * @param  {Body} bi\n\t * @param  {Convex} si\n\t * @param  {Array} xi\n\t * @param  {Number} ai\n\t * @param  {Body} bj\n\t * @param  {Convex} sj\n\t * @param  {Array} xj\n\t * @param  {Number} aj\n\t * @param  {boolean} justTest\n\t * @return {number}\n\t */\n\t//Narrowphase.prototype[Shape.CONVEX] =\n\t//Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =\n\t//Narrowphase.prototype[Shape.BOX] =\n\tconvexConvex(\n\t\tbodyA: Body,\n\t\tpolyA: Convex,\n\t\tpositionA: Float32Array,\n\t\tangleA: f32,\n\t\tbodyB: Body,\n\t\tpolyB: Convex,\n\t\tpositionB: Float32Array,\n\t\tangleB: f32,\n\t\tjustTest: boolean\n\t): u16{\n\t\tlet maxManifoldPoints = 2;\n\n\t\tlet totalRadius: f32 = 0;\n\t\tlet dist: Float32Array = collidePolygons_dist;\n\n\t\tlet tempVec: Float32Array = collidePolygons_tempVec;\n\t\tlet tmpVec: Float32Array = collidePolygons_tmpVec;\n\n\t\tlet edgeA: i32 = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);\n\t\tlet separationA: f32 = tempVec[0];\n\t\tif (separationA > totalRadius){\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet edgeB: u32 = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);\n\t\tlet separationB = tmpVec[0];\n\t\tif (separationB > totalRadius){\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet poly1: Convex;\t// reference polygon\n\t\tlet poly2: Convex;\t// incident polygon\n\n\t\tlet position1: Float32Array;\n\t\tlet position2: Float32Array;\n\t\tlet angle1: f32;\n\t\tlet angle2: f32;\n\t\tlet body1: Body;\n\t\tlet body2: Body;\n\n\t\tlet edge1: i32;\t\t\t\t\t// reference edge\n\t\tlet type: u16;\n\n\t\tif (separationB > separationA)\n\t\t{\n\t\t\tpoly1 = polyB;\n\t\t\tpoly2 = polyA;\n\t\t\tbody1 = bodyB;\n\t\t\tbody2 = bodyA;\n\t\t\tposition1 = positionB;\n\t\t\tangle1 = angleB;\n\t\t\tposition2 = positionA;\n\t\t\tangle2 = angleA;\n\t\t\tedge1 = edgeB;\n\t\t\ttype = 1; // faceB\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpoly1 = polyA;\n\t\t\tpoly2 = polyB;\n\t\t\tbody1 = bodyA;\n\t\t\tbody2 = bodyB;\n\t\t\tposition1 = positionA;\n\t\t\tangle1 = angleA;\n\t\t\tposition2 = positionB;\n\t\t\tangle2 = angleB;\n\t\t\tedge1 = edgeA;\n\t\t\ttype = 0; // faceA\n\t\t}\n\n\t\tlet incidentEdge = collidePolygons_incidentEdge;\n\t\tfindIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);\n\n\t\tlet count1 = poly1.vertices.length;\n\t\tlet vertices1 = poly1.vertices;\n\n\t\tlet iv1: i32 = edge1;\n\t\tlet iv2: i32 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n\t\tlet v11 = collidePolygons_v11;\n\t\tlet v12 = collidePolygons_v12;\n\t\tvec2.copy(v11, vertices1[iv1]);\n\t\tvec2.copy(v12, vertices1[iv2]);\n\n\t\tlet localTangent = collidePolygons_localTangent;\n\t\tvec2.subtract(localTangent, v12, v11);\n\t\tvec2.normalize(localTangent, localTangent);\n\n\t\tlet localNormal = collidePolygons_localNormal;\n\t\tvec2.crossVZ(localNormal, localTangent, 1.0);\n\t\tlet planePoint = collidePolygons_planePoint;\n\t\tvec2.add(planePoint, v11, v12);\n\t\tvec2.scale(planePoint, planePoint, 0.5);\n\n\t\tlet tangent = collidePolygons_tangent; // tangent in world space\n\t\tvec2.rotate(tangent, localTangent, angle1);\n\t\tlet normal = collidePolygons_normal; // normal in world space\n\t\tvec2.crossVZ(normal, tangent, 1.0);\n\n\t\tvec2.toGlobalFrame(v11, v11, position1, angle1);\n\t\tvec2.toGlobalFrame(v12, v12, position1, angle1);\n\n\t\t// Face offset.\n\t\tlet frontOffset = vec2.dot(normal, v11);\n\n\t\t// Side offsets, extended by polytope skin thickness.\n\t\tlet sideOffset1 = -vec2.dot(tangent, v11) + totalRadius;\n\t\tlet sideOffset2 = vec2.dot(tangent, v12) + totalRadius;\n\n\t\t// Clip incident edge against extruded edge1 side edges.\n\t\tlet clipPoints1 = collidePolygons_clipPoints1;\n\t\tlet clipPoints2 = collidePolygons_clipPoints2;\n\t\tlet np = 0;\n\n\t\t// Clip to box side 1\n\t\tlet negativeTangent = collidePolygons_negativeTangent;\n\t\tvec2.scale(negativeTangent, tangent, -1);\n\t\tnp = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1/*, iv1*/);\n\n\t\tif (np < 2){\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Clip to negative box side 1\n\t\tnp = clipSegmentToLine(clipPoints2, clipPoints1,  tangent, sideOffset2/*, iv2*/);\n\n\t\tif (np < 2){\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet pointCount: u16 = 0;\n\t\tfor (let i = 0; i < maxManifoldPoints; ++i)\n\t\t{\n\t\t\tlet separation = vec2.dot(normal, clipPoints2[i]) - frontOffset;\n\n\t\t\tif (separation <= totalRadius)\n\t\t\t{\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t++pointCount;\n\n\t\t\t\tlet c = this.createContactEquation(body1,body2,poly1,poly2);\n\n\t\t\t\tvec2.copy(c.normalA, normal);\n\t\t\t\tvec2.copy(c.contactPointB, clipPoints2[i]);\n\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, body2.position);\n\n\t\t\t\tvec2.scale(dist, normal, -separation);\n\t\t\t\tvec2.add(c.contactPointA, clipPoints2[i], dist);\n\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, body1.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(this.enableFriction && !this.enableFrictionReduction){\n\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(pointCount && this.enableFrictionReduction && this.enableFriction){\n\t\t\tthis.frictionEquations.push(this.createFrictionFromAverage(pointCount));\n\t\t}\n\n\t\treturn pointCount;\n\t};\n\n\t//Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =\n\tcircleHeightfield( circleBody: Body,circleShape: Circle,circlePos: Float32Array,\n\t\t\t\t\t\thfBody: Body,hfShape: Heightfield,hfPos: Float32Array, justTest: boolean, radius: f32 ): u16{\n\n\t\tlet data: f32[] = hfShape.heights,\n\t\t\tw: f32 = hfShape.elementWidth,\n\t\t\tdist: Float32Array = circleHeightfield_dist,\n\t\t\tcandidate: Float32Array = circleHeightfield_candidate,\n\t\t\tminCandidate: Float32Array = circleHeightfield_minCandidate,\n\t\t\tminCandidateNormal: Float32Array = circleHeightfield_minCandidateNormal,\n\t\t\tworldNormal: Float32Array = circleHeightfield_worldNormal,\n\t\t\tv0: Float32Array = circleHeightfield_v0,\n\t\t\tv1: Float32Array = circleHeightfield_v1;\n\n\t\t// Get the index of the points to test against\n\t\t\n\t\t// FIXME: What the hell is going on here. Are these f32s or integers?\n\t\tlet idxA: i32 = Mathf.floor( (circlePos[0] - radius - hfPos[0]) / w ) as i32,\n\t\t\tidxB: i32 = Mathf.ceil( (circlePos[0] + radius - hfPos[0]) / w ) as i32;\n\n\t\t/*if(idxB < 0 || idxA >= data.length)\n\t\t\treturn justTest ? false : 0;*/\n\n\t\tif(idxA < 0){\n\t\t\tidxA = 0;\n\t\t}\n\n\t\tif(idxB >= data.length){\n\t\t\tidxB = data.length - 1;\n\t\t}\n\n\t\t// Get max and min\n\t\tlet max: f32 = data[idxA],\n\t\t\tmin: f32 = data[idxB];\n\t\tfor(let i: i32 = idxA; i<idxB; i++){\n\t\t\tif(data[i] < min){\n\t\t\t\tmin = data[i];\n\t\t\t}\n\t\t\tif(data[i] > max){\n\t\t\t\tmax = data[i];\n\t\t\t}\n\t\t}\n\n\t\tif(circlePos[1]-radius > max){\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\tif(circlePos[1]+radius < min){\n\t\t\t// Below the minimum point... We can just guess.\n\t\t\t// TODO\n\t\t}\n\t\t*/\n\n\t\t// 1. Check so center of circle is not inside the field. If it is, this wont work...\n\t\t// 2. For each edge\n\t\t// 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n\t\t// 2. 2. Check if point is inside.\n\n\t\tlet found = false;\n\n\t\t// Check all edges first\n\t\tfor(let i: i32 = idxA; i<idxB; i++){\n\n\t\t\t// Get points\n\t\t\tvec2.set(v0,     (i as f32)*w, data[i]  );\n\t\t\tvec2.set(v1, ((i as f32)+1.0)*w, data[i+1]);\n\t\t\tvec2.add(v0,v0,hfPos); // @todo transform circle to local heightfield space instead\n\t\t\tvec2.add(v1,v1,hfPos);\n\n\t\t\t// Get normal\n\t\t\tvec2.subtract(worldNormal, v1, v0);\n\t\t\tvec2.rotate(worldNormal, worldNormal, Mathf.PI/2);\n\t\t\tvec2.normalize(worldNormal,worldNormal);\n\n\t\t\t// Get point on circle, closest to the edge\n\t\t\tvec2.scale(candidate,worldNormal,-radius);\n\t\t\tvec2.add(candidate,candidate,circlePos);\n\n\t\t\t// Distance from v0 to the candidate point\n\t\t\tvec2.subtract(dist,candidate,v0);\n\n\t\t\t// Check if it is in the element \"stick\"\n\t\t\tlet d = vec2.dot(dist,worldNormal);\n\t\t\tif(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){\n\n\t\t\t\tif(justTest){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\n\t\t\t\t// Store the candidate point, projected to the edge\n\t\t\t\tvec2.scale(dist,worldNormal,-d);\n\t\t\t\tvec2.add(minCandidate,candidate,dist);\n\t\t\t\tvec2.copy(minCandidateNormal,worldNormal);\n\n\t\t\t\tlet c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n\t\t\t\t// Normal is out of the heightfield\n\t\t\t\tvec2.copy(c.normalA, minCandidateNormal);\n\n\t\t\t\t// Vector from circle to heightfield\n\t\t\t\tvec2.scale(c.contactPointB,  c.normalA, -radius);\n\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, circlePos);\n\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, circleBody.position);\n\n\t\t\t\tvec2.copy(c.contactPointA, minCandidate);\n\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, hfBody.position);\n\n\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\tif(this.enableFriction){\n\t\t\t\t\tthis.frictionEquations.push( this.createFrictionFromContact(c) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check all vertices\n\t\tfound = false;\n\t\tif(radius > 0){\n\t\t\tfor(let i: i32 = idxA; i<=idxB; i++){\n\n\t\t\t\t// Get point\n\t\t\t\tvec2.set(v0, (i as f32) * w, data[i]);\n\t\t\t\tvec2.add(v0,v0,hfPos);\n\n\t\t\t\tvec2.subtract(dist, circlePos, v0);\n\n\t\t\t\tif(vec2.squaredLength(dist) < Mathf.pow(radius, 2)){\n\n\t\t\t\t\tif(justTest){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tlet c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n\t\t\t\t\t// Construct normal - out of heightfield\n\t\t\t\t\tvec2.copy(c.normalA, dist);\n\t\t\t\t\tvec2.normalize(c.normalA,c.normalA);\n\n\t\t\t\t\tvec2.scale(c.contactPointB, c.normalA, -radius);\n\t\t\t\t\tvec2.add(c.contactPointB, c.contactPointB, circlePos);\n\t\t\t\t\tvec2.subtract(c.contactPointB, c.contactPointB, circleBody.position);\n\n\t\t\t\t\tvec2.subtract(c.contactPointA, v0, hfPos);\n\t\t\t\t\tvec2.add(c.contactPointA, c.contactPointA, hfPos);\n\t\t\t\t\tvec2.subtract(c.contactPointA, c.contactPointA, hfBody.position);\n\n\t\t\t\t\tthis.contactEquations.push(c);\n\n\t\t\t\t\tif(this.enableFriction){\n\t\t\t\t\t\tthis.frictionEquations.push(this.createFrictionFromContact(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(found){\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\t//Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =\n\t//Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =\n\tconvexHeightfield( convexBody: Body, convexShape: Convex, convexPos: Float32Array, convexAngle: f32,\n\t\t\t\t\t\thfBody: Body, hfShape: Heightfield, hfPos: Float32Array, justTest: boolean ): u16{\n\t\t\t\n\t\tlet data = hfShape.heights,\n\t\t\tw = hfShape.elementWidth,\n\t\t\tv0 = convexHeightfield_v0,\n\t\t\tv1 = convexHeightfield_v1,\n\t\t\ttilePos = convexHeightfield_tilePos,\n\t\t\ttileConvex = convexHeightfield_tempConvexShape;\n\n\t\t// Get the index of the points to test against\n\t\tlet idxA: i32 = Mathf.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ) as i32,\n\t\t\tidxB: i32 = Mathf.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w ) as i32;\n\n\t\tif(idxA < 0){\n\t\t\tidxA = 0;\n\t\t}\n\t\tif(idxB >= data.length){\n\t\t\tidxB = data.length-1;\n\t\t}\n\n\t\t// Get max and min\n\t\tlet max = data[idxA],\n\t\t\tmin = data[idxB];\n\t\tfor(let i: i32 = idxA; i<idxB; i++){\n\t\t\tif(data[i] < min){\n\t\t\t\tmin = data[i];\n\t\t\t}\n\t\t\tif(data[i] > max){\n\t\t\t\tmax = data[i];\n\t\t\t}\n\t\t}\n\n\t\tif(convexBody.aabb.lowerBound[1] > max){\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet numContacts: u16 = 0;\n\n\t\t// Loop over all edges\n\t\t// @todo If possible, construct a convex from several data points (need o check if the points make a convex shape)\n\t\t// @todo transform convex to local heightfield space.\n\t\t// @todo bail out if the heightfield tile is not tall enough.\n\t\tfor(let i: i32 = idxA; i<idxB; i++){\n\n\t\t\t// Get points\n\t\t\tvec2.set(v0, (i as f32)*w, data[i]  );\n\t\t\tvec2.set(v1, ((i+1) as f32)*w, data[i+1]);\n\t\t\tvec2.add(v0,v0,hfPos);\n\t\t\tvec2.add(v1,v1,hfPos);\n\n\t\t\t// Construct a convex\n\t\t\tlet tileHeight: f32 = 100.0; // todo\n\t\t\tvec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);\n\n\t\t\tvec2.subtract(tileConvex.vertices[0], v1, tilePos);\n\t\t\tvec2.subtract(tileConvex.vertices[1], v0, tilePos);\n\t\t\tvec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);\n\t\t\tvec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);\n\t\t\ttileConvex.vertices[2][1] -= tileHeight;\n\t\t\ttileConvex.vertices[3][1] -= tileHeight;\n\t\t\ttileConvex.updateNormals();\n\n\t\t\t// Do convex collision\n\t\t\tnumContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,\n\t\t\t\t\t\t\t\t\t\t\t\thfBody, tileConvex, tilePos, 0, justTest);\n\t\t}\n\n\t\treturn numContacts;\n\t}\n}","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\n  var ptr = __rtti_base;\n  if (id <= load<u32>(ptr)) {\n    do if (id == superId) return true;\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __alloc(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var array = __alloc(offsetof<i32[]>(), id);\n  var bufferSize = <usize>length << alignLog2;\n  var buffer = __allocBuffer(bufferSize, idof<ArrayBuffer>(), data);\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// @builtin @unsafe\n// export declare function __alloc(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ref: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __retain(ref: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __release(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ref: usize, cookie: u32): void;\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  // depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    let newCapacity = minSize << alignLog2;\n    let newData = __realloc(oldData, newCapacity); // keeps RC\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n    }\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  private dataStart: usize;\n  private byteLength: i32;\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var bufferSize = <usize>length << alignof<T>();\n    var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, bufferSize);\n    this.buffer = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    var oldLength = this.length_;\n    if (isManaged<T>()) {\n      if (oldLength > newLength) { // release no longer used refs\n        let dataStart = this.dataStart;\n        let cur = dataStart + (<usize>newLength << alignof<T>());\n        let end = dataStart + (<usize>oldLength << alignof<T>());\n        do __release(load<usize>(cur));\n        while ((cur += sizeof<T>()) < end);\n      } else {\n        ensureSize(changetype<usize>(this), newLength, alignof<T>());\n      }\n    } else {\n      ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    }\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = this.__uget(index);\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    if (isManaged<T>()) {\n      let offset = this.dataStart + (<usize>index << alignof<T>());\n      let oldRef = load<usize>(offset);\n      if (changetype<usize>(value) != oldRef) {\n        store<usize>(offset, __retain(changetype<usize>(value)));\n        __release(oldRef);\n      }\n    } else {\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\n        if (changetype<usize>(value) != oldRef) {\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length_;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      let dataStart = this.dataStart;\n      while (fromIndex < length) {\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (isManaged<T>()) {\n      if (from < to && to < (from + count)) { // right to left\n        from += count - 1;\n        to   += count - 1;\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          --from, --to, --count;\n        }\n      } else { // left to right\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          ++from, ++to, --count;\n        }\n      }\n    } else {\n      memory.copy( // is memmove\n        dataStart + (<usize>to << alignof<T>()),\n        dataStart + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element; // no need to retain -> is moved\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\n      if (isManaged<U>()) {\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\n      } else {\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\n      }\n      // releases result\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element; // no need to retain -> is moved\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    if (isManaged<T>()) {\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\n    } else {\n      store<T>(dataStart, value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, __retain(ref));\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    // no need to retain -> is moved\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var length = this.length_;\n    var selfDataStart = this.dataStart;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < length; i++) {\n      let child = load<usize>(selfDataStart + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    var byteLength = <usize>size << usize(alignof<valueof<T>>());\n    var dataStart = __alloc(byteLength, idof<ArrayBuffer>());\n\n    // create the return value and initialize it\n    var result = __alloc(offsetof<T>(), idof<T>());\n    store<i32>(result, size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(result, byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(result, dataStart, offsetof<T>(\"dataStart\"));\n    store<usize>(result, __retain(dataStart), offsetof<T>(\"buffer\"));\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < length; i++) { // for each child\n      let child = load<usize>(selfDataStart + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (child == 0) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = load<i32>(child, offsetof<T>(\"byteLength\"));\n      memory.copy(\n        dataStart + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        <usize>childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must call __retain() on each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; i++) {\n        __retain(load<usize>(dataStart + (<usize>i << usize(alignof<valueof<T>>()))));\n      }\n    }\n\n    return changetype<T>(result);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import * as JSMath from \"./bindings/Math\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of /2 * |x|\n *\n * y = /4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of /4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 /  with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2)\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const pio2_1  = reinterpret<f64>(0x3FF921FB54400000); // 1.57079632673412561417e+00\n  const pio2_1t = reinterpret<f64>(0x3DD0B4611A626331); // 6.07710050650619224932e-11\n  const pio2_2  = reinterpret<f64>(0x3DD0B4611A600000); // 6.07710050630396597660e-11\n  const pio2_2t = reinterpret<f64>(0x3BA3198A2E037073); // 2.02226624879595063154e-21\n  const pio2_3  = reinterpret<f64>(0x3BA3198A2E000000); // 2.02226624871116645580e-21\n  const pio2_3t = reinterpret<f64>(0x397B839A252049C1); // 8.47842766036889956997e-32\n  const invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const S1 = reinterpret<f64>(0xBFC5555555555549); // -1.66666666666666324348e-01\n  const S2 = reinterpret<f64>(0x3F8111111110F8A6); //  8.33333333332248946124e-03\n  const S3 = reinterpret<f64>(0xBF2A01A019C161D5); // -1.98412698298579493134e-04\n  const S4 = reinterpret<f64>(0x3EC71DE357B1FE7D); //  2.75573137070700676789e-06\n  const S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB); // -2.50507602534068634195e-08\n  const S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const C1 = reinterpret<f64>(0x3FA555555555554C); //  4.16666666666666019037e-02\n  const C2 = reinterpret<f64>(0xBF56C16C16C15177); // -1.38888888888741095749e-03\n  const C3 = reinterpret<f64>(0x3EFA01A019CB1590); //  2.48015872894767294178e-05\n  const C4 = reinterpret<f64>(0xBE927E4F809C52AD); // -2.75573143513906633035e-07\n  const C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4); //  2.08757232129817482790e-09\n  const C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const T0  = reinterpret<f64>(0x3FD5555555555563); //  3.33333333333334091986e-01\n  const T1  = reinterpret<f64>(0x3FC111111110FE7A); //  1.33333333333201242699e-01\n  const T2  = reinterpret<f64>(0x3FABA1BA1BB341FE); //  5.39682539762260521377e-02\n  const T3  = reinterpret<f64>(0x3F9664F48406D637); //  2.18694882948595424599e-02\n  const T4  = reinterpret<f64>(0x3F8226E3E96E8493); //  8.86323982359930005737e-03\n  const T5  = reinterpret<f64>(0x3F6D6D22C9560328); //  3.59207910759131235356e-03\n  const T6  = reinterpret<f64>(0x3F57DBC8FEE08315); //  1.45620945432529025516e-03\n  const T7  = reinterpret<f64>(0x3F4344D8F2F26501); //  5.88041240820264096874e-04\n  const T8  = reinterpret<f64>(0x3F3026F71A8D1068); //  2.46463134818469906812e-04\n  const T9  = reinterpret<f64>(0x3F147E88A03792A6); //  7.81794442939557092300e-05\n  const T10 = reinterpret<f64>(0x3F12B80F32F0A7E9); //  7.14072491382608190305e-05\n  const T11 = reinterpret<f64>(0xBEF375CBDB605373); // -1.85586374855275456654e-05\n  const T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const one    = reinterpret<f64>(0x3FF0000000000000); // 1.00000000000000000000e+00\n  const pio4   = reinterpret<f64>(0x3FE921FB54442D18); // 7.85398163397448278999e-01\n  const pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\n  var big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy var random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy var random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000);\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31)    return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000);\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += <i32>(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n      let u_ = reinterpret<u64>(x);\n      let hx = <i32>(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = <i32>(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = <u32>(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = <u32>(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    assert(\n      random_state0_64 != 0 && random_state1_64 != 0 &&\n      random_state0_32 != 0 && random_state1_32 != 0\n    );\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    // In ECMAScript all NaN values are indistinguishable from each other\n    // so we need handle NaN and negative NaN in similar way\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & i32(x == x));\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var absx = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(absx);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(absx, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx << 63;\n    return reinterpret<f64>(ux);\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) {  // |x| ~<= /4\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); //  * 0x1p-65 = 8.51530395021638647334e-20\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { //  * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); // 0x15554d3418c99f.0p-54\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); // 0x1112fd38999f72.0p-55\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); // 0x1b54c91d865afe.0p-57\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); // 0x191df3908c33ce.0p-58\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); // 0x185dadfcecf44e.0p-61\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  var i = reinterpret<i64>(x);\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  var xx = x * x;\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  var n = nearest(x);\n  x -= n;\n  var xx = x * x;\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) {\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5/4\n        if (ix > 0x4016CBE3) { // |x|  ~> 3/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9/4\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000);\n      let hx = reinterpret<u32>(x);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign_) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) {\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      if (u < 0x00800000 || <bool>(u >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (u >> 31) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += <u32>(<i32>u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) {\n      return x;\n    } else if (ix == 0x3F800000) {\n      return 0;\n    }\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n      let ix = reinterpret<u32>(x);\n      let k: i32 = 0;\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\n        if (ix << 1 == 0) return -1 / (x * x);\n        if (ix >> 31) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ix = reinterpret<u32>(x);\n      } else if (ix >= 0x7F800000) {\n        return x;\n      } else if (ix == 0x3F800000) {\n        return 0;\n      }\n      ix += 0x3F800000 - 0x3F3504F3;\n      k += <i32>(ix >> 23) - 0x7F;\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ix);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = uy >> 31 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = uy >> 31 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    // @ts-ignore: type\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var absx = reinterpret<f32>(u);\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(absx);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(absx, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // argument reduction\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      if (ux1 == uy1) return 0 * x;\n      return x;\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= -ex + 1;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    ux |= sx;\n    return reinterpret<f32>(ux);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= -ex + 1;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= -ey + 1;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n\n/*\n\tPolyK library\n\turl: http://polyk.ivank.net\n\tReleased under MIT licence.\n\n\tCopyright (c) 2012 Ivan Kuckir\n\n\tPermission is hereby granted, free of charge, to any person\n\tobtaining a copy of this software and associated documentation\n\tfiles (the \"Software\"), to deal in the Software without\n\trestriction, including without limitation the rights to use,\n\tcopy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the\n\tSoftware is furnished to do so, subject to the following\n\tconditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\tOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\tNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\tHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\tFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\tOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/*\n\tIs Polygon self-intersecting?\n\n\tO(n^2)\n*/\n/*\nIsSimple(p)\n{\n\tlet n = p.length>>1;\n\tif(n<4) return true;\n\tlet a1 = new this._P(), a2 = new this._P();\n\tlet b1 = new this._P(), b2 = new this._P();\n\tlet c = new this._P();\n\n\tfor(let i: i32 = 0; i<n; i++)\n\t{\n\t\ta1.x = p[2*i  ];\n\t\ta1.y = p[2*i+1];\n\t\tif(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }\n\t\telse        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }\n\n\t\tfor(let j: i32 =0; j<n; j++)\n\t\t{\n\t\t\tif(Math.abs(i-j) < 2) continue;\n\t\t\tif(j==n-1 && i==0) continue;\n\t\t\tif(i==n-1 && j==0) continue;\n\n\t\t\tb1.x = p[2*j  ];\n\t\t\tb1.y = p[2*j+1];\n\t\t\tif(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }\n\t\t\telse        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }\n\n\t\t\tif(this._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nIsConvex(p)\n{\n\tif(p.length<6) return true;\n\tlet l = p.length - 4;\n\tfor(let i: i32 = 0; i<l; i+=2)\n\t\tif(!this._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;\n\tif(!this._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;\n\tif(!this._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;\n\treturn true;\n}\n*/\n\nexport function GetArea(p: Float32Array): f32\n{\n\tif(p.length <6) return 0;\n\tlet l = p.length - 2;\n\tlet sum = 0;\n\tfor(let i: i32 = 0; i<l; i+=2)\n\t\tsum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\n\tsum += (p[0]-p[l]) * (p[l+1]+p[1]);\n\treturn - sum * 0.5;\n}\n\n/*\nGetAABB(p)\n{\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet maxx = -minx;\n\tlet maxy = -miny;\n\tfor(let i: i32 = 0; i<p.length; i+=2)\n\t{\n\t\tminx = Math.min(minx, p[i  ]);\n\t\tmaxx = Math.max(maxx, p[i  ]);\n\t\tminy = Math.min(miny, p[i+1]);\n\t\tmaxy = Math.max(maxy, p[i+1]);\n\t}\n\treturn {x:minx, y:miny, width:maxx-minx, height:maxy-miny};\n}\n*/\n\nexport function Triangulate(p: Array<f32>): Array<u16>\n{\n\tlet n: u16 = (p.length>>1) as u16;\n\tif(n < 3) return [];\n\tlet tgs: u16[] = [];\n\tlet avl: u16[] = [];\n\tfor(let i:u16 = 0; i < n; i++) avl.push(i);\n\n\tlet i: u16 = 0;\n\tlet al: u16 = n;\n\twhile(al > 3)\n\t{\n\t\tlet i0: u16 = avl[(i+0)%al];\n\t\tlet i1: u16 = avl[(i+1)%al];\n\t\tlet i2: u16 = avl[(i+2)%al];\n\n\t\tlet ax = p[2*i0],  ay = p[2*i0+1];\n\t\tlet bx = p[2*i1],  by = p[2*i1+1];\n\t\tlet cx = p[2*i2],  cy = p[2*i2+1];\n\n\t\tlet earFound = false;\n\t\tif(_convex(ax, ay, bx, by, cx, cy))\n\t\t{\n\t\t\tearFound = true;\n\t\t\tfor(let j:u16=0; j<al; j++)\n\t\t\t{\n\t\t\t\tlet vi = avl[j];\n\t\t\t\tif(vi==i0 || vi==i1 || vi==i2) continue;\n\t\t\t\tif(_PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}\n\t\t\t}\n\t\t}\n\t\tif(earFound)\n\t\t{\n\t\t\ttgs.push(i0);\n\t\t\ttgs.push(i1);\n\t\t\ttgs.push(i2);\n\t\t\tavl.splice((i+1)%al, 1);\n\t\t\tal--;\n\t\t\ti= 0;\n\t\t}\n\t\telse if(i++ > 3*al) break;      // no convex angles :(\n\t}\n\ttgs.push(avl[0]);\n\ttgs.push(avl[1]);\n\ttgs.push(avl[2]);\n\treturn tgs;\n}\n/*\nContainsPoint(p, px, py)\n{\n\tlet n = p.length>>1;\n\tlet ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;\n\tlet depth = 0;\n\tfor(let i: i32 = 0; i<n; i++)\n\t{\n\t\tax = bx;  ay = by;\n\t\tbx = p[2*i  ] - px;\n\t\tby = p[2*i+1] - py;\n\t\tif(ay< 0 && by< 0) continue;    // both \"up\" or both \"donw\"\n\t\tif(ay>=0 && by>=0) continue;    // both \"up\" or both \"donw\"\n\t\tif(ax< 0 && bx< 0) continue;\n\n\t\tlet lx = ax + (bx-ax)*(-ay)/(by-ay);\n\t\tif(lx>0) depth++;\n\t}\n\treturn (depth & 1) == 1;\n}\n\nSlice(p, ax, ay, bx, by)\n{\n\tif(this.ContainsPoint(p, ax, ay) || this.ContainsPoint(p, bx, by)) return [p.slice(0)];\n\n\tlet a = new this._P(ax, ay);\n\tlet b = new this._P(bx, by);\n\tlet iscs = [];  // intersections\n\tlet ps = [];    // points\n\tfor(let i: i32 = 0; i<p.length; i+=2) ps.push(new this._P(p[i], p[i+1]));\n\n\tfor(let i: i32 = 0; i<ps.length; i++)\n\t{\n\t\tlet isc = new this._P(0,0);\n\t\tisc = this._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);\n\n\t\tif(isc)\n\t\t{\n\t\t\tisc.flag = true;\n\t\t\tiscs.push(isc);\n\t\t\tps.splice(i+1,0,isc);\n\t\t\ti++;\n\t\t}\n\t}\n\tif(iscs.length == 0) return [p.slice(0)];\n\tlet comp(u,v) {return this._P.dist(a,u) - this._P.dist(a,v); }\n\tiscs.sort(comp);\n\n\tlet pgs = [];\n\tlet dir = 0;\n\twhile(iscs.length > 0)\n\t{\n\t\tlet n = ps.length;\n\t\tlet i0 = iscs[0];\n\t\tlet i1 = iscs[1];\n\t\tlet ind0 = ps.indexOf(i0);\n\t\tlet ind1 = ps.indexOf(i1);\n\t\tlet solved = false;\n\n\t\tif(this._firstWithFlag(ps, ind0) == ind1) solved = true;\n\t\telse\n\t\t{\n\t\t\ti0 = iscs[1];\n\t\t\ti1 = iscs[0];\n\t\t\tind0 = ps.indexOf(i0);\n\t\t\tind1 = ps.indexOf(i1);\n\t\t\tif(this._firstWithFlag(ps, ind0) == ind1) solved = true;\n\t\t}\n\t\tif(solved)\n\t\t{\n\t\t\tdir--;\n\t\t\tlet pgn = this._getPoints(ps, ind0, ind1);\n\t\t\tpgs.push(pgn);\n\t\t\tps = this._getPoints(ps, ind1, ind0);\n\t\t\ti0.flag = i1.flag = false;\n\t\t\tiscs.splice(0,2);\n\t\t\tif(iscs.length == 0) pgs.push(ps);\n\t\t}\n\t\telse { dir++; iscs.reverse(); }\n\t\tif(dir>1) break;\n\t}\n\tlet result = [];\n\tfor(let i: i32 = 0; i<pgs.length; i++)\n\t{\n\t\tlet pg = pgs[i];\n\t\tlet npg = [];\n\t\tfor(let j: i32 =0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);\n\t\tresult.push(npg);\n\t}\n\treturn result;\n}\n\nRaycast(p, x, y, dx, dy, isc)\n{\n\tlet l = p.length - 2;\n\tlet tp = this._tp;\n\tlet a1 = tp[0], a2 = tp[1],\n\tb1 = tp[2], b2 = tp[3], c = tp[4];\n\ta1.x = x; a1.y = y;\n\ta2.x = x+dx; a2.y = y+dy;\n\n\tif(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};\n\tisc.dist = Infinity;\n\n\tfor(let i: i32 = 0; i<l; i+=2)\n\t{\n\t\tb1.x = p[i  ];  b1.y = p[i+1];\n\t\tb2.x = p[i+2];  b2.y = p[i+3];\n\t\tlet nisc = this._RayLineIntersection(a1, a2, b1, b2, c);\n\t\tif(nisc) this._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);\n\t}\n\tb1.x = b2.x;  b1.y = b2.y;\n\tb2.x = p[0];  b2.y = p[1];\n\tlet nisc = this._RayLineIntersection(a1, a2, b1, b2, c);\n\tif(nisc) this._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);\n\n\treturn (isc.dist != Infinity) ? isc : null;\n}\n\nClosestEdge(p, x, y, isc)\n{\n\tlet l = p.length - 2;\n\tlet tp = this._tp;\n\tlet a1 = tp[0],\n\tb1 = tp[2], b2 = tp[3], c = tp[4];\n\ta1.x = x; a1.y = y;\n\n\tif(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};\n\tisc.dist = Infinity;\n\n\tfor(let i: i32 = 0; i<l; i+=2)\n\t{\n\t\tb1.x = p[i  ];  b1.y = p[i+1];\n\t\tb2.x = p[i+2];  b2.y = p[i+3];\n\t\tthis._pointLineDist(a1, b1, b2, i>>1, isc);\n\t}\n\tb1.x = b2.x;  b1.y = b2.y;\n\tb2.x = p[0];  b2.y = p[1];\n\tthis._pointLineDist(a1, b1, b2, l>>1, isc);\n\n\tlet idst = 1/isc.dist;\n\tisc.norm.x = (x-isc.point.x)*idst;\n\tisc.norm.y = (y-isc.point.y)*idst;\n\treturn isc;\n}\n\n_pointLineDist(p, a, b, edge, isc)\n{\n\tlet x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;\n\n\tlet A = x - x1;\n\tlet B = y - y1;\n\tlet C = x2 - x1;\n\tlet D = y2 - y1;\n\n\tlet dot = A * C + B * D;\n\tlet len_sq = C * C + D * D;\n\tlet param = dot / len_sq;\n\n\tlet xx, yy;\n\n\tif (param < 0 || (x1 == x2 && y1 == y2)) {\n\t\txx = x1;\n\t\tyy = y1;\n\t}\n\telse if (param > 1) {\n\t\txx = x2;\n\t\tyy = y2;\n\t}\n\telse {\n\t\txx = x1 + param * C;\n\t\tyy = y1 + param * D;\n\t}\n\n\tlet dx = x - xx;\n\tlet dy = y - yy;\n\tlet dst = Math.sqrt(dx * dx + dy * dy);\n\tif(dst<isc.dist)\n\t{\n\t\tisc.dist = dst;\n\t\tisc.edge = edge;\n\t\tisc.point.x = xx;\n\t\tisc.point.y = yy;\n\t}\n}\n\n_updateISC(dx, dy, a1, b1, b2, c, edge, isc)\n{\n\tlet nrl = this._P.dist(a1, c);\n\tif(nrl<isc.dist)\n\t{\n\t\tlet ibl = 1/this._P.dist(b1, b2);\n\t\tlet nx = -(b2.y-b1.y)*ibl;\n\t\tlet ny =  (b2.x-b1.x)*ibl;\n\t\tlet ddot = 2*(dx*nx+dy*ny);\n\t\tisc.dist = nrl;\n\t\tisc.norm.x = nx;\n\t\tisc.norm.y = ny;\n\t\tisc.refl.x = -ddot*nx+dx;\n\t\tisc.refl.y = -ddot*ny+dy;\n\t\tisc.edge = edge;\n\t}\n}\n\n_getPoints(ps, ind0, ind1)\n{\n\tlet n = ps.length;\n\tlet nps = [];\n\tif(ind1<ind0) ind1 += n;\n\tfor(let i: i32 = ind0; i<= ind1; i++) nps.push(ps[i%n]);\n\treturn nps;\n}\n\n_firstWithFlag(ps, ind)\n{\n\tlet n = ps.length;\n\twhile(true)\n\t{\n\t\tind = (ind+1)%n;\n\t\tif(ps[ind].flag) return ind;\n\t}\n}\n*/\n\nfunction _PointInTriangle(px: f32, py: f32, ax: f32, ay: f32, bx: f32, by: f32, cx: f32, cy: f32): boolean\n{\n\tlet v0x:f32 = cx-ax;\n\tlet v0y:f32 = cy-ay;\n\tlet v1x:f32 = bx-ax;\n\tlet v1y:f32 = by-ay;\n\tlet v2x:f32 = px-ax;\n\tlet v2y:f32 = py-ay;\n\n\tlet dot00:f32 = v0x*v0x+v0y*v0y;\n\tlet dot01:f32 = v0x*v1x+v0y*v1y;\n\tlet dot02:f32 = v0x*v2x+v0y*v2y;\n\tlet dot11:f32 = v1x*v1x+v1y*v1y;\n\tlet dot12:f32 = v1x*v2x+v1y*v2y;\n\n\tlet invDenom:f32 = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\tlet u:f32 = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tlet v:f32 = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t// Check if point is in triangle\n\treturn (u >= 0) && (v >= 0) && (u + v < 1);\n}\n/*\n_RayLineIntersection(a1, a2, b1, b2, c)\n{\n\tlet dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n\tlet day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n\tlet Den = dax*dby - day*dbx;\n\tif (Den == 0) return null;  // parallel\n\n\tlet A = (a1.x * a2.y - a1.y * a2.x);\n\tlet B = (b1.x * b2.y - b1.y * b2.x);\n\n\tlet I = c;\n\tlet iDen = 1/Den;\n\tI.x = ( A*dbx - dax*B ) * iDen;\n\tI.y = ( A*dby - day*B ) * iDen;\n\n\tif(!this._InRect(I, b1, b2)) return null;\n\tif((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;\n\tif((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;\n\treturn I;\n}\n\n_GetLineIntersection(a1, a2, b1, b2, c)\n{\n\tlet dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n\tlet day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n\tlet Den = dax*dby - day*dbx;\n\tif (Den == 0) return null;  // parallel\n\n\tlet A = (a1.x * a2.y - a1.y * a2.x);\n\tlet B = (b1.x * b2.y - b1.y * b2.x);\n\n\tlet I = c;\n\tI.x = ( A*dbx - dax*B ) / Den;\n\tI.y = ( A*dby - day*B ) / Den;\n\n\tif(this._InRect(I, a1, a2) && this._InRect(I, b1, b2)) return I;\n\treturn null;\n}\n\n_InRect(a, b, c)\n{\n\tif  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));\n\tif  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));\n\n\tif(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)\n\t&& a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))\n\treturn true;\n\treturn false;\n}\n*/\nfunction _convex(ax: f32, ay: f32, bx: f32, by: f32, cx: f32, cy: f32): boolean\n{\n\treturn (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;\n}\n\n/*\n\t_P(x,y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.flag = false;\n\t}\n\t_P.prototype.toString()\n\t{\n\t\treturn \"Point [\"+this.x+\", \"+this.y+\"]\";\n\t}\n\t_P.dist(a,b)\n\t{\n\t\tlet dx = b.x-a.x;\n\t\tlet dy = b.y-a.y;\n\t\treturn Math.sqrt(dx*dx + dy*dy);\n\t}\n\n\t_tp = [];\n\tfor(let i: i32 = 0; i<10; i++) this._tp.push(new this._P(0,0));\n*/\n\n\n// var PolyK = new _PolyK();\n\n// export default PolyK;\n\n\n\n// import {Triangulate} from \"../math/polyk\";\n// import {GetArea} from \"../math/polyk\";","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"../objects/body\";\nimport Equation from \"../equations/equation\";\n\n\nexport class ConstraintOptions{\n\tcollideConnected: boolean = true;\n\twakeUpBodies: boolean = false;\n}\n\nexport default class Constraint{\n\t/**\n\t * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.\n\t * @property {number} type\n\t */\n\ttype: u16;\n\n\t/**\n\t * Equations to be solved in this constraint\n\t *\n\t * @property equations\n\t * @type {Array}\n\t */\n\tequations: Equation[];\n\n\t/**\n\t * First body participating in the constraint.\n\t * @property bodyA\n\t * @type {Body}\n\t */\n\tbodyA: Body;\n\n\t/**\n\t * Second body participating in the constraint.\n\t * @property bodyB\n\t * @type {Body}\n\t */\n\tbodyB: Body;\n\n\t/**\n\t * Set to true if you want the connected bodies to collide.\n\t * @property collideConnected\n\t * @type {boolean}\n\t * @default true\n\t */\n\tcollideConnected: boolean = true;\n\n\t/**\n\t * Base constraint class.\n\t *\n\t * @class Constraint\n\t * @constructor\n\t * @author schteppe\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Number} type\n\t * @param {Object} [options]\n\t * @param {Object} [options.collideConnected=true]\n\t */\n\tconstructor(bodyA: Body, bodyB: Body, type: u16, options: ConstraintOptions|null){\n\t\tthis.type = type;\n\t\tthis.equations = [];\n\t\tthis.bodyA = bodyA;\n\t\tthis.bodyB = bodyB;\n\n\t\tif(options){\n\t\t\tthis.collideConnected = options.collideConnected;\n\n\t\t\t// Wake up bodies when connected\n\t\t\tif(options.wakeUpBodies){\n\t\t\t\t//if(bodyA){\n\t\t\t\t\tbodyA.wakeUp();\n\t\t\t\t//}\n\t\t\t\t//if(bodyB){\n\t\t\t\t\tbodyB.wakeUp();\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates the internal constraint parameters before solve.\n\t * @method update\n\t */\n\tupdate(): void{\n\t\tthrow new Error(\"method update() not implmemented in this Constraint subclass!\");\n\t};\n\n\t/**\n\t * @static\n\t * @property {number} DISTANCE\n\t */\n\tstatic DISTANCE: u16 = 1;\n\n\t/**\n\t * @static\n\t * @property {number} GEAR\n\t */\n\tstatic GEAR: u16 = 2;\n\n\t/**\n\t * @static\n\t * @property {number} LOCK\n\t */\n\tstatic LOCK: u16 = 3;\n\n\t/**\n\t * @static\n\t * @property {number} PRISMATIC\n\t */\n\tstatic PRISMATIC: u16 = 4;\n\n\t/**\n\t * @static\n\t * @property {number} REVOLUTE\n\t */\n\tstatic REVOLUTE: u16 = 5;\n\n\t/**\n\t * Set stiffness for this constraint.\n\t * @method setStiffness\n\t * @param {Number} stiffness\n\t */\n\tsetStiffness(stiffness: f32): void{\n\t\tlet eqs: Equation[] = this.equations;\n\t\tfor(let i: u16 = 0; i < (eqs.length as u16); i++){\n\t\t\tlet eq = eqs[i];\n\t\t\teq.stiffness = stiffness;\n\t\t\teq.needsUpdate = true;\n\t\t}\n\t};\n\n\t/**\n\t * Set relaxation for this constraint.\n\t * @method setRelaxation\n\t * @param {Number} relaxation\n\t */\n\tsetRelaxation(relaxation: f32): void{\n\t\tlet eqs = this.equations;\n\t\tfor(let i: u16 = 0; i < (eqs.length as u16); i++){\n\t\t\tlet eq = eqs[i];\n\t\t\teq.relaxation = relaxation;\n\t\t\teq.needsUpdate = true;\n\t\t}\n\t};\n\n\t/**\n\t * @method setMaxBias\n\t * @param {Number} maxBias\n\t */\n\tsetMaxBias(maxBias: f32): void{\n\t\tlet eqs = this.equations;\n\t\tfor(let i: u16 = 0; i < (eqs.length as u16); i++){\n\t\t\tlet eq = eqs[i];\n\t\t\teq.maxBias = maxBias;\n\t\t}\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport GSSolver from  \"../solver/gs-solver\";\nimport vec2 from  \"../math/vec2\";\nimport Shape from  \"../shapes/shape\";\nimport EventEmitter from  \"../events/event-emitter\";\nimport { EventArgument } from  \"../events/event-emitter\";\nimport Body from  \"../objects/body\";\nimport Material from  \"../material/material\";\nimport ContactMaterial from  \"../material/contact-material\";\nimport AABB from  \"../collision/aabb\";\nimport SAPBroadphase from  \"../collision/sap-broadphase\";\nimport Narrowphase from  \"../collision/narrowphase\";\nimport Utils from  \"../utils/utils\";\n//import arrayRemove from  \"ayRemo\"; // Get rid of this dependency!\nimport OverlapKeeper from  \"../utils/overlap-keeper\";\nimport UnionFind from  \"./union-find\";\nimport Equation from \"../equations/equation\";\nimport Solver from \"../solver/solver\";\nimport Spring from \"../objects/spring\";\nimport Broadphase from \"../collision/broadphase\";\nimport Constraint from \"../constraints/constraint\";\nimport FrictionEquation from \"../equations/friction-equation\";\nimport ContactEquation from \"../equations/contact-equation\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport OverlapKeeperRecord from \"../utils/overlap-keeper-record\";\n\n//import f32 from \"f32\";\n\n/**\n * Fired after the step().\n * @event postStep\n */\nexport class PostStepEvent extends EventArgument {\n\tconstructor(){\n\t\tsuper(\"postStep\");\n\t}\n};\n\nvar postStepEvent:PostStepEvent = new PostStepEvent();\n\n/**\n * Fired when a body is added to the world.\n * @event addBody\n * @param {Body} body\n */\nexport class AddBodyEvent extends EventArgument{\n\tbody: Body|null = null;\n\tsapBroadphase : SAPBroadphase|null = null;\n\tconstructor(){\n\t\tsuper(\"addBody\");\n\t}\n}\n\n/**\n * Fired when a body is removed from the world.\n * @event removeBody\n * @param {Body} body\n */\nexport class RemoveBodyEvent extends EventArgument{\n\tbody : Body|null = null;\n\tsapBroadphase : SAPBroadphase|null = null;\n\tconstructor(){\n\t\tsuper(\"removeBody\");\n\t}\n}\n\n/**\n * Fired when a spring is added to the world.\n * @event addSpring\n * @param {Spring} spring\n */\nexport class AddSpringEvent extends EventArgument{\n\tspring: Spring|null = null;\n\n\tconstructor(){\n\t\tsuper(\"addSpring\");\n\t}\n}\nvar addSpringEvent = new AddSpringEvent();\n\n/**\n * Fired when a first contact is created between two bodies. This event is fired after the step has been done.\n * @event impact\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @deprecated Impact event will be removed. Use beginContact instead.\n */\nexport class ImpactEvent extends EventArgument{\n\tbodyA: Body|null = null;\n\tbodyB: Body|null = null;\n\tshapeA: Shape|null = null;\n\tshapeB: Shape|null = null;\n\tcontactEquation: ContactEquation|null = null;\n\n\tconstructor(){\n\t\tsuper(\"impact\");\n\t}\n}\nvar impactEvent = new ImpactEvent();\n\n\n/**\n * Fired after the Broadphase has collected collision pairs in the world.\n * Inside the event handler, you can modify the pairs array as you like, to\n * prevent collisions between objects that you don't want.\n * @event postBroadphase\n * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.\n */\nexport class PostBroadphaseEvent extends EventArgument{\n\tpairs: Body[]|null = null;\n\tconstructor(){\n\t\tsuper(\"postBroadphase\");\n\t}\n}\nvar postBroadphaseEvent = new PostBroadphaseEvent;\n\n\nexport class BeginContactEvent extends EventArgument{\n\tshapeA: Shape|null = null;\n\tshapeB: Shape|null = null;\n\tbodyA: Body|null = null;\n\tbodyB: Body|null = null;\n\tcontactEquations: ContactEquation[] = [];\n\n\tconstructor(){\n\t\tsuper(\"beginContact\");\n\t}\n}\n\n/**\n * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.\n * @event beginContact\n * @param {Shape} shapeA\n * @param {Shape} shapeB\n * @param {Body}  bodyA\n * @param {Body}  bodyB\n * @param {Array} contactEquations\n */\nvar beginContactEvent = new BeginContactEvent();\n\n/**\n * Fired when two shapes stop overlapping, after the narrowphase (during step).\n * @event endContact\n * @param {Shape} shapeA\n * @param {Shape} shapeB\n * @param {Body}  bodyA\n * @param {Body}  bodyB\n */\nexport class EndContactEvent extends EventArgument {\n\tshapeA: Shape|null = null;\n\tshapeB: Shape|null = null;\n\tbodyA: Body|null = null;\n\tbodyB: Body|null = null;\n\n\tconstructor(){\n\t\tsuper(\"endContact\");\n\t}\n};\n\nvar endContactEvent = new EndContactEvent();\n\nvar hitTest_tmp1 = vec2.create(),\n\thitTest_tmp2 = vec2.create();\n\n/**\n * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.\n * @event preSolve\n * @param {Array} contactEquations  An array of contacts to be solved.\n * @param {Array} frictionEquations An array of friction equations to be solved.\n */\nexport class PreSolveEvent extends EventArgument{\n\tcontactEquations: ContactEquation[]|null = null;\n\tfrictionEquations: FrictionEquation[]|null = null;\n\n\tconstructor(){\n\t\tsuper(\"preSolve\");\n\t}\n}\nvar preSolveEvent = new PreSolveEvent();\n\nfunction sortBodiesByIsland(a: Body,b: Body): i32{\n\treturn a.islandId - b.islandId;\n}\n\nfunction sortEquationsByIsland(equationA: Equation, equationB: Equation): i32{\n\tif(!equationA.bodyA || !equationA.bodyB || !equationB.bodyA || !equationB.bodyB) return 0;\n\n\tlet islandA: i32 = equationA.bodyA!.islandId > 0 ? equationA.bodyA!.islandId : equationA.bodyB!.islandId;\n\tlet islandB: i32 = equationB.bodyA!.islandId > 0 ? equationB.bodyA!.islandId : equationB.bodyB!.islandId;\n\n\tif(islandA !== islandB){\n\t\treturn islandA - islandB;\n\t} else {\n\t\t// Sort by equation type if same island\n\t\treturn equationA.index - equationB.index;\n\t}\n}\n\n// Why not just make this a private method in world?\n// What are all these props???\nfunction runNarrowphase(world: World, np: Narrowphase, bi: Body, si: Shape, xi: Float32Array, ai: f32, bj: Body, sj: Shape, xj: Float32Array, aj: f32, cm: ContactMaterial, glen: f32): void{\n\n\tlet xiw = vec2.create();\n\tlet xjw = vec2.create();\n\n\t// Check collision groups and masks\n\tif(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){\n\t\treturn;\n\t}\n\n\t// Get world position and angle of each shape\n\tvec2.toGlobalFrame(xiw, xi, bi.position, bi.angle);\n\tvec2.toGlobalFrame(xjw, xj, bj.position, bj.angle);\n\n\tif(vec2.distance(xiw,xjw) > si.boundingRadius + sj.boundingRadius){\n\t\treturn;\n\t}\n\n\tlet aiw = ai + bi.angle;\n\tlet ajw = aj + bj.angle;\n\n\tnp.enableFriction = cm.friction > 0;\n\tlet reducedMass: f32;\n\tif(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){\n\t\treducedMass = bj.mass;\n\t} else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){\n\t\treducedMass = bi.mass;\n\t} else {\n\t\treducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);\n\t}\n\tnp.slipForce = cm.friction*glen*reducedMass;\n\tnp.currentContactMaterial = cm;\n\tnp.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n\tlet sensor = si.sensor || sj.sensor;\n\tlet numFrictionBefore = np.frictionEquations.length;\n\n\tlet numContacts = np.testContact(bi, si, xiw, bj, sj, xjw, sensor);\n\t\n\tlet numFrictionEquations: i32 = np.frictionEquations.length - numFrictionBefore;\n\n\tif(numContacts){\n\n\t\tif( bi.allowSleep &&\n\t\t\tbi.type === Body.DYNAMIC &&\n\t\t\tbi.sleepState  === Body.SLEEPING &&\n\t\t\tbj.sleepState  === Body.AWAKE &&\n\t\t\tbj.type !== Body.STATIC\n\t\t){\n\t\t\tlet speedSquaredB = vec2.squaredLength(bj.velocity) + Mathf.pow(bj.angularVelocity,2);\n\t\t\tlet speedLimitSquaredB = Mathf.pow(bj.sleepSpeedLimit,2);\n\t\t\tif(speedSquaredB >= speedLimitSquaredB*2){\n\t\t\t\tbi._wakeUpAfterNarrowphase = true;\n\t\t\t}\n\t\t}\n\n\t\tif( bj.allowSleep &&\n\t\t\tbj.type === Body.DYNAMIC &&\n\t\t\tbj.sleepState  === Body.SLEEPING &&\n\t\t\tbi.sleepState  === Body.AWAKE &&\n\t\t\tbi.type !== Body.STATIC\n\t\t){\n\t\t\tlet speedSquaredA = vec2.squaredLength(bi.velocity) + Mathf.pow(bi.angularVelocity,2);\n\t\t\tlet speedLimitSquaredA = Mathf.pow(bi.sleepSpeedLimit,2);\n\t\t\tif(speedSquaredA >= speedLimitSquaredA*2){\n\t\t\t\tbj._wakeUpAfterNarrowphase = true;\n\t\t\t}\n\t\t}\n\n\t\tworld.overlapKeeper.setOverlapping(bi, si, bj, sj);\n\t\tif(world.has('beginContact', null) && world.overlapKeeper.isNewOverlap(si, sj)){\n\n\t\t\t// Report new shape overlap\n\t\t\tlet e = beginContactEvent;\n\t\t\te.shapeA = si;\n\t\t\te.shapeB = sj;\n\t\t\te.bodyA = bi;\n\t\t\te.bodyB = bj;\n\n\t\t\t// Reset contact equations\n\t\t\te.contactEquations.length = 0;\n\n\t\t\tif(!sensor){\n\t\t\t\tfor(let i: i32 = np.contactEquations.length - numContacts; i<np.contactEquations.length; i++){\n\t\t\t\t\te.contactEquations.push(np.contactEquations[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworld.emit(e);\n\t\t}\n\n\t\t// divide the max friction force by the number of contacts\n\t\tif(!sensor && numFrictionEquations > 1){ // Why divide by 1?\n\t\t\tfor(let i: i32 = np.frictionEquations.length - numFrictionEquations; i<np.frictionEquations.length; i++){\n\t\t\t\tlet f = np.frictionEquations[i];\n\t\t\t\tf.setSlipForce(f.getSlipForce() / (numFrictionEquations as f32));\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction setGlobalEquationParams(world: World, relaxation: f32, stiffness: f32): void {\n\tlet constraints = world.constraints;\n\tfor(let i: i32 = 0; i < constraints.length; i++){\n\t\tlet c = constraints[i];\n\t\tlet eqs = c.equations;\n\t\tfor(let j: i32 = 0; j < eqs.length; j++){\n\t\t\tlet eq = eqs[j];\n\t\t\teq.relaxation = relaxation != -1 ? relaxation : eq.relaxation;\n\t\t\teq.stiffness = stiffness != -1 ? stiffness : eq.stiffness;\n\t\t\teq.needsUpdate = true;\n\t\t}\n\t}\n}\n\nexport class WorldOptions{\n\tgravity: Float32Array|null = null;\n\tislandSplit: boolean = true;\n}\n\nexport default class World extends EventEmitter{\n\n\t/**\n\t * All springs in the world. To add a spring to the world, use {{#crossLink \"World/addSpring:method\"}}{{/crossLink}}.\n\t *\n\t * @property springs\n\t * @type {Array}\n\t */\n\tsprings: Spring[] = [];\n\n\t/**\n\t * All bodies in the world. To add a body to the world, use {{#crossLink \"World/addBody:method\"}}{{/crossLink}}.\n\t * @property {Array} bodies\n\t */\n\tbodies: Body[] = [];\n\n\t/**\n\t * Disabled body collision pairs. See {{#crossLink \"World/disableBodyCollision:method\"}}.\n\t * @private\n\t * @property {Array} disabledBodyCollisionPairs\n\t */\n\tdisabledBodyCollisionPairs: Array<Body> = [];\n\n\t/**\n\t * The solver used to satisfy constraints and contacts. Default is {{#crossLink \"GSSolver\"}}{{/crossLink}}.\n\t * @property {Solver} solver\n\t */\n\tsolver: Solver = new GSSolver(null);\n\n\t/**\n\t * The narrowphase to use to generate contacts.\n\t *\n\t * @property narrowphase\n\t * @type {Narrowphase}\n\t */\n\tnarrowphase: Narrowphase = new Narrowphase();\n\n\t/**\n\t * Gravity in the world. This is applied on all bodies in the beginning of each step().\n\t *\n\t * @property gravity\n\t * @type {Array}\n\t */\n\tgravity: Float32Array = vec2.fromValues(0, -9.78);\n\n\t/**\n\t * Gravity to use when approximating the friction max force (mu*mass*gravity).\n\t * @property {Number} frictionGravity\n\t */\n\tfrictionGravity: f32 = 10;\n\n\t/**\n\t * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.\n\t * @property {boolean} useWorldGravityAsFrictionGravity\n\t * @default true\n\t */\n\tuseWorldGravityAsFrictionGravity: boolean = true;\n\n\t/**\n\t * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.\n\t * @property {boolean} useFrictionGravityOnZeroGravity\n\t * @default true\n\t */\n\tuseFrictionGravityOnZeroGravity: boolean = true;\n\n\t/**\n\t * The broadphase algorithm to use.\n\t *\n\t * @property broadphase\n\t * @type {Broadphase}\n\t */\n\tbroadphase: Broadphase = new SAPBroadphase();\n\n\t/**\n\t * User-added constraints.\n\t *\n\t * @property constraints\n\t * @type {Array}\n\t */\n\tconstraints: Constraint[] = [];\n\n\t/**\n\t * Dummy default material in the world, used in .defaultContactMaterial\n\t * @property {Material} defaultMaterial\n\t */\n\tdefaultMaterial: Material = new Material();\n\n\t/**\n\t * The default contact material to use, if no contact material was set for the colliding materials.\n\t * @property {ContactMaterial} defaultContactMaterial\n\t */\n\tdefaultContactMaterial: ContactMaterial|null = null;\n\n\t/**\n\t * For keeping track of what time step size we used last step\n\t * @property lastTimeStep\n\t * @type {Number}\n\t */\n\tlastTimeStep: f32 = 1/60;\n\n\t/**\n\t * Enable to automatically apply spring forces each step.\n\t * @property applySpringForces\n\t * @type {boolean}\n\t * @default true\n\t */\n\tapplySpringForces: boolean = true;\n\n\t/**\n\t * Enable to automatically apply body damping each step.\n\t * @property applyDamping\n\t * @type {boolean}\n\t * @default true\n\t */\n\tapplyDamping: boolean = true;\n\n\t/**\n\t * Enable to automatically apply gravity each step.\n\t * @property applyGravity\n\t * @type {boolean}\n\t * @default true\n\t */\n\tapplyGravity: boolean = true;\n\n\t/**\n\t * Enable/disable constraint solving in each step.\n\t * @property solveConstraints\n\t * @type {boolean}\n\t * @default true\n\t */\n\tsolveConstraints: boolean = true;\n\n\t/**\n\t * The ContactMaterials added to the World.\n\t * @property contactMaterials\n\t * @type {Array}\n\t */\n\tcontactMaterials: Array<ContactMaterial> = [];\n\n\t/**\n\t * World time.\n\t * @property time\n\t * @type {Number}\n\t */\n\ttime: f32 = 0.0;\n\n\taccumulator: f32 = 0;\n\n\t/**\n\t * Is true during step().\n\t * @property {boolean} stepping\n\t */\n\tstepping: boolean = false;\n\n\t/**\n\t * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance.\n\t * @property {boolean} islandSplit\n\t * @default false\n\t */\n\tislandSplit: boolean = true;\n\n\t/**\n\t * Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n\t * @property emitImpactEvent\n\t * @type {boolean}\n\t * @default true\n\t * @deprecated Impact event will be removed. Use beginContact instead.\n\t */\n\temitImpactEvent: boolean = true;\n\n\t/**\n\t * How to deactivate bodies during simulation. Possible modes are: {{#crossLink \"World/NO_SLEEPING:property\"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink \"World/BODY_SLEEPING:property\"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink \"World/ISLAND_SLEEPING:property\"}}World.ISLAND_SLEEPING{{/crossLink}}.\n\t * If sleeping is enabled, you might need to {{#crossLink \"Body/wakeUp:method\"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink \"Body/allowSleep:property\"}}Body.allowSleep{{/crossLink}}.\n\t * @property sleepMode\n\t * @type {number}\n\t * @default World.NO_SLEEPING\n\t */\n\tsleepMode: u16 = World.NO_SLEEPING;\n\n\t/**\n\t * @property {UnionFind} unionFind\n\t */\n\tunionFind: UnionFind = new UnionFind(1);\n\n\t// Id counters\n\tprivate _constraintIdCounter: u32 = 0;\n\tprivate _bodyIdCounter: u32 = 0;\n\n\t/**\n\t * @property {OverlapKeeper} overlapKeeper\n\t */\n\toverlapKeeper: OverlapKeeper = new OverlapKeeper();\n\n\t// Special non-static events.\n\taddBodyEvent: AddBodyEvent = new AddBodyEvent();\n\tremoveBodyEvent: RemoveBodyEvent = new RemoveBodyEvent();\n\n\t/**\n\t * The dynamics world, where all bodies and constraints live.\n\t *\n\t * @class World\n\t * @constructor\n\t * @param {Object} [options]\n\t * @param {Solver} [options.solver] Defaults to GSSolver.\n\t * @param {Array} [options.gravity] Defaults to y=-9.78.\n\t * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase\n\t * @param {boolean} [options.islandSplit=true]\n\t * @extends EventEmitter\n\t *\n\t * @example\n\t *     let world = new World({\n\t *         gravity: [0, -10],\n\t *         broadphase: new SAPBroadphase()\n\t *     });\n\t *     world.addBody(new Body());\n\t */\n\tconstructor(options: WorldOptions){\n\t\tsuper();\n\n\t\tif(options){\n\t\t\tif(options.gravity) vec2.copy(this.gravity, options.gravity!);\n\t\t\tthis.islandSplit = options.islandSplit;\n\t\t}\n\t\n\t\tthis.frictionGravity = vec2.length(this.gravity) || 10;\n\t\tthis.broadphase.setWorld(this);\n\t\tthis.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, null);\n\n\t\tthis.addBodyEvent.sapBroadphase = this.broadphase as SAPBroadphase;\n\t\tthis.removeBodyEvent.sapBroadphase = this.broadphase as SAPBroadphase;\n\t}\n\n\t/**\n\t * Never deactivate bodies.\n\t * @static\n\t * @property {number} NO_SLEEPING\n\t */\n\tstatic NO_SLEEPING: u16 = 1;\n\n\t/**\n\t * Deactivate individual bodies if they are sleepy.\n\t * @static\n\t * @property {number} BODY_SLEEPING\n\t */\n\tstatic BODY_SLEEPING: u16 = 2;\n\n\t/**\n\t * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink \"World/islandSplit:property\"}}.islandSplit{{/crossLink}} for this to work.\n\t * @static\n\t * @property {number} ISLAND_SLEEPING\n\t */\n\tstatic ISLAND_SLEEPING: u16 = 4;\n\n\t/**\n\t * Add a constraint to the simulation. Note that both bodies connected to the constraint must be added to the world first. Also note that you can't run this method during step.\n\t *\n\t * @method addConstraint\n\t * @param {Constraint} constraint\n\t * @example\n\t *     let constraint = new LockConstraint(bodyA, bodyB);\n\t *     world.addConstraint(constraint);\n\t */\n\taddConstraint(constraint: Constraint): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Constraints cannot be added during step.');\n\t\t}\n\n\t\tlet bodies = this.bodies;\n\t\tif(bodies.indexOf(constraint.bodyA) === -1){\n\t\t\tthrow new Error('Cannot add Constraint: bodyA is not added to the World.');\n\t\t}\n\t\tif(bodies.indexOf(constraint.bodyB) === -1){\n\t\t\tthrow new Error('Cannot add Constraint: bodyB is not added to the World.');\n\t\t}\n\n\t\tthis.constraints.push(constraint);\n\t}\n\n\t/**\n\t * Add a ContactMaterial to the simulation.\n\t * @method addContactMaterial\n\t * @param {ContactMaterial} contactMaterial\n\t */\n\taddContactMaterial(contactMaterial: ContactMaterial): void{\n\t\tthis.contactMaterials.push(contactMaterial);\n\t}\n\n\t/**\n\t * Removes a contact material\n\t *\n\t * @method removeContactMaterial\n\t * @param {ContactMaterial} cm\n\t */\n\tremoveContactMaterial(cm: ContactMaterial): void{\n\t\tUtils.arrayRemove(this.contactMaterials, cm);\n\t}\n\n\t/**\n\t * Get a contact material given two materials\n\t * @method getContactMaterial\n\t * @param {Material} materialA\n\t * @param {Material} materialB\n\t * @return {ContactMaterial} The matching ContactMaterial, or false on fail.\n\t * @todo Use faster hash map to lookup from material id's\n\t */\n\tgetContactMaterial(materialA: Material,materialB: Material): ContactMaterial | null{\n\t\tlet cmats = this.contactMaterials;\n\t\tfor(let i: i32 = 0, N: i32 = cmats.length; i< N; i++){\n\t\t\tlet cm = cmats[i];\n\t\t\tif((cm.materialA === materialA && cm.materialB === materialB) || (cm.materialA === materialB && cm.materialB === materialA)){\n\t\t\t\treturn cm;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes a constraint. Note that you can't run this method during step.\n\t *\n\t * @method removeConstraint\n\t * @param {Constraint} constraint\n\t */\n\tremoveConstraint(constraint: Constraint): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Constraints cannot be removed during step.');\n\t\t}\n\t\tUtils.arrayRemove(this.constraints, constraint);\n\t}\n\n\t/**\n\t * Step the physics world forward in time.\n\t *\n\t * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n\t *\n\t * @method step\n\t * @param {Number} dt                       The fixed time step size to use.\n\t * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.\n\t * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n\t *\n\t * @example\n\t *     // Simple fixed timestepping without interpolation\n\t *     let fixedTimeStep = 1 / 60;\n\t *     let world = new World();\n\t *     let body = new Body({ mass: 1 });\n\t *     world.addBody(body);\n\t *\n\t *     function animate(){\n\t *         requestAnimationFrame(animate);\n\t *         world.step(fixedTimeStep);\n\t *         renderBody(body.position, body.angle);\n\t *     }\n\t *\n\t *     // Start animation loop\n\t *     requestAnimationFrame(animate);\n\t *\n\t * @example\n\t *     // Fixed timestepping with interpolation\n\t *     let maxSubSteps = 10;\n\t *     let lastTimeSeconds;\n\t *\n\t *     function animate(time){\n\t *         requestAnimationFrame(animate);\n\t *         let timeSeconds = time / 1000;\n\t *\n\t *         if(lastTimeSeconds){\n\t *             let deltaTime = timeSeconds - lastTimeSeconds;\n\t *             world.step(fixedTimeStep, deltaTime, maxSubSteps);\n\t *         }\n\t *\n\t *         lastTimeSeconds = timeSeconds;\n\t *\n\t *         renderBody(body.interpolatedPosition, body.interpolatedAngle);\n\t *     }\n\t *\n\t *     // Start animation loop\n\t *     requestAnimationFrame(animate);\n\t *\n\t * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n\t */\n\tstep(dt: f32,timeSinceLastCalled: f32, maxSubSteps: u16): void {\n\t\tmaxSubSteps = maxSubSteps || 10;\n\t\ttimeSinceLastCalled = timeSinceLastCalled || 0;\n\n\t\tif(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n\t\t\tthis.internalStep(dt);\n\n\t\t\t// Increment time\n\t\t\tthis.time += dt;\n\n\t\t} else {\n\n\t\t\tthis.accumulator += timeSinceLastCalled;\n\t\t\tlet substeps: u16 = 0;\n\t\t\twhile (this.accumulator >= dt && substeps < maxSubSteps) {\n\t\t\t\t// Do fixed steps to catch up\n\t\t\t\tthis.internalStep(dt);\n\t\t\t\tthis.time += dt;\n\t\t\t\tthis.accumulator -= dt;\n\t\t\t\tsubsteps++;\n\t\t\t}\n\n\t\t\tlet t = (this.accumulator % dt) / dt;\n\t\t\tfor(let j: i32 = 0; j < this.bodies.length; j++){\n\t\t\t\tlet b = this.bodies[j];\n\t\t\t\tvec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);\n\t\t\t\tb.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Make a fixed step.\n\t * @method internalStep\n\t * @param  {number} dt\n\t * @private\n\t */\n\tinternalStep(dt: f32): void{\n\n\t\tlet step_mg = vec2.create();\n\n\t\tlet endOverlaps: OverlapKeeperRecord[] = [];\n\n\t\tthis.stepping = true;\n\n\t\tlet Nsprings: u16 = this.springs.length as u16,\n\t\t\tsprings: Spring[] = this.springs,\n\t\t\tbodies: Body[] = this.bodies,\n\t\t\tg: Float32Array = this.gravity,\n\t\t\tsolver: Solver = this.solver,\n\t\t\tNbodies: u16 = this.bodies.length as u16,\n\t\t\tbroadphase: Broadphase = this.broadphase,\n\t\t\tnp: Narrowphase = this.narrowphase,\n\t\t\tconstraints: Constraint[] = this.constraints,\n\t\t\tmg: Float32Array = step_mg;\n\n\t\tthis.overlapKeeper.tick();\n\n\t\tthis.lastTimeStep = dt;\n\n\t\t// Update approximate friction gravity.\n\t\tif(this.useWorldGravityAsFrictionGravity){\n\t\t\tlet gravityLen = vec2.length(this.gravity);\n\t\t\tif(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){\n\t\t\t\t// Nonzero gravity. Use it.\n\t\t\t\tthis.frictionGravity = gravityLen;\n\t\t\t}\n\t\t}\n\n\t\t// Add gravity to bodies\n\t\tif(this.applyGravity){\n\t\t\tfor(let i: u16 = 0; i < Nbodies; i++){\n\t\t\t\tlet b = bodies[i],\n\t\t\t\t\tfi = b.force;\n\t\t\t\tif(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvec2.scale(mg, g, b.mass * b.gravityScale); // F=m*g\n\t\t\t\tvec2.add(fi,fi,mg);\n\t\t\t}\n\t\t}\n\n\t\t// Add spring forces\n\t\tif(this.applySpringForces){\n\t\t\tfor(let i: u16 = 0; i < Nsprings; i++){\n\t\t\t\tlet s = springs[i];\n\t\t\t\ts.applyForce();\n\t\t\t}\n\t\t}\n\n\t\tif(this.applyDamping){\n\t\t\tfor(let i: u16 = 0; i < Nbodies; i++){\n\t\t\t\tlet b = bodies[i];\n\t\t\t\tif(b.type === Body.DYNAMIC){\n\t\t\t\t\tb.applyDamping(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Broadphase\n\t\tlet result: Body[] = broadphase.getCollisionPairs();\n\n\t\t// Remove ignored collision pairs\n\t\tlet ignoredPairs = this.disabledBodyCollisionPairs;\n\t\tfor(let i: i32 = ignoredPairs.length - 2; i >=0; i -= 2){\n\t\t\tfor(let j: i32 = result.length - 2; j >= 0; j -= 2){\n\t\t\t\tif( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||\n\t\t\t\t\t(ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){\n\t\t\t\t\tresult.splice(j,2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove constrained pairs with collideConnected == false\n\t\tlet Nconstraints = constraints.length;\n\t\tfor(let i: u16 = 0; i!==Nconstraints; i++){\n\t\t\tlet c = constraints[i];\n\t\t\tif(!c.collideConnected){\n\t\t\t\tfor(let j: i32 = result.length - 2; j >= 0; j -= 2){\n\t\t\t\t\tif( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||\n\t\t\t\t\t\t(c.bodyB === result[j] && c.bodyA === result[j+1])){\n\t\t\t\t\t\tresult.splice(j,2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// postBroadphase event\n\t\tpostBroadphaseEvent.pairs = result;\n\t\tthis.emit(postBroadphaseEvent);\n\t\tpostBroadphaseEvent.pairs = null;\n\n\t\t// Narrowphase\n\t\tnp.reset();\n\t\tlet defaultContactMaterial = this.defaultContactMaterial!;\n\t\tlet frictionGravity = this.frictionGravity;\n\t\tfor(let i: u16 = 0, Nresults = (result.length as u16); i !== Nresults; i+=2){\n\t\t\tlet bi = result[i],\n\t\t\t\tbj = result[i+1];\n\n\t\t\t// Loop over all shapes of body i\n\t\t\tfor(let k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){\n\t\t\t\tlet si = bi.shapes[k],\n\t\t\t\t\txi = si.position,\n\t\t\t\t\tai = si.angle;\n\n\t\t\t\t// All shapes of body j\n\t\t\t\tfor(let l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){\n\t\t\t\t\tlet sj = bj.shapes[l],\n\t\t\t\t\t\txj = sj.position,\n\t\t\t\t\t\taj = sj.angle;\n\n\t\t\t\t\tlet contactMaterial: ContactMaterial | null = null;\n\t\t\t\t\tif(si.material && sj.material){\n\t\t\t\t\t\tcontactMaterial = this.getContactMaterial(si.material!, sj.material!);\n\t\t\t\t\t}\n\n\t\t\t\t\trunNarrowphase(this,np,bi,si,xi,ai,bj,sj,xj,aj,(contactMaterial || defaultContactMaterial)!, frictionGravity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Wake up bodies\n\t\tfor(let i: u16 = 0; i < Nbodies; i++){\n\t\t\tlet body = bodies[i];\n\t\t\tif(body._wakeUpAfterNarrowphase){\n\t\t\t\tbody.wakeUp();\n\t\t\t\tbody._wakeUpAfterNarrowphase = false;\n\t\t\t}\n\t\t}\n\n\t\t// Emit end overlap events\n\t\tif(super.has(\"endContact\", null)){\n\t\t\tthis.overlapKeeper.getEndOverlaps(endOverlaps);\n\t\t\tlet e = endContactEvent;\n\t\t\tlet l = endOverlaps.length;\n\t\t\twhile(l--){\n\t\t\t\tlet data = endOverlaps[l];\n\t\t\t\te.shapeA = data.shapeA;\n\t\t\t\te.shapeB = data.shapeB;\n\t\t\t\te.bodyA = data.bodyA;\n\t\t\t\te.bodyB = data.bodyB;\n\t\t\t\tthis.emit(e);\n\t\t\t}\n\t\t\tendOverlaps.length = 0;\n\t\t}\n\n\t\tpreSolveEvent.contactEquations = np.contactEquations;\n\t\tpreSolveEvent.frictionEquations = np.frictionEquations;\n\t\tthis.emit(preSolveEvent);\n\t\tpreSolveEvent.contactEquations = null;\n\t\tpreSolveEvent.frictionEquations = null;\n\n\t\t// update constraint equations\n\t\tNconstraints = constraints.length;\n\n\t\tfor(let i: i32 = 0; i < Nconstraints; i++){\n\t\t\tconstraints[i].update();\n\t\t}\n\n\t\tif(np.contactEquations.length || np.frictionEquations.length || Nconstraints){\n\n\t\t\t// Get all equations\n\t\t\tlet equations: Equation[] = [];\n\n\t\t\tfor (let i: i32 = 0, len = np.contactEquations.length; i < len; i++) {\n\t\t\t\tequations.push(np.contactEquations[i]);\n\t\t\t}\n\t\t\tfor (let i: i32 = 0, len = np.frictionEquations.length; i < len; i++) {\n\t\t\t\tequations.push(np.frictionEquations[i]);\n\t\t\t}\n\n\t\t\tfor(let i: i32 = 0; i < Nconstraints; i++){\n\t\t\t\tlet a = constraints[i].equations;\n\t\t\t\tfor (let j: i32 = 0, len = a.length; j < len; j++) {\n\t\t\t\t\tequations.push(a[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.islandSplit){\n\n\t\t\t\t// Initialize the UnionFind\n\t\t\t\tlet unionFind = this.unionFind;\n\t\t\t\tunionFind.resize(this.bodies.length + 1);\n\n\t\t\t\t// Update equation index\n\t\t\t\tfor(let i: u16 = 0; i < (equations.length as u16); i++){\n\t\t\t\t\tequations[i].index = i;\n\t\t\t\t}\n\n\t\t\t\t// Unite bodies if they are connected by an equation\n\t\t\t\tfor(let i: u16 = 0; i < (equations.length as u16); i++){\n\t\t\t\t\tlet bodyA = equations[i].bodyA;\n\t\t\t\t\tlet bodyB = equations[i].bodyB;\n\t\t\t\t\tif(!bodyA || !bodyB) continue;\n\t\t\t\t\tif(bodyA.type === Body.DYNAMIC && bodyB.type === Body.DYNAMIC){\n\t\t\t\t\t\tunionFind.union(bodyA.index, bodyB.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Find the body islands\n\t\t\t\tfor(let i: u16 = 0; i < (bodies.length as u16); i++){\n\t\t\t\t\tlet body = bodies[i];\n\t\t\t\t\tbody.islandId = body.type == Body.DYNAMIC ? unionFind.find(body.index) : -1;\n\t\t\t\t}\n\n\t\t\t\t// Sort equations by island\n\t\t\t\tequations = equations.sort(sortEquationsByIsland);\n\n\t\t\t\tlet equationIndex = 0;\n\t\t\t\twhile(equationIndex < equations.length){\n\t\t\t\t\tlet equation = equations[equationIndex++];\n\t\t\t\t\tsolver.addEquation(equation);\n\t\t\t\t\tif(!equation.bodyA || !equation.bodyB) continue;\n\t\t\t\t\tlet currentIslandId: i32 = equation.bodyA!.islandId > 0 ? equation.bodyA!.islandId : equation.bodyB!.islandId;\n\t\t\t\t\tlet nextIslandId: i32 = -1;\n\n\t\t\t\t\tnextIslandId = equation.bodyA!.islandId > 0 ? equation.bodyA!.islandId : equation.bodyB!.islandId;\n\t\t\t\t\tif(nextIslandId < 0) nextIslandId = 0;\n\n\t\t\t\t\tif(nextIslandId !== currentIslandId || equationIndex === equations.length){\n\t\t\t\t\t\t// Solve this island\n\t\t\t\t\t\tif(this.solveConstraints){\n\t\t\t\t\t\t\tsolver.solve(dt,this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsolver.removeAllEquations();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Solve all as one island\n\t\t\t\tsolver.addEquations(equations);\n\t\t\t\tif(this.solveConstraints){\n\t\t\t\t\tsolver.solve(dt,this);\n\t\t\t\t}\n\t\t\t\tsolver.removeAllEquations();\n\n\t\t\t}\n\t\t}\n\n\t\t// Step forward\n\t\tfor(let i: u16 =0; i < Nbodies; i++){\n\t\t\tlet body = bodies[i];\n\t\t\tif(body.type === Body.DYNAMIC || body.type === Body.KINEMATIC){\n\t\t\t\tbody.integrate(dt);\n\t\t\t}\n\t\t}\n\n\t\t// Reset force\n\t\tfor(let i: u16 =0; i < Nbodies; i++){\n\t\t\tbodies[i].setZeroForce();\n\t\t}\n\n\t\t// Emit impact event\n\t\tif(this.emitImpactEvent && this.has(\"impact\", null)){\n\t\t\tlet ev = impactEvent;\n\t\t\tfor(let i: u16 = 0; i < (np.contactEquations.length as u16); i++){\n\t\t\t\tlet eq = np.contactEquations[i];\n\t\t\t\tif(eq.firstImpact){\n\t\t\t\t\tev.bodyA = eq.bodyA;\n\t\t\t\t\tev.bodyB = eq.bodyB;\n\t\t\t\t\tev.shapeA = eq.shapeA;\n\t\t\t\t\tev.shapeB = eq.shapeB;\n\t\t\t\t\tev.contactEquation = eq;\n\t\t\t\t\tthis.emit(ev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Sleeping update\n\t\tif(this.sleepMode === World.BODY_SLEEPING){\n\n\t\t\tfor(let i: u16 = 0; i < Nbodies; i++){\n\t\t\t\tbodies[i].sleepTick(this.time, false, dt);\n\t\t\t}\n\n\t\t} else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){\n\n\t\t\t// Tell all bodies to sleep tick but dont sleep yet\n\t\t\tfor(let i: u16 = 0; i < Nbodies; i++){\n\t\t\t\tbodies[i].sleepTick(this.time, true, dt);\n\t\t\t}\n\n\t\t\t// Sleep islands\n\t\t\tlet bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);\n\t\t\tlet islandEnd: i32 = 1;\n\t\t\tfor(let islandStart: i32 = 0; islandStart < bodiesSortedByIsland.length; islandStart = islandEnd){\n\t\t\t\tlet islandId = bodiesSortedByIsland[islandStart].islandId;\n\n\t\t\t\t// Get islandEnd index\n\t\t\t\t/* jshint ignore:start */\n\t\t\t\tfor(islandEnd = islandStart+1; islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++){}\n\t\t\t\t/* jshint ignore:end */\n\n\t\t\t\t// Don't check static objects\n\t\t\t\tif(islandId === -1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet islandShouldSleep = true;\n\t\t\t\tfor(let i: i32 = islandStart; i<islandEnd; i++){\n\t\t\t\t\tif(!bodiesSortedByIsland[i].wantsToSleep){\n\t\t\t\t\t\tislandShouldSleep = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(islandShouldSleep){\n\t\t\t\t\tfor(let i: i32 = islandStart; i<islandEnd; i++){\n\t\t\t\t\t\tbodiesSortedByIsland[i].sleep();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.stepping = false;\n\n\t\tsuper.emit(postStepEvent);\n\t}\n\n\t/**\n\t * Add a spring to the simulation. Note that this operation can't be done during step.\n\t *\n\t * @method addSpring\n\t * @param {Spring} spring\n\t */\n\taddSpring(spring: Spring): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Springs cannot be added during step.');\n\t\t}\n\t\tthis.springs.push(spring);\n\t\taddSpringEvent.spring = spring;\n\t\tthis.emit(addSpringEvent);\n\t\taddSpringEvent.spring = null;\n\t}\n\n\t/**\n\t * Remove a spring. Note that this operation can't be done during step.\n\t *\n\t * @method removeSpring\n\t * @param {Spring} spring\n\t */\n\tremoveSpring(spring: Spring): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Springs cannot be removed during step.');\n\t\t}\n\t\tUtils.arrayRemove(this.springs, spring);\n\t}\n\n\t/**\n\t * Add a body to the simulation. Note that you can't add a body during step: you have to wait until after the step (see the postStep event).\n\t * Also note that bodies can only be added to one World at a time.\n\t *\n\t * @method addBody\n\t * @param {Body} body\n\t *\n\t * @example\n\t *     let world = new World(),\n\t *         body = new Body();\n\t *     world.addBody(body);\n\t */\n\taddBody(body: Body): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Bodies cannot be added during step.');\n\t\t}\n\n\t\t// Already added?\n\t\tif(body.world){\n\t\t\tthrow new Error('Body is already added to a World.');\n\t\t}\n\n\t\tbody.index = this.bodies.length;\n\t\tthis.bodies.push(body);\n\t\tbody.world = this;\n\n\t\tthis.addBodyEvent.body = body;\n\t\tthis.emit(this.addBodyEvent);\n\t\tthis.addBodyEvent.body = null;\n\t}\n\n\t/**\n\t * Remove a body from the simulation. Note that bodies cannot be removed during step (for example, inside the beginContact event). In that case you need to wait until the step is done (see the postStep event).\n\t *\n\t * Also note that any constraints connected to the body must be removed before the body.\n\t *\n\t * @method removeBody\n\t * @param {Body} body\n\t *\n\t * @example\n\t *     let removeBody;\n\t *     world.on(\"beginContact\",function(event){\n\t *         // We cannot remove the body here since the world is still stepping.\n\t *         // Instead, schedule the body to be removed after the step is done.\n\t *         removeBody = body;\n\t *     });\n\t *     world.on(\"postStep\",function(event){\n\t *         if(removeBody){\n\t *             // Safely remove the body from the world.\n\t *             world.removeBody(removeBody);\n\t *             removeBody = null;\n\t *         }\n\t *     });\n\t */\n\tremoveBody(body: Body): void{\n\t\tif(this.stepping){\n\t\t\tthrow new Error('Bodies cannot be removed during step.');\n\t\t}\n\n\t\t// TODO: would it be smart to have a .constraints array on the body?\n\t\tlet constraints = this.constraints;\n\t\tlet l: i32 = constraints.length;\n\t\twhile (l--) {\n\t\t\tif(constraints[l].bodyA === body || constraints[l].bodyB === body){\n\t\t\t\tthrow new Error('Cannot remove Body from World: it still has constraints connected to it.');\n\t\t\t}\n\t\t}\n\n\t\tbody.world = null;\n\t\tlet bodies = this.bodies;\n\t\tUtils.arrayRemove(bodies, body);\n\t\tbody.index = -1;\n\t\tl = bodies.length;\n\t\twhile (l--) {\n\t\t\tbodies[l].index = l;\n\t\t}\n\n\t\t// Emit removeBody event\n\t\tthis.removeBodyEvent.body = body;\n\t\tbody.resetConstraintVelocity();\n\t\tthis.emit(this.removeBodyEvent);\n\t\tthis.removeBodyEvent.body = null;\n\n\t\t// Remove disabled body collision pairs that involve body\n\t\tlet pairs = this.disabledBodyCollisionPairs;\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tif (pairs[i] === body || pairs[i + 1] === body) {\n\t\t\t\tpairs.splice(i, 2);\n\t\t\t} else {\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get a body by its id.\n\t * @method getBodyById\n\t * @param {number} id\n\t * @return {Body} The body, or false if it was not found.\n\t */\n\tgetBodyById(id: u16): Body|null{\n\t\tlet bodies = this.bodies;\n\t\tfor(let i: i32 = 0; i<bodies.length; i++){\n\t\t\tlet b = bodies[i];\n\t\t\tif(b.id === id){\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Disable collision between two bodies\n\t * @method disableBodyCollision\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t */\n\tdisableBodyCollision(bodyA: Body, bodyB: Body): void{\n\t\tthis.disabledBodyCollisionPairs.push(bodyA);\n\t\tthis.disabledBodyCollisionPairs.push(bodyB);\n\t}\n\n\t/**\n\t * Enable collisions between the given two bodies, if they were previously disabled using .disableBodyCollision().\n\t * @method enableBodyCollision\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t */\n\tenableBodyCollision(bodyA: Body,bodyB: Body): void{\n\t\tlet pairs = this.disabledBodyCollisionPairs;\n\t\tfor(let i: i32 = 0; i<pairs.length; i+=2){\n\t\t\tif((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){\n\t\t\t\tpairs.splice(i,2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes all bodies, constraints, springs, and contact materials from the world.\n\t * @method clear\n\t */\n\tclear(): void\n\t{\n\n\t\t// Remove all solver equations\n\t\tthis.solver.removeAllEquations();\n\n\t\t// Remove all constraints\n\t\tlet cs = this.constraints;\n\t\tlet i = cs.length;\n\t\twhile(i--){\n\t\t\tthis.removeConstraint(cs[i]);\n\t\t}\n\n\t\t// Remove all bodies\n\t\tlet bodies = this.bodies;\n\t\ti = bodies.length;\n\t\twhile(i--){\n\t\t\tthis.removeBody(bodies[i]);\n\t\t}\n\n\t\t// Remove all springs\n\t\tlet springs = this.springs;\n\t\ti = springs.length;\n\t\twhile(i--){\n\t\t\tthis.removeSpring(springs[i]);\n\t\t}\n\n\t\t// Remove all contact materials\n\t\tlet cms = this.contactMaterials;\n\t\ti = cms.length;\n\t\twhile(i--){\n\t\t\tthis.removeContactMaterial(cms[i]);\n\t\t}\n\t}\n\n\n\t/**\n\t * Test if a world point overlaps bodies\n\t * @method hitTest\n\t * @param  {Array} worldPoint Point to use for intersection tests\n\t * @param  {Array} bodies A list of objects to check for intersection\n\t * @param  {Number} precision Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n\t * @return {Array} Array of bodies that overlap the point\n\t * @todo Should use an api similar to the raycast function\n\t * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient\n\t * @todo Should use the broadphase\n\t * @todo Returning the hit shape would be fine - it carries a reference to the body now\n\t */\n\thitTest(worldPoint: Float32Array, bodies: Body[], precision: f32): Body[]{\n\n\t\tprecision = precision || 0;\n\n\t\t// Create a dummy particle body with a particle shape to test against the bodies\n\t\tlet shapeWorldPosition = hitTest_tmp1,\n\t\t\tshapeLocalPoint = hitTest_tmp2;\n\n\t\tlet result: Body[] = [];\n\n\t\t// Check bodies\n\t\tfor(let i: i32 = 0, N = bodies.length; i!==N; i++){\n\t\t\tlet body = bodies[i];\n\n\t\t\tfor(let j: i32 = 0, NS = body.shapes.length; j!==NS; j++){\n\t\t\t\tlet shape = body.shapes[j];\n\n\t\t\t\t// Get local point position in the shape\n\t\t\t\tshape.worldPointToLocal(shapeLocalPoint, worldPoint);\n\n\t\t\t\tif(shape.pointTest(shapeLocalPoint)){\n\t\t\t\t\tresult.push(body);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Get shape world position\n\t\t\t\t\tvec2.rotate(shapeWorldPosition, shape.position, body.angle);\n\t\t\t\t\tvec2.add(shapeWorldPosition, shapeWorldPosition, body.position);\n\n\t\t\t\t\tif(shape.type === Shape.PARTICLE && vec2.squaredDistance(shapeWorldPosition, worldPoint) < precision * precision){\n\t\t\t\t\t\tresult.push(body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Set the stiffness for all equations and contact materials.\n\t * @method setGlobalStiffness\n\t * @param {Number} stiffness\n\t */\n\tsetGlobalStiffness(stiffness: f32): void{\n\t\tsetGlobalEquationParams(this, -1, stiffness);\n\n\t\t// Set for all contact materials\n\t\tlet contactMaterials = this.contactMaterials;\n\t\tfor(let i: i32 = 0; i !== contactMaterials.length; i++){\n\t\t\tlet c = contactMaterials[i];\n\t\t\tc.stiffness = c.frictionStiffness = stiffness;\n\t\t}\n\n\t\t// Set for default contact material\n\t\tlet c = this.defaultContactMaterial!;\n\t\tc.stiffness = c.frictionStiffness = stiffness;\n\t}\n\n\t/**\n\t * Set the relaxation for all equations and contact materials.\n\t * @method setGlobalRelaxation\n\t * @param {Number} relaxation\n\t */\n\tsetGlobalRelaxation(relaxation: f32): void{\n\t\tsetGlobalEquationParams(this, relaxation, -1);\n\n\t\t// Set for all contact materials\n\t\tfor(let i: i32 = 0; i !== this.contactMaterials.length; i++){\n\t\t\tlet c = this.contactMaterials[i];\n\t\t\tc.relaxation = c.frictionRelaxation = relaxation;\n\t\t}\n\n\t\t// Set for default contact material\n\t\tlet c = this.defaultContactMaterial!;\n\t\tc.relaxation = c.frictionRelaxation = relaxation;\n\t}\n\n\t/**\n\t * Ray cast against all bodies in the world.\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @return {boolean} True if any body was hit.\n\t *\n\t * @example\n\t *     let ray = new Ray({\n\t *         mode: Ray.CLOSEST, // or ANY\n\t *         from: [0, 0],\n\t *         to: [10, 0],\n\t *     });\n\t *     let result = new RaycastResult();\n\t *     world.raycast(result, ray);\n\t *\n\t *     // Get the hit point\n\t *     let hitPoint = vec2.create();\n\t *     result.getHitPoint(hitPoint, ray);\n\t *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n\t *\n\t * @example\n\t *     let ray = new Ray({\n\t *         mode: Ray.ALL,\n\t *         from: [0, 0],\n\t *         to: [10, 0],\n\t *         callback: function(result){\n\t *\n\t *             // Print some info about the hit\n\t *             console.log('Hit body and shape: ', result.body, result.shape);\n\t *\n\t *             // Get the hit point\n\t *             let hitPoint = vec2.create();\n\t *             result.getHitPoint(hitPoint, ray);\n\t *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n\t *\n\t *             // If you are happy with the hits you got this far, you can stop the traversal here:\n\t *             result.stop();\n\t *         }\n\t *     });\n\t *     let result = new RaycastResult();\n\t *     world.raycast(result, ray);\n\t */\n\traycast(result: RaycastResult, ray: Ray): boolean{\n\n\t\tlet tmpAABB:AABB = new AABB(null, null);\n\t\tlet tmpArray:Body[] = [];\n\n\t\t// Get all bodies within the ray AABB\n\t\tray.getAABB(tmpAABB);\n\t\tthis.broadphase.aabbQuery(tmpAABB, tmpArray);\n\t\tray.intersectBodies(result, tmpArray);\n\t\ttmpArray.length = 0;\n\n\t\treturn result.hasHit();\n\t}\n}\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n\nexport class EventArgument{\n\ttype:string = \"\";\n\ttarget:EventEmitter|null = null;\n\n\tconstructor(type: string){\n\t\tthis.type = type;\n\t}\n}\n\n/**\n * Base class for Objects that dispatches events.\n * @class EventEmitter\n * @example\n *     var emitter = new EventEmitter();\n *     emitter.on('myEvent', function(evt){\n *         console.log(evt.message);\n *     });\n *     emitter.emit({\n *         type: 'myEvent',\n *         message: 'Hello world!'\n *     });\n */\nexport default class EventEmitter{\n\n\t//private _listeners: Map<string, Function[]> = new Map<string, Function[]>();\n\tprivate _listeners: Map<string, Array<(event:EventArgument)=>void>> = new Map<string, Array<(event:EventArgument)=>void>>();\n\tprivate _contexts: Map<string, Object[]> = new Map<string, Object[]>();\n\n\tconstructor(){}\n\n\t/**\n\t * Add an event listener\n\t * @method on\n\t * @param  {String} type\n\t * @param  {Function} listener\n\t * @return {EventEmitter} The self Object, for chainability.\n\t * @example\n\t *     emitter.on('myEvent', function(evt){\n\t *         console.log('myEvt was triggered!');\n\t *     });\n\t */\n\ton ( type: string, listener: (event:EventArgument)=>void, context: Object ): EventEmitter {\n\t\t\n\t\tif ( !this._listeners.has( type )) {\n\t\t\tthis._listeners.set( type , []);\n\t\t\tthis._contexts.set( type , []);\n\t\t}\n\t\tlet listeners = this._listeners.get( type );\n\t\tif ( listeners.indexOf( listener ) === -1 ) {\n\t\t\tlet contexts = this._contexts.get( type );\n\t\t\tlisteners.push( listener );\n\t\t\tcontexts.push( context );\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event listener\n\t * @method off\n\t * @param  {String} type\n\t * @param  {Function} listener\n\t * @return {EventEmitter} The self Object, for chainability.\n\t * @example\n\t *     emitter.on('myEvent', handler); // Add handler\n\t *     emitter.off('myEvent', handler); // Remove handler\n\t */\n\toff ( type: string, listener: (event:EventArgument)=>void ): EventEmitter {\n\t\tif(!this._listeners.has(type)){\n\t\t\treturn this;\n\t\t}\n\t\tlet listeners:Array<(event:EventArgument)=>void> = this._listeners.get(type);\n\t\tlet index = listeners.indexOf( listener );\n\t\tif ( index !== - 1 ) {\n\t\t\tlet contexts: Object[] = this._contexts.get(type);\n\t\t\tlisteners.splice( index, 1 );\n\t\t\tcontexts.splice( index, 1 );\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Check if an event listener is added\n\t * @method has\n\t * @param  {String} type\n\t * @param  {Function} listener\n\t * @return {boolean}\n\t */\n\thas ( type: string, listener: ((event:EventArgument)=>void)|null): boolean {\n\n\t\tif(listener){\n\t\t\tif ( this._listeners.has( type ) && this._listeners.get( type ).indexOf( listener ) !== - 1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!this._listeners.has( type )) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Emit an event.\n\t * @method emit\n\t * @param  {Object} event\n\t * @param  {String} event.type\n\t * @return {EventEmitter} The self Object, for chainability.\n\t * @example\n\t *     emitter.emit({\n\t *         type: 'myEvent',\n\t *         customData: 123\n\t *     });\n\t */\n\temit ( event: EventArgument ): EventEmitter {\n\t\t//let listenerArray: ((event:EventArgument)=>void)[] = this._listeners.get( event.type );\n\t\tlet listenerArray = this._listeners.get( event.type );\n\t\tlet contextArray: Object[] = this._contexts.get( event.type );\n\t\t\tevent.target = this;\n\n\t\t// Need to copy the listener array, in case some listener was added/removed inside a listener\n\t\tlet tmpListenerArray: Array<(event:EventArgument)=>void> = [];\n\t\tlet tmpContextArray: Object[] = [];\n\t\tfor (let i: u16 = 0, l = listenerArray.length as u16; i < l; i++) {\n\t\t\ttmpListenerArray.push(listenerArray[i]);\n\t\t\ttmpContextArray.push(contextArray[i]);\n\t\t}\n\t\tfor (let i: u16 = 0, l = listenerArray.length as u16; i < l; i++) {\n\t\t\tlet listener: (event:EventArgument)=>void = listenerArray[ i ];\n\t\t\tlet context: Object = contextArray[ i ];\n\t\t\t// listener.call( context, event );\n\t\t\t// callListener( context, listener, event );\n\t\t\tlistener(event);\n\t\t}\n\t\t\t\n\t\treturn this;\n\t}\n}\n\n// function callListener(context: Object, listener: (event:EventArgument)=>void, event: EventArgument):void{\n// \tlistener.call( context, event );\n// }","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\n\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nimport {Triangulate} from \"../math/polyk\";\n\nvar updateCenterOfMass_centroid = vec2.create(),\n\tupdateCenterOfMass_centroid_times_mass = vec2.create(),\n\tupdateCenterOfMass_a = vec2.create(),\n\tupdateCenterOfMass_b = vec2.create(),\n\tupdateCenterOfMass_c = vec2.create();\n\nvar tmpVec1 = vec2.create();\n\nvar intersectConvex_rayStart = vec2.create();\nvar intersectConvex_rayEnd = vec2.create();\nvar intersectConvex_normal = vec2.create();\n\nvar pic_r0 = vec2.create();\nvar pic_r1 = vec2.create();\n\nvar tmpVec2 = vec2.create();\nvar worldAxis = tmpVec2;\n\nexport class ConvexOptions extends ShapeOptions{}\n\nexport default class Convex extends Shape {\n\n\t// TODO: this would be more efficient if I didn't use float32array[]s. Just convert to a big float32array with double the size.\n\t// Let's get this working first then switch it.\n\t\n\t/**\n\t * Vertices defined in the local frame.\n\t * @property vertices\n\t * @type {Array}\n\t */\n\tpublic vertices: Float32Array[] = [];\n\n\t/**\n\t * Edge normals defined in the local frame, pointing out of the shape.\n\t * @property normals\n\t * @type {Array}\n\t */\n\tpublic normals: Float32Array[] = [];\n\n\t/**\n\t * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n\t * @property triangles\n\t * @type {Array}\n\t */\n\tpublic triangles: Uint16Array[] = [];\n\n\t/**\n\t * The center of mass of the Convex\n\t * @property centerOfMass\n\t * @type {Array}\n\t */\n\tpublic centerOfMass: Float32Array = vec2.create();\n\n\t/**\n\t * Convex shape class.\n\t * @class Convex\n\t * @constructor\n\t * @extends Shape\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];\n\t *     let convexShape = new Convex({\n\t *         vertices: vertices\n\t *     });\n\t *     body.addShape(convexShape);\n\t */\n\tconstructor(type: u16, vertices: Array<Float32Array>|null, options: ShapeOptions|null){\n\t\tsuper(type || Shape.CONVEX, options); \n\n\t\t// Copy the verts\n\t\tlet newVertices: Array<Float32Array>;\n\t\tif(vertices != null) newVertices = vertices;\n\t\telse newVertices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tfor(let i: i32 = 0; i < newVertices.length; i++){\n\t\t\tthis.vertices.push(vec2.clone(newVertices[i]));\n\t\t\tthis.normals.push(vec2.create());\n\t\t}\n\n\t\t// These are called in the shape constructor, but need to call again here because verts weren't set up yet!\n\t\tthis.updateBoundingRadius();\n\t\tthis.updateArea();\n\n\t\tthis.updateNormals();\n\n\t\tthis.triangles = [];\n\n\t\tif(this.vertices.length){\n\t\t\tthis.updateTriangles();\n\t\t\tthis.updateCenterOfMass();\n\t\t}\n\n\t\t/**\n\t\t * The bounding radius of the convex\n\t\t * @property boundingRadius\n\t\t * @type {Number}\n\t\t */\n\t\tthis.boundingRadius = 0;\n\n\t\tthis.updateBoundingRadius();\n\t\tthis.updateArea();\n\t\tif(this.area < 0){\n\t\t\tthrow new Error(\"Convex vertices must be given in counter-clockwise winding.\");\n\t\t}\n\t}\n\n\t\n\tupdateNormals(): void{\n\t\tlet vertices = this.vertices;\n\t\tlet normals = this.normals;\n\n\t\tfor(let i: i32 = 0; i < vertices.length; i++){\n\t\t\tlet worldPoint0 = vertices[i];\n\t\t\tlet worldPoint1 = vertices[(i+1) % vertices.length];\n\n\t\t\tlet normal = normals[i];\n\t\t\tvec2.subtract(normal, worldPoint1, worldPoint0);\n\n\t\t\t// Get normal - just rotate 90 degrees since vertices are given in CCW\n\t\t\tvec2.rotate90cw(normal, normal);\n\t\t\tvec2.normalize(normal, normal);\n\t\t}\n\t}\n\n\t/**\n\t * Project a Convex onto a world-oriented axis\n\t * @method projectOntoAxis\n\t * @static\n\t * @param  {Array} offset\n\t * @param  {Array} localAxis\n\t * @param  {Array} result\n\t */\n\tprojectOntoLocalAxis(localAxis: Float32Array, result: Float32Array): void{\n\n\t\tlet max: f32 = -Infinity,\n\t\t\tmin: f32 = Infinity,\n\t\t\tv: Float32Array|null,\n\t\t\tvalue: f32 = 0;\n\t\t//localAxis = tmpVec1; // TODO: this makes no sense. However, it comes from source: https://github.com/schteppe/p2.js/blob/master/src/shapes/Convex.js#L122\n\n\t\t// Get projected position of all vertices\n\t\tfor(let i: u16 = 0; i < (this.vertices.length as u16); i++){\n\t\t\tv = this.vertices[i];\n\t\t\tvalue = vec2.dot(v, localAxis);\n\t\t\tif(value > max){\n\t\t\t\tmax = value;\n\t\t\t}\n\t\t\tif(value < min){\n\t\t\t\tmin = value;\n\t\t\t}\n\t\t}\n\n\t\tif(min > max){\n\t\t\tlet t = min;\n\t\t\tmin = max;\n\t\t\tmax = t;\n\t\t}\n\n\t\tvec2.set(result, min, max);\n\t}\n\n\tConvexprojectOntoWorldAxis(localAxis: Float32Array, shapeOffset: Float32Array, shapeAngle: f32, result: Float32Array): void{\n\n\t\tthis.projectOntoLocalAxis(localAxis, result);\n\n\t\t// Project the position of the body onto the axis - need to add this to the result\n\t\tif(shapeAngle !== 0){\n\t\t\tvec2.rotate(worldAxis, localAxis, shapeAngle);\n\t\t} else {\n\t\t\tworldAxis = localAxis;\n\t\t}\n\t\tlet offset = vec2.dot(shapeOffset, worldAxis);\n\n\t\tvec2.set(result, result[0] + offset, result[1] + offset);\n\t}\n\n\n\t/**\n\t * Update the .triangles property\n\t * @method updateTriangles\n\t */\n\tupdateTriangles(): void{\n\n\t\tthis.triangles.length = 0;\n\n\t\t// Rewrite on polyk notation, array of numbers\n\t\tlet polykVerts:f32[] = [];\n\t\tfor(let i:u16=0; i < (this.vertices.length as u16); i++){\n\t\t\tlet v = this.vertices[i];\n\t\t\tpolykVerts.push(v[0]);\n\t\t\tpolykVerts.push(v[1]);\n\t\t}\n\n\t\t// Triangulate\n\t\tlet triangles = Triangulate(polykVerts);\n\n\t\t// Loop over all triangles, add their inertia contributions to I\n\t\tfor(let i:u16=0; i < (triangles.length as u16); i+=3){\n\t\t\tlet id1:u16 = triangles[i] as u16,\n\t\t\t\tid2:u16 = triangles[i+1] as u16,\n\t\t\t\tid3:u16 = triangles[i+2] as u16;\n\n\t\t\t// Add to triangles\n\t\t\tlet T = new Uint16Array(3);\n\t\t\tT[0] = id1;\n\t\t\tT[1] = id2;\n\t\t\tT[2] = id3;\n\t\t\tthis.triangles.push(T);\n\t\t}\n\t}\n\n\t/**\n\t * Update the .centerOfMass property.\n\t * @method updateCenterOfMass\n\t */\n\tupdateCenterOfMass(): void{\n\n\n\t\tlet triangles = this.triangles,\n\t\t\t\tverts = this.vertices,\n\t\t\t\tcm = this.centerOfMass,\n\t\t\t\tcentroid = updateCenterOfMass_centroid,\n\t\t\t\ta = updateCenterOfMass_a,\n\t\t\t\tb = updateCenterOfMass_b,\n\t\t\t\tc = updateCenterOfMass_c,\n\t\t\t\tcentroid_times_mass = updateCenterOfMass_centroid_times_mass;\n\n\t\tvec2.set(cm,0,0);\n\t\tlet totalArea: f32 = 0;\n\n\t\tfor(let i: u16 = 0; i < (triangles.length as u16); i++){\n\t\t\tlet t = triangles[i],\n\t\t\t\tva = verts[t[0]],\n\t\t\t\tvb = verts[t[1]],\n\t\t\t\tvc = verts[t[2]];\n\n\t\t\tvec2.centroid(centroid,va,vb,vc);\n\n\t\t\t// Get mass for the triangle (density=1 in this case)\n\t\t\t// http://Mathf.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n\t\t\tlet m = Convex.triangleArea(va,vb,vc);\n\t\t\ttotalArea += m;\n\n\t\t\t// Add to center of mass\n\t\t\tvec2.scale(centroid_times_mass, centroid, m);\n\t\t\tvec2.add(cm, cm, centroid_times_mass);\n\t\t}\n\n\t\tvec2.scale(cm,cm,1/totalArea);\n\t}\n\n\t/**\n\t * Compute the moment of inertia of the Convex.\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\tlet denom: f32 = 0.0,\n\t\t\tnumer: f32 = 0.0,\n\t\t\tN: i32 = this.vertices.length;\n\t\tfor(let j: i32 = N-1, i = 0; i < N; j = i, i ++){\n\t\t\tlet p0 = this.vertices[j];\n\t\t\tlet p1 = this.vertices[i];\n\t\t\tlet a = Mathf.abs(vec2.crossLength(p0,p1));\n\t\t\tlet b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);\n\t\t\tdenom += a * b;\n\t\t\tnumer += a;\n\t\t}\n\t\treturn (1.0 / 6.0) * (denom / numer);\n\t}\n\n\t/**\n\t * Updates the .boundingRadius property\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tlet verts = this.vertices,\n\t\t\tr2: f32 = 0;\n\t\tif(!verts || verts.length == 0) return 0;\n\t\tfor(let i:u16 = 0; i!==verts.length; i++){\n\t\t\tlet l2: f32 = vec2.squaredLength(verts[i]);\n\t\t\tif(l2 > r2){\n\t\t\t\tr2 = l2;\n\t\t\t}\n\t\t}\n\n\t\tthis.boundingRadius = Mathf.sqrt(r2);\n\t\t\n\t\treturn this.boundingRadius;\n\t}\n\n\t/**\n\t * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.\n\t * @static\n\t * @method triangleArea\n\t * @param {Array} a\n\t * @param {Array} b\n\t * @param {Array} c\n\t * @return {Number}\n\t * @deprecated\n\t */\n\tstatic triangleArea(a: Float32Array, b: Float32Array, c: Float32Array): f32{\n\t\treturn (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;\n\t}\n\n\t/**\n\t * Update the .area\n\t * @method updateArea\n\t */\n\tupdateArea(): f32{\n\t\tif(!this.vertices) return 0;\n\t\tthis.updateTriangles();\n\t\tthis.area = 0;\n\n\t\tlet triangles = this.triangles,\n\t\t\tverts = this.vertices;\n\t\tfor(let i: i32 = 0; i!==triangles.length; i++){\n\t\t\tlet t = triangles[i],\n\t\t\t\ta = verts[t[0]],\n\t\t\t\tb = verts[t[1]],\n\t\t\t\tc = verts[t[2]];\n\n\t\t\t// Get mass for the triangle (density=1 in this case)\n\t\t\tlet m = Convex.triangleArea(a,b,c);\n\t\t\tthis.area += m;\n\t\t}\n\n\t\treturn this.area;\n\t}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t * @todo: approximate with a local AABB?\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tout.setFromPoints(this.vertices, position, angle, 0);\n\t}\n\n\n\t/**\n\t * @method raycast\n\t * @param  {RaycastResult} result\n\t * @param  {Ray} ray\n\t * @param  {array} position\n\t * @param  {number} angle\n\t */\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32): void{\n\t\tlet rayStart = intersectConvex_rayStart;\n\t\tlet rayEnd = intersectConvex_rayEnd;\n\t\tlet normal = intersectConvex_normal;\n\t\tlet vertices = this.vertices;\n\n\t\t// Transform to local shape space\n\t\tvec2.toLocalFrame(rayStart, ray.from, position, angle);\n\t\tvec2.toLocalFrame(rayEnd, ray.to, position, angle);\n\n\t\tlet n = vertices.length;\n\n\t\tfor (let i = 0; i < n && !result.shouldStop(ray); i++) {\n\t\t\tlet q1 = vertices[i];\n\t\t\tlet q2 = vertices[(i+1) % n];\n\t\t\tlet delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);\n\n\t\t\tif(delta >= 0){\n\t\t\t\tvec2.subtract(normal, q2, q1);\n\t\t\t\tvec2.rotate(normal, normal, -Mathf.PI / 2 + angle);\n\t\t\t\tvec2.normalize(normal, normal);\n\t\t\t\tray.reportIntersection(result, delta, normal, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpointTest(localPoint: Float32Array): boolean{\n\n\t\tlet r0: Float32Array = pic_r0,\n\t\t\tr1: Float32Array = pic_r1,\n\t\t\tverts: Float32Array[] = this.vertices,\n\t\t\tlastCross: f32 = -1,\n\t\t\tnumVerts: u16 = verts.length as u16;\n\n\t\tfor(let i: u16 = 0; i < numVerts + 1; i++){\n\t\t\tlet v0 = verts[i % numVerts],\n\t\t\t\tv1 = verts[(i + 1) % numVerts];\n\n\t\t\tvec2.subtract(r0, v0, localPoint);\n\t\t\tvec2.subtract(r1, v1, localPoint);\n\n\t\t\tlet cross: f32 = vec2.crossLength(r0,r1);\n\n\t\t\tif(lastCross === -1){\n\t\t\t\tlastCross = cross;\n\t\t\t}\n\n\t\t\t// If we got a different sign of the distance vector, the point is out of the polygon\n\t\t\tif(cross * lastCross < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlastCross = cross;\n\t\t}\n\t\treturn true;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\r\n\r\n\r\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\r\nfunction lineInt(l1: Array<Float32Array>,l2: Array<Float32Array>,precision: f32 = 0): Float32Array{\r\n    let i = new Float32Array(2); // point\r\n    let a1: f32, b1: f32, c1: f32, a2: f32, b2: f32, c2: f32, det: f32; // scalars\r\n    a1 = l1[1][1] - l1[0][1];\r\n    b1 = l1[0][0] - l1[1][0];\r\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\r\n    a2 = l2[1][1] - l2[0][1];\r\n    b2 = l2[0][0] - l2[1][0];\r\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\r\n    det = a1 * b2 - a2*b1;\r\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\r\n        i[0] = (b2 * c1 - b1 * c2) / det;\r\n        i[1] = (a1 * c2 - a2 * c1) / det;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {boolean} True if the two line segments intersect\r\n */\r\nfunction lineSegmentsIntersect(p1: Float32Array, p2: Float32Array, q1: Float32Array, q2: Float32Array): boolean{\r\n\tlet dx = p2[0] - p1[0];\r\n\tlet dy = p2[1] - p1[1];\r\n\tlet da = q2[0] - q1[0];\r\n\tlet db = q2[1] - q1[1];\r\n\r\n\t// segments are parallel\r\n\tif((da*dy - db*dx) === 0){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tlet s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\r\n\tlet t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\r\n\r\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\r\n}\r\n\r\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\r\nfunction triangleArea(a: Float32Array, b: Float32Array, c: Float32Array): f32{\r\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\r\n}\r\n\r\nfunction isLeft(a: Float32Array,b:Float32Array,c:Float32Array): boolean{\r\n    return triangleArea(a,b,c) > 0;\r\n}\r\n\r\nfunction isLeftOn(a:Float32Array,b:Float32Array,c:Float32Array): boolean {\r\n    return triangleArea(a, b, c) >= 0;\r\n}\r\n\r\nfunction isRight(a:Float32Array,b:Float32Array,c:Float32Array): boolean {\r\n    return triangleArea(a, b, c) < 0;\r\n}\r\n\r\nfunction isRightOn(a:Float32Array,b:Float32Array,c:Float32Array): boolean {\r\n    return triangleArea(a, b, c) <= 0;\r\n}\r\n\r\nlet tmpPoint1 = new Float32Array(2),\r\n    tmpPoint2 = new Float32Array(2);\r\n\r\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {boolean}\r\n */\r\nfunction collinear(a: Float32Array,b: Float32Array,c: Float32Array, thresholdAngle: f32): boolean {\r\n    if(!thresholdAngle){\r\n        return triangleArea(a, b, c) === 0;\r\n    } else {\r\n        let ab = tmpPoint1,\r\n            bc = tmpPoint2;\r\n\r\n        ab[0] = b[0]-a[0];\r\n        ab[1] = b[1]-a[1];\r\n        bc[0] = c[0]-b[0];\r\n        bc[1] = c[1]-b[1];\r\n\r\n        let dot = ab[0]*bc[0] + ab[1]*bc[1],\r\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\r\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\r\n            angle = Math.acos(dot/(magA*magB));\r\n        return angle < thresholdAngle;\r\n    }\r\n}\r\n\r\nfunction sqdist(a: Float32Array,b: Float32Array): f32{\r\n    let dx = b[0] - a[0];\r\n    let dy = b[1] - a[1];\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\r\nfunction polygonAt(polygon: Float32Array[], i: i32): Float32Array{\r\n    let s: u16 = polygon.length as u16;\r\n    return polygon[i < 0 ? i % s + s : i % s];\r\n}\r\n\r\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\r\nfunction polygonClear(polygon: Array<Float32Array>): void{\r\n    polygon.length = 0;\r\n}\r\n\r\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\r\nfunction polygonAppend(polygon: Float32Array[], poly: Float32Array[], from: u16, to: u16): void{\r\n    for(let i: u16 = from; i < to; i++){\r\n        polygon.push(poly[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\r\nexport function polygonMakeCCW(polygon: Float32Array[]): boolean{\r\n    let br: u16 = 0,\r\n        v: Float32Array[] = polygon;\r\n\r\n    // find bottom right point\r\n    for (let i: u16 = 1; i < (polygon.length as u16); ++i) {\r\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\r\n            br = i;\r\n        }\r\n    }\r\n\r\n    // reverse poly if clockwise\r\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\r\n        polygonReverse(polygon);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\r\nfunction polygonReverse(polygon: Float32Array[]): void{\r\n    let tmp:Float32Array[] = [];\r\n    let N: u16 = polygon.length as u16;\r\n    for(let i: u16 = 0; i < N; i++){\r\n\t\tlet p: Float32Array = polygon.pop();\r\n        tmp.push(p);\r\n    }\r\n    for(let i: u16 = 0; i < N; i++){\r\n\t\tpolygon[i] = tmp[i];\r\n    }\r\n}\r\n\r\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {boolean}\r\n */\r\nfunction polygonIsReflex(polygon: Float32Array[], i: i32): boolean{\r\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\r\n}\r\n\r\nvar tmpLine1: Array<Float32Array>=[],\r\n    tmpLine2: Array<Float32Array>=[];\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {boolean}\r\n */\r\nfunction polygonCanSee(polygon: Float32Array[], a: u32,b: u32): boolean {\r\n\tlet p: Float32Array;\r\n\tlet dist: f32;\r\n\tlet l1:Float32Array[] = tmpLine1;\r\n\tlet l2:Float32Array[] = tmpLine2;\r\n\r\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\r\n        return false;\r\n    }\r\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\r\n    for (let i: u16 = 0; i < (polygon.length as u16); ++i) { // for each edge\r\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\r\n            continue;\r\n        }\r\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\r\n            l1[0] = polygonAt(polygon, a);\r\n            l1[1] = polygonAt(polygon, b);\r\n            l2[0] = polygonAt(polygon, i);\r\n            l2[1] = polygonAt(polygon, i + 1);\r\n            p = lineInt(l1,l2);\r\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {boolean}\r\n */\r\nfunction polygonCanSee2(polygon: Float32Array[], a: u32,b:u32):boolean {\r\n    // for each edge\r\n    for (let i: u16 = 0; i < (polygon.length as u16); ++i) {\r\n        // ignore incident edges\r\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\r\n            continue;\r\n        }\r\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\r\nfunction polygonCopy(polygon: Array<Float32Array>, i: u16, j: u16, targetPoly: Float32Array[]|null): Array<Float32Array>{\r\n    let p: Array<Float32Array> = targetPoly || [];\r\n    polygonClear(p);\r\n    if (i < j) {\r\n        // Insert all vertices from i to j\r\n        for(let k: u16 = i; k <= j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n    } else {\r\n\r\n        // Insert vertices 0 to j\r\n        for(let k: u16 = 0; k <= j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n        // Insert vertices i to end\r\n        for(let k: u16 = i; k < (polygon.length as u16); k++){\r\n            p.push(polygon[k]);\r\n        }\r\n    }\r\n\r\n    return p;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\r\nfunction polygonGetCutEdges(polygon: Array<Float32Array>): Array<Array<Float32Array>> {\r\n    let min: Array<Array<Float32Array>> = [], tmp1: Array<Array<Float32Array>> = [], tmp2: Array<Array<Float32Array>> = [], tmpPoly: Array<Float32Array> = [];\r\n    let nDiags = Infinity;\r\n\r\n    for (let i: u16 = 0; i < (polygon.length as u16); ++i) {\r\n        if (polygonIsReflex(polygon, i)) {\r\n            for (let j: u16 = 0; j < (polygon.length as u16); ++j) {\r\n                if (polygonCanSee(polygon, i, j)) {\r\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\r\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\r\n\r\n                    for(let k: u16 = 0; k < (tmp2.length as u16); k++){\r\n                        tmp1.push(tmp2[k]);\r\n                    }\r\n\r\n                    if (tmp1.length < nDiags) {\r\n                        min = tmp1;\r\n\t\t\t\t\t\tnDiags = tmp1.length;\r\n\t\t\t\t\t\tlet p = [polygonAt(polygon, i), polygonAt(polygon, j)];\r\n                        min.push(p);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\r\nexport function polygonDecomp(polygon: Array<Float32Array>): Array<Array<Float32Array>>{\r\n    let edges = polygonGetCutEdges(polygon);\r\n    if(edges.length > 0){\r\n        return polygonSlice(polygon, edges);\r\n    } else {\r\n        return [polygon];\r\n    }\r\n}\r\n\r\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @warning The inner workings of this function was massively modified when switching to typescript. Needs thorough testing.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\r\nfunction polygonSlice(polygon: Array<Float32Array>, cutEdges: Array<Array<Float32Array>>): Array<Array<Float32Array>>{\r\n    if(cutEdges.length === 0){\r\n\t\treturn [polygon];\r\n    }\r\n    if(cutEdges[0].length===2){\r\n\r\n        let polys = [polygon];\r\n\r\n        for(let i: u16 = 0; i < (cutEdges.length as u16); i++){\r\n            let cutEdge = [cutEdges[i]];\r\n            // Cut all polys\r\n            for(let j: u16 = 0; j < (polys.length as u16); j++){\r\n                let poly = polys[j];\r\n                let result = polygonSlice(poly, cutEdge);\r\n                if(result){\r\n                    // Found poly! Cut and quit\r\n                    polys.splice(j,1);\r\n                    polys.push(result[0]);\r\n                    polys.push(result[1]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return polys;\r\n    } else {\r\n\r\n        // Was given one edge\r\n        let cutEdge = cutEdges;\r\n        let i: i32 = polygon.indexOf(cutEdge[0][0]);\r\n        let j: i32 = polygon.indexOf(cutEdge[0][1]);\r\n\r\n        if(i !== -1 && j !== -1){\r\n            return [polygonCopy(polygon, i,j,null),\r\n                    polygonCopy(polygon, j,i,null)];\r\n        } else {\r\n            return new Array<Array<Float32Array>>();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {boolean}\r\n * @todo Should it check all segments with all others?\r\n */\r\nexport function polygonIsSimple(polygon: Array<Float32Array>): boolean{\r\n    let path: Array<Float32Array> = polygon, i: u32;\r\n    // Check\r\n    for(let i:u16=0; i+1<(path.length as u16); i++){\r\n        for(let j:u16=0; j + 1 < i ; j++){\r\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check the segment between the last and the first point to all others\r\n    for(let i: u16 = 1; i + 2 < (path.length as u16); i++){\r\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getIntersectionPoint(p1: Float32Array, p2: Float32Array, q1: Float32Array, q2: Float32Array, delta: f32 = 0): Float32Array{\r\n\tlet a1 = p2[1] - p1[1];\r\n\tlet b1 = p1[0] - p2[0];\r\n\tlet c1 = (a1 * p1[0]) + (b1 * p1[1]);\r\n\tlet a2 = q2[1] - q1[1];\r\n\tlet b2 = q1[0] - q2[0];\r\n\tlet c2 = (a2 * q1[0]) + (b2 * q1[1]);\r\n\tlet det = (a1 * b2) - (a2 * b1);\r\n\r\n\tlet pt = new Float32Array(2);\r\n\r\n\tif(!scalar_eq(det,0,delta)){\r\n\t\tpt[0] = ((b2 * c1) - (b1 * c2)) / det;\r\n\t\tpt[1] = ((a1 * c2) - (a2 * c1)) / det;\r\n\t\treturn pt;\r\n\t} else {\r\n\t\tpt[0] = 0;\r\n\t\tpt[1] = 0;\r\n\t\treturn pt;\r\n    }\r\n}\r\n\r\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\r\nexport function polygonQuickDecomp(\r\n\tpolygon: Array<Float32Array>, \r\n\tresult: Array<Array<Float32Array>> = new Array<Array<Float32Array>>(), \r\n\treflexVertices: Array<Float32Array> = [], \r\n\tsteinerPoints: Array<Float32Array> = [], \r\n\tdelta: f32 = 25, \r\n\tmaxlevel: f32 = 100, \r\n\tlevel: u16 = 0\r\n): Array<Array<Float32Array>>{\r\n\t// TODO: should upperInt really be initialized here? It looks like it's overwritten.\r\n\tlet upperInt=new Float32Array(2), lowerInt=new Float32Array(2), p=new Float32Array(2); // Points\r\n\tupperInt[0] = 0;\r\n\tupperInt[1] = 0;\r\n\tlowerInt[0] = 0;\r\n\tlowerInt[1] = 0;\r\n\tp[0] = 0;\r\n\tp[1] = 0;\r\n    let upperDist: f32=0, lowerDist: f32=0, d=0, closestDist: f32=0; // scalars\r\n    let upperIndex: u16 = 0, lowerIndex: u16 = 0, closestIndex: u16=0; // Integers\r\n    let lowerPoly=new Array<Float32Array>(), upperPoly=new Array<Float32Array>(); // polygons\r\n    let poly = polygon,\r\n        v = polygon;\r\n\r\n    if(v.length < 3){\r\n\t\treturn result;\r\n    }\r\n\r\n    level++;\r\n    if(level > maxlevel){\r\n        //console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\r\n        return result;\r\n    }\r\n\r\n    for (let i: u16 = 0; i < (polygon.length as u16); ++i) {\r\n        if (polygonIsReflex(poly, i)) {\r\n            reflexVertices.push(poly[i]);\r\n            upperDist = lowerDist = Infinity;\r\n\r\n\r\n            for (let j: u16 = 0; j < (polygon.length as u16); ++j) {\r\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\r\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\r\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < lowerDist) { // keep only the closest intersection\r\n                            lowerDist = d;\r\n                            lowerInt = p;\r\n                            lowerIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\r\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\r\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < upperDist) {\r\n                            upperDist = d;\r\n                            upperInt = p;\r\n                            upperIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if there are no vertices to connect to, choose a point in the middle\r\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\r\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\r\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\r\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\r\n                steinerPoints.push(p);\r\n\r\n                if (i < upperIndex) {\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    if (lowerIndex !== 0){\r\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\r\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\r\n                    }\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\r\n                        polygonAppend(lowerPoly, poly,i,poly.length);\r\n                    }\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\r\n                }\r\n            } else {\r\n                // connect to the closest point within the triangle\r\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\r\n\r\n                if (lowerIndex > upperIndex) {\r\n                    upperIndex += polygon.length;\r\n                }\r\n                closestDist = Infinity;\r\n\r\n                if(upperIndex < lowerIndex){\r\n                    return result;\r\n                }\r\n\r\n                for (let j: u16 = lowerIndex; j <= upperIndex; ++j) {\r\n                    if (\r\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\r\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\r\n                    ) {\r\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\r\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\r\n                            closestDist = d;\r\n                            closestIndex = j % polygon.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (i < closestIndex) {\r\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\r\n                    if (closestIndex !== 0){\r\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\r\n                    }\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        polygonAppend(lowerPoly, poly,i,v.length);\r\n                    }\r\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\r\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\r\n                }\r\n            }\r\n\r\n            // solve smallest poly first\r\n            if (lowerPoly.length < upperPoly.length) {\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            } else {\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    result.push(polygon);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\r\nexport function polygonRemoveCollinearPoints(polygon: Array<Float32Array>, precision: f32): u32{\r\n    let num: i32 = 0;\r\n    for(let i:i32 = polygon.length - 1; polygon.length > 3 && i >= 0; --i){\r\n        if(collinear(polygonAt(polygon, i-1), polygonAt(polygon, i), polygonAt(polygon, i+1), precision)){\r\n            // Remove the middle point\r\n            polygon.splice(i%polygon.length,1);\r\n            num++;\r\n        }\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\r\nexport function polygonRemoveDuplicatePoints(polygon: Array<Float32Array>, precision: f32): void{\r\n    for(let i: i32 = polygon.length - 1; i>=1; --i){\r\n        let pi = polygon[i];\r\n        for(let j: i32 = i - 1; j >= 0; --j){\r\n            if(points_eq(pi, polygon[j], precision)){\r\n                polygon.splice(i,1);\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {boolean}\r\n */\r\nfunction scalar_eq(a: f32,b: f32,precision: f32): boolean{\r\n    precision = precision || 0;\r\n    return Math.abs(a-b) <= precision;\r\n}\r\n\r\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {boolean}\r\n */\r\nfunction points_eq(a: Float32Array,b: Float32Array,precision: f32): boolean{\r\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\r\n}\r\n\r\n\r\n// export default {\r\n//     decomp: polygonDecomp,\r\n//     quickDecomp: polygonQuickDecomp,\r\n//     isSimple: polygonIsSimple,\r\n//     removeCollinearPoints: polygonRemoveCollinearPoints,\r\n//     removeDuplicatePoints: polygonRemoveDuplicatePoints,\r\n//     makeCCW: polygonMakeCCW,\r\n// };\r\n\r\n// import {polygonDecomp as decomp} from \"./math/poly-decomp\";\r\n// import {polygonQuickDecomp as quickDecomp} from \"./math/poly-decomp\";\r\n// import {polygonIsSimple as isSimple} from \"./math/poly-decomp\";\r\n// import {polygonRemoveCollinearPoints as removeCollinearPoints} from \"./math/poly-decomp\";\r\n// import {polygonRemoveDuplicatePoints as removeDuplicatePoints} from \"./math/poly-decomp\";\r\n// import {polygonMakeCCW as makeCCW} from \"./math/poly-decomp\";","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\n\nimport World from \"../world/world\";\nimport Shape from \"../shapes/shape\";\nimport AABB from \"../collision/aabb\";\nimport Convex from \"../shapes/Convex\";\nimport Ray from \"../collision/ray\";\nimport { RayOptions } from \"../collision/ray\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport EventEmitter from \"../events/event-emitter\";\nimport { EventArgument } from \"../events/event-emitter\";\n\nimport {polygonDecomp as decomp} from \"../math/poly-decomp\";\nimport {polygonQuickDecomp as quickDecomp} from \"../math/poly-decomp\";\nimport {polygonIsSimple as isSimple} from \"../math/poly-decomp\";\nimport {polygonRemoveCollinearPoints as removeCollinearPoints} from \"../math/poly-decomp\";\nimport {polygonRemoveDuplicatePoints as removeDuplicatePoints} from \"../math/poly-decomp\";\nimport {polygonMakeCCW as makeCCW} from \"../math/poly-decomp\";\n\nconst integrate_fhMinv: Float32Array = vec2.create();\nconst integrate_velodt: Float32Array = vec2.create();\nconst _tmp: Float32Array = vec2.create();\n\nvar _idCounter:u32 = 0;\n\nexport class BodyOptions{\n\tmass: f32 = 0;\n\tfixedRotation: boolean = false;\n\tfixedX: boolean = false;\n\tfixedY: boolean = false;\n\tposition: Float32Array|null = null;\n\tvelocity: Float32Array|null = null;\n\tangle: f32 = 0;\n\tangularVelocity: f32 = 0;\n\tforce: Float32Array|null = null;\n\tangularForce: f32 = 0;\n\tdamping: f32 = 0.1;\n\tangularDamping: f32 = 0.1;\n\tsleepTimeLimit: f32 = 1;\n\ttype: u16 = 0; // Constructor decides based on mass.\n\tallowSleep: boolean = true;\n\tsleepSpeedLimit: f32 = 0.2;\n\tgravityScale: f32 = 1;\n\tcollisionResponse: boolean = true;\n\tccdSpeedThreshold: f32 = -1;\n\tccdIterations: f32 = 10;\n}\n\nexport class BodyFromPolygonOptions{\n\tremoveCollinearPoints: f32 = 0;\n\tskipSimpleCheck: boolean = true;\n\toptimalDecomp: boolean = false;\n}\n\nexport default class Body extends EventEmitter{\n\n\t/**\n\t * The body identifier. Read only!\n\t * @readonly\n\t * @property id\n\t * @type {Number}\n\t*/\n\tpublic id:u32 = 0;\n\n\t/**\n\t * Index of the body in the World .bodies array. Is set to -1 if the body isn't added to a World.\n\t * @readonly\n\t * @property index\n\t * @type {Number}\n\t */\n\tpublic index: i32 = 0;\n\n\t/**\n\t * The world that this body is added to (read only). This property is set to NULL if the body is not added to any world.\n\t * @readonly\n\t * @property world\n\t * @type {World}\n\t */\n\tpublic world: World|null = null;\n\n\t/**\n\t * The shapes of the body.\n\t *\n\t * @property shapes\n\t * @type {Array}\n\t */\n\tpublic shapes: Array<Shape> = [];\n\n\t/**\n\t * The mass of the body. If you change this number, you should call {{#crossLink \"Body/updateMassProperties:method\"}}{{/crossLink}}.\n\t *\n\t * @property mass\n\t * @type {number}\n\t *\n\t * @example\n\t *     body.mass = 1;\n\t *     body.updateMassProperties();\n\t */\n\tpublic mass: f32 = 0;\n\n\t/**\n\t * The inverse mass of the body.\n\t *\n\t * @readonly\n\t * @property invMass\n\t * @type {number}\n\t */\n\tpublic invMass: f32 = 0;\n\n\t/**\n\t * The inertia of the body around the Z axis.\n\t * @readonly\n\t * @property inertia\n\t * @type {number}\n\t */\n\tpublic inertia: f32 = 0;\n\n\t/**\n\t * The inverse inertia of the body.\n\t * @readonly\n\t * @property invInertia\n\t * @type {number}\n\t */\n\tpublic invInertia: f32 = 0;\n\n\tpublic invMassSolve: f32 = 0;\n\tpublic invInertiaSolve: f32 = 0;\n\n\t/**\n\t * Set to true if you want to fix the rotation of the body.\n\t *\n\t * @property fixedRotation\n\t * @type {boolean}\n\t *\n\t * @example\n\t *     // Fix rotation during runtime\n\t *     body.fixedRotation = true;\n\t *     body.updateMassProperties();\n\t */\n\tpublic fixedRotation: boolean = false;\n\n\t/**\n\t * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.\n\t * @property {boolean} fixedX\n\t *\n\t * @example\n\t *     // Fix X movement on body creation\n\t *     let body = new Body({ mass: 1, fixedX: true });\n\t *\n\t * @example\n\t *     // Fix X movement during runtime\n\t *     body.fixedX = true;\n\t *     body.updateMassProperties();\n\t */\n\tpublic fixedX: boolean = false;\n\n\t/**\n\t * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X. See .fixedX\n\t * @property {boolean} fixedY\n\t */\n\tpublic fixedY: boolean = false;\n\n\t/**\n\t * @private\n\t * @property {array} massMultiplier\n\t */\n\tpublic massMultiplier:Float32Array = vec2.create();\n\n\t/**\n\t * The position of the body in the world. Don't use this for rendering, instead use .interpolatedPosition\n\t * @property position\n\t * @type {Array}\n\t */\n\tpublic position: Float32Array = vec2.create();\n\n\t/**\n\t * The interpolated position of the body. Use this for rendering.\n\t * @readonly\n\t * @property interpolatedPosition\n\t * @type {Array}\n\t */\n\tpublic interpolatedPosition: Float32Array = vec2.create();\n\n\t/**\n\t * The previous position of the body.\n\t * @property previousPosition\n\t * @type {Array}\n\t */\n\tpublic previousPosition: Float32Array = vec2.create();\n\n\t/**\n\t * The current velocity of the body.\n\t * @property velocity\n\t * @type {Array}\n\t */\n\tpublic velocity: Float32Array = vec2.create();\n\n\t/**\n\t * Constraint velocity that was added to the body during the last step.\n\t * @readonly\n\t * @property vlambda\n\t * @type {Array}\n\t */\n\tpublic vlambda: Float32Array = vec2.create();\n\n\t/**\n\t * Angular constraint velocity that was added to the body during last step.\n\t * @readonly\n\t * @property wlambda\n\t * @type {Array} // This was array before the port, but hte assignment was always 0.\n\t */\n\tpublic wlambda: f32 = 0;\n\n\t/**\n\t * The angle of the body, in radians.\n\t * @property angle\n\t * @type {number}\n\t * @example\n\t *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.\n\t *     // If you need a value between 0 and 2*pi, use the following function to normalize it.\n\t *     function normalizeAngle(angle){\n\t *         angle = angle % (2*Mathf.PI);\n\t *         if(angle < 0){\n\t *             angle += (2*Mathf.PI);\n\t *         }\n\t *         return angle;\n\t *     }\n\t */\n\tpublic angle: f32 = 0;\n\n\t/**\n\t * The previous angle of the body.\n\t * @readonly\n\t * @property previousAngle\n\t * @type {Number}\n\t */\n\tpublic previousAngle: f32 = 0;\n\n\t/**\n\t * The interpolated angle of the body. Use this for rendering.\n\t * @readonly\n\t * @property interpolatedAngle\n\t * @type {Number}\n\t */\n\tpublic interpolatedAngle: f32 = 0;\n\n\t/**\n\t * The angular velocity of the body, in radians per second.\n\t * @property angularVelocity\n\t * @type {number}\n\t */\n\tpublic angularVelocity: f32 = 0;\n\n\t/**\n\t * The force acting on the body. Since the body force (and {{#crossLink \"Body/angularForce:property\"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.\n\t * @property force\n\t * @type {Array}\n\t *\n\t * @example\n\t *     // This produces a forcefield of 1 Newton in the positive x direction.\n\t *     for(let i: u16 = 0; i<numSteps; i++){\n\t *         body.force[0] = 1;\n\t *         world.step(1/60);\n\t *     }\n\t *\n\t * @example\n\t *     // This will apply a rotational force on the body\n\t *     for(let i: u16=0; i<numSteps; i++){\n\t *         body.angularForce = -3;\n\t *         world.step(1/60);\n\t *     }\n\t */\n\tpublic force: Float32Array = vec2.create();\n\n\t/**\n\t * The angular force acting on the body. See {{#crossLink \"Body/force:property\"}}{{/crossLink}}.\n\t * @property angularForce\n\t * @type {number}\n\t */\n\tpublic angularForce: f32 = 0;\n\n\t/**\n\t * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.\n\t * @property damping\n\t * @type {Number}\n\t * @default 0.1\n\t */\n\tpublic damping: f32 = 0.1;\n\n\t/**\n\t * The angular force acting on the body. Should be a value between 0 and 1.\n\t * @property angularDamping\n\t * @type {Number}\n\t * @default 0.1\n\t */\n\tpublic angularDamping: f32 = 0.1;\n\n\t/**\n\t * The type of motion this body has. Should be one of: {{#crossLink \"Body/STATIC:property\"}}Body.STATIC{{/crossLink}}, {{#crossLink \"Body/DYNAMIC:property\"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink \"Body/KINEMATIC:property\"}}Body.KINEMATIC{{/crossLink}}.\n\t *\n\t * * Static bodies do not move, and they do not respond to forces or collision.\n\t * * Dynamic bodies body can move and respond to collisions and forces.\n\t * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.\n\t *\n\t * @property type\n\t * @type {number}\n\t *\n\t * @example\n\t *     // Bodies are static by default. Static bodies will never move.\n\t *     let body = new Body();\n\t *     console.log(body.type == Body.STATIC); // true\n\t *\n\t * @example\n\t *     // By setting the mass of a body to a nonzero number, the body\n\t *     // will become dynamic and will move and interact with other bodies.\n\t *     let dynamicBody = new Body({\n\t *         mass : 1\n\t *     });\n\t *     console.log(dynamicBody.type == Body.DYNAMIC); // true\n\t *\n\t * @example\n\t *     // Kinematic bodies will only move if you change their velocity.\n\t *     let kinematicBody = new Body({\n\t *         type: Body.KINEMATIC // Type can be set via the options object.\n\t *     });\n\t */\n\tpublic type: u16 = Body.STATIC;\n\n\t/**\n\t * Bounding circle radius. Update with {{#crossLink \"Body/updateBoundingRadius:method\"}}{{/crossLink}}.\n\t * @readonly\n\t * @property boundingRadius\n\t * @type {Number}\n\t */\n\tpublic boundingRadius: f32 = 0;\n\n\t/**\n\t * Bounding box of this body. Update with {{#crossLink \"Body/updateAABB:method\"}}{{/crossLink}}.\n\t * @property aabb\n\t * @type {AABB}\n\t */\n\tpublic aabb: AABB = new AABB(null, null);\n\n\t/**\n\t * Indicates if the AABB needs update. Update it with {{#crossLink \"Body/updateAABB:method\"}}{{/crossLink}}.\n\t * @property aabbNeedsUpdate\n\t * @type {boolean}\n\t * @see updateAABB\n\t *\n\t * @example\n\t *     // Force update the AABB\n\t *     body.aabbNeedsUpdate = true;\n\t *     body.updateAABB();\n\t *     console.log(body.aabbNeedsUpdate); // false\n\t */\n\tpublic aabbNeedsUpdate: boolean = true;\n\n\t/**\n\t * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink \"World\"}}{{/crossLink}} before anything will happen.\n\t * @property allowSleep\n\t * @type {boolean}\n\t * @default true\n\t */\n\tpublic allowSleep: boolean = true;\n\n\tpublic wantsToSleep: boolean = false;\n\n\t/**\n\t * One of {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}}, {{#crossLink \"Body/SLEEPY:property\"}}Body.SLEEPY{{/crossLink}} and {{#crossLink \"Body/SLEEPING:property\"}}Body.SLEEPING{{/crossLink}}.\n\t *\n\t * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).\n\t *\n\t * @property sleepState\n\t * @type {Number}\n\t * @default Body.AWAKE\n\t */\n\tpublic sleepState: u16 = Body.AWAKE;\n\n\t/**\n\t * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n\t * @property sleepSpeedLimit\n\t * @type {Number}\n\t * @default 0.2\n\t */\n\tpublic sleepSpeedLimit: f32 = 0.2;\n\n\t/**\n\t * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n\t * @property sleepTimeLimit\n\t * @type {Number}\n\t * @default 1\n\t */\n\tpublic sleepTimeLimit: f32 = 1;\n\n\t/**\n\t * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.\n\t * @property {Number} gravityScale\n\t * @default 1\n\t */\n\tpublic gravityScale:f32 = 1;\n\n\t/**\n\t * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.\n\t * @property {boolean} collisionResponse\n\t */\n\tpublic collisionResponse: boolean = true;\n\n\t/**\n\t * How long the body has been sleeping.\n\t * @readonly\n\t * @property {Number} idleTime\n\t */\n\tpublic idleTime: f32 = 0;\n\n\t/**\n\t * The last time when the body went to SLEEPY state.\n\t * @readonly\n\t * @property {Number} timeLastSleepy\n\t * @private\n\t */\n\tpublic timeLastSleepy: f32 = 0;\n\n\t/**\n\t * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.\n\t * @property {number} ccdSpeedThreshold\n\t * @default -1\n\t */\n\tpublic ccdSpeedThreshold: f32 = -1;\n\n\t/**\n\t * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.\n\t * @property {number} ccdIterations\n\t * @default 10\n\t */\n\tpublic ccdIterations: i32 = 10;\n\n\t/**\n\t * @property {number} islandId\n\t */\n\tpublic islandId: i32 = -1;\n\n\tpublic concavePath: Float32Array[]|null = null;\n\n\t// Should be private, but used by world.\n\t_wakeUpAfterNarrowphase: boolean = false;\n\n\tprivate _shapeAABB: AABB = new AABB(null, null);\n\n\t/**\n\t * A rigid body. Has got a center of mass, position, velocity and a number of\n\t * shapes that are used for collisions.\n\t *\n\t * @class Body\n\t * @constructor\n\t * @extends EventEmitter\n\t * @param {Object} [options]\n\t * @param {boolean} [options.allowSleep=true]\n\t * @param {Number} [options.angle=0]\n\t * @param {Number} [options.angularDamping=0.1]\n\t * @param {Number} [options.angularForce=0]\n\t * @param {Number} [options.angularVelocity=0]\n\t * @param {Number} [options.ccdIterations=10]\n\t * @param {Number} [options.ccdSpeedThreshold=-1]\n\t * @param {boolean} [options.collisionResponse]\n\t * @param {Number} [options.damping=0.1]\n\t * @param {boolean} [options.fixedRotation=false]\n\t * @param {boolean} [options.fixedX=false]\n\t * @param {boolean} [options.fixedY=false]\n\t * @param {Array} [options.force]\n\t * @param {Number} [options.gravityScale=1]\n\t * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.\n\t * @param {Array} [options.position]\n\t * @param {Number} [options.sleepSpeedLimit]\n\t * @param {Number} [options.sleepTimeLimit]\n\t * @param {Number} [options.type] See {{#crossLink \"Body/type:property\"}}{{/crossLink}}\n\t * @param {Array} [options.velocity]\n\t *\n\t * @example\n\t *\n\t *     // Create a typical dynamic body\n\t *     let body = new Body({\n\t *         mass: 1, // non-zero mass will set type to Body.DYNAMIC\n\t *         position: [0, 5],\n\t *         angle: 0,\n\t *         velocity: [0, 0],\n\t *         angularVelocity: 0\n\t *     });\n\t *\n\t *     // Add a circular shape to the body\n\t *     let circleShape = new Circle({ radius: 0.5 });\n\t *     body.addShape(circleShape);\n\t *\n\t *     // Add the body to the world\n\t *     world.addBody(body);\n\t *\n\t * @example\n\t *\n\t *     // Create a static plane body\n\t *     let planeBody = new Body({\n\t *         mass: 0, // zero mass will set type to Body.STATIC\n\t *         position: [0, 0]\n\t *     });\n\t *     let planeShape = new Plane();\n\t *     planeBody.addShape(planeShape);\n\t *     world.addBody(planeBody);\n\t *\n\t * @example\n\t *\n\t *     // Create a moving kinematic box body\n\t *     let platformBody = new Body({\n\t *         type: Body.KINEMATIC,\n\t *         position: [0, 3],\n\t *         velocity: [1, 0]\n\t *     });\n\t *     let boxShape = new Box({ width: 2, height: 0.5 });\n\t *     platformBody.addShape(boxShape);\n\t *     world.addBody(platformBody);\n\t */\n\tconstructor(options: BodyOptions|null){\n\t\tsuper();\n\n\t\tthis.id = ++_idCounter;\n\n\t\tif(options){\n\t\t\tthis.mass = options.mass;\n\t\t\tthis.fixedRotation = options.fixedRotation;\n\t\t\tthis.fixedX = options.fixedX;\n\t\t\tthis.fixedY = options.fixedY;\n\t\t\tif(options.position != null) vec2.copy(this.position, options.position as Float32Array);\n\t\t\tif(options.velocity != null) vec2.copy(this.velocity, options.velocity as Float32Array);\n\t\t\tthis.angle = options.angle;\n\t\t\tthis.previousAngle = this.angle;\n\t\t\tthis.interpolatedAngle = this.angle;\n\t\t\tthis.angularVelocity = options.angularVelocity;\n\t\t\tif(options.force != null) vec2.copy(this.force, options.force as Float32Array);\n\t\t\tthis.angularForce = options.angularForce;\n\t\t\tthis.damping = options.damping;\n\t\t\tthis.angularDamping = options.angularDamping;\n\t\t\tthis.sleepTimeLimit = options.sleepTimeLimit;\n\n\t\t\tif(options.type){\n\t\t\t\tthis.type = options.type;\n\t\t\t} else if(!(options.mass)){\n\t\t\t\tthis.type = Body.STATIC;\n\t\t\t} else {\n\t\t\t\tthis.type = Body.DYNAMIC;\n\t\t\t}\n\n\t\t\tthis.allowSleep = options.allowSleep;\n\t\t\tthis.sleepSpeedLimit = options.sleepSpeedLimit;\n\t\t\tthis.gravityScale = options.gravityScale;\n\t\t\tthis.collisionResponse = options.collisionResponse;\n\t\t\tthis.ccdSpeedThreshold = options.ccdSpeedThreshold;\n\t\t\tthis.ccdIterations = options.ccdIterations;\n\t\t}\n\t\telse{\n\t\t\tthis.type = Body.STATIC;\n\t\t}\n\t\tthis.previousPosition = vec2.clone(this.position);\n\t\tthis.interpolatedPosition = vec2.clone(this.position);\n\n\n\t\tthis.updateMassProperties();\n\t}\n\n\t/**\n\t * @private\n\t * @method updateSolveMassProperties\n\t */\n\tupdateSolveMassProperties(): void{\n\t\tif(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){\n\t\t\tthis.invMassSolve = 0;\n\t\t\tthis.invInertiaSolve = 0;\n\t\t} else {\n\t\t\tthis.invMassSolve = this.invMass;\n\t\t\tthis.invInertiaSolve = this.invInertia;\n\t\t}\n\t};\n\n\t/**\n\t * Set the total density of the body\n\t * @method setDensity\n\t * @param {number} density\n\t */\n\tsetDensity(density: f32): void {\n\t\tlet totalArea = this.getArea();\n\t\tthis.mass = totalArea * density;\n\t\tthis.updateMassProperties();\n\t}\n\n\t/**\n\t * Get the total area of all shapes in the body\n\t * @method getArea\n\t * @return {Number}\n\t */\n\tgetArea(): f32 {\n\t\tlet totalArea: f32 = 0;\n\t\tfor(let i: u16=0; i<(this.shapes.length as u16); i++){\n\t\t\ttotalArea += this.shapes[i].area;\n\t\t}\n\t\treturn totalArea;\n\t}\n\n\t/**\n\t * Get the AABB from the body. The AABB is updated if necessary.\n\t * @method getAABB\n\t * @return {AABB} The AABB instance from the body.\n\t */\n\tgetAABB(): AABB{ // TODO: switch to typescript getter.\n\t\tif(this.aabbNeedsUpdate){\n\t\t\tthis.updateAABB();\n\t\t}\n\t\treturn this.aabb;\n\t}\n\n\t/**\n\t * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.\n\t * @method updateAABB\n\t */\n\tupdateAABB(): void {\n\t\tlet shapes: Shape[] = this.shapes,\n\t\t\tN:u16 = shapes.length as u16,\n\t\t\toffset: Float32Array = _tmp,\n\t\t\tbodyAngle: f32 = this.angle;\n\n\t\tfor(let i: u16 = 0; i < N; i++){\n\t\t\tlet shape = shapes[i],\n\t\t\t\tangle = shape.angle + bodyAngle;\n\n\t\t\t// Get shape world offset\n\t\t\tvec2.rotate(offset, shape.position, bodyAngle);\n\t\t\tvec2.add(offset, offset, this.position);\n\n\t\t\t// Get shape AABB\n\t\t\tshape.computeAABB(this._shapeAABB, offset, angle);\n\n\t\t\tif(i===0){\n\t\t\t\tthis.aabb.copy(this._shapeAABB);\n\t\t\t} else {\n\t\t\t\tthis.aabb.extend(this._shapeAABB);\n\t\t\t}\n\t\t}\n\n\t\tthis.aabbNeedsUpdate = false;\n\t}\n\n\t/**\n\t * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): void{\n\t\tlet shapes:Shape[] = this.shapes,\n\t\t\tN:u16 = shapes.length as u16,\n\t\t\tradius:f32 = 0;\n\n\t\tfor(let i:u16=0; i!==N; i++){\n\t\t\tlet shape:Shape = shapes[i],\n\t\t\t\toffset:f32 = vec2.length(shape.position),\n\t\t\t\tr:f32 = shape.boundingRadius;\n\t\t\tif(offset + r > radius){\n\t\t\t\tradius = offset + r;\n\t\t\t}\n\t\t}\n\n\t\tthis.boundingRadius = radius;\n\t}\n\n\t/**\n\t * Add a shape to the body. You can pass a local transform when adding a shape,\n\t * so that the shape gets an offset and angle relative to the body center of mass.\n\t * Will automatically update the mass properties and bounding radius.\n\t *\n\t * @method addShape\n\t * @param  {Shape}              shape\n\t * @param  {Array} [offset] Local body offset of the shape.\n\t * @param  {Number}             [angle]  Local body angle.\n\t *\n\t * @example\n\t *     let body = new Body(),\n\t *         shape = new Circle({ radius: 1 });\n\t *\n\t *     // Add the shape to the body, positioned in the center\n\t *     body.addShape(shape);\n\t *\n\t *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.\n\t *     body.addShape(shape,[1,0]);\n\t *\n\t *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.\n\t *     body.addShape(shape,[0,1],Mathf.PI/2);\n\t */\n\taddShape(shape: Shape, offset: Float32Array, angle: f32 = 0): void{\n\t\tif(shape.body){\n\t\t\tthrow new Error('A shape can only be added to one body.');\n\t\t}\n\t\tlet world = this.world;\n\t\tif(world && world.stepping){\n\t\t\tthrow new Error('A shape cannot be added during step.');\n\t\t}\n\t\tshape.body = this;\n\n\t\t// Copy the offset vector\n\t\tif(offset){\n\t\t\tvec2.copy(shape.position, offset);\n\t\t} else {\n\t\t\tvec2.set(shape.position, 0, 0);\n\t\t}\n\n\t\tshape.angle = angle || 0;\n\n\t\tthis.shapes.push(shape);\n\t\tthis.updateMassProperties();\n\t\tthis.updateBoundingRadius();\n\n\t\tthis.aabbNeedsUpdate = true;\n\t}\n\n\t/**\n\t * Remove a shape.\n\t * @method removeShape\n\t * @param  {Shape} shape\n\t * @return {boolean} True if the shape was found and removed, else false.\n\t */\n\tremoveShape(shape: Shape): boolean{\n\t\tlet world = this.world;\n\t\tif(world && world.stepping){\n\t\t\tthrow new Error('A shape cannot be removed during step.');\n\t\t}\n\n\t\tlet idx = this.shapes.indexOf(shape);\n\n\t\tif(idx !== -1){\n\t\t\tthis.shapes.splice(idx,1);\n\t\t\tthis.aabbNeedsUpdate = true;\n\t\t\tshape.body = null;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Updates .inertia, .invMass, .invInertia for this Body. Should be called when changing the structure or mass of the Body.\n\t *\n\t * @method updateMassProperties\n\t *\n\t * @example\n\t *     body.mass += 1;\n\t *     body.updateMassProperties();\n\t */\n\tupdateMassProperties(): void{\n\t\tif(this.type === Body.STATIC || this.type === Body.KINEMATIC){\n\n\t\t\t// Consider making it infinity.\n\t\t\tthis.mass = Infinity;\n\t\t\tthis.invMass = 0;\n\t\t\tthis.inertia = Infinity;\n\t\t\tthis.invInertia = 0;\n\n\t\t} else {\n\n\t\t\tlet shapes:Shape[] = this.shapes,\n\t\t\t\tN: u16 = shapes.length as u16,\n\t\t\t\tI:f32 = 0;\n\n\t\t\tif(!this.fixedRotation){\n\t\t\t\tfor(let i:u16=0; i<N; i++){\n\t\t\t\t\tlet shape: Shape = shapes[i],\n\t\t\t\t\t\tr2: f32 = vec2.squaredLength(shape.position),\n\t\t\t\t\t\tIcm: f32 = shape.computeMomentOfInertia();\n\t\t\t\t\tI += Icm + r2;\n\t\t\t\t}\n\t\t\t\tthis.inertia = this.mass * I;\n\t\t\t\tthis.invInertia = I>0 ? 1/I : 0;\n\n\t\t\t} else {\n\t\t\t\tthis.inertia = Infinity;\n\t\t\t\tthis.invInertia = 0;\n\t\t\t}\n\n\t\t\t// Inverse mass properties are easy\n\t\t\tthis.invMass = 1 / this.mass;\n\n\t\t\tvec2.set(\n\t\t\t\tthis.massMultiplier,\n\t\t\t\tthis.fixedX ? 0 : 1,\n\t\t\t\tthis.fixedY ? 0 : 1\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.\n\t * @method applyForce\n\t * @param  {Array} force The force vector to add, oriented in world space.\n\t * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the force will be exerted on the center of mass.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let relativePoint = [1, 0]; // Will apply the force at [body.position[0] + 1, body.position[1]]\n\t *     let force = [0, 1]; // up\n\t *     body.applyForce(force, relativePoint);\n\t *     console.log(body.force); // [0, 1]\n\t *     console.log(body.angularForce); // 1\n\t */\n\tapplyForce(force: Float32Array, relativePoint: Float32Array): void{\n\n\t\t// Add linear force\n\t\tvec2.add(this.force, this.force, force);\n\n\t\tif(relativePoint){\n\n\t\t\t// Compute produced rotational force\n\t\t\tlet rotForce = vec2.crossLength(relativePoint,force);\n\n\t\t\t// Add rotational force\n\t\t\tthis.angularForce += rotForce;\n\t\t}\n\t}\n\n\t/**\n\t * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.\n\t * @method applyForceLocal\n\t * @param  {Array} localForce The force vector to add, oriented in local body space.\n\t * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the force will be exerted on the center of mass.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let localPoint = [1, 0]; // x=1 locally in the body\n\t *     let localForce = [0, 1]; // up, locally in the body\n\t *     body.applyForceLocal(localForce, localPoint);\n\t *     console.log(body.force); // [0, 1]\n\t *     console.log(body.angularForce); // 1\n\t */\n\tapplyForceLocal(localForce: Float32Array, localPoint: Float32Array): void{\n\t\t// These 3 lines were originally outside of this function. Not sure why.\n\t\tlet Body_applyForce_forceWorld = vec2.create();\n\t\tlet Body_applyForce_pointWorld = vec2.create();\n\t\tlet Body_applyForce_pointLocal = vec2.create();\n\n\t\tlocalPoint = localPoint || Body_applyForce_pointLocal;\n\t\tlet worldForce = Body_applyForce_forceWorld;\n\t\tlet worldPoint = Body_applyForce_pointWorld;\n\t\tthis.vectorToWorldFrame(worldForce, localForce);\n\t\tthis.vectorToWorldFrame(worldPoint, localPoint);\n\t\tthis.applyForce(worldForce, worldPoint);\n\t}\n\n\t/**\n\t * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n\t * @method applyImpulse\n\t * @param  {Array} impulseVector The impulse vector to add, oriented in world space.\n\t * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let relativePoint = [0, 0]; // center of the body\n\t *     let impulseVector = [0, 1]; // world up\n\t *     body.applyImpulse(impulseVector, relativePoint);\n\t */\n\tapplyImpulse(impulseVector: Float32Array, relativePoint: Float32Array): void{\n\t\tlet Body_applyImpulse_velo = vec2.create(); // Was originally outside of this function. \n\n\t\tif(this.type !== Body.DYNAMIC){\n\t\t\treturn;\n\t\t}\n\n\t\t// Compute produced central impulse velocity\n\t\tlet velo = Body_applyImpulse_velo;\n\t\tvec2.scale(velo, impulseVector, this.invMass);\n\t\tvec2.multiply(velo, this.massMultiplier, velo);\n\n\t\t// Add linear impulse\n\t\tvec2.add(this.velocity, velo, this.velocity);\n\n\t\tif(relativePoint){\n\t\t\t// Compute produced rotational impulse velocity\n\t\t\tlet rotVelo = vec2.crossLength(relativePoint, impulseVector);\n\t\t\trotVelo *= this.invInertia;\n\n\t\t\t// Add rotational Impulse\n\t\t\tthis.angularVelocity += rotVelo;\n\t\t}\n\t}\n\n\t/**\n\t * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n\t * @method applyImpulseLocal\n\t * @param  {Array} localImpulse The impulse vector to add, oriented in local body space.\n\t * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.\n\t * @example\n\t *     let body = new Body({ mass: 1 });\n\t *     let localPoint = [1, 0]; // x=1, locally in the body\n\t *     let localImpulse = [0, 1]; // up, locally in the body\n\t *     body.applyImpulseLocal(localImpulse, localPoint);\n\t *     console.log(body.velocity); // [1, 0]\n\t *     console.log(body.angularVelocity); // 1\n\t */\n\tapplyImpulseLocal(localImpulse: Float32Array, localPoint: Float32Array): void {\n\t\t// Originally outside of this function.\n\t\tlet Body_applyImpulse_impulseWorld = vec2.create();\n\t\tlet Body_applyImpulse_pointWorld = vec2.create();\n\t\tlet Body_applyImpulse_pointLocal = vec2.create();\n\n\t\tlocalPoint = localPoint || Body_applyImpulse_pointLocal;\n\t\tlet worldImpulse = Body_applyImpulse_impulseWorld;\n\t\tlet worldPoint = Body_applyImpulse_pointWorld;\n\t\tthis.vectorToWorldFrame(worldImpulse, localImpulse);\n\t\tthis.vectorToWorldFrame(worldPoint, localPoint);\n\t\tthis.applyImpulse(worldImpulse, worldPoint);\n\t}\n\n\t/**\n\t * Transform a world point to local body frame.\n\t * @method toLocalFrame\n\t * @param  {Array} out          The point to store the result in\n\t * @param  {Array} worldPoint   The input world point\n\t */\n\ttoLocalFrame(out: Float32Array, worldPoint: Float32Array): void {\n\t\tvec2.toLocalFrame(out, worldPoint, this.position, this.angle);\n\t}\n\n\t/**\n\t * Transform a local point to world frame.\n\t * @method toWorldFrame\n\t * @param  {Array} out          The point to store the result in\n\t * @param  {Array} localPoint   The input local point\n\t */\n\ttoWorldFrame(out: Float32Array, localPoint: Float32Array): void {\n\t\tvec2.toGlobalFrame(out, localPoint, this.position, this.angle);\n\t}\n\n\t/**\n\t * Transform a world vector to local body frame.\n\t * @method vectorToLocalFrame\n\t * @param  {Array} out          The vector to store the result in\n\t * @param  {Array} worldVector  The input world vector\n\t */\n\tvectorToLocalFrame(out: Float32Array, worldVector: Float32Array): void {\n\t\tvec2.vectorToLocalFrame(out, worldVector, this.angle);\n\t}\n\n\t/**\n\t * Transform a local vector to world frame.\n\t * @method vectorToWorldFrame\n\t * @param  {Array} out          The vector to store the result in\n\t * @param  {Array} localVector  The input local vector\n\t */\n\tvectorToWorldFrame(out: Float32Array, localVector: Float32Array): void {\n\t\tvec2.rotate(out, localVector, this.angle);\n\t}\n\n\t/**\n\t * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.\n\t * @method fromPolygon\n\t * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.\n\t * @param {Object} [options]\n\t * @param {boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n\t * @param {boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.\n\t * @param {Number} [options.removeCollinearPoints=0] Set to a number (angle threshold value) to remove collinear points, or 0 to keep all points.\n\t * @return {boolean} True on success, else false.\n\t * @example\n\t *     let body = new Body();\n\t *     let path = [\n\t *         [-1, 1],\n\t *         [-1, 0],\n\t *         [1, 0],\n\t *         [1, 1],\n\t *         [0.5, 0.5]\n\t *     ];\n\t *     body.fromPolygon(path);\n\t *     console.log(body.shapes); // [Convex, Convex, ...]\n\t */\n\tfromPolygon(path: Float32Array[], options: BodyFromPolygonOptions|null): boolean {\n\t\t// Remove all shapes // TODO: this should really just be a method.\n\t\tfor(let i: i32 = this.shapes.length; i>=0; --i){\n\t\t\tthis.removeShape(this.shapes[i]);\n\t\t}\n\n\t\t// Copy the path\n\t\tlet p: Float32Array[] = [];\n\t\tfor(let i:u16=0; i<(path.length as u16); i++){\n\t\t\tp[i] = vec2.clone(path[i]);\n\t\t}\n\n\t\t// Make it counter-clockwise\n\t\tmakeCCW(p);\n\n\t\tif(options){\n\t\t\tif(options.removeCollinearPoints != 0){\n\t\t\t\tremoveCollinearPoints(p, options.removeCollinearPoints);\n\t\t\t}\n\n\t\t}\n\n\t\t// Check if any line segment intersects the path itself\n\t\tif(!options || !options.skipSimpleCheck){\n\t\t\tif(!isSimple(p)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Save this path for later\n\t\tthis.concavePath = [];\n\t\tfor(let i:u16=0; i<(p.length as u16); i++){\n\t\t\tthis.concavePath[i] = vec2.clone(p[i]);\n\t\t}\n\n\t\t// Slow or fast decomp?\n\t\tlet convexes: Array<Array<Float32Array>>;\n\t\tif(options && options.optimalDecomp){\n\t\t\tconvexes = decomp(p);\n\t\t} else {\n\t\t\tconvexes = quickDecomp(p);\n\t\t}\n\n\t\tlet cm = vec2.create();\n\n\t\t// Add convexes\n\t\tfor(let i: i32 = 0; i!==convexes.length; i++){\n\t\t\t// Create convex\n\t\t\tlet c = new Convex(0, convexes[i], null );\n\n\t\t\t// Move all vertices so its center of mass is in the local center of the convex\n\t\t\tfor(let j: i32 = 0; j < c.vertices.length; j++){\n\t\t\t\tlet v = c.vertices[j];\n\t\t\t\tvec2.subtract(v,v,c.centerOfMass);\n\t\t\t}\n\n\t\t\tvec2.copy(cm,c.centerOfMass);\n\n\t\t\tc = new Convex(0, c.vertices, null );\n\n\t\t\t// Add the shape\n\t\t\tthis.addShape(c,cm);\n\t\t}\n\n\t\tthis.adjustCenterOfMass();\n\n\t\tthis.aabbNeedsUpdate = true;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Moves the shape offsets so their center of mass becomes the body center of mass.\n\t * @method adjustCenterOfMass\n\t * @example\n\t *     let body = new Body({ position: [0, 0] });\n\t *     let shape = new Circle({ radius: 1 });\n\t *     body.addShape(shape, [1, 0], 0);\n\t *     body.adjustCenterOfMass();\n\t *     console.log(body.position); // [1, 0]\n\t *     console.log(shape.position); // [0, 0]\n\t */\n\tadjustCenterOfMass(): void {\n\n\t\tlet adjustCenterOfMass_tmp2 = vec2.create(),\n\t\t\tadjustCenterOfMass_tmp3 = vec2.create(),\n\t\t\tadjustCenterOfMass_tmp4 = vec2.create();\n\n\t\tlet offset_times_area = adjustCenterOfMass_tmp2,\n\t\t\tsum =               adjustCenterOfMass_tmp3,\n\t\t\tcm =                adjustCenterOfMass_tmp4,\n\t\t\ttotalArea =         0;\n\t\tvec2.set(sum,0,0);\n\n\t\tfor(let i: u16 = 0; i < (this.shapes.length as u16); i++){\n\t\t\tlet s = this.shapes[i];\n\t\t\tvec2.scale(offset_times_area, s.position, s.area);\n\t\t\tvec2.add(sum, sum, offset_times_area);\n\t\t\ttotalArea += s.area;\n\t\t}\n\n\t\tvec2.scale(cm,sum,1/totalArea);\n\n\t\t// Now move all shapes\n\t\tfor(let i: u16 = 0; i < (this.shapes.length as u16); i++){\n\t\t\tlet s = this.shapes[i];\n\t\t\tvec2.subtract(s.position, s.position, cm);\n\t\t}\n\n\t\t// Move the body position too\n\t\tvec2.add(this.position,this.position,cm);\n\n\t\t// And concave path\n\t\tif(this.concavePath){\n\t\t\tfor(let i: u16 = 0; i<(this.concavePath.length as u16); i++){\n\t\t\t\tvec2.subtract(this.concavePath[i], this.concavePath[i], cm);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateMassProperties();\n\t\tthis.updateBoundingRadius();\n\t}\n\n\t/**\n\t * Sets the force on the body to zero.\n\t * @method setZeroForce\n\t */\n\tsetZeroForce(): void {\n\t\tlet f = this.force;\n\t\tf[0] = f[1] = this.angularForce = 0;\n\t}\n\n\tresetConstraintVelocity(): void {\n\t\tlet b = this,\n\t\t\tvlambda = b.vlambda;\n\t\tvec2.set(vlambda,0,0);\n\t\tb.wlambda = 0;\n\t}\n\n\taddConstraintVelocity(): void {\n\t\tlet b = this,\n\t\t\tv = b.velocity;\n\t\tvec2.add( v, v, b.vlambda);\n\t\tb.angularVelocity += b.wlambda;\n\t}\n\n\t/**\n\t * Apply damping, see <a href=\"http://code.google.com/p/bullet/issues/detail?id=74\">this</a> for details.\n\t * @method applyDamping\n\t * @param  {number} dt Current time step\n\t */\n\tapplyDamping(dt: f32): void {\n\t\tif(this.type === Body.DYNAMIC){ // Only for dynamic bodies\n\t\t\tlet v = this.velocity;\n\t\t\tvec2.scale(v, v, Mathf.pow(1 - this.damping,dt));\n\t\t\tthis.angularVelocity *= Mathf.pow(1 - this.angularDamping,dt);\n\t\t}\n\t}\n\n\t/**\n\t * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.\n\t * Sets the sleepState to {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.\n\t * @method wakeUp\n\t */\n\twakeUp(): void {\n\t\tlet s = this.sleepState;\n\t\tthis.sleepState = Body.AWAKE;\n\t\tthis.idleTime = 0;\n\t\tif(s !== Body.AWAKE){\n\t\t\tsuper.emit(wakeUpEvent);\n\t\t}\n\t}\n\n\t/**\n\t * Force body sleep\n\t * @method sleep\n\t */\n\tsleep(): void {\n\t\tthis.sleepState = Body.SLEEPING;\n\t\tthis.angularVelocity = this.angularForce = 0;\n\t\tvec2.set(this.velocity,0,0);\n\t\tvec2.set(this.force,0,0);\n\t\tsuper.emit(sleepEvent);\n\t}\n\n\t/**\n\t * Called every timestep to update internal sleep timer and change sleep state if needed.\n\t * @method sleepTick\n\t * @param {number} time The world time in seconds\n\t * @param {boolean} dontSleep\n\t * @param {number} dt\n\t */\n\tsleepTick(time: f32, dontSleep: boolean, dt: f32): void {\n\t\tif(!this.allowSleep || this.type === Body.SLEEPING){\n\t\t\treturn;\n\t\t}\n\n\t\tthis.wantsToSleep = false;\n\n\t\tlet speedSquared = vec2.squaredLength(this.velocity) + Mathf.pow(this.angularVelocity,2),\n\t\t\tspeedLimitSquared = Mathf.pow(this.sleepSpeedLimit,2);\n\n\t\t// Add to idle time\n\t\tif(speedSquared >= speedLimitSquared){\n\t\t\tthis.idleTime = 0;\n\t\t\tthis.sleepState = Body.AWAKE;\n\t\t} else {\n\t\t\tthis.idleTime += dt;\n\t\t\tif(this.sleepState !== Body.SLEEPY){\n\t\t\t\tthis.sleepState = Body.SLEEPY;\n\t\t\t\tsuper.emit(sleepyEvent);\n\t\t\t}\n\t\t}\n\n\t\tif(this.idleTime > this.sleepTimeLimit){\n\t\t\tif(!dontSleep){\n\t\t\t\tthis.sleep();\n\t\t\t} else {\n\t\t\t\tthis.wantsToSleep = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.\n\t * @method overlaps\n\t * @param  {Body} body\n\t * @return {boolean}\n\t */\n\toverlaps(body: Body): boolean{\n\t\tif(!this.world) return false;\n\t\treturn this.world.overlapKeeper.bodiesAreOverlapping(this, body);\n\t}\n\n\t/**\n\t * Move the body forward in time given its current velocity.\n\t * @method integrate\n\t * @param  {Number} dt\n\t */\n\tintegrate(dt: f32): void{\n\n\t\tlet minv = this.invMass,\n\t\t\tf = this.force,\n\t\t\tpos = this.position,\n\t\t\tvelo = this.velocity;\n\n\t\t// Save old position\n\t\tvec2.copy(this.previousPosition, this.position);\n\t\tthis.previousAngle = this.angle;\n\n\t\t// Velocity update\n\t\tif(!this.fixedRotation){\n\t\t\tthis.angularVelocity += this.angularForce * this.invInertia * dt;\n\t\t}\n\t\tvec2.scale(integrate_fhMinv, f, dt * minv);\n\t\tvec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);\n\t\tvec2.add(velo, integrate_fhMinv, velo);\n\n\t\t// CCD\n\t\tif(!this.integrateToTimeOfImpact(dt)){\n\n\t\t\t// Regular position update\n\t\t\tvec2.scale(integrate_velodt, velo, dt);\n\t\t\tvec2.add(pos, pos, integrate_velodt);\n\t\t\tif(!this.fixedRotation){\n\t\t\t\tthis.angle += this.angularVelocity * dt;\n\t\t\t}\n\t\t}\n\n\t\tthis.aabbNeedsUpdate = true;\n\t}\n\n\tintegrateToTimeOfImpact(dt: f32): boolean{\n\n\t\tif(!this.world) return false;\n\t\tlet world = this.world!;\n\n\t\tlet result = new RaycastResult();\n\t\tlet rOpts = new RayOptions();\n\t\trOpts.mode = Ray.CLOSEST;\n\t\trOpts.skipBackfaces = true;\n\t\tlet ray = new Ray(rOpts);\n\n\t\tlet direction = vec2.create();\n\t\tlet end = vec2.create();\n\t\tlet startToEnd = vec2.create();\n\t\tlet rememberPosition = vec2.create();\n\n\t\tif(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < this.ccdSpeedThreshold*this.ccdSpeedThreshold){\n\t\t\treturn false;\n\t\t}\n\n\t\t// Ignore all the ignored body pairs\n\t\t// This should probably be done somewhere else for optimization\n\t\tlet ignoreBodies: Body[] = [];\n\t\tlet disabledPairs: Body[] = world.disabledBodyCollisionPairs;\n\t\tfor(let i: i32 = 0; i<disabledPairs.length; i+=2){\n\t\t\tlet bodyA: Body = disabledPairs[i];\n\t\t\tlet bodyB: Body = disabledPairs[i+1];\n\t\t\tif(bodyA === this){\n\t\t\t\tignoreBodies.push(bodyB);\n\t\t\t} else if(bodyB === this){\n\t\t\t\tignoreBodies.push(bodyA);\n\t\t\t}\n\t\t}\n\n\t\tvec2.normalize(direction, this.velocity);\n\n\t\tvec2.scale(end, this.velocity, dt);\n\t\tvec2.add(end, end, this.position);\n\n\t\tvec2.subtract(startToEnd, end, this.position);\n\t\tlet startToEndAngle: f32 = this.angularVelocity * dt;\n\t\tlet len: f32 = vec2.length(startToEnd);\n\n\t\tlet timeOfImpact: f32 = 1;\n\n\t\tlet hitBody: Body|null = null;\n\t\tvec2.copy(ray.from, this.position);\n\t\tvec2.copy(ray.to, end);\n\t\tray.update();\n\t\tfor(let i: i32 = 0; i<this.shapes.length; i++){\n\t\t\tlet shape = this.shapes[i];\n\t\t\tresult.reset();\n\t\t\tray.collisionGroup = shape.collisionGroup;\n\t\t\tray.collisionMask = shape.collisionMask;\n\t\t\tworld.raycast(result, ray);\n\t\t\thitBody = result.body;\n\t\t\tif(!hitBody) continue;\n\n\t\t\tif(hitBody === this || ignoreBodies.indexOf(hitBody) !== -1){\n\t\t\t\thitBody = null;\n\t\t\t}\n\n\t\t\tif(hitBody){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!hitBody || !timeOfImpact){\n\t\t\treturn false;\n\t\t}\n\t\tresult.getHitPoint(end, ray);\n\t\tvec2.subtract(startToEnd, end, this.position);\n\t\ttimeOfImpact = vec2.distance(end, this.position) / len; // guess\n\n\t\tlet rememberAngle = this.angle;\n\t\tvec2.copy(rememberPosition, this.position);\n\n\t\t// Got a start and end point. Approximate time of impact using binary search\n\t\tlet iter: i32 = 0;\n\t\tlet tmin: f32 = 0;\n\t\tlet tmid: f32 = timeOfImpact;\n\t\tlet tmax: f32 = 1;\n\t\twhile (tmax >= tmin && iter < this.ccdIterations) {\n\t\t\titer++;\n\n\t\t\t// calculate the midpoint\n\t\t\ttmid = (tmax + tmin) / 2;\n\n\t\t\t// Move the body to that point\n\t\t\tvec2.scale(integrate_velodt, startToEnd, tmid);\n\t\t\tvec2.add(this.position, rememberPosition, integrate_velodt);\n\t\t\tthis.angle = rememberAngle + startToEndAngle * tmid;\n\t\t\tthis.updateAABB();\n\n\t\t\t// check overlap\n\t\t\tlet overlaps = this.aabb.overlaps(hitBody.aabb) && world.narrowphase.bodiesOverlap(this, hitBody, true);\n\n\t\t\tif (overlaps) {\n\t\t\t\t// change max to search lower interval\n\t\t\t\ttmax = tmid;\n\t\t\t} else {\n\t\t\t\t// change min to search upper interval\n\t\t\t\ttmin = tmid;\n\t\t\t}\n\t\t}\n\n\t\ttimeOfImpact = tmax; // Need to guarantee overlap to resolve collisions\n\n\t\tvec2.copy(this.position, rememberPosition);\n\t\tthis.angle = rememberAngle;\n\n\t\t// move to TOI\n\t\tvec2.scale(integrate_velodt, startToEnd, timeOfImpact);\n\t\tvec2.add(this.position, this.position, integrate_velodt);\n\t\tif(!this.fixedRotation){\n\t\t\tthis.angle += startToEndAngle * timeOfImpact;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Get velocity of a point in the body.\n\t * @method getVelocityAtPoint\n\t * @param  {Array} result A vector to store the result in\n\t * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from\n\t * @return {Array} The result vector\n\t * @example\n\t *     let body = new Body({\n\t *         mass: 1,\n\t *         velocity: [1, 0],\n\t *         angularVelocity: 1\n\t *     });\n\t *     let result = [];\n\t *     let point = [1, 0];\n\t *     body.getVelocityAtPoint(result, point);\n\t *     console.log(result); // [1, 1]\n\t */\n\tgetVelocityAtPoint(result: Float32Array, relativePoint: Float32Array): Float32Array{\n\t\tvec2.crossVZ(result, relativePoint, this.angularVelocity);\n\t\tvec2.subtract(result, this.velocity, result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Dynamic body.\n\t * @property DYNAMIC\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic DYNAMIC: u16 = 1;\n\n\t/**\n\t * Static body.\n\t * @property STATIC\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic STATIC: u16 = 2;\n\n\t/**\n\t * Kinematic body.\n\t * @property KINEMATIC\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic KINEMATIC: u16 = 4;\n\n\t/**\n\t * @property AWAKE\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic AWAKE: u16 = 0;\n\n\t/**\n\t * @property SLEEPY\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic SLEEPY: u16 = 1;\n\n\t/**\n\t * @property SLEEPING\n\t * @type {Number}\n\t * @static\n\t */\n\tstatic SLEEPING: u16 = 2;\n}\n\n\n/**\n * @event sleepy\n */\nclass SleepyEvent extends EventArgument {\n\tconstructor(){\n\t\tsuper(\"sleepy\");\n\t}\n};\n\n/**\n * @event sleep\n */\nclass SleepEvent extends EventArgument {\n\tconstructor(){\n\t\tsuper(\"sleep\");\n\t}\n};\n\n/**\n * @event wakeup\n */\nclass WakeUpEvent extends EventArgument {\n\tconstructor(){\n\t\tsuper(\"wakeup\");\n\t}\n};\n\nconst sleepyEvent = new SleepyEvent();\nconst sleepEvent = new SleepEvent();\nconst wakeUpEvent = new WakeUpEvent();\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Body from \"../objects/body\";\nimport RaycastResult from \"./raycast-result\";\nimport Shape from \"../shapes/shape\";\nimport AABB from \"./aabb\";\n\nvar intersectBody_worldPosition = vec2.create();\n\nvar  v0 = vec2.create(),\n\tintersect = vec2.create();\n\nvar doNothing = function(result: RaycastResult): void{}\n\nexport class RayOptions{\n\tfrom: Float32Array|null;\n\tto: Float32Array|null;\n\tcheckCollisionResponse: boolean = true;\n\tskipBackfaces: boolean = false;\n\tcollisionMask: i16 = -1;\n\tcollisionGroup: i16 = -1;\n\tmode: u16 = Ray.ANY;\n\tcallback: (result: RaycastResult)=>void = doNothing;\n}\n\nexport default class Ray{\n\t/**\n\t * Ray start point.\n\t * @property {array} from\n\t */\n\tpublic from: Float32Array = vec2.create();\n\n\t/**\n\t * Ray end point\n\t * @property {array} to\n\t */\n\tpublic to: Float32Array = vec2.create();\n\n\t/**\n\t * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n\t * @property {boolean} checkCollisionResponse\n\t */\n\tpublic checkCollisionResponse: boolean = true;\n\n\t/**\n\t * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n\t * @property {boolean} skipBackfaces\n\t */\n\tpublic skipBackfaces: boolean = false;\n\n\t/**\n\t * @property {number} collisionMask\n\t * @default -1\n\t */\n\tpublic collisionMask: i16;\n\n\t/**\n\t * @property {number} collisionGroup\n\t * @default -1\n\t */\n\tpublic collisionGroup: i16;\n\n\t/**\n\t * The intersection mode. Should be {{#crossLink \"Ray/ANY:property\"}}Ray.ANY{{/crossLink}}, {{#crossLink \"Ray/ALL:property\"}}Ray.ALL{{/crossLink}} or {{#crossLink \"Ray/CLOSEST:property\"}}Ray.CLOSEST{{/crossLink}}.\n\t * @property {number} mode\n\t */\n\tpublic mode: u16;\n\n\t/**\n\t * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n\t * @property {Function} callback\n\t */\n\tpublic callback: (result: RaycastResult)=>void = function(){};\n\n\t/**\n\t * @readOnly\n\t * @property {array} direction\n\t */\n\tpublic direction: Float32Array = vec2.create();\n\n\t/**\n\t * Length of the ray\n\t * @readOnly\n\t * @property {number} length\n\t */\n\tpublic length: f32 = 1;\n\n\tprivate _currentShape: Shape|null = null;\n\tprivate _currentBody: Body|null = null;\n\n\t/**\n\t * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink \"World/raycast:method\"}}World.raycast{{/crossLink}}\n\t * @class Ray\n\t * @constructor\n\t * @param {object} [options]\n\t * @param {array} [options.from]\n\t * @param {array} [options.to]\n\t * @param {boolean} [options.checkCollisionResponse=true]\n\t * @param {boolean} [options.skipBackfaces=false]\n\t * @param {number} [options.collisionMask=-1]\n\t * @param {number} [options.collisionGroup=-1]\n\t * @param {number} [options.mode=Ray.ANY]\n\t * @param {Function} [options.callback]\n\t */\n\tconstructor(options: RayOptions|null){\n\n\t\tif(options){\n\t\t\tthis.from = options.from ? vec2.copy(this.from, options.from!) : vec2.create();\n\t\t\tthis.to = options.to ? vec2.copy(this.to, options.to!) : vec2.create();\n\t\t\tthis.checkCollisionResponse = options.checkCollisionResponse;\n\t\t\tthis.skipBackfaces = options.skipBackfaces;\n\t\t\tthis.collisionMask = options.collisionMask;\n\t\t\tthis.collisionGroup = options.collisionGroup;\n\t\t\tthis.mode = options.mode;\n\t\t\tthis.callback = options.callback;\n\t\t}\n\t\telse{\n\t\t\tthis.from = vec2.create();\n\t\t\tthis.to = vec2.create();\n\t\t}\n\n\t\tthis.update();\n\t}\n\n\t/**\n\t * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.\n\t * @static\n\t * @property {Number} CLOSEST\n\t */\n\tstatic CLOSEST: u16 = 1;\n\n\t/**\n\t * This raycasting mode will make the Ray stop when it finds the first intersection point.\n\t * @static\n\t * @property {Number} ANY\n\t */\n\tstatic ANY: u16 = 2;\n\n\t/**\n\t * This raycasting mode will traverse all intersection points and executes a callback for each one.\n\t * @static\n\t * @property {Number} ALL\n\t */\n\tstatic ALL: u16 = 4;\n\n\t/**\n\t * Should be called if you change the from or to point.\n\t * @method update\n\t */\n\tupdate(): void{\n\n\t\t// Update .direction and .length\n\t\tvar d = this.direction;\n\t\tvec2.subtract(d, this.to, this.from);\n\t\tthis.length = vec2.length(d);\n\t\tvec2.normalize(d, d);\n\n\t};\n\n\t/**\n\t * @method intersectBodies\n\t * @param {Array} bodies An array of Body objects.\n\t */\n\tintersectBodies (result: RaycastResult, bodies: Body[]): void {\n\t\tfor (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {\n\t\t\tvar body = bodies[i];\n\t\t\tvar aabb = body.getAABB();\n\t\t\tif(aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)){\n\t\t\t\tthis.intersectBody(result, body);\n\t\t\t}\n\t\t}\n\t};\n\n\t\n\n\t/**\n\t * Shoot a ray at a body, get back information about the hit.\n\t * @method intersectBody\n\t * @private\n\t * @param {Body} body\n\t */\n\tintersectBody (result: RaycastResult, body: Body): void {\n\t\tvar checkCollisionResponse = this.checkCollisionResponse;\n\n\t\tif(checkCollisionResponse && !body.collisionResponse){\n\t\t\treturn;\n\t\t}\n\n\t\tvar worldPosition = intersectBody_worldPosition;\n\n\t\tfor (var i = 0, N = body.shapes.length; i < N; i++) {\n\t\t\tvar shape = body.shapes[i];\n\n\t\t\tif(checkCollisionResponse && !shape.collisionResponse){\n\t\t\t\tcontinue; // Skip\n\t\t\t}\n\n\t\t\tif((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get world angle and position of the shape\n\t\t\tvec2.rotate(worldPosition, shape.position, body.angle);\n\t\t\tvec2.add(worldPosition, worldPosition, body.position);\n\t\t\tvar worldAngle = shape.angle + body.angle;\n\n\t\t\tthis.intersectShape(\n\t\t\t\tresult,\n\t\t\t\tshape,\n\t\t\t\tworldAngle,\n\t\t\t\tworldPosition,\n\t\t\t\tbody\n\t\t\t);\n\n\t\t\tif(result.shouldStop(this)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @method intersectShape\n\t * @private\n\t * @param {Shape} shape\n\t * @param {number} angle\n\t * @param {array} position\n\t * @param {Body} body\n\t */\n\tintersectShape(result: RaycastResult, shape: Shape, angle: f32, position: Float32Array, body: Body): void{\n\t\tvar from = this.from;\n\n\t\t// Checking radius\n\t\tvar distance = distanceFromIntersectionSquared(from, this.direction, position);\n\t\tif (distance > shape.boundingRadius * shape.boundingRadius) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._currentBody = body;\n\t\tthis._currentShape = shape;\n\n\t\tshape.raycast(result, this, position, angle);\n\n\t\tthis._currentBody = null;\n\t\tthis._currentShape = null;\n\t};\n\n\t/**\n\t * Get the AABB of the ray.\n\t * @method getAABB\n\t * @param  {AABB} aabb\n\t */\n\tgetAABB(result: AABB): void{\n\t\tvar to = this.to;\n\t\tvar from = this.from;\n\t\tvec2.set(\n\t\t\tresult.lowerBound,\n\t\t\tMathf.min(to[0], from[0]),\n\t\t\tMathf.min(to[1], from[1])\n\t\t);\n\t\tvec2.set(\n\t\t\tresult.upperBound,\n\t\t\tMathf.max(to[0], from[0]),\n\t\t\tMathf.max(to[1], from[1])\n\t\t);\n\t};\n\n\t/**\n\t * @method reportIntersection\n\t * @private\n\t * @param  {number} fraction\n\t * @param  {array} normal\n\t * @param  {number} [faceIndex=-1]\n\t * @return {boolean} True if the intersections should continue // This never returned anything.\n\t */\n\treportIntersection(result: RaycastResult, fraction: f32, normal: Float32Array, faceIndex: u32): void{\n\t\tvar shape = this._currentShape as Shape;\n\t\tvar body = this._currentBody as Body;\n\n\t\t// Skip back faces?\n\t\tif(this.skipBackfaces && vec2.dot(normal, this.direction) > 0){\n\t\t\treturn;\n\t\t}\n\n\t\tswitch(this.mode){\n\n\t\tcase Ray.ALL:\n\t\t\tresult.set(\n\t\t\t\tnormal,\n\t\t\t\tshape,\n\t\t\t\tbody,\n\t\t\t\tfraction,\n\t\t\t\tfaceIndex\n\t\t\t);\n\t\t\tthis.callback(result);\n\t\t\tbreak;\n\n\t\tcase Ray.CLOSEST:\n\n\t\t\t// Store if closer than current closest\n\t\t\tif(fraction < result.fraction || !result.hasHit()){\n\t\t\t\tresult.set(\n\t\t\t\t\tnormal,\n\t\t\t\t\tshape,\n\t\t\t\t\tbody,\n\t\t\t\t\tfraction,\n\t\t\t\t\tfaceIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Ray.ANY:\n\n\t\t\t// Report and stop.\n\t\t\tresult.set(\n\t\t\t\tnormal,\n\t\t\t\tshape,\n\t\t\t\tbody,\n\t\t\t\tfraction,\n\t\t\t\tfaceIndex\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t};\n\n\n}\n\nfunction distanceFromIntersectionSquared(from: Float32Array, direction: Float32Array, position: Float32Array): f32 {\n\n\t// v0 is vector from from to position\n\tvec2.subtract(v0, position, from);\n\tlet dot = vec2.dot(v0, direction);\n\n\t// intersect = direction * dot + from\n\tvec2.scale(intersect, direction, dot);\n\tvec2.add(intersect, intersect, from);\n\n\treturn vec2.squaredDistance(position, intersect);\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"../objects/body\";\nimport vec2 from \"../math/vec2\";\nimport Utils from \"../utils/utils\";\n\nexport default class Equation{\n\n\t/**\n\t * Minimum force to apply when solving.\n\t * @property minForce\n\t * @type {Number}\n\t */\n\tpublic minForce: f32;\n\n\t/**\n\t * Max force to apply when solving.\n\t * @property maxForce\n\t * @type {Number}\n\t */\n\tpublic maxForce: f32;\n\n\t/**\n\t * Cap the constraint violation (G*q) to this value.\n\t * @property maxBias\n\t * @type {Number}\n\t */\n\tpublic maxBias: f32 = Infinity;\n\n\t/**\n\t * First body participating in the constraint\n\t * @property bodyA\n\t * @type {Body}\n\t */\n\tpublic bodyA: Body|null;\n\n\t/**\n\t * Second body participating in the constraint\n\t * @property bodyB\n\t * @type {Body}\n\t */\n\tpublic bodyB: Body|null;\n\n\t/**\n\t * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n\t * @property stiffness\n\t * @type {Number}\n\t */\n\tpublic stiffness: f32 = Equation.DEFAULT_STIFFNESS;\n\n\t/**\n\t * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n\t * @property relaxation\n\t * @type {Number}\n\t */\n\tpublic relaxation: f32 = Equation.DEFAULT_RELAXATION;\n\n\t/**\n\t * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n\t * @property G\n\t * @type {Array}\n\t */\n\tpublic G: Float32Array;\n\n\tpublic offset: f32 = 0;\n\n\tpublic a: f32 = 0;\n\tpublic b: f32 = 0;\n\tpublic epsilon: f32 = 0;\n\tpublic timeStep: f32 = 1/60;\n\n\t/**\n\t * Indicates if stiffness or relaxation was changed.\n\t * @property {boolean} needsUpdate\n\t */\n\tpublic needsUpdate: boolean = true;\n\n\t/**\n\t * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n\t * @property multiplier\n\t * @type {Number}\n\t */\n\tpublic multiplier: f32 = 0;\n\n\t/**\n\t * Relative velocity.\n\t * @property {Number} relativeVelocity\n\t */\n\tpublic relativeVelocity: f32 = 0;\n\n\t/**\n\t * Whether this equation is enabled or not. If true, it will be added to the solver.\n\t * @property {boolean} enabled\n\t */\n\tpublic enabled: boolean = true;\n\n\t// Temp stuff\n\tmaxForceDt: f32 = 0;\n\tminForceDt: f32 = 0;\n\tinvC: f32 = 0;\n\tB: f32 = 0;\n\tlambda: f32 = 0;\n\tindex: i32 = -1;\n\n\t/**\n\t * Base class for constraint equations.\n\t * @class Equation\n\t * @constructor\n\t * @param {Body} bodyA First body participating in the equation\n\t * @param {Body} bodyB Second body participating in the equation\n\t * @param {number} minForce Minimum force to apply. Default: -Infinity\n\t * @param {number} maxForce Maximum force to apply. Default: Infinity\n\t */\n\tconstructor(bodyA: Body|null, bodyB: Body|null, minForce: f32, maxForce: f32){\n\n\t\t// f32 is not nullable in assemblyscript.....\n\t\t// this.minForce = minForce == null ? -Infinity : minForce;\n\t\t// this.maxForce = maxForce == null ? Infinity : maxForce;\n\t\tthis.minForce = minForce;\n\t\tthis.maxForce = maxForce;\n\t\tthis.maxBias = Infinity;\n\t\tthis.bodyA = bodyA || null;\n\t\tthis.bodyB = bodyB || null;\n\t\tthis.stiffness = Equation.DEFAULT_STIFFNESS;\n\t\tthis.relaxation = Equation.DEFAULT_RELAXATION;\n\t\tthis.G = new Float32Array(6);\n\t\tfor(let i: u16 = 0; i < 6; i++){\n\t\t\tthis.G[i] = 0;\n\t\t}\n\t}\n\n\tcomputeGq(): f32 {\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar ai = bi.angle,\n\t\t\taj = bj.angle;\n\t\n\t\tvar qi = vec2.create(),\n\t\t\tqj = vec2.create()\n\t\treturn this.gmult(G, qi, ai, qj, aj) + this.offset;\n\t}\n\n\t/**\n\t * The default stiffness when creating a new Equation.\n\t * @static\n\t * @property {Number} DEFAULT_STIFFNESS\n\t * @default 1e6\n\t */\n\tstatic DEFAULT_STIFFNESS:f32 = 1e6;\n\n\t/**\n\t * The default relaxation when creating a new Equation.\n\t * @static\n\t * @property {Number} DEFAULT_RELAXATION\n\t * @default 4\n\t */\n\tstatic DEFAULT_RELAXATION:f32 = 4;\n\n\n\t/**\n\t * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href=\"http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\">SPOOK notes</a>.\n\t * @method update\n\t */\n\tupdate(): void{\n\t\tvar k = this.stiffness,\n\t\t\td = this.relaxation,\n\t\t\th = this.timeStep;\n\n\t\tthis.a = 4 / (h * (1 + 4 * d));\n\t\tthis.b = (4 * d) / (1 + 4 * d);\n\t\tthis.epsilon = 4 / (h * h * k * (1 + 4 * d));\n\n\t\tthis.needsUpdate = false;\n\t}\n\n\t/**\n\t * Multiply a jacobian entry with corresponding positions or velocities\n\t * @method gmult\n\t * @return {Number}\n\t */\n\tgmult(G: Float32Array,vi: Float32Array,wi: f32,vj: Float32Array,wj: f32): f32{\n\t\treturn  G[0] * vi[0] +\n\t\t\t\tG[1] * vi[1] +\n\t\t\t\tG[2] * wi +\n\t\t\t\tG[3] * vj[0] +\n\t\t\t\tG[4] * vj[1] +\n\t\t\t\tG[5] * wj;\n\t}\n\n\t/**\n\t * Computes the RHS of the SPOOK equation\n\t * @method computeB\n\t * @return {Number}\n\t */\n\tcomputeB(a: f32,b: f32,h: f32): f32{\n\t\tlet GW: f32 = this.computeGW();\n\t\tlet Gq: f32 = this.computeGq();\n\t\tlet maxBias = this.maxBias;\n\t\tif(Math.abs(Gq) > maxBias){\n\t\t\tGq = Gq > 0 ? maxBias : -maxBias;\n\t\t}\n\t\tlet GiMf = this.computeGiMf();\n\t\tlet B = - Gq * a - GW * b - GiMf * h;\n\t\treturn B;\n\t}\n\n\t/**\n\t * Computes G\\*W, where W are the body velocities\n\t * @method computeGW\n\t * @return {Number}\n\t */\n\tcomputeGW(): f32{\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar vi = bi.velocity,\n\t\t\tvj = bj.velocity,\n\t\t\twi = bi.angularVelocity,\n\t\t\twj = bj.angularVelocity;\n\t\treturn this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;\n\t}\n\n\t/**\n\t * Computes G\\*Wlambda, where W are the body velocities\n\t * @method computeGWlambda\n\t * @return {Number}\n\t */\n\tcomputeGWlambda(): f32{\n\t\tvar G = this.G,\n\t\t\tbi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar vi = bi.vlambda,\n\t\t\tvj = bj.vlambda,\n\t\t\twi = bi.wlambda,\n\t\t\twj = bj.wlambda;\n\t\treturn this.gmult(G,vi,wi,vj,wj);\n\t}\n\n\t/**\n\t * Computes G\\*inv(M)\\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n\t * @method computeGiMf\n\t * @return {Number}\n\t */\n\tcomputeGiMf(): f32{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar fi = bi.force,\n\t\t\tti = bi.angularForce,\n\t\t\tfj = bj.force,\n\t\t\ttj = bj.angularForce,\n\t\t\tinvMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\tvar iMfi = vec2.create(),\n\t\t\tiMfj = vec2.create();\n\n\t\tvec2.scale(iMfi, fi, invMassi);\n\t\tvec2.multiply(iMfi, bi.massMultiplier, iMfi);\n\t\tvec2.scale(iMfj, fj,invMassj);\n\t\tvec2.multiply(iMfj, bj.massMultiplier, iMfj);\n\n\t\treturn this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);\n\t}\n\n\t/**\n\t * Computes G\\*inv(M)\\*G'\n\t * @method computeGiMGt\n\t * @return {Number}\n\t */\n\tcomputeGiMGt(): f32{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return 0;\n\t\tvar invMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\treturn  G[0] * G[0] * invMassi * bi.massMultiplier[0] +\n\t\t\t\tG[1] * G[1] * invMassi * bi.massMultiplier[1] +\n\t\t\t\tG[2] * G[2] *    invIi +\n\t\t\t\tG[3] * G[3] * invMassj * bj.massMultiplier[0] +\n\t\t\t\tG[4] * G[4] * invMassj * bj.massMultiplier[1] +\n\t\t\t\tG[5] * G[5] *    invIj;\n\t}\n\n\tupdateJacobian(): void{};\n\n\t/**\n\t * Add constraint velocity to the bodies.\n\t * @method addToWlambda\n\t * @param {Number} deltalambda\n\t */\n\taddToWlambda(deltalambda: f32): void{\n\t\tvar bi = this.bodyA,\n\t\t\tbj = this.bodyB;\n\t\tif(!bi || ! bj) return;\n\t\tvar invMassi = bi.invMassSolve,\n\t\t\tinvMassj = bj.invMassSolve,\n\t\t\tinvIi = bi.invInertiaSolve,\n\t\t\tinvIj = bj.invInertiaSolve,\n\t\t\tG = this.G;\n\n\t\t// v_lambda = G * inv(M) * delta_lambda\n\n\t\taddToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);\n\t\tbi.wlambda += invIi * G[2] * deltalambda;\n\n\t\taddToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);\n\t\tbj.wlambda += invIj * G[5] * deltalambda;\n\t}\n\n\t/**\n\t * Compute the denominator part of the SPOOK equation: C = G\\*inv(M)\\*G' + eps\n\t * @method computeInvC\n\t * @param  {Number} eps\n\t * @return {Number}\n\t */\n\tcomputeInvC(eps: f32): f32{\n\t\tvar invC: f32 = 1.0 / (this.computeGiMGt() + eps);\n\t\treturn invC;\n\t}\n\n}\n\nfunction addToVLambda(vlambda: Float32Array, Gx: f32, Gy: f32, invMass: f32, deltalambda: f32, massMultiplier: Float32Array): void{\n\tvlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];\n\tvlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Body from \"../objects/body\";\nimport Constraint from \"./constraint\";\nimport { ConstraintOptions } from \"./constraint\";\nimport Equation from \"../equations/equation\";\nimport DistanceEquation from \"../equations/distance-equation\";\n\nvar n = vec2.create();\nvar ri = vec2.create(); // worldAnchorA\nvar rj = vec2.create(); // worldAnchorB\n\nexport class DistanceConstraintOptions extends ConstraintOptions{\n\tlocalAnchorA: Float32Array|null = null;\n\tlocalAnchorB: Float32Array|null = null;\n\tdistance: f32 = 0;\n\tmaxForce: f32 = Infinity;\n}\n\nexport default class DistanceConstraint extends Constraint{\n\t/**\n\t * Local anchor in body A.\n\t * @property localAnchorA\n\t * @type {Array}\n\t */\n\tlocalAnchorA: Float32Array = vec2.create();\n\t/**\n\t * Local anchor in body B.\n\t * @property localAnchorB\n\t * @type {Array}\n\t */\n\tlocalAnchorB: Float32Array = vec2.create();\n\t/**\n\t * The distance to keep.\n\t * @property distance\n\t * @type {Number}\n\t */\n\tdistance: f32 = 0;\n\t/**\n\t * Max force to apply.\n\t * @property {number} maxForce\n\t */\n\tmaxForce: f32 = Infinity;\n\t/**\n\t * If the upper limit is enabled or not.\n\t * @property {boolean} upperLimitEnabled\n\t */\n\tupperLimitEnabled: boolean = false;\n\t/**\n\t * The upper constraint limit.\n\t * @property {number} upperLimit\n\t */\n\tupperLimit: f32 = 1;\n\t/**\n\t * If the lower limit is enabled or not.\n\t * @property {boolean} lowerLimitEnabled\n\t */\n\tlowerLimitEnabled: boolean = false;\n\t/**\n\t * The lower constraint limit.\n\t * @property {number} lowerLimit\n\t */\n\tlowerLimit: f32 = 0;\n\t/**\n\t * Current constraint position. This is equal to the current distance between the world anchor points.\n\t * @property {number} position\n\t */\n\tposition: f32 = 0;\n\n\t// this.upperLimitEnabled = false;\n\t// this.upperLimit = 1;\n\t// this.lowerLimitEnabled = false;\n\t// this.lowerLimit = 0;\n\t// this.position = 0;\n\n\t/**\n\t * Constraint that tries to keep the distance between two bodies constant.\n\t *\n\t * @class DistanceConstraint\n\t * @constructor\n\t * @author schteppe\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {object} [options]\n\t * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.\n\t * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].\n\t * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].\n\t * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.\n\t * @extends Constraint\n\t *\n\t * @example\n\t *     // If distance is not given as an option, then the current distance between the bodies is used.\n\t *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.\n\t *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n\t *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n\t *     var constraint = new DistanceConstraint(bodyA, bodyB);\n\t *     world.addConstraint(constraint);\n\t *\n\t * @example\n\t *     // Manually set the distance and anchors\n\t *     var constraint = new DistanceConstraint(bodyA, bodyB, {\n\t *         distance: 1,          // Distance to keep between the points\n\t *         localAnchorA: [1, 0], // Point on bodyA\n\t *         localAnchorB: [-1, 0] // Point on bodyB\n\t *     });\n\t *     world.addConstraint(constraint);\n\t */\n\tconstructor(bodyA: Body, bodyB: Body, options: DistanceConstraintOptions){\n\t\tsuper(bodyA,bodyB,Constraint.DISTANCE, options);\n\n\t\tif(options){\n\t\t\tif(options.localAnchorA) vec2.copy(this.localAnchorA, options.localAnchorA!);\n\t\t\tif(options.localAnchorB) vec2.copy(this.localAnchorB, options.localAnchorB!);\n\t\t\tthis.distance = options.distance;\n\t\t\tthis.maxForce = options.maxForce;\t\n\t\t}\n\n\t\tif(this.distance == -1){\n\t\t\t// Use the current world distance between the world anchor points.\n\t\t\tlet worldAnchorA = vec2.create(),\n\t\t\t\tworldAnchorB = vec2.create(),\n\t\t\t\tr = vec2.create();\n\n\t\t\t// Transform local anchors to world\n\t\t\tvec2.rotate(worldAnchorA, this.localAnchorA, bodyA.angle);\n\t\t\tvec2.rotate(worldAnchorB, this.localAnchorB, bodyB.angle);\n\n\t\t\tvec2.add(r, bodyB.position, worldAnchorB);\n\t\t\tvec2.subtract(r, r, worldAnchorA);\n\t\t\tvec2.subtract(r, r, bodyA.position);\n\n\t\t\tthis.distance = vec2.length(r);\n\t\t}\n\n\t\tlet normal = new DistanceEquation(this, bodyA,bodyB,-this.maxForce,this.maxForce); // Just in the normal direction\n\t\tthis.equations = [ normal ];\n\n\t\t// g = (xi - xj).dot(n)\n\t\t// dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'\n\n\t\t// ...and if we were to include offset points:\n\t\t// g =\n\t\t//      (xj + rj - xi - ri).dot(n) - distance\n\t\t\n\t\t// dg/dt =\n\t\t//      (vj + wj x rj - vi - wi x ri).dot(n) =\n\t\t//      { term 2 is near zero } =\n\t\t//      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =\n\t\t//      G * W\n\t\t\n\t\t// => G = [-n -rixn n rjxn]\n\n\t\t// MOVED TO DistanceEquation:\n\t\t// {\n\t\t\t// let r = vec2.create();\n\t\t\t// let ri = vec2.create(); // worldAnchorA\n\t\t\t// let rj = vec2.create(); // worldAnchorB\n\n\t\t\t// normal.computeGq = (eq: Equation): f32 => {\n\t\t\t// \tvar bodyA = eq.bodyA!,\n\t\t\t// \t\tbodyB = eq.bodyB!,\n\t\t\t// \t\txi = bodyA.position,\n\t\t\t// \t\txj = bodyB.position;\n\n\t\t\t// \t// Transform local anchors to world\n\t\t\t// \tvec2.rotate(ri, that.localAnchorA, bodyA.angle);\n\t\t\t// \tvec2.rotate(rj, that.localAnchorB, bodyB.angle);\n\n\t\t\t// \tvec2.add(r, xj, rj);\n\t\t\t// \tvec2.subtract(r, r, ri);\n\t\t\t// \tvec2.subtract(r, r, xi);\n\n\t\t\t// \t//vec2.subtract(r, bodyB.position, bodyA.position);\n\t\t\t// \treturn vec2.length(r) - that.distance;\n\t\t\t// };\n\t\t// }\n\n\t\t// Make the contact constraint bilateral\n\t\tthis.setMaxForce(this.maxForce);\n\n\t}\n\n\t/**\n\t * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n\t * @method update\n\t */\n\tupdate(): void{\n\t\tlet bodyA: Body = this.bodyA,\n\t\t\tbodyB: Body = this.bodyB,\n\t\t\txi: Float32Array = bodyA.position,\n\t\t\txj: Float32Array = bodyB.position,\n\t\t\tnormalEquation: Equation = this.equations[0],\n\t\t\tG = normalEquation.G;\n\n\t\t// Transform local anchors to world\n\t\tvec2.rotate(ri, this.localAnchorA, bodyA.angle);\n\t\tvec2.rotate(rj, this.localAnchorB, bodyB.angle);\n\n\t\t// Get world anchor points and normal\n\t\tvec2.add(n, xj, rj);\n\t\tvec2.subtract(n, n, ri);\n\t\tvec2.subtract(n, n, xi);\n\t\tthis.position = vec2.length(n);\n\n\t\tlet violating = false;\n\t\tif(this.upperLimitEnabled){\n\t\t\tif(this.position > this.upperLimit){\n\t\t\t\tnormalEquation.maxForce = 0;\n\t\t\t\tnormalEquation.minForce = -this.maxForce;\n\t\t\t\tthis.distance = this.upperLimit;\n\t\t\t\tviolating = true;\n\t\t\t}\n\t\t}\n\n\t\tif(this.lowerLimitEnabled){\n\t\t\tif(this.position < this.lowerLimit){\n\t\t\t\tnormalEquation.maxForce = this.maxForce;\n\t\t\t\tnormalEquation.minForce = 0;\n\t\t\t\tthis.distance = this.lowerLimit;\n\t\t\t\tviolating = true;\n\t\t\t}\n\t\t}\n\n\t\tif((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){\n\t\t\t// No constraint needed.\n\t\t\tnormalEquation.enabled = false;\n\t\t\treturn;\n\t\t}\n\n\t\tnormalEquation.enabled = true;\n\n\t\tvec2.normalize(n,n);\n\n\t\t// Caluclate cross products\n\t\tlet rixn = vec2.crossLength(ri, n),\n\t\t\trjxn = vec2.crossLength(rj, n);\n\n\t\t// G = [-n -rixn n rjxn]\n\t\tG[0] = -n[0];\n\t\tG[1] = -n[1];\n\t\tG[2] = -rixn;\n\t\tG[3] = n[0];\n\t\tG[4] = n[1];\n\t\tG[5] = rjxn;\n\t}\n\n\t/**\n\t * Set the max force to be used\n\t * @method setMaxForce\n\t * @param {Number} maxForce\n\t */\n\tsetMaxForce(maxForce: f32): void{\n\t\tlet normal: Equation = this.equations[0];\n\t\tnormal.minForce = -maxForce;\n\t\tnormal.maxForce =  maxForce;\n\t}\n\n\t/**\n\t * Get the max force\n\t * @method getMaxForce\n\t * @return {Number}\n\t */\n\tgetMaxForce(): f32{\n\t\tlet normal: Equation = this.equations[0];\n\t\treturn normal.maxForce;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Body from \"./body\";\nimport Spring from \"./spring\";\nimport { SpringOptions } from \"./spring\";\n\nvar applyForce_r =              vec2.create(),\n\tapplyForce_r_unit =         vec2.create(),\n\tapplyForce_u =              vec2.create(),\n\tapplyForce_f =              vec2.create(),\n\tapplyForce_worldAnchorA =   vec2.create(),\n\tapplyForce_worldAnchorB =   vec2.create(),\n\tapplyForce_ri =             vec2.create(),\n\tapplyForce_rj =             vec2.create(),\n\tapplyForce_tmp =            vec2.create();\n\nexport class LinearSpringOptions extends SpringOptions{\n\tlocalAnchorA: Float32Array|null = null;\n\tlocalAnchorB: Float32Array|null = null;\n\tworldAnchorA: Float32Array|null = null;\n\tworldAnchorB: Float32Array|null = null;\n}\n\nexport default class LinearSpring extends Spring{\n\t/**\n\t * Anchor for bodyA in local bodyA coordinates.\n\t * @property localAnchorA\n\t * @type {Array}\n\t */\n\tlocalAnchorA: Float32Array = vec2.create();\n\t/**\n\t * Anchor for bodyB in local bodyB coordinates.\n\t * @property localAnchorB\n\t * @type {Array}\n\t */\n\tlocalAnchorB: Float32Array = vec2.create();\n\t/**\n\t * Rest length of the spring. Can be set dynamically.\n\t * @property restLength\n\t * @type {number}\n\t */\n\trestLength: f32;\n\n\t/**\n\t * A spring, connecting two bodies.\n\t *\n\t * The Spring explicitly adds force and angularForce to the bodies.\n\t *\n\t * @class LinearSpring\n\t * @extends Spring\n\t * @constructor\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Object} [options]\n\t * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.\n\t * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n\t * @param {number} [options.damping=1]      A number >= 0. Default: 1\n\t * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n\t * @param {Array}  [options.worldAnchorB]\n\t * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n\t * @param {Array}  [options.localAnchorB]\n\t *\n\t * @example\n\t *     var spring = new LinearSpring(bodyA, bodyB, {\n\t *         stiffness: 100,\n\t *         damping: 1,\n\t *         localAnchorA: [0,0], // center of bodyA\n\t *         localAnchorB: [0,0] // center of bodyB\n\t *     });\n\t *     world.addSpring(spring);\n\t */\n\tconstructor(bodyA: Body,bodyB: Body,options: LinearSpringOptions|null){\n\n\t\tsuper(bodyA, bodyB, options);\n\n\t\tthis.localAnchorA = vec2.create();\n\t\tthis.localAnchorB = vec2.create();\n\n\t\tif(options){\n\t\t\tif(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA!); }\n\t\t\tif(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB!); }\n\t\t\tif(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA!); }\n\t\t\tif(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB!); }\n\t\t}\n\n\t\tvar worldAnchorA = vec2.create();\n\t\tvar worldAnchorB = vec2.create();\n\t\tthis.getWorldAnchorA(worldAnchorA);\n\t\tthis.getWorldAnchorB(worldAnchorB);\n\t\tvar worldDistance = vec2.distance(worldAnchorA, worldAnchorB);\n\n\t\tthis.restLength = worldDistance;\n\t}\n\n\t/**\n\t * Set the anchor point on body A, using world coordinates.\n\t * @method setWorldAnchorA\n\t * @param {Array} worldAnchorA\n\t */\n\tsetWorldAnchorA(worldAnchorA: Float32Array): void{\n\t\tthis.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);\n\t}\n\n\t/**\n\t * Set the anchor point on body B, using world coordinates.\n\t * @method setWorldAnchorB\n\t * @param {Array} worldAnchorB\n\t */\n\tsetWorldAnchorB(worldAnchorB: Float32Array): void{\n\t\tthis.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);\n\t}\n\n\t/**\n\t * Get the anchor point on body A, in world coordinates.\n\t * @method getWorldAnchorA\n\t * @param {Array} result The vector to store the result in.\n\t */\n\tgetWorldAnchorA(result: Float32Array): void{\n\t\tthis.bodyA.toWorldFrame(result, this.localAnchorA);\n\t}\n\n\t/**\n\t * Get the anchor point on body B, in world coordinates.\n\t * @method getWorldAnchorB\n\t * @param {Array} result The vector to store the result in.\n\t */\n\tgetWorldAnchorB(result: Float32Array): void{\n\t\tthis.bodyB.toWorldFrame(result, this.localAnchorB);\n\t}\n\n\t/**\n\t * Apply the spring force to the connected bodies.\n\t * @private\n\t * @method applyForce\n\t */\n\tapplyForce(): void{\n\t\tvar k = this.stiffness,\n\t\t\td = this.damping,\n\t\t\tl = this.restLength,\n\t\t\tbodyA = this.bodyA,\n\t\t\tbodyB = this.bodyB,\n\t\t\tr = applyForce_r,\n\t\t\tr_unit = applyForce_r_unit,\n\t\t\tu = applyForce_u,\n\t\t\tf = applyForce_f,\n\t\t\ttmp = applyForce_tmp;\n\n\t\tvar worldAnchorA = applyForce_worldAnchorA,\n\t\t\tworldAnchorB = applyForce_worldAnchorB,\n\t\t\tri = applyForce_ri,\n\t\t\trj = applyForce_rj;\n\n\t\t// Get world anchors\n\t\tthis.getWorldAnchorA(worldAnchorA);\n\t\tthis.getWorldAnchorB(worldAnchorB);\n\n\t\t// Get offset points\n\t\tvec2.subtract(ri, worldAnchorA, bodyA.position);\n\t\tvec2.subtract(rj, worldAnchorB, bodyB.position);\n\n\t\t// Compute distance vector between world anchor points\n\t\tvec2.subtract(r, worldAnchorB, worldAnchorA);\n\t\tvar rlen = vec2.length(r);\n\t\tvec2.normalize(r_unit,r);\n\n\t\t// Compute relative velocity of the anchor points, u\n\t\tvec2.subtract(u, bodyB.velocity, bodyA.velocity);\n\t\tvec2.crossZV(tmp, bodyB.angularVelocity, rj);\n\t\tvec2.add(u, u, tmp);\n\t\tvec2.crossZV(tmp, bodyA.angularVelocity, ri);\n\t\tvec2.subtract(u, u, tmp);\n\n\t\t// F = - k * ( x - L ) - D * ( u )\n\t\tvec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));\n\n\t\t// Add forces to bodies\n\t\tvec2.subtract( bodyA.force, bodyA.force, f);\n\t\tvec2.add( bodyB.force, bodyB.force, f);\n\n\t\t// Angular force\n\t\tvar ri_x_f = vec2.crossLength(ri, f);\n\t\tvar rj_x_f = vec2.crossLength(rj, f);\n\t\tbodyA.angularForce -= ri_x_f;\n\t\tbodyB.angularForce += rj_x_f;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Ray from \"./ray\";\n\nexport default class AABB{\n\n\tlowerBound: Float32Array;\n\tupperBound: Float32Array;\n\tprivate tmp: Float32Array = vec2.create();\n\n\t/**\n\t * Axis aligned bounding box class.\n\t * @class AABB\n\t * @constructor\n\t * @param {Object}  [options]\n\t * @param {Array}   [options.upperBound]\n\t * @param {Array}   [options.lowerBound]\n\t * @example\n\t *     let aabb = new AABB({\n\t *         upperBound: [1, 1],\n\t *         lowerBound: [-1, -1]\n\t *     });\n\t */\n\tconstructor(upperBound: Float32Array|null, lowerBound: Float32Array|null){\n\n\t\t/**\n\t\t * The lower bound of the bounding box.\n\t\t * @property lowerBound\n\t\t * @type {Array}\n\t\t */\n\t\tthis.lowerBound = lowerBound ? vec2.clone(lowerBound) : vec2.create();\n\n\t\t/**\n\t\t * The upper bound of the bounding box.\n\t\t * @property upperBound\n\t\t * @type {Array}\n\t\t */\n\t\tthis.upperBound = upperBound ? vec2.clone(upperBound) : vec2.create();\n\t}\n\n\n\t/**\n\t * Set the AABB bounds from a set of points, transformed by the given position and angle.\n\t * @method setFromPoints\n\t * @param {Array} points An array of vec2's.\n\t * @param {Array} position\n\t * @param {number} [angle=0]\n\t * @param {number} [skinSize=0] Some margin to be added to the AABB.\n\t */\n\tsetFromPoints(points: Float32Array[], position: Float32Array, angle: f32, skinSize: f32 = 0): void{\n\t\tlet l = this.lowerBound,\n\t\t\tu = this.upperBound;\n\n\t\tangle = angle || 0;\n\n\t\t// Set to the first point\n\t\tif(angle !== 0){\n\t\t\tvec2.rotate(l, points[0], angle);\n\t\t} else {\n\t\t\tvec2.copy(l, points[0]);\n\t\t}\n\t\tvec2.copy(u, l);\n\n\t\t// Compute cosines and sines just once\n\t\tlet cosAngle = Mathf.cos(angle),\n\t\t\tsinAngle = Mathf.sin(angle);\n\t\tfor(let i: i32 = 1; i<points.length; i++){\n\t\t\tlet p = points[i];\n\n\t\t\tif(angle !== 0){\n\t\t\t\tlet x = p[0],\n\t\t\t\t\ty = p[1];\n\t\t\t\tthis.tmp[0] = cosAngle * x -sinAngle * y;\n\t\t\t\tthis.tmp[1] = sinAngle * x +cosAngle * y;\n\t\t\t\tp = this.tmp;\n\t\t\t}\n\n\t\t\tfor(let j: i32 = 0; j < 2; j++){\n\t\t\t\tif(p[j] > u[j]){\n\t\t\t\t\tu[j] = p[j];\n\t\t\t\t}\n\t\t\t\tif(p[j] < l[j]){\n\t\t\t\t\tl[j] = p[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add offset\n\t\tif(position){\n\t\t\tvec2.add(l, l, position);\n\t\t\tvec2.add(u, u, position);\n\t\t}\n\n\t\tif(skinSize){\n\t\t\tl[0] -= skinSize;\n\t\t\tl[1] -= skinSize;\n\t\t\tu[0] += skinSize;\n\t\t\tu[1] += skinSize;\n\t\t}\n\t}\n\n\t/**\n\t * Copy bounds from an AABB to this AABB\n\t * @method copy\n\t * @param  {AABB} aabb\n\t */\n\tcopy(aabb: AABB): void{\n\t\tvec2.copy(this.lowerBound, aabb.lowerBound);\n\t\tvec2.copy(this.upperBound, aabb.upperBound);\n\t}\n\n\t/**\n\t * Extend this AABB so that it covers the given AABB too.\n\t * @method extend\n\t * @param  {AABB} aabb\n\t */\n\textend(aabb: AABB): void{\n\t\tlet lower = this.lowerBound,\n\t\t\tupper = this.upperBound;\n\n\t\t// Loop over x and y\n\t\tlet i = 2;\n\t\twhile(i--){\n\t\t\t// Extend lower bound\n\t\t\tlet l = aabb.lowerBound[i];\n\t\t\tif(lower[i] > l){\n\t\t\t\tlower[i] = l;\n\t\t\t}\n\n\t\t\t// Upper\n\t\t\tlet u = aabb.upperBound[i];\n\t\t\tif(upper[i] < u){\n\t\t\t\tupper[i] = u;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the given AABB overlaps this AABB.\n\t * @method overlaps\n\t * @param  {AABB} aabb\n\t * @return {boolean}\n\t */\n\toverlaps(aabb: AABB): boolean{\n\t\tlet l1 = this.lowerBound,\n\t\t\tu1 = this.upperBound,\n\t\t\tl2 = aabb.lowerBound,\n\t\t\tu2 = aabb.upperBound;\n\n\t\t//      l2        u2\n\t\t//      |---------|\n\t\t// |--------|\n\t\t// l1       u1\n\n\t\treturn ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&\n\t\t\t((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));\n\t};\n\n\t/**\n\t * @method containsPoint\n\t * @param  {Array} point\n\t * @return {boolean}\n\t */\n\tcontainsPoint(point: Float32Array): boolean{\n\t\tlet l = this.lowerBound,\n\t\t\tu = this.upperBound;\n\t\treturn l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];\n\t}\n\n\t/**\n\t * Check if the AABB is hit by a ray.\n\t * @method overlapsRay\n\t * @param  {Ray} ray\n\t * @return {number} -1 if no hit, a number between 0 and 1 if hit, indicating the position between the \"from\" and \"to\" points.\n\t * @example\n\t *     let aabb = new AABB({\n\t *         upperBound: [1, 1],\n\t *         lowerBound: [-1, -1]\n\t *     });\n\t *     let ray = new Ray({\n\t *         from: [-2, 0],\n\t *         to: [0, 0]\n\t *     });\n\t *     let fraction = aabb.overlapsRay(ray); // fraction == 0.5\n\t */\n\toverlapsRay(ray: Ray): f32{\n\n\t\t// ray.direction is unit direction vector of ray\n\t\tlet dirFracX: f32 = 1.0 / ray.direction[0];\n\t\tlet dirFracY: f32 = 1.0 / ray.direction[1];\n\n\t\t// this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n\t\tlet from = ray.from;\n\t\tlet lowerBound: Float32Array = this.lowerBound;\n\t\tlet upperBound: Float32Array = this.upperBound;\n\t\tlet t1: f32 = (lowerBound[0] - from[0]) * dirFracX;\n\t\tlet t2: f32 = (upperBound[0] - from[0]) * dirFracX;\n\t\tlet t3: f32 = (lowerBound[1] - from[1]) * dirFracY;\n\t\tlet t4: f32 = (upperBound[1] - from[1]) * dirFracY;\n\n\t\tlet tmin: f32 = Mathf.max(Mathf.min(t1, t2), Mathf.min(t3, t4));\n\t\tlet tmax: f32 = Mathf.min(Mathf.max(t1, t2), Mathf.max(t3, t4));\n\n\t\t// if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n\t\tif (tmax < 0){\n\t\t\t//t = tmax;\n\t\t\treturn -1;\n\t\t}\n\n\t\t// if tmin > tmax, ray doesn't intersect AABB\n\t\tif (tmin > tmax){\n\t\t\t//t = tmax;\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn tmin / ray.length;\n\t}\n}","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(this, radix);\n    } else {\n      return itoa64(this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return utoa32(this, radix);\n    } else {\n      return utoa64(this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Equation from \"./Equation\";\nimport Body from \"../objects/body\";\n\nexport default class AngleLockEquation extends Equation{\n\tangle: f32;\n\n\t/**\n\t * The gear ratio.\n\t * @property {Number} ratio\n\t * @readonly\n\t * @see setRatio\n\t */\n\tratio: f32;\n\n\t/**\n\t * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n\t *\n\t * @class AngleLockEquation\n\t * @constructor\n\t * @extends Equation\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Object} [options]\n\t * @param {Number} [options.angle] Angle to add to the local vector in body A.\n\t * @param {Number} [options.ratio] Gear ratio\n\t */\n\tconstructor(bodyA: Body, bodyB: Body, angle: f32, ratio: f32){\n\t\tsuper(bodyA, bodyB, -Infinity, Infinity);\n\t\tthis.angle = angle;\n\n\t\tthis.ratio = ratio;\n\n\t\tthis.setRatio(this.ratio);\n\t}\n\n\tcomputeGq(): f32{\n\t\treturn this.ratio * this.bodyA!.angle - this.bodyB!.angle + this.angle;\n\t}\n\n\t/**\n\t * Set the gear ratio for this equation\n\t * @method setRatio\n\t * @param {Number} ratio\n\t */\n\tsetRatio(ratio: f32): void{\n\t\tvar G = this.G;\n\t\tG[2] =  ratio;\n\t\tG[5] = -1;\n\t\tthis.ratio = ratio;\n\t}\n\n\t/**\n\t * Set the max force for the equation.\n\t * @method setMaxTorque\n\t * @param {Number} torque\n\t */\n\tsetMaxTorque(torque: f32): void{\n\t\tthis.maxForce =  torque;\n\t\tthis.minForce = -torque;\n\t}\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<String>(out); // retains\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = __alloc(<usize>length << 1, idof<String>());\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(out + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return changetype<String>(out);\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(out, lo | (hi << 16));\n    }\n    return changetype<String>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (intStart << 1), size);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, size);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<Array<String>>(__allocArray(<i32>length, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<Array<String>>(__allocArray(1, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 2 * 2, idof<String>());\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(codes + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(codes + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(codes + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(codes + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(codes + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 3 * 2, idof<String>());\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(codes + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(codes + (j << 1), ab, 0);\n            store<u16>(codes + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(codes + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(codes + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var buf = __alloc(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>());\n      encodeUnsafe(changetype<usize>(str), str.length, buf, nullTerminated);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && str + 2 < strEnd) {\n            let c2 = <u32>load<u16>(str, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; str += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<String>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = __alloc(<usize>byteLength(str), idof<ArrayBuffer>());\n      encodeUnsafe(changetype<usize>(str), str.length, buf);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = __alloc(len &= ~1, idof<String>());\n      memory.copy(str, buf, len);\n      return changetype<String>(str); // retains\n    }\n  }\n}\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Shape from \"../shapes/shape\";\nimport Body from \"../objects/body\";\nimport Ray from \"./ray\";\n\n\nexport default class RaycastResult{\n\t/**\n\t * The normal of the hit, oriented in world space.\n\t * @property {array} normal\n\t */\n\tnormal: Float32Array = vec2.create();\n\n\t/**\n\t * The hit shape, or null.\n\t * @property {Shape} shape\n\t */\n\tshape: Shape|null = null;\n\n\t/**\n\t * The hit body, or null.\n\t * @property {Body} body\n\t */\n\tbody: Body|null = null;\n\n\t/**\n\t * The index of the hit triangle, if the hit shape was indexable.\n\t * @property {number} faceIndex\n\t * @default -1\n\t */\n\tfaceIndex: u32 = -1;\n\n\t/**\n\t * Distance to the hit, as a fraction. 0 is at the \"from\" point, 1 is at the \"to\" point. Will be set to -1 if there was no hit yet.\n\t * @property {number} fraction\n\t * @default -1\n\t */\n\tfraction: f32 = -1;\n\n\t/**\n\t * If the ray should stop traversing.\n\t * @readonly\n\t * @property {boolean} isStopped\n\t */\n\tisStopped:boolean = false;\n\n\t/**\n\t * Storage for Ray casting hit data.\n\t * @class RaycastResult\n\t * @constructor\n\t */\n\tconstructor(){\n\t}\n\n\t/**\n\t * Reset all result data. Must be done before re-using the result object.\n\t * @method reset\n\t */\n\treset(): void {\n\t\tvec2.set(this.normal, 0, 0);\n\t\tthis.shape = null;\n\t\tthis.body = null;\n\t\tthis.faceIndex = -1;\n\t\tthis.fraction = -1;\n\t\tthis.isStopped = false;\n\t}\n\n\t/**\n\t * Get the distance to the hit point.\n\t * @method getHitDistance\n\t * @param {Ray} ray\n\t * @return {number}\n\t */\n\tgetHitDistance(ray: Ray): f32 {\n\t\treturn vec2.distance(ray.from, ray.to) * this.fraction;\n\t}\n\n\t/**\n\t * Returns true if the ray hit something since the last reset().\n\t * @method hasHit\n\t * @eturn {boolean}\n\t */\n\thasHit(): boolean {\n\t\treturn this.fraction !== -1;\n\t}\n\n\t/**\n\t * Get world hit point.\n\t * @method getHitPoint\n\t * @param {array} out\n\t * @param {Ray} ray\n\t */\n\tgetHitPoint(out: Float32Array, ray: Ray): void {\n\t\tvec2.lerp(out, ray.from, ray.to, this.fraction);\n\t}\n\n\t/**\n\t * Can be called while iterating over hits to stop searching for hit points.\n\t * @method stop\n\t */\n\tstop(): void{\n\t\tthis.isStopped = true;\n\t}\n\n\t/**\n\t * @method shouldStop\n\t * @private\n\t * @param {Ray} ray\n\t * @return {boolean}\n\t */\n\tshouldStop(ray: Ray): boolean{\n\t\treturn this.isStopped || (this.fraction !== -1 && ray.mode === Ray.ANY);\n\t}\n\n\t/**\n\t * @method set\n\t * @private\n\t * @param {array} normal\n\t * @param {Shape} shape\n\t * @param {Body} body\n\t * @param {number} fraction\n\t * @param {number} faceIndex\n\t */\n\tset(\n\t\tnormal: Float32Array,\n\t\tshape: Shape,\n\t\tbody: Body,\n\t\tfraction: f32,\n\t\tfaceIndex: u32\n\t): void{\n\t\tvec2.copy(this.normal, normal);\n\t\tthis.shape = shape;\n\t\tthis.body = body;\n\t\tthis.fraction = fraction;\n\t\tthis.faceIndex = faceIndex;\n\t}\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      if (isManaged<V>()) {\n        let oldRef = changetype<usize>(entry.value);\n        if (changetype<usize>(value) != oldRef) {\n          entry.value = changetype<V>(__retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      } else {\n        entry.value = value;\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = isManaged<K>()\n        ? changetype<K>(__retain(changetype<usize>(key)))\n        : key;\n      entry.value = isManaged<V>()\n        ? changetype<V>(__retain(changetype<usize>(value)))\n        : value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    if (isManaged<K>()) __release(changetype<usize>(entry.key));\n    if (isManaged<V>()) __release(changetype<usize>(entry.value));\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","// @ts-ignore: decorator\n@inline\nexport function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() == 1) return hash8 (u32(key));\n    if (sizeof<T>() == 2) return hash16(u32(key));\n    if (sizeof<T>() == 4) return hash32(u32(key));\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\n\n// @ts-ignore: decorator\n@inline const FNV_OFFSET: u32 = 2166136261;\n\n// @ts-ignore: decorator\n@inline const FNV_PRIME: u32 = 16777619;\n\nfunction hash8(key: u32): u32 {\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\n}\n\nfunction hash16(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash32(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash64(key: u64): u32 {\n  var l = <u32> key;\n  var h = <u32>(key >>> 32);\n  var v = FNV_OFFSET;\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hashStr(key: string): u32 {\n  var v = FNV_OFFSET;\n  if (key !== null) {\n    for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\n      v = (v ^ <u32>load<u8>(changetype<usize>(key) + i)) * FNV_PRIME;\n    }\n  }\n  return v;\n}\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// import Pool from \"./pool\";\nimport ContactEquation from \"../equations/contact-equation\";\n\n\nexport default class ContactEquationPool{\n\n\t/**\n\t * @property {Array} objects\n\t * @type {Array}\n\t */\n\tobjects: ContactEquation[] = [];\n\n\t/**\n\t * @class\n\t */\n\tconstructor(size: u32) {\n\t\tthis.resize(size);\n\t}\n\n\t/**\n\t * @method resize\n\t * @param {number} size\n\t * @return {Pool} Self, for chaining\n\t */\n\tresize(size: i32): ContactEquationPool {\n\t\tvar objects = this.objects;\n\n\t\twhile (objects.length > size) {\n\t\t\tobjects.pop();\n\t\t}\n\n\t\twhile (objects.length < size) {\n\t\t\tobjects.push(this.create());\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get an object from the pool or create a new instance.\n\t * @method get\n\t * @return {Object}\n\t */\n\tget(): ContactEquation {\n\t\tvar objects = this.objects;\n\t\treturn objects.length ? objects.pop() : this.create();\n\t}\n\n\t/**\n\t * Clean up and put the object back into the pool for later use.\n\t * @method release\n\t * @param {Object} object\n\t * @return {Pool} Self for chaining\n\t */\n\trelease(object: ContactEquation): ContactEquationPool {\n\t\tthis.destroy(object);\n\t\tthis.objects.push(object);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @method create\n\t * @return {ContactEquation}\n\t */\n\tcreate(): ContactEquation {\n\t\treturn new ContactEquation(null, null);\n\t}\n\n\t/**\n\t * @method destroy\n\t * @param {ContactEquation} equation\n\t * @return {ContactEquationPool}\n\t */\n\tdestroy(equation: ContactEquation): ContactEquationPool {\n\t\tequation.bodyA = equation.bodyB = null;\n\t\treturn this;\n\t}\n}\n","import Equation from \"./equation\";\r\nimport Body from \"../objects/body\";\r\nimport vec2 from \"../math/vec2\";\r\nimport DistanceConstraint from \"../constraints/distance-constraint\";\r\n\r\nexport default class DistanceEquation extends Equation{\r\n\r\n\tdistanceConstraint: DistanceConstraint;\r\n\tr: Float32Array = vec2.create();\r\n\tri: Float32Array = vec2.create(); // worldAnchorA\r\n\trj: Float32Array = vec2.create(); // worldAnchorB\r\n\r\n\tconstructor(distanceConstraint: DistanceConstraint, bodyA: Body|null, bodyB: Body|null, minForce: f32, maxForce: f32){\r\n\t\tsuper(bodyA, bodyB, minForce, maxForce);\r\n\t\tthis.distanceConstraint = distanceConstraint;\r\n\t}\r\n\r\n\tcomputeGq(): f32 {\r\n\t\tlet bodyA: Body = this.bodyA!,\r\n\t\t\tbodyB: Body = this.bodyB!,\r\n\t\t\txi: Float32Array = bodyA.position,\r\n\t\t\txj: Float32Array = bodyB.position;\r\n\r\n\t\t// Transform local anchors to world\r\n\t\tvec2.rotate(this.ri, this.distanceConstraint.localAnchorA, bodyA.angle);\r\n\t\tvec2.rotate(this.rj, this.distanceConstraint.localAnchorB, bodyB.angle);\r\n\r\n\t\tvec2.add(this.r, xj, this.rj);\r\n\t\tvec2.subtract(this.r, this.r, this.ri);\r\n\t\tvec2.subtract(this.r, this.r, xi);\r\n\r\n\t\t//vec2.subtract(r, bodyB.position, bodyA.position);\r\n\t\treturn vec2.length(this.r) - this.distanceConstraint.distance;\r\n\t}\r\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport vec2 from \"../math/vec2\";\nimport Equation from \"./equation\";\nimport Body from \"../objects/body\";\nimport ContactEquationPool from \"../utils/contact-equation-pool\";\nimport Shape from \"../shapes/shape\";\nimport ContactEquation from \"./contact-equation\";\n\nexport default class FrictionEquation extends Equation{\n\n\t/**\n\t * Relative vector from center of body A to the contact point, world oriented.\n\t * @property contactPointA\n\t * @type {Array}\n\t */\n\tcontactPointA: Float32Array = vec2.create();\n\n\t/**\n\t * Relative vector from center of body B to the contact point, world oriented.\n\t * @property contactPointB\n\t * @type {Array}\n\t */\n\tcontactPointB: Float32Array = vec2.create();\n\n\t/**\n\t * Tangent vector that the friction force will act along. World oriented.\n\t * @property t\n\t * @type {Array}\n\t */\n\tt: Float32Array = vec2.create();\n\n\t/**\n\t * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.\n\t * @property contactEquations\n\t * @type {ContactEquation[]}\n\t */\n\tcontactEquations: Array<ContactEquation> = [];\n\n\t/**\n\t * The shape in body i that triggered this friction.\n\t * @property shapeA\n\t * @type {Shape}\n\t * @todo Needed? The shape can be looked up via contactEquation.shapeA...\n\t */\n\tshapeA: Shape|null = null;\n\n\t/**\n\t * The shape in body j that triggered this friction.\n\t * @property shapeB\n\t * @type {Shape}\n\t * @todo Needed? The shape can be looked up via contactEquation.shapeB...\n\t */\n\tshapeB: Shape|null = null;\n\n\t/**\n\t * The friction coefficient to use.\n\t * @property frictionCoefficient\n\t * @type {Number}\n\t */\n\tfrictionCoefficient: f32 = 0.3;\n\n\t/**\n\t * Constrains the slipping in a contact along a tangent\n\t *\n\t * @class FrictionEquation\n\t * @constructor\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Number} slipForce = Infinity\n\t * @extends Equation\n\t */\n\tconstructor(bodyA: Body|null, bodyB: Body|null, slipForce: f32){\n\t\tsuper(bodyA, bodyB, -slipForce, slipForce);\n\t}\n\n\t/**\n\t * Set the slipping condition for the constraint. The friction force cannot be\n\t * larger than this value.\n\t * @method setSlipForce\n\t * @param  {Number} slipForce\n\t */\n\tsetSlipForce(slipForce: f32): void{\n\t\tthis.maxForce = slipForce;\n\t\tthis.minForce = -slipForce;\n\t};\n\n\t/**\n\t * Get the max force for the constraint.\n\t * @method getSlipForce\n\t * @return {Number}\n\t */\n\tgetSlipForce(): f32{\n\t\treturn this.maxForce;\n\t};\n\n\tcomputeB(a: f32,b: f32,h: f32): f32{\n\t\tvar ri = this.contactPointA,\n\t\t\trj = this.contactPointB,\n\t\t\tt = this.t,\n\t\t\tG = this.G;\n\n\t\t// G = [-t -rixt t rjxt]\n\t\t// And remember, this is a pure velocity constraint, g is always zero!\n\t\tG[0] = -t[0];\n\t\tG[1] = -t[1];\n\t\tG[2] = -vec2.crossLength(ri,t);\n\t\tG[3] = t[0];\n\t\tG[4] = t[1];\n\t\tG[5] = vec2.crossLength(rj,t);\n\n\t\tvar GW = this.computeGW(),\n\t\t\tGiMf = this.computeGiMf();\n\n\t\tvar B = /* - g * a  */ - GW * b - h*GiMf;\n\n\t\treturn B;\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n//import Pool from \"./pool\";\nimport FrictionEquation from \"../equations/friction-equation\";\n\n\nexport default class FrictionEquationPool{\n\n\t/**\n\t * @property {Array} objects\n\t * @type {Array}\n\t */\n\tobjects: FrictionEquation[] = [];\n\n\t/**\n\t * @class\n\t */\n\tconstructor(size: u32) {\n\t\tthis.resize(size);\n\t}\n\n\t/**\n\t * @method resize\n\t * @param {number} size\n\t * @return {Pool} Self, for chaining\n\t */\n\tresize(size: i32): FrictionEquationPool {\n\t\tvar objects = this.objects;\n\n\t\twhile (objects.length > size) {\n\t\t\tobjects.pop();\n\t\t}\n\n\t\twhile (objects.length < size) {\n\t\t\tobjects.push(this.create());\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get an object from the pool or create a new instance.\n\t * @method get\n\t * @return {Object}\n\t */\n\tget(): FrictionEquation {\n\t\tvar objects = this.objects;\n\t\treturn objects.length ? objects.pop() : this.create();\n\t}\n\n\t/**\n\t * Clean up and put the object back into the pool for later use.\n\t * @method release\n\t * @param {Object} object\n\t * @return {Pool} Self for chaining\n\t */\n\trelease(object: FrictionEquation): FrictionEquationPool {\n\t\tthis.destroy(object);\n\t\tthis.objects.push(object);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @method create\n\t * @return {FrictionEquation}\n\t */\n\tcreate(): FrictionEquation {\n\t\treturn new FrictionEquation(null, null, Infinity);\n\t};\n\n\t/**\n\t * @method destroy\n\t * @param {FrictionEquation} equation\n\t * @return {FrictionEquationPool}\n\t */\n\tdestroy(equation: FrictionEquation): FrictionEquationPool {\n\t\tequation.bodyA = equation.bodyB = null;\n\t\treturn this;\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Equation from \"../equations/equation\";\nimport Solver from \"./solver\";\nimport { SolverOptions } from \"./solver\";\nimport World from \"../world/world\";\nimport FrictionEquation from \"../equations/friction-equation\";\nimport Body from \"../objects/body\";\n\n\n\n// Sets the .multiplier property of each equation\nfunction updateMultipliers(equations: Equation[], invDt: f32): void{\n\tlet l = equations.length;\n\twhile(l--){\n\t\tlet eq = equations[l];\n\t\teq.multiplier = eq.lambda * invDt;\n\t}\n}\n\nfunction iterateEquation(eq: Equation): f32{\n\t// Compute iteration\n\tlet B = eq.B,\n\t\teps = eq.epsilon,\n\t\tinvC = eq.invC,\n\t\tlambdaj = eq.lambda,\n\t\tGWlambda = eq.computeGWlambda(),\n\t\tmaxForce_dt = eq.maxForceDt,\n\t\tminForce_dt = eq.minForceDt;\n\n\tlet deltalambda = invC * ( B - GWlambda - eps * lambdaj );\n\n\t// Clamp if we are not within the min/max interval\n\tlet lambdaj_plus_deltalambda = lambdaj + deltalambda;\n\tif(lambdaj_plus_deltalambda < minForce_dt){\n\t\tdeltalambda = minForce_dt - lambdaj;\n\t} else if(lambdaj_plus_deltalambda > maxForce_dt){\n\t\tdeltalambda = maxForce_dt - lambdaj;\n\t}\n\teq.lambda += deltalambda;\n\teq.addToWlambda(deltalambda);\n\n\treturn deltalambda;\n}\n\nexport class GSSolverOptions extends SolverOptions{\n\titerations: i32 = 10;\n\ttolerance: f32 = 1e-7;\n\tfrictionIterations: i32 = 0;\n}\n\nexport default class GSSolver extends Solver{\n\t/**\n\t * The max number of iterations to do when solving. More gives better results, but is more expensive.\n\t * @property iterations\n\t * @type {Number}\n\t */\n\titerations: i32 = 10;\n\t/**\n\t * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.\n\t * @property tolerance\n\t * @type {Number}\n\t * @default 1e-7\n\t */\n\ttolerance: f32 = 1e-7;\n\t/**\n\t * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.\n\t *\n\t * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.\n\t *\n\t * @property frictionIterations\n\t * @type {Number}\n\t * @default 0\n\t */\n\tfrictionIterations: i32;\n\t/**\n\t * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.\n\t * @property {Number} usedIterations\n\t */\n\tusedIterations: i32 = 0;\n\n\t/**\n\t * Iterative Gauss-Seidel constraint equation solver.\n\t *\n\t * @class GSSolver\n\t * @constructor\n\t * @extends Solver\n\t * @param {Object} [options]\n\t * @param {Number} [options.iterations=10]\n\t * @param {Number} [options.tolerance=0]\n\t */\n\tconstructor(options: GSSolverOptions|null){\n\t\tsuper(options, Solver.GS);\n\n\t\tif(options){\n\t\t\tthis.iterations = options.iterations;\n\t\t\tthis.tolerance = options.tolerance;\n\t\t\tthis.frictionIterations = options.frictionIterations;\n\t\t}\n\n\t}\n\n\t/**\n\t * Solve the system of equations\n\t * @method solve\n\t * @param  {Number}  h       Time step\n\t * @param  {World}   world    World to solve\n\t */\n\tsolve(h: f32, world: World): void{\n\n\t\tthis.sortEquations();\n\n\t\tlet maxIter = this.iterations,\n\t\t\tmaxFrictionIter = this.frictionIterations,\n\t\t\tequations: Equation[] = this.equations,\n\t\t\tNeq: i32 = equations.length,\n\t\t\ttolSquared: f32 = (this.tolerance * (Neq as f32)) * (this.tolerance * (Neq as f32)),\n\t\t\tbodies: Body[] = world.bodies,\n\t\t\tNbodies:i32 = bodies.length;\n\n\t\tthis.usedIterations = 0;\n\n\t\tif(Neq){\n\t\t\tfor(let i: i32 = 0; i < Nbodies; i++){\n\t\t\t\tlet b: Body = bodies[i];\n\n\t\t\t\t// Update solve mass\n\t\t\t\tb.updateSolveMassProperties();\n\t\t\t}\n\t\t}\n\n\t\tfor(let i: i32 = 0; i < Neq; i++){\n\t\t\tlet c: Equation = equations[i];\n\t\t\tc.lambda = 0;\n\t\t\tif(c.timeStep !== h || c.needsUpdate){\n\t\t\t\tc.timeStep = h;\n\t\t\t\tc.update();\n\t\t\t}\n\t\t\tc.B = c.computeB(c.a,c.b,h);\n\t\t\tc.invC = c.computeInvC(c.epsilon);\n\n\t\t\tc.maxForceDt = c.maxForce * h;\n\t\t\tc.minForceDt = c.minForce * h;\n\t\t}\n\n\t\tlet c: Equation, deltalambdaTot: f32;\n\n\t\tif(Neq !== 0){\n\n\t\t\tfor(let i: i32 = 0; i < Nbodies; i++){\n\t\t\t\tlet b: Body = bodies[i];\n\n\t\t\t\t// Reset vlambda\n\t\t\t\tb.resetConstraintVelocity();\n\t\t\t}\n\n\t\t\tif(maxFrictionIter){\n\t\t\t\t// Iterate over contact equations to get normal forces\n\t\t\t\tfor(let iter: i32 = 0; iter !== maxFrictionIter; iter++){\n\n\t\t\t\t\t// Accumulate the total error for each iteration.\n\t\t\t\t\tdeltalambdaTot = 0.0;\n\n\t\t\t\t\tfor(let j: i32 = 0; j < Neq; j++){\n\t\t\t\t\t\tc = equations[j];\n\n\t\t\t\t\t\tlet deltalambda: f32 = iterateEquation(c);\n\t\t\t\t\t\tdeltalambdaTot += Mathf.abs(deltalambda);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.usedIterations++;\n\n\t\t\t\t\t// If the total error is small enough - stop iterate\n\t\t\t\t\tif(deltalambdaTot*deltalambdaTot <= tolSquared){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdateMultipliers(equations, 1/h);\n\n\t\t\t\t// Set computed friction force\n\t\t\t\tfor(let j: i32 = 0; j < Neq; j++){\n\t\t\t\t\tlet eq = equations[j];\n\t\t\t\t\tif(eq instanceof FrictionEquation){\n\t\t\t\t\t\tlet feq: FrictionEquation = eq as FrictionEquation;\n\t\t\t\t\t\tlet f: f32 = 0.0;\n\t\t\t\t\t\tfor(let k: i32 = 0; k < feq.contactEquations.length; k++){\n\t\t\t\t\t\t\tf += feq.contactEquations[k].multiplier;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf *= feq.frictionCoefficient / (feq.contactEquations.length as f32);\n\t\t\t\t\t\tfeq.maxForce =  f;\n\t\t\t\t\t\tfeq.minForce = -f;\n\n\t\t\t\t\t\tfeq.maxForceDt = f * h;\n\t\t\t\t\t\tfeq.minForceDt = -f * h;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Iterate over all equations\n\t\t\tfor(let iter:i32 = 0; iter < maxIter; iter++){\n\n\t\t\t\t// Accumulate the total error for each iteration.\n\t\t\t\tdeltalambdaTot = 0.0;\n\t\t\t\tfor(let j: i32 = 0; j < Neq; j++){\n\t\t\t\t\tc = equations[j];\n\n\t\t\t\t\tlet deltalambda = iterateEquation(c);\n\t\t\t\t\tdeltalambdaTot += Mathf.abs(deltalambda);\n\t\t\t\t}\n\n\t\t\t\tthis.usedIterations++;\n\n\t\t\t\t// If the total error is small enough - stop iterate\n\t\t\t\tif(deltalambdaTot*deltalambdaTot < tolSquared){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add result to velocity\n\t\t\tfor(let i:i32 = 0; i < Nbodies; i++){\n\t\t\t\tbodies[i].addConstraintVelocity();\n\t\t\t}\n\n\t\t\tupdateMultipliers(equations, 1/h);\n\t\t}\n\t}\n}","import { compareImpl } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): (a: T, b: T) => i32 {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a: T, b: T): i32 => (i32(a) - i32(b));\n    } else {\n      return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= (ia >> 31) >>> 1;\n        ib ^= (ib >> 31) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= (ia >> 63) >>> 1;\n        ib ^= (ib >> 63) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a: T, b: T): i32 => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!alen && !blen) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      return compareImpl(changetype<string>(a), 0, changetype<string>(b), 0, <usize>min(alen, blen));\n    };\n  } else {\n    return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function SORT<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  if (isReference<T>()) {\n    // TODO replace this to faster stable sort (TimSort) when it implemented\n    insertionSort<T>(dataStart, length, comparator);\n  } else {\n    if (length < 256) {\n      insertionSort<T>(dataStart, length, comparator);\n    } else {\n      weakHeapSort<T>(dataStart, length, comparator);\n    }\n  }\n}\n\nfunction insertionSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  for (let i = 0; i < length; i++) {\n    let a: T = load<T>(dataStart + (<usize>i << alignof<T>())); // a = arr[i]\n    let j = i - 1;\n    while (j >= 0) {\n      let b: T = load<T>(dataStart + (<usize>j << alignof<T>())); // b = arr[j]\n      if (comparator(a, b) < 0) {\n        store<T>(dataStart + (<usize>(j-- + 1) << alignof<T>()), b); // arr[j + 1] = b\n      } else break;\n    }\n    store<T>(dataStart + (<usize>(j + 1) << alignof<T>()), a); // arr[j + 1] = a\n  }\n}\n\nfunction weakHeapSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  const shift32 = alignof<u32>();\n\n  var bitsetSize = (<usize>length + 31) >> 5 << shift32;\n  var bitset = __alloc(bitsetSize, 0); // indexed in 32-bit chunks below\n  memory.fill(bitset, 0, bitsetSize);\n\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\n\n  for (let i = length - 1; i > 0; i--) {\n    let j = i;\n    while ((j & 1) == (load<u32>(bitset + (<usize>j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\n\n    let p = j >> 1;\n    let a: T = load<T>(dataStart + (<usize>p << alignof<T>())); // a = arr[p]\n    let b: T = load<T>(dataStart + (<usize>i << alignof<T>())); // b = arr[i]\n    if (comparator(a, b) < 0) {\n      store<u32>(\n        bitset + (<usize>i >> 5 << shift32),\n        load<u32>(bitset + (<usize>i >> 5 << shift32)) ^ (1 << (i & 31))\n      );\n      store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n      store<T>(dataStart + (<usize>p << alignof<T>()), b); // arr[p] = b\n    }\n  }\n\n  for (let i = length - 1; i >= 2; i--) {\n    let a: T = load<T>(dataStart); // a = arr[0]\n    store<T>(dataStart, load<T>(dataStart + (<usize>i << alignof<T>()))); // arr[0] = arr[i]\n    store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n\n    let x = 1, y: i32;\n    while ((y = (x << 1) + ((load<u32>(bitset + (<usize>x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\n\n    while (x > 0) {\n      a = load<T>(dataStart); // a = arr[0]\n      let b: T = load<T>(dataStart + (<usize>x << alignof<T>())); // b = arr[x]\n\n      if (comparator(a, b) < 0) {\n        store<u32>(\n          bitset + (<usize>x >> 5 << shift32),\n          load<u32>(bitset + (<usize>x >> 5 << shift32)) ^ (1 << (x & 31))\n        );\n        store<T>(dataStart + (<usize>x << alignof<T>()), a); // arr[x] = a\n        store<T>(dataStart, b); // arr[0] = b\n      }\n      x >>= 1;\n    }\n  }\n\n  __free(bitset);\n\n  var t: T = load<T>(dataStart, sizeof<T>()); // t = arr[1]\n  store<T>(dataStart, load<T>(dataStart), sizeof<T>()); // arr[1] = arr[0]\n  store<T>(dataStart, t); // arr[0] = t\n}\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma<T>(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms<T>(v1: v128, v2: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v16x8 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v32x4 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v64x2 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\ndeclare function seed(): f64;\n","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Utils from \"./utils\";\n\nexport default class TupleDictionary<T>{\n\tdata: Map<i64, T>;\n\tkeys: i64[];\n\n\t/**\n\t * @class TupleDictionary\n\t * @constructor\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The data storage\n\t\t * @property data\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = new Map<i64, T>();\n\n\t\t/**\n\t\t * Keys that are currently used.\n\t\t * @property {Array} keys\n\t\t */\n\t\tthis.keys = [];\n\t}\n\n\t/**\n\t * Generate a key given two integers\n\t * @method getKey\n\t * @param  {i64} i\n\t * @param  {i64} j\n\t * @return {i64}\n\t */\n\tgetKey(id1: i64, id2: i64): i64 {\n\n\t\tif ( (id1) === (id2) ){\n\t\t\treturn -1;\n\t\t}\n\n\t\t// valid for values < 2^16\n\t\treturn ((id1) > (id2) ?\n\t\t\t(id1 << 16) | (id2 & 0xFFFF) :\n\t\t\t(id2 << 16) | (id1 & 0xFFFF))|0\n\t\t\t;\n\t}\n\n\t/**\n\t * @method getByKey\n\t * @param  {i64} key\n\t * @return {Object}\n\t */\n\tgetByKey(key: i64): T {\n\t\treturn this.data.get(key);\n\t}\n\n\t/**\n\t * @method get\n\t * @param  {i64} i\n\t * @param  {i64} j\n\t * @return {i64}\n\t */\n\tget(i: i64, j: i64): T {\n\t\treturn this.getByKey(this.getKey(i, j));\n\t}\n\n\t/**\n\t * Set a value.\n\t * @method set\n\t * @param  {i64} i\n\t * @param  {i64} j\n\t * @param {i64} value\n\t */\n\tset(i: i64, j: i64, value: T): i64 {\n\t\tif(!value){\n\t\t\tthrow new Error(\"No data!\");\n\t\t}\n\n\t\tvar key = this.getKey(i, j);\n\n\t\t// Check if key already exists\n\t\tif(!this.data.has(key)){\n\t\t\tthis.keys.push(key);\n\t\t}\n\n\t\tthis.data.set(key, value);\n\n\t\treturn key;\n\t}\n\n\t/**\n\t * Remove all data.\n\t * @method reset\n\t */\n\treset(): void {\n\t\tvar data = this.data,\n\t\t\tkeys = this.keys;\n\n\t\tdata.clear();\n\n\t\tkeys.length = 0;\n\t}\n\n\t/**\n\t * Copy another TupleDictionary. Note that all data in this dictionary will be removed.\n\t * @method copy\n\t * @param {TupleDictionary} dict The TupleDictionary to copy into this one.\n\t */\n\tcopy(dict: TupleDictionary<T>): void {\n\t\tthis.reset();\n\t\tUtils.appendArray(this.keys, dict.keys);\n\t\tvar l = dict.keys.length;\n\t\twhile(l--){\n\t\t\tvar key = dict.keys[l];\n\t\t\tthis.data.set(key, dict.getByKey(key));\n\t\t}\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// var vec2 = require('../math/vec2')\n// ,   Shape = require('./Shape')\n// ,   shallowClone = require('../utils/Utils').shallowClone\n// ,   Convex = require('./Convex');\n\nimport Convex from \"./convex\";\nimport { ConvexOptions } from \"./convex\";\nimport AABB from \"../collision/aabb\";\nimport Shape from \"./shape\";\nimport vec2 from \"../math/vec2\";\n\nexport class BoxOptions extends ConvexOptions{\n\twidth: f32 = 1;\n\theight: f32 = 1;\n}\n\nexport default class Box extends Convex{\n\t/**\n\t * Total width of the box\n\t * @property width\n\t * @type {Number}\n\t */\n\twidth: f32 = 1;\n\n\t/**\n\t * Total height of the box\n\t * @property height\n\t * @type {Number}\n\t */\n\theight: f32 = 1;\n\n\t/**\n\t * Box shape class.\n\t * @class Box\n\t * @constructor\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Number} [options.width=1] Total width of the box\n\t * @param {Number} [options.height=1] Total height of the box\n\t * @extends Convex\n\t * @example\n\t *     var body = new Body({ mass: 1 });\n\t *     var boxShape = new Box({\n\t *         width: 2,\n\t *         height: 1\n\t *     });\n\t *     body.addShape(boxShape);\n\t */\n\tconstructor(options: BoxOptions|null){\n\t\t// let width:f32 = 1;\n\t\t// let height:f32 = 1;\n\t\t// if(options){\n\t\t// \twidth = options.width;\n\t\t// \theight = options.height;\n\t\t// }\n\n\t\t// let hw = width/2;\n\t\t// let hh = height/2;\n\n\t\tsuper(Shape.BOX, (\n\t\t\toptions ? [\n\t\t\t\tvec2.fromValues(-options.width/2, -options.height/2),\n\t\t\t\tvec2.fromValues( options.width/2, -options.height/2),\n\t\t\t\tvec2.fromValues( options.width/2,  options.height/2),\n\t\t\t\tvec2.fromValues(-options.width/2,  options.height/2)\n\t\t\t] : [\n\t\t\t\tvec2.fromValues(-0.5, -0.5),\n\t\t\t\tvec2.fromValues( 0.5, -0.5),\n\t\t\t\tvec2.fromValues( 0.5,  0.5),\n\t\t\t\tvec2.fromValues(-0.5,  0.5)\n\t\t\t]), options);\n\n\t\tif(options){\n\t\t\tthis.height = options.height;\t\t\n\t\t\tthis.width = options.width;\t\n\t\t}\n\t}\n\n\t/**\n\t * Compute moment of inertia\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\tvar w = this.width,\n\t\t\th = this.height;\n\t\treturn (h*h + w*w) / 12;\n\t};\n\n\t/**\n\t * Update the bounding radius\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tvar w = this.width,\n\t\t\th = this.height;\n\t\tthis.boundingRadius = Mathf.sqrt(w*w + h*h) / 2;\n\t\treturn this.boundingRadius;\n\t};\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tvar c = Mathf.abs(Mathf.cos(angle)),\n\t\t\ts = Mathf.abs(Mathf.sin(angle)),\n\t\t\tw = this.width,\n\t\t\th = this.height;\n\n\t\tvar height = (w * s + h * c) * 0.5;\n\t\tvar width = (h * s + w * c) * 0.5;\n\n\t\tvar l = out.lowerBound;\n\t\tvar u = out.upperBound;\n\t\tvar px = position[0];\n\t\tvar py = position[1];\n\t\tl[0] = px - width;\n\t\tl[1] = py - height;\n\t\tu[0] = px + width;\n\t\tu[1] = py + height;\n\t};\n\n\tupdateArea():f32{\n\t\tthis.area = this.width * this.height;\n\t\treturn this.area;\n\t};\n\n\tpointTest(localPoint: Float32Array): boolean{\n\t\treturn Mathf.abs(localPoint[0]) <= this.width * 0.5 && Mathf.abs(localPoint[1]) <= this.height * 0.5;\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Broadphase from \"./broadphase\";\nimport World from \"../world/world\";\nimport Body from \"../objects/body\";\nimport AABB from \"./aabb\";\n\n\nexport default class NaiveBroadphase extends Broadphase{\n\n\t/**\n\t * Naive broadphase implementation. Does N^2 tests.\n\t *\n\t * @class NaiveBroadphase\n\t * @constructor\n\t * @extends Broadphase\n\t */\n\tconstructor(){\n\t\tsuper(Broadphase.NAIVE);\n\t}\n\t\n\n\t/**\n\t * Get the colliding pairs\n\t * @method getCollisionPairs\n\t * @param  {World} world\n\t * @return {Array}\n\t */\n\tgetCollisionPairs(): Body[]{\n\t\tlet bodies: Body[] = this.world!.bodies,\n\t\t\tresult: Body[] = this.result;\n\n\t\tresult.length = 0;\n\n\t\tfor(let i: u16 = 0, Ncolliding: u16 = (bodies.length as u16); i < Ncolliding; i++){\n\t\t\tlet bi = bodies[i];\n\n\t\t\tfor(let j: u16 = 0; j < i; j++){\n\t\t\t\tlet bj = bodies[j];\n\n\t\t\t\tif(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n\t\t\t\t\tresult.push(bi);\n\t\t\t\t\tresult.push(bj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Returns all the bodies within an AABB.\n\t * @method aabbQuery\n\t * @param  {World} world\n\t * @param  {AABB} aabb\n\t * @param {array} result An array to store resulting bodies in.\n\t * @return {array}\n\t */\n\taabbQuery(aabb: AABB, result: Body[]): void{\n\t\tlet bodies: Body[] = this.world!.bodies;\n\t\tfor(let i: u16 = 0; i < (bodies.length as u16); i++){\n\t\t\tlet b: Body = bodies[i];\n\n\t\t\tif(b.aabbNeedsUpdate){\n\t\t\t\tb.updateAABB();\n\t\t\t}\n\n\t\t\tif(b.aabb.overlaps(aabb)){\n\t\t\t\tresult.push(b);\n\t\t\t}\n\t\t}\n\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// var Shape = require('./Shape')\n// ,   shallowClone = require('../utils/Utils').shallowClone\n// ,   copy = require('../math/vec2').copy;\n\nimport Shape from \"./shape\";\nimport { ShapeOptions } from \"./shape\";\nimport AABB from \"../collision/aabb\";\nimport RaycastResult from \"../collision/raycast-result\";\nimport Ray from \"../collision/ray\";\nimport vec2 from \"../math/vec2\";\n\nexport class ParticleOptions extends ShapeOptions{}\n\nexport default class Particle extends Shape{\n\n\t/**\n\t * Particle shape class.\n\t * @class Particle\n\t * @constructor\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @extends Shape\n\t * @example\n\t *     var body = new Body();\n\t *     var shape = new Particle();\n\t *     body.addShape(shape);\n\t */\n\tconstructor(options:ShapeOptions|null){\n\t\tsuper(Shape.PARTICLE, options);\n\t}\n\n\tcomputeMomentOfInertia(): f32{\n\t\treturn 0; // Can't rotate a particle\n\t};\n\n\tupdateBoundingRadius(): f32{\n\t\tthis.boundingRadius = 0;\n\t\treturn 0;\n\t};\n\n\tupdateArea(): f32 { return 0}\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tvec2.copy(out.lowerBound, position);\n\t\tvec2.copy(out.upperBound, position);\n\t};\n\n\traycast(result: RaycastResult, ray: Ray, position: Float32Array, angle: f32):void{}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// var vec2 = require('../math/vec2')\n// ,   Shape = require('./Shape')\n// ,   shallowClone = require('../utils/Utils').shallowClone\n// ,   Convex = require('./Convex');\n\nimport Convex from \"./convex\";\nimport { ConvexOptions } from \"./convex\";\nimport AABB from \"../collision/aabb\";\nimport Shape from \"./shape\";\nimport vec2 from \"../math/vec2\";\n\nexport class BoxOptions extends ConvexOptions{\n\twidth: f32 = 1;\n\theight: f32 = 1;\n}\n\nexport default class Box extends Convex{\n\t/**\n\t * Total width of the box\n\t * @property width\n\t * @type {Number}\n\t */\n\twidth: f32 = 1;\n\n\t/**\n\t * Total height of the box\n\t * @property height\n\t * @type {Number}\n\t */\n\theight: f32 = 1;\n\n\t/**\n\t * Box shape class.\n\t * @class Box\n\t * @constructor\n\t * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n\t * @param {Number} [options.width=1] Total width of the box\n\t * @param {Number} [options.height=1] Total height of the box\n\t * @extends Convex\n\t * @example\n\t *     var body = new Body({ mass: 1 });\n\t *     var boxShape = new Box({\n\t *         width: 2,\n\t *         height: 1\n\t *     });\n\t *     body.addShape(boxShape);\n\t */\n\tconstructor(options: BoxOptions|null){\n\t\t// let width:f32 = 1;\n\t\t// let height:f32 = 1;\n\t\t// if(options){\n\t\t// \twidth = options.width;\n\t\t// \theight = options.height;\n\t\t// }\n\n\t\t// let hw = width/2;\n\t\t// let hh = height/2;\n\n\t\tsuper(Shape.BOX, (\n\t\t\toptions ? [\n\t\t\t\tvec2.fromValues(-options.width/2, -options.height/2),\n\t\t\t\tvec2.fromValues( options.width/2, -options.height/2),\n\t\t\t\tvec2.fromValues( options.width/2,  options.height/2),\n\t\t\t\tvec2.fromValues(-options.width/2,  options.height/2)\n\t\t\t] : [\n\t\t\t\tvec2.fromValues(-0.5, -0.5),\n\t\t\t\tvec2.fromValues( 0.5, -0.5),\n\t\t\t\tvec2.fromValues( 0.5,  0.5),\n\t\t\t\tvec2.fromValues(-0.5,  0.5)\n\t\t\t]), options);\n\n\t\tif(options){\n\t\t\tthis.height = options.height;\t\t\n\t\t\tthis.width = options.width;\t\n\t\t}\n\t}\n\n\t/**\n\t * Compute moment of inertia\n\t * @method computeMomentOfInertia\n\t * @return {Number}\n\t */\n\tcomputeMomentOfInertia(): f32{\n\t\tvar w = this.width,\n\t\t\th = this.height;\n\t\treturn (h*h + w*w) / 12;\n\t};\n\n\t/**\n\t * Update the bounding radius\n\t * @method updateBoundingRadius\n\t */\n\tupdateBoundingRadius(): f32{\n\t\tvar w = this.width,\n\t\t\th = this.height;\n\t\tthis.boundingRadius = Mathf.sqrt(w*w + h*h) / 2;\n\t\treturn this.boundingRadius;\n\t};\n\n\t/**\n\t * @method computeAABB\n\t * @param  {AABB}   out      The resulting AABB.\n\t * @param  {Array}  position\n\t * @param  {Number} angle\n\t */\n\tcomputeAABB(out: AABB, position: Float32Array, angle: f32): void{\n\t\tvar c = Mathf.abs(Mathf.cos(angle)),\n\t\t\ts = Mathf.abs(Mathf.sin(angle)),\n\t\t\tw = this.width,\n\t\t\th = this.height;\n\n\t\tvar height = (w * s + h * c) * 0.5;\n\t\tvar width = (h * s + w * c) * 0.5;\n\n\t\tvar l = out.lowerBound;\n\t\tvar u = out.upperBound;\n\t\tvar px = position[0];\n\t\tvar py = position[1];\n\t\tl[0] = px - width;\n\t\tl[1] = py - height;\n\t\tu[0] = px + width;\n\t\tu[1] = py + height;\n\t};\n\n\tupdateArea():f32{\n\t\tthis.area = this.width * this.height;\n\t\treturn this.area;\n\t};\n\n\tpointTest(localPoint: Float32Array): boolean{\n\t\treturn Mathf.abs(localPoint[0]) <= this.width * 0.5 && Mathf.abs(localPoint[1]) <= this.height * 0.5;\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Equation from \"./Equation\";\nimport Body from \"../objects/body\";\n\n\nexport default class RotationalVelocityEquation extends Equation{\n\tratio: f32;\n\n\t/**\n\t * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).\n\t *\n\t * @class RotationalVelocityEquation\n\t * @constructor\n\t * @extends Equation\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t */\n\tconstructor(bodyA: Body, bodyB: Body){\n\t\tsuper(bodyA, bodyB, -Infinity, Infinity);\n\t\tthis.relativeVelocity = 1;\n\t\tthis.ratio = 1;\n\t}\n\t\n\tcomputeB(a: f32,b: f32,h: f32): f32{\n\t\tvar G = this.G;\n\t\tG[2] = -1;\n\t\tG[5] = this.ratio;\n\n\t\tvar GiMf = this.computeGiMf();\n\t\tvar GW = this.computeGW();\n\t\tvar B = - GW * b - h*GiMf;\n\n\t\treturn B;\n\t}\n\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Broadphase from \"./broadphase\";\nimport World from \"../world/world\";\nimport { RemoveBodyEvent } from \"../world/world\";\nimport { AddBodyEvent } from \"../world/world\";\nimport Body from \"../objects/body\";\nimport AABB from \"./aabb\";\nimport Utils from \"../utils/utils\";\nimport { EventArgument } from \"../events/event-emitter\";\n\n// TODO: this appears to be a bubble sort. We could probably do better.\nfunction sortAxisList(a: Body[], axisIndex: u32): Body[]{\n\tfor(let i: u16 = 1, l: u16 = (a.length as u16); i < l; i++) { // Why not i=0?\n\t\tlet v = a[i];\n\t\tlet j: i32 = i - 1;\n\t\tfor(; j >= 0; j--) {\n\t\t\tif(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[j + 1] = a[j];\n\t\t}\n\t\ta[j + 1] = v;\n\t}\n\treturn a;\n}\n\nfunction _addBodyHandler(e: EventArgument): void{\n\tif(e instanceof AddBodyEvent && (e as AddBodyEvent).body){\n\t\tlet sapB = (e as AddBodyEvent).sapBroadphase;\n\t\tif(sapB) sapB.axisList.push((e as AddBodyEvent).body!);\n\t}\n}\n\nfunction _removeBodyHandler(e: EventArgument): void{\n\t// Remove from list\n\tif(e instanceof RemoveBodyEvent && (e as RemoveBodyEvent).body){\n\t\tlet sapB = (e as RemoveBodyEvent).sapBroadphase;\n\t\tif(sapB){\n\t\t\tlet idx = sapB.axisList.indexOf((e as RemoveBodyEvent).body!);\n\t\t\tif(idx !== -1){\n\t\t\t\tsapB.axisList.splice(idx,1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport default class SAPBroadphase extends Broadphase{\n\t/**\n\t * List of bodies currently in the broadphase.\n\t * @property axisList\n\t * @type {Array}\n\t */\n\taxisList: Body[] = [];\n\t/**\n\t * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.\n\t * @property axisIndex\n\t * @type {Number}\n\t */\n\taxisIndex: i32 = 0;\n\t// private _addBodyHandler: (e: EventArgument) => void = (e: EventArgument)=>{};\n\t// private _removeBodyHandler: (e: EventArgument) => void = (e: EventArgument)=>{};\n\n\t/**\n\t * Sweep and prune broadphase along one axis.\n\t *\n\t * @class SAPBroadphase\n\t * @constructor\n\t * @extends Broadphase\n\t */\n\tconstructor(){\n\t\tsuper(Broadphase.SAP);\n\t}\n\n\t/**\n\t * Change the world\n\t * @method setWorld\n\t * @param {World} world\n\t */\n\tsetWorld(world: World): void{\n\t\t// Clear the old axis array\n\t\tthis.axisList.length = 0;\n\n\t\t// Add all bodies from the new world\n\t\tUtils.appendArray(this.axisList, world.bodies);\n\n\t\t// Remove old handlers, if any\n\t\tworld\n\t\t\t.off(\"addBody\", _addBodyHandler)\n\t\t\t.off(\"removeBody\", _removeBodyHandler);\n\n\t\t// Add handlers to update the list of bodies.\n\t\t// TODO: now that I've added context, we can test moving those inline functions to proper private methods.\n\t\tworld.on(\"addBody\", _addBodyHandler, this)\n\t\t\t.on(\"removeBody\", _removeBodyHandler, this);\n\n\t\tthis.world = world;\n\t};\n\n\tsortList(): void{\n\t\tlet bodies = this.axisList,\n\t\taxisIndex = this.axisIndex;\n\n\t\t// Sort the lists\n\t\tsortAxisList(bodies, axisIndex);\n\t};\n\n\t/**\n\t * Get the colliding pairs\n\t * @method getCollisionPairs\n\t * @param  {World} world\n\t * @return {Array}\n\t */\n\tgetCollisionPairs(/*world*/): Body[]{\n\t\tlet bodies = this.axisList,\n\t\t\tresult = this.result,\n\t\t\taxisIndex = this.axisIndex;\n\n\t\tresult.length = 0;\n\n\t\t// Update all AABBs if needed\n\t\tlet l: i32 = bodies.length;\n\t\twhile(l--){\n\t\t\tlet b = bodies[l];\n\t\t\tif(b.aabbNeedsUpdate){\n\t\t\t\tb.updateAABB();\n\t\t\t}\n\t\t}\n\n\t\t// Sort the lists\n\t\tthis.sortList();\n\n\t\t// Look through the X list\n\t\tfor(let i: u16=0, N: u16 = (bodies.length as u16); i < N; i++){\n\t\t\tlet bi = bodies[i];\n\n\t\t\tfor(let j: u16 = i + 1; j < N; j++){\n\t\t\t\tlet bj = bodies[j];\n\n\t\t\t\t// Bounds overlap?\n\t\t\t\tlet overlaps: boolean = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);\n\t\t\t\tif(!overlaps){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n\t\t\t\t\tresult.push(bi);\n\t\t\t\t\tresult.push(bj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Returns all the bodies within an AABB.\n\t * @method aabbQuery\n\t * @param  {World} world\n\t * @param  {AABB} aabb\n\t * @param {array} result An array to store resulting bodies in.\n\t * @return {array}\n\t * @todo since the list is sorted, optimization can be done\n\t */\n\taabbQuery(aabb: AABB, result: Body[]): void{\n\t\tresult = result || [];\n\n\t\tthis.sortList();\n\n\t\tlet axisList = this.axisList;\n\t\tfor(let i: u16 = 0; i < (axisList.length as u16); i++){\n\t\t\tlet b = axisList[i];\n\n\t\t\tif(b.aabbNeedsUpdate){\n\t\t\t\tb.updateAABB();\n\t\t\t}\n\n\t\t\tif(b.aabb.overlaps(aabb)){\n\t\t\t\tresult.push(b);\n\t\t\t}\n\t\t}\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"./body\";\n\nexport class SpringOptions{\n\tstiffness: f32 = 100;\n\tdamping: f32 = 1;\n}\n\nexport default abstract class Spring{\n\t/**\n\t * Stiffness of the spring.\n\t * @property stiffness\n\t * @type {number}\n\t */\n\tstiffness: f32 = 100;\n\t/**\n\t * Damping of the spring.\n\t * @property damping\n\t * @type {number}\n\t */\n\tdamping: f32 = 1;\n\t/**\n\t * First connected body.\n\t * @property bodyA\n\t * @type {Body}\n\t */\n\tbodyA: Body;\n\t/**\n\t * Second connected body.\n\t * @property bodyB\n\t * @type {Body}\n\t */\n\tbodyB: Body;\n\n\t/**\n\t * Base class for {{#crossLink \"LinearSpring\"}}{{/crossLink}} and {{#crossLink \"RotationalSpring\"}}{{/crossLink}}. Not supposed to be used directly.\n\t *\n\t * @class Spring\n\t * @constructor\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Object} [options]\n\t * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n\t * @param {number} [options.damping=1]      A number >= 0. Default: 1\n\t * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n\t * @param {Array}  [options.localAnchorB]\n\t * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n\t * @param {Array}  [options.worldAnchorB]\n\t */\n\tconstructor(bodyA: Body, bodyB: Body, options:SpringOptions|null){\n\t\tif(options){\n\t\t\tthis.stiffness = options.stiffness;\n\t\t\tthis.damping = options.damping;\n\t\t}\n\t\tthis.bodyA = bodyA;\n\t\tthis.bodyB = bodyB;\n\t}\n\n\t/**\n\t * Apply the spring force to the connected bodies. Called automatically by the World.\n\t * @private\n\t * @method applyForce\n\t */\n\tabstract applyForce(): void;\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Body from \"./body\";\nimport Spring from \"./spring\";\nimport { SpringOptions } from \"./spring\";\n\nexport class RotationalSpringOptions extends SpringOptions{}\n\nexport default class RotationalSpring extends Spring{\n\trestAngle: f32 = 0;\n\n\t/**\n\t * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.\n\t *\n\t * The spring can be combined with a {{#crossLink \"RevoluteConstraint\"}}{{/crossLink}} to make, for example, a mouse trap.\n\t *\n\t * @class RotationalSpring\n\t * @extends Spring\n\t * @constructor\n\t * @param {Body} bodyA\n\t * @param {Body} bodyB\n\t * @param {Object} [options]\n\t * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.\n\t * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.\n\t * @param {number} [options.damping=1] A number >= 0.\n\t *\n\t * @example\n\t *     var spring = new RotationalSpring(bodyA, bodyB, {\n\t *         stiffness: 100,\n\t *         damping: 1\n\t *     });\n\t *     world.addSpring(spring);\n\t */\n\tconstructor(bodyA: Body, bodyB: Body, options: SpringOptions){\n\n\t\tsuper(bodyA, bodyB, options);\n\t\t// TODO: removed the ability to set the rest angle in options to work with webasm. \n\t\t// To fix, just add a boolean prop to options to ask whether we want to use the provided restangle.\n\t\tthis.restAngle = bodyB.angle - bodyA.angle;\n\t}\n\n\t/**\n\t * Apply the spring force to the connected bodies.\n\t * @method applyForce\n\t */\n\tapplyForce(): void{\n\t\tvar k = this.stiffness,\n\t\t\td = this.damping,\n\t\t\tl = this.restAngle,\n\t\t\tbodyA = this.bodyA,\n\t\t\tbodyB = this.bodyB,\n\t\t\tx = bodyB.angle - bodyA.angle,\n\t\t\tu = bodyB.angularVelocity - bodyA.angularVelocity;\n\n\t\tvar torque = - k * (x - l) - d * u;\n\n\t\tbodyA.angularForce -= torque;\n\t\tbodyB.angularForce += torque;\n\t};\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nexport default class UnionFind{\n\tid: i32[];\n\tsz: i32[];\n\tsize: i32;\n\tcount: i32;\n\n\t/**\n\t * Weighted Quick Union-Find with Path Compression. Based on https://github.com/juzerali/unionfind, but optimized for performance.\n\t * @class UnionFind\n\t * @constructor\n\t * @param {number} size\n\t */\n\tconstructor(size: i32){\n\t\tthis.id = [];\n\t\tthis.sz = [];\n\n\t\t/**\n\t\t * The number of elements.\n\t\t * @property {number} size\n\t\t */\n\t\tthis.size = size;\n\n\t\t/**\n\t\t * The number of distinct groups.\n\t\t * @property {number} count\n\t\t */\n\t\tthis.count = size;\n\n\t\tthis.resize(size);\n\t}\n\n\t/**\n\t * Initialize the UnionFind data structure with number of distinct groups to begin with. Each group will be referred to as index of the array of size size starting at 0.\n\t * @method resize\n\t * @param {number} size\n\t */\n\tresize(size: i32): void{\n\t\tthis.count = this.size = size;\n\t\tvar sz = this.sz;\n\t\tvar id = this.id;\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\tid[i] = i;\n\t\t\tsz[i] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Return the root (value) of the group in which p is.\n\t * @method find\n\t * @param {number} p\n\t */\n\tfind (p: i32): i32 {\n\t\tvar id = this.id;\n\t\twhile(p !== id[p]){\n\t\t\tid[p] = id[id[p]];\n\t\t\tp = id[p];\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Combine elements in groups p and q into a single group. In other words connect the two groups.\n\t * @method union\n\t * @param {number} p\n\t * @param {number} q\n\t */\n\tunion(p: i32, q: i32): void{\n\t\tvar i = this.find(p)\n\t\t,\tj = this.find(q);\n\n\t\tif (i === j){\n\t\t\treturn;\n\t\t}\n\n\t\tvar sz = this.sz;\n\t\tvar id = this.id;\n\t\tif (sz[i] < sz[j]) \t{id[i] = j; sz[j] += sz[i];}\n\t\telse\t\t\t\t{id[j] = i; sz[i] += sz[j];}\n\n\t\tthis.count--;\n\t\treturn;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport TupleDictionary from \"./tuple-dictionary\";\nimport OverlapKeeperRecordPool from \"./overlap-keeper-record-pool\";\nimport Body from \"../objects/body\";\nimport Shape from \"../shapes/shape\";\nimport OverlapKeeperRecord from \"./overlap-keeper-record\";\n\n\nexport default class OverlapKeeper{\n\toverlappingShapesLastState: TupleDictionary<OverlapKeeperRecord> = new TupleDictionary<OverlapKeeperRecord>();\n\toverlappingShapesCurrentState: TupleDictionary<OverlapKeeperRecord> = new TupleDictionary<OverlapKeeperRecord>();\n\trecordPool: OverlapKeeperRecordPool = new OverlapKeeperRecordPool(16);\n\ttmpDict: TupleDictionary<OverlapKeeperRecord> = new TupleDictionary<OverlapKeeperRecord>();\n\ttmpArray1: Array<OverlapKeeperRecord> = [];\n\n\t/**\n\t * Keeps track of overlaps in the current state and the last step state.\n\t * @class OverlapKeeper\n\t * @constructor\n\t */\n\tconstructor() { }\n\n\t/**\n\t * Ticks one step forward in time. This will move the current overlap state to the \"old\" overlap state, and create a new one as current.\n\t * @method tick\n\t */\n\ttick(): void {\n\t\tvar last = this.overlappingShapesLastState;\n\t\tvar current = this.overlappingShapesCurrentState;\n\n\t\t// Save old objects into pool\n\t\tvar l = last.keys.length;\n\t\twhile(l--){\n\t\t\tvar key = last.keys[l];\n\t\t\tvar lastObject = last.getByKey(key);\n\t\t\tif(lastObject){\n\t\t\t\t// The record is only used in the \"last\" dict, and will be removed. We might as well pool it.\n\t\t\t\tthis.recordPool.release(lastObject);\n\t\t\t}\n\t\t}\n\n\t\t// Clear last object\n\t\tlast.reset();\n\n\t\t// Transfer from new object to old\n\t\tlast.copy(current);\n\n\t\t// Clear current object\n\t\tcurrent.reset();\n\t}\n\n\t/**\n\t * @method setOverlapping\n\t * @param {Body} bodyA\n\t * @param {Body} shapeA\n\t * @param {Body} bodyB\n\t * @param {Body} shapeB\n\t */\n\tsetOverlapping(bodyA: Body, shapeA: Shape, bodyB: Body, shapeB: Shape): void {\n\t\tvar current = this.overlappingShapesCurrentState;\n\n\t\t// Store current contact state\n\t\tif(!current.get(shapeA.id, shapeB.id)){\n\t\t\tvar data = this.recordPool.get();\n\t\t\tdata.set(bodyA, shapeA, bodyB, shapeB);\n\t\t\tcurrent.set(shapeA.id, shapeB.id, data);\n\t\t}\n\t}\n\n\tgetNewOverlaps(result: Array<OverlapKeeperRecord>): Array<OverlapKeeperRecord>{\n\t\treturn this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);\n\t}\n\n\tgetEndOverlaps(result: Array<OverlapKeeperRecord>): Array<OverlapKeeperRecord>{\n\t\treturn this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);\n\t}\n\n\t/**\n\t * Checks if two bodies are currently overlapping.\n\t * @method bodiesAreOverlapping\n\t * @param  {Body} bodyA\n\t * @param  {Body} bodyB\n\t * @return {boolean}\n\t */\n\tbodiesAreOverlapping(bodyA: Body, bodyB: Body): boolean{\n\t\tvar current = this.overlappingShapesCurrentState;\n\t\tvar l = current.keys.length;\n\t\twhile(l--){\n\t\t\tvar key = current.keys[l];\n\t\t\tvar data = current.getByKey(key);\n\t\t\tif((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Made result non-nullable. Hopefully that's okay.\n\tgetDiff(dictA: TupleDictionary<OverlapKeeperRecord>, dictB: TupleDictionary<OverlapKeeperRecord>, result: Array<OverlapKeeperRecord>): Array<OverlapKeeperRecord>{\n\t\tresult = result || [];\n\t\tvar last = dictA;\n\t\tvar current = dictB;\n\n\t\tresult.length = 0;\n\n\t\tvar l = current.keys.length;\n\t\twhile(l--){\n\t\t\tvar key = current.keys[l];\n\t\t\tvar data = current.getByKey(key);\n\n\t\t\tif(!data){\n\t\t\t\tthrow new Error(\"Key \" + key.toString() + \" had no data!\");\n\t\t\t}\n\n\t\t\tvar lastData = last.getByKey(key);\n\t\t\tif(!lastData){\n\t\t\t\t// Not overlapping in last state, but in current.\n\t\t\t\tresult.push(data);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tisNewOverlap(shapeA: Shape, shapeB: Shape): boolean{\n\t\tvar last = this.overlappingShapesLastState;\n\t\tvar current = this.overlappingShapesCurrentState;\n\t\t// Not in last but in new\n\t\treturn !last.get(shapeA.id, shapeB.id) && !!current.get(shapeA.id, shapeB.id);\n\t}\n\n\tgetNewBodyOverlaps(result: Array<Body>): Array<Body>{\n\t\tthis.tmpArray1.length = 0;\n\t\tvar overlaps = this.getNewOverlaps(this.tmpArray1);\n\t\treturn this.getBodyDiff(overlaps, result);\n\t}\n\n\tgetEndBodyOverlaps(result: Array<Body>): Array<Body>{\n\t\tthis.tmpArray1.length = 0;\n\t\tvar overlaps = this.getEndOverlaps(this.tmpArray1);\n\t\treturn this.getBodyDiff(overlaps, result);\n\t}\n\n\tgetBodyDiff(overlaps: Array<OverlapKeeperRecord>, result: Array<Body>): Array<Body>{\n\t\tresult = result || [];\n\t\tvar accumulator = this.tmpDict;\n\n\t\tvar l = overlaps.length;\n\n\t\twhile(l--){\n\t\t\tlet data = overlaps[l];\n\n\t\t\t// Since we use body id's for the accumulator, these will be a subset of the original one\n\t\t\tif(data.bodyA && data.bodyB)\n\t\t\t\taccumulator.set(data.bodyA.id, data.bodyB.id, data);\n\t\t}\n\n\t\tl = accumulator.keys.length;\n\t\twhile(l--){\n\t\t\tlet data = accumulator.getByKey(accumulator.keys[l]);\n\t\t\tif(data && data.bodyA && data.bodyB){\n\t\t\t\tresult.push(data.bodyA);\n\t\t\t\tresult.push(data.bodyB);\n\t\t\t}\n\t\t}\n\n\t\taccumulator.reset();\n\n\t\treturn result;\n\t}\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\n// import Pool from \"./pool\";\nimport OverlapKeeperRecord from \"./overlap-keeper-record\";\n// import OverlapKeeper from \"./overlap-keeper\";\n\n\nexport default class OverlapKeeperRecordPool{\n\n\t/**\n\t * @property {Array} objects\n\t * @type {Array}\n\t */\n\tobjects: OverlapKeeperRecord[] = [];\n\n\t/**\n\t * @class\n\t */\n\tconstructor(size: u32) {\n\t\tthis.resize(size);\n\t}\n\n\t/**\n\t * @method resize\n\t * @param {number} size\n\t * @return {Pool} Self, for chaining\n\t */\n\tresize(size: i32): OverlapKeeperRecordPool {\n\t\tvar objects = this.objects;\n\n\t\twhile (objects.length > size) {\n\t\t\tobjects.pop();\n\t\t}\n\n\t\twhile (objects.length < size) {\n\t\t\tobjects.push(this.create());\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get an object from the pool or create a new instance.\n\t * @method get\n\t * @return {Object}\n\t */\n\tget(): OverlapKeeperRecord {\n\t\tvar objects = this.objects;\n\t\treturn objects.length ? objects.pop() : this.create();\n\t}\n\n\t/**\n\t * Clean up and put the object back into the pool for later use.\n\t * @method release\n\t * @param {Object} object\n\t * @return {Pool} Self for chaining\n\t */\n\trelease(object: OverlapKeeperRecord): OverlapKeeperRecordPool {\n\t\tthis.destroy(object);\n\t\tthis.objects.push(object);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @method create\n\t * @return {OverlapKeeperRecord}\n\t */\n\tcreate(): OverlapKeeperRecord {\n\t\treturn new OverlapKeeperRecord(null, null, null, null);\n\t};\n\n\t/**\n\t * @method destroy\n\t * @param {OverlapKeeperRecord} record\n\t * @return {OverlapKeeperRecordPool}\n\t */\n\tdestroy(record: OverlapKeeperRecord): OverlapKeeperRecordPool {\n\t\trecord.set(null,null,null,null);\n\t\treturn this;\n\t};\n\n}","//type i16=number; type i32=number;type i64=number;type u16=number; type u32=number;type u64=number;type f32=number;\n\nimport Shape from \"../shapes/shape\";\nimport Body from \"../objects/body\";\n\n\nexport default class OverlapKeeperRecord{\n\t/**\n\t * @property {Shape} shapeA\n\t */\n\tshapeA: Shape|null = null;\n\t/**\n\t * @property {Shape} shapeB\n\t */\n\tshapeB: Shape|null = null;\n\t/**\n\t * @property {Body} bodyA\n\t*/\n\tbodyA: Body|null = null;\n\t/**\n\t * @property {Body} bodyB\n\t */\n\tbodyB: Body|null = null;\n\n\t/**\n\t * Overlap data container for the OverlapKeeper\n\t * @class OverlapKeeperRecord\n\t * @constructor\n\t * @param {Body} bodyA\n\t * @param {Shape} shapeA\n\t * @param {Body} bodyB\n\t * @param {Shape} shapeB\n\t */\n\tconstructor(bodyA: Body|null, shapeA: Shape|null, bodyB: Body|null, shapeB: Shape|null){\n\t\tthis.set(bodyA, shapeA, bodyB, shapeB);\n\t}\n\n\t/**\n\t * Set the data for the record\n\t * @method set\n\t * @param {Body} bodyA\n\t * @param {Shape} shapeA\n\t * @param {Body} bodyB\n\t * @param {Shape} shapeB\n\t */\n\tset(bodyA: Body|null, shapeA: Shape|null, bodyB: Body|null, shapeB: Shape|null): void{\n\t\tthis.shapeA = shapeA;\n\t\tthis.shapeB = shapeB;\n\t\tthis.bodyA = bodyA;\n\t\tthis.bodyB = bodyB;\n\t};\n}","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}