!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var AABB = /** @class */ (function () {
    /**
     * Axis aligned bounding box class.
     * @class AABB
     * @constructor
     * @param {Object}  [options]
     * @param {Array}   [options.upperBound]
     * @param {Array}   [options.lowerBound]
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     */
    function AABB(options) {
        this.tmp = vec2_1.default.create();
        options = options !== null && options !== void 0 ? options : {};
        /**
         * The lower bound of the bounding box.
         * @property lowerBound
         * @type {Array}
         */
        this.lowerBound = options.lowerBound ? vec2_1.default.clone(options.lowerBound) : vec2_1.default.create();
        /**
         * The upper bound of the bounding box.
         * @property upperBound
         * @type {Array}
         */
        this.upperBound = options.upperBound ? vec2_1.default.clone(options.upperBound) : vec2_1.default.create();
    }
    /**
     * Set the AABB bounds from a set of points, transformed by the given position and angle.
     * @method setFromPoints
     * @param {Array} points An array of vec2's.
     * @param {Array} position
     * @param {number} [angle=0]
     * @param {number} [skinSize=0] Some margin to be added to the AABB.
     */
    AABB.prototype.setFromPoints = function (points, position, angle, skinSize) {
        if (skinSize === void 0) { skinSize = 0; }
        var l = this.lowerBound, u = this.upperBound;
        angle = angle || 0;
        // Set to the first point
        if (angle !== 0) {
            vec2_1.default.rotate(l, points[0], angle);
        }
        else {
            vec2_1.default.copy(l, points[0]);
        }
        vec2_1.default.copy(u, l);
        // Compute cosines and sines just once
        var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
        for (var i = 1; i < points.length; i++) {
            var p = points[i];
            if (angle !== 0) {
                var x = p[0], y = p[1];
                this.tmp[0] = cosAngle * x - sinAngle * y;
                this.tmp[1] = sinAngle * x + cosAngle * y;
                p = this.tmp;
            }
            for (var j = 0; j < 2; j++) {
                if (p[j] > u[j]) {
                    u[j] = p[j];
                }
                if (p[j] < l[j]) {
                    l[j] = p[j];
                }
            }
        }
        // Add offset
        if (position) {
            vec2_1.default.add(l, l, position);
            vec2_1.default.add(u, u, position);
        }
        if (skinSize) {
            l[0] -= skinSize;
            l[1] -= skinSize;
            u[0] += skinSize;
            u[1] += skinSize;
        }
    };
    /**
     * Copy bounds from an AABB to this AABB
     * @method copy
     * @param  {AABB} aabb
     */
    AABB.prototype.copy = function (aabb) {
        vec2_1.default.copy(this.lowerBound, aabb.lowerBound);
        vec2_1.default.copy(this.upperBound, aabb.upperBound);
    };
    /**
     * Extend this AABB so that it covers the given AABB too.
     * @method extend
     * @param  {AABB} aabb
     */
    AABB.prototype.extend = function (aabb) {
        var lower = this.lowerBound, upper = this.upperBound;
        // Loop over x and y
        var i = 2;
        while (i--) {
            // Extend lower bound
            var l = aabb.lowerBound[i];
            if (lower[i] > l) {
                lower[i] = l;
            }
            // Upper
            var u = aabb.upperBound[i];
            if (upper[i] < u) {
                upper[i] = u;
            }
        }
    };
    /**
     * Returns true if the given AABB overlaps this AABB.
     * @method overlaps
     * @param  {AABB} aabb
     * @return {Boolean}
     */
    AABB.prototype.overlaps = function (aabb) {
        var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
        //      l2        u2
        //      |---------|
        // |--------|
        // l1       u1
        return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
            ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
    };
    ;
    /**
     * @method containsPoint
     * @param  {Array} point
     * @return {boolean}
     */
    AABB.prototype.containsPoint = function (point) {
        var l = this.lowerBound, u = this.upperBound;
        return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
    };
    /**
     * Check if the AABB is hit by a ray.
     * @method overlapsRay
     * @param  {Ray} ray
     * @return {number} -1 if no hit, a number between 0 and 1 if hit, indicating the position between the "from" and "to" points.
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     *     var ray = new Ray({
     *         from: [-2, 0],
     *         to: [0, 0]
     *     });
     *     var fraction = aabb.overlapsRay(ray); // fraction == 0.5
     */
    AABB.prototype.overlapsRay = function (ray) {
        // ray.direction is unit direction vector of ray
        var dirFracX = 1 / ray.direction[0];
        var dirFracY = 1 / ray.direction[1];
        // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
        var from = ray.from;
        var lowerBound = this.lowerBound;
        var upperBound = this.upperBound;
        var t1 = (lowerBound[0] - from[0]) * dirFracX;
        var t2 = (upperBound[0] - from[0]) * dirFracX;
        var t3 = (lowerBound[1] - from[1]) * dirFracY;
        var t4 = (upperBound[1] - from[1]) * dirFracY;
        var tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        var tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));
        // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
        if (tmax < 0) {
            //t = tmax;
            return -1;
        }
        // if tmin > tmax, ray doesn't intersect AABB
        if (tmin > tmax) {
            //t = tmax;
            return -1;
        }
        return tmin / ray.length;
    };
    return AABB;
}());
exports.default = AABB;

},{"../math/vec2":28}],2:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Body_1 = __importDefault(_dereq_("../objects/Body"));
// TODO: I think this is supposed to be abstract.
var Broadphase = /** @class */ (function () {
    /**
     * Base class for broadphase implementations. Don't use this class directly.
     * @class Broadphase
     * @constructor
     */
    function Broadphase(type) {
        /**
         * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
         * @property result
         * @type {Array}
         */
        this.result = [];
        /**
         * The world to search for collision pairs in. To change it, use .setWorld()
         * @property world
         * @type {World}
         * @readOnly
         */
        this.world = null;
        /**
         * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
         * @property {Number} boundingVolumeType
         */
        this.boundingVolumeType = Broadphase.AABB;
        this.type = type || 1;
    }
    /**
     * Set the world that we are searching for collision pairs in.
     * @method setWorld
     * @param  {World} world
     */
    // TODO: move to constructor!
    Broadphase.prototype.setWorld = function (world) {
        this.world = world;
    };
    ;
    /*
     * Get all potential intersecting body pairs.
     * @method getCollisionPairs
     * @param  {World} world The world to search in.
     * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
     */
    Broadphase.prototype.getCollisionPairs = function (world) {
        // I guess this should be overridden?
        // TODO: possible abstract method.
        return [];
    };
    ;
    /**
     * Check whether the bounding radius of two bodies overlap.
     * @method  boundingRadiusCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.boundingRadiusCheck = function (bodyA, bodyB) {
        var d2 = vec2_1.default.squaredDistance(bodyA.position, bodyB.position), r = bodyA.boundingRadius + bodyB.boundingRadius;
        return d2 <= r * r;
    };
    ;
    /**
     * Check whether the AABB of two bodies overlap.
     * @method  aabbCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.aabbCheck = function (bodyA, bodyB) {
        return bodyA.getAABB().overlaps(bodyB.getAABB());
    };
    ;
    /**
     * Check whether the bounding volumes of two bodies overlap.
     * @method  boundingVolumeCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.prototype.boundingVolumeCheck = function (bodyA, bodyB) {
        var result;
        switch (this.boundingVolumeType) {
            case Broadphase.BOUNDING_CIRCLE:
                result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                break;
            case Broadphase.AABB:
                result = Broadphase.aabbCheck(bodyA, bodyB);
                break;
            default:
                throw new Error('Bounding volume type not recognized: ' + this.boundingVolumeType);
        }
        return result;
    };
    ;
    /**
     * Check whether two bodies are allowed to collide at all.
     * @method  canCollide
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.canCollide = function (bodyA, bodyB) {
        var KINEMATIC = Body_1.default.KINEMATIC;
        var STATIC = Body_1.default.STATIC;
        var typeA = bodyA.type;
        var typeB = bodyB.type;
        // Cannot collide static bodies
        if (typeA === STATIC && typeB === STATIC) {
            return false;
        }
        // Cannot collide static vs kinematic bodies
        if ((typeA === KINEMATIC && typeB === STATIC) ||
            (typeA === STATIC && typeB === KINEMATIC)) {
            return false;
        }
        // Cannot collide kinematic vs kinematic
        if (typeA === KINEMATIC && typeB === KINEMATIC) {
            return false;
        }
        // Cannot collide both sleeping bodies
        if (bodyA.sleepState === Body_1.default.SLEEPING && bodyB.sleepState === Body_1.default.SLEEPING) {
            return false;
        }
        // Cannot collide if one is static and the other is sleeping
        if ((bodyA.sleepState === Body_1.default.SLEEPING && typeB === STATIC) ||
            (bodyB.sleepState === Body_1.default.SLEEPING && typeA === STATIC)) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    Broadphase.prototype.aabbQuery = function (world, aabb, result) {
        // To be implemented in subclasses
    };
    ;
    // Mode:
    Broadphase.NAIVE = 1;
    Broadphase.SAP = 2;
    // Bounding box:
    /**
     * Axis aligned bounding box type.
     * @static
     * @property {Number} AABB
     */
    Broadphase.AABB = 1;
    /**
     * Bounding circle type.
     * @static
     * @property {Number} BOUNDING_CIRCLE
     */
    Broadphase.BOUNDING_CIRCLE = 2;
    return Broadphase;
}());
exports.default = Broadphase;

},{"../math/vec2":28,"../objects/Body":29}],3:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var NaiveBroadphase = /** @class */ (function (_super) {
    __extends(NaiveBroadphase, _super);
    /**
     * Naive broadphase implementation. Does N^2 tests.
     *
     * @class NaiveBroadphase
     * @constructor
     * @extends Broadphase
     */
    function NaiveBroadphase() {
        return _super.call(this, broadphase_1.default.NAIVE) || this;
    }
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    NaiveBroadphase.prototype.getCollisionPairs = function (world) {
        var bodies = world.bodies, result = this.result;
        result.length = 0;
        for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
            var bi = bodies[i];
            for (var j = 0; j < i; j++) {
                var bj = bodies[j];
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        var bodies = world.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return NaiveBroadphase;
}(broadphase_1.default));
exports.default = NaiveBroadphase;

},{"./broadphase":2}],4:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var sub = vec2_1.default.subtract, add = vec2_1.default.add, dot = vec2_1.default.dot, rotate = vec2_1.default.rotate, normalize = vec2_1.default.normalize, copy = vec2_1.default.copy, scale = vec2_1.default.scale, squaredLength = vec2_1.default.squaredLength, createVec2 = vec2_1.default.create;
var Circle_1 = __importDefault(_dereq_("../shapes/Circle"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var Box_1 = __importDefault(_dereq_("../shapes/Box"));
var contact_equation_pool_1 = __importDefault(_dereq_("../utils/contact-equation-pool"));
var friction_equation_pool_1 = __importDefault(_dereq_("../utils/friction-equation-pool"));
var tuple_dictionary_1 = __importDefault(_dereq_("../utils/tuple-dictionary"));
var yAxis = vec2_1.default.fromValues(0, 1);
var tmp1 = createVec2(), tmp2 = createVec2(), tmp3 = createVec2(), tmp4 = createVec2(), tmp5 = createVec2(), tmp6 = createVec2(), tmp7 = createVec2(), tmp8 = createVec2(), tmp9 = createVec2(), tmp10 = createVec2(), tmp11 = createVec2(), tmp12 = createVec2(), tmp13 = createVec2(), tmp14 = createVec2(), tmp15 = createVec2(), tmpArray = [];
var findMaxSeparation_n = vec2_1.default.create();
var findMaxSeparation_v1 = vec2_1.default.create();
var findMaxSeparation_tmp = vec2_1.default.create();
var findMaxSeparation_tmp2 = vec2_1.default.create();
var findIncidentEdge_normal1 = vec2_1.default.create();
var collidePolygons_tempVec = vec2_1.default.create();
var collidePolygons_tmpVec = vec2_1.default.create();
var collidePolygons_localTangent = vec2_1.default.create();
var collidePolygons_localNormal = vec2_1.default.create();
var collidePolygons_planePoint = vec2_1.default.create();
var collidePolygons_tangent = vec2_1.default.create();
var collidePolygons_normal = vec2_1.default.create();
var collidePolygons_negativeTangent = vec2_1.default.create();
var collidePolygons_v11 = vec2_1.default.create();
var collidePolygons_v12 = vec2_1.default.create();
var collidePolygons_dist = vec2_1.default.create();
var collidePolygons_clipPoints1 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_clipPoints2 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_incidentEdge = [vec2_1.default.create(), vec2_1.default.create()];
var pic_localPoint = createVec2(), pic_r0 = createVec2(), pic_r1 = createVec2();
var bodiesOverlap_shapePositionA = createVec2(), bodiesOverlap_shapePositionB = createVec2();
var capsuleCapsule_tempVec1 = createVec2(), capsuleCapsule_tempVec2 = createVec2();
var convexCapsule_tempVec = createVec2();
var planeCapsule_tmp1 = createVec2(), planeCapsule_tmp2 = createVec2();
var circleHeightfield_candidate = createVec2(), circleHeightfield_dist = createVec2(), circleHeightfield_v0 = createVec2(), circleHeightfield_v1 = createVec2(), circleHeightfield_minCandidate = createVec2(), circleHeightfield_worldNormal = createVec2(), circleHeightfield_minCandidateNormal = createVec2();
var convexHeightfield_v0 = createVec2(), convexHeightfield_v1 = createVec2(), convexHeightfield_tilePos = createVec2(), convexHeightfield_tempConvexShape = new Convex_1.default(undefined, [createVec2(), createVec2(), createVec2(), createVec2()]);
function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
    var capsuleRadius = capsuleShape.radius;
    var halfCapsuleLength = capsuleShape.length * 0.5;
    var verts = convexShape.vertices;
    vec2_1.default.set(verts[0], -halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[1], halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[2], halfCapsuleLength, capsuleRadius);
    vec2_1.default.set(verts[3], -halfCapsuleLength, capsuleRadius);
}
/*
* Check if a point is in a polygon
*/
function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
    var localPoint = pic_localPoint, r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null;
    vec2_1.default.toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);
    for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
/*
* Check if a point is in a polygon
*/
function pointInConvexLocal(localPoint, convexShape) {
    var r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null, numVerts = verts.length;
    for (var i = 0; i < numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
function addSub(out, a, b, c) {
    out[0] = a[0] + b[0] - c[0];
    out[1] = a[1] + b[1] - c[1];
}
function findMaxSeparation(maxSeparationOut, poly1, position1, angle1, poly2, position2, angle2) {
    // Find the max separation between poly1 and poly2 using edge normals from poly1.
    var count1 = poly1.vertices.length;
    var count2 = poly2.vertices.length;
    var n1s = poly1.normals;
    var v1s = poly1.vertices;
    var v2s = poly2.vertices;
    var n = findMaxSeparation_n;
    var v1 = findMaxSeparation_v1;
    var tmp = findMaxSeparation_tmp;
    var tmp2 = findMaxSeparation_tmp2;
    var angle = angle1 - angle2;
    var bestIndex = 0;
    var maxSeparation = -Infinity;
    for (var i = 0; i < count1; ++i) {
        // Get poly1 normal in frame2.
        vec2_1.default.rotate(n, n1s[i], angle);
        // Get poly1 vertex in frame2
        vec2_1.default.toGlobalFrame(tmp2, v1s[i], position1, angle1);
        vec2_1.default.toLocalFrame(v1, tmp2, position2, angle2);
        // Find deepest point for normal i.
        var si = Infinity;
        for (var j = 0; j < count2; ++j) {
            vec2_1.default.subtract(tmp, v2s[j], v1);
            var sij = vec2_1.default.dot(n, tmp);
            if (sij < si) {
                si = sij;
            }
        }
        if (si > maxSeparation) {
            maxSeparation = si;
            bestIndex = i;
        }
    }
    // Use a vec2 for storing the float value and always return int, for perf
    maxSeparationOut[0] = maxSeparation;
    return bestIndex;
}
function findIncidentEdge(clipVerticesOut, poly1, position1, angle1, edge1, poly2, position2, angle2) {
    var normals1 = poly1.normals;
    var count2 = poly2.vertices.length;
    var vertices2 = poly2.vertices;
    var normals2 = poly2.normals;
    // Get the normal of the reference edge in poly2's frame.
    var normal1 = findIncidentEdge_normal1;
    vec2_1.default.rotate(normal1, normals1[edge1], angle1 - angle2);
    // Find the incident edge on poly2.
    var index = 0;
    var minDot = Infinity;
    for (var i = 0; i < count2; ++i) {
        var dot_1 = vec2_1.default.dot(normal1, normals2[i]);
        if (dot_1 < minDot) {
            minDot = dot_1;
            index = i;
        }
    }
    // Build the clip vertices for the incident edge.
    var i1 = index;
    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
    vec2_1.default.toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);
    vec2_1.default.toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);
}
function clipSegmentToLine(vOut, vIn, normal, offset) {
    // Start with no output points
    var numOut = 0;
    // Calculate the distance of end points to the line
    var distance0 = vec2_1.default.dot(normal, vIn[0]) - offset;
    var distance1 = vec2_1.default.dot(normal, vIn[1]) - offset;
    // If the points are behind the plane
    if (distance0 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[0]);
    }
    if (distance1 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[1]);
    }
    // If the points are on different sides of the plane
    if (distance0 * distance1 < 0.0) {
        // Find intersection point of edge and plane
        var interp = distance0 / (distance0 - distance1);
        var v = vOut[numOut];
        vec2_1.default.subtract(v, vIn[1], vIn[0]);
        vec2_1.default.scale(v, v, interp);
        vec2_1.default.add(v, v, vIn[0]);
        ++numOut;
    }
    return numOut;
}
var Narrowphase = /** @class */ (function () {
    /**
     * Narrowphase. Creates contacts and friction given shapes and transforms.
     * @class Narrowphase
     * @constructor
     */
    function Narrowphase() {
        /**
         * @property contactEquations
         * @type {Array}
         */
        this.contactEquations = [];
        /**
         * @property frictionEquations
         * @type {Array}
         */
        this.frictionEquations = [];
        /**
         * Whether to make friction equations in the upcoming contacts.
         * @property enableFriction
         * @type {Boolean}
         */
        this.enableFriction = true;
        /**
         * Whether to make equations enabled in upcoming contacts.
         * @property enabledEquations
         * @type {Boolean}
         */
        this.enabledEquations = true;
        /**
         * The friction slip force to use when creating friction equations.
         * @property slipForce
         * @type {Number}
         */
        this.slipForce = 10.0;
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {ContactEquationPool} contactEquationPool
         *
         * @example
         *
         *     // Allocate a few equations before starting the simulation.
         *     // This way, no contact objects need to be created on the fly in the game loop.
         *     world.narrowphase.contactEquationPool.resize(1024);
         *     world.narrowphase.frictionEquationPool.resize(1024);
         */
        this.contactEquationPool = new contact_equation_pool_1.default({ size: 32 });
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {FrictionEquationPool} frictionEquationPool
         */
        this.frictionEquationPool = new friction_equation_pool_1.default({ size: 64 });
        /**
         * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
         * @property enableFrictionReduction
         * @type {Boolean}
         * @deprecated This flag will be removed when the feature is stable enough.
         * @default true
         */
        this.enableFrictionReduction = true;
        /**
         * Keeps track of the colliding bodies last step.
         * @private
         * @property collidingBodiesLastStep
         * @type {TupleDictionary}
         */
        this.collidingBodiesLastStep = new tuple_dictionary_1.default();
        /**
         * @property currentContactMaterial
         * @type {ContactMaterial}
         */
        this.currentContactMaterial = null;
    }
    /**
     * @method bodiesOverlap
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @param  {boolean} [checkCollisionMasks=false]
     * @return {Boolean}
     */
    Narrowphase.prototype.bodiesOverlap = function (bodyA, bodyB, checkCollisionMasks) {
        if (checkCollisionMasks === void 0) { checkCollisionMasks = false; }
        var shapePositionA = bodiesOverlap_shapePositionA;
        var shapePositionB = bodiesOverlap_shapePositionB;
        // Loop over all shapes of bodyA
        for (var k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++) {
            var shapeA = bodyA.shapes[k];
            // All shapes of body j
            for (var l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++) {
                var shapeB = bodyB.shapes[l];
                // Check collision groups and masks
                if (checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)) {
                    return false;
                }
                bodyA.toWorldFrame(shapePositionA, shapeA.position);
                bodyB.toWorldFrame(shapePositionB, shapeB.position);
                var result = this.testContact(bodyA, shapeA, shapePositionA, bodyB, shapeB, shapePositionB, true);
                if (result)
                    return true;
            }
        }
        return false;
    };
    ;
    /**
     * Check if the bodies were in contact since the last reset().
     * @method collidedLastStep
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Narrowphase.prototype.collidedLastStep = function (bodyA, bodyB) {
        var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
        return !!this.collidingBodiesLastStep.get(id1, id2);
    };
    ;
    /**
     * Throws away the old equations and gets ready to create new
     * @method reset
     */
    Narrowphase.prototype.reset = function () {
        this.collidingBodiesLastStep.reset();
        var eqs = this.contactEquations;
        var l = eqs.length;
        while (l--) {
            var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
            this.collidingBodiesLastStep.set(id1, id2, 1);
        }
        var ce = this.contactEquations, fe = this.frictionEquations;
        for (var i = 0; i < ce.length; i++) {
            this.contactEquationPool.release(ce[i]);
        }
        for (var i = 0; i < fe.length; i++) {
            this.frictionEquationPool.release(fe[i]);
        }
        // Reset
        this.contactEquations.length = this.frictionEquations.length = 0;
    };
    ;
    /**
     * Creates a ContactEquation, either by reusing an existing object or creating a new one.
     * @method createContactEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {ContactEquation}
     */
    Narrowphase.prototype.createContactEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.contactEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.enabled = this.enabledEquations;
        c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
        c.restitution = currentContactMaterial.restitution;
        c.stiffness = currentContactMaterial.stiffness;
        c.relaxation = currentContactMaterial.relaxation;
        c.offset = currentContactMaterial.contactSkinSize;
        c.needsUpdate = true;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
     * @method createFrictionEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.frictionEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.setSlipForce(this.slipForce);
        c.enabled = this.enabledEquations;
        c.frictionCoefficient = currentContactMaterial.friction;
        c.relativeVelocity = currentContactMaterial.surfaceVelocity;
        c.stiffness = currentContactMaterial.frictionStiffness;
        c.relaxation = currentContactMaterial.frictionRelaxation;
        c.needsUpdate = true;
        c.contactEquations.length = 0;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
     * @method createFrictionFromContact
     * @param  {ContactEquation} contactEquation
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionFromContact = function (c) {
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        copy(eq.contactPointA, c.contactPointA);
        copy(eq.contactPointB, c.contactPointB);
        vec2_1.default.rotate90cw(eq.t, c.normalA);
        eq.contactEquations.push(c);
        return eq;
    };
    ;
    // Take the average N latest contact point on the plane.
    Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
        var c = this.contactEquations[this.contactEquations.length - 1];
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        var bodyA = c.bodyA;
        vec2_1.default.set(eq.contactPointA, 0, 0);
        vec2_1.default.set(eq.contactPointB, 0, 0);
        vec2_1.default.set(eq.t, 0, 0);
        for (var i = 0; i < numContacts; i++) {
            c = this.contactEquations[this.contactEquations.length - 1 - i];
            if (c.bodyA === bodyA) {
                add(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                add(eq.contactPointB, eq.contactPointB, c.contactPointB);
            }
            else {
                sub(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                add(eq.contactPointB, eq.contactPointB, c.contactPointA);
            }
            eq.contactEquations.push(c);
        }
        var invNumContacts = 1 / numContacts;
        scale(eq.contactPointA, eq.contactPointA, invNumContacts);
        scale(eq.contactPointB, eq.contactPointB, invNumContacts);
        normalize(eq.t, eq.t);
        vec2_1.default.rotate90cw(eq.t, eq.t);
        return eq;
    };
    ;
    Narrowphase.prototype.testContact = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest
    // meta?: {
    // 	radiusA?: f32,
    // 	radiusB?: f32
    // }
    ) {
        var result = 0;
        if (shapeA.type > shapeB.type) {
            var bTmp = bodyB;
            bodyB = bodyA;
            bodyA = bTmp;
            var sTmp = shapeB;
            shapeB = shapeA;
            shapeA = sTmp;
            var pTmp = offsetB;
            offsetB = offsetA;
            offsetA = pTmp;
        }
        switch (shapeA.type | shapeB.type) {
            case 1: { // Circle/circle
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCircle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius, sb.radius);
                break;
            }
            case 3: { // Particle/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleParticle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest);
                break;
            }
            case 5: { // Plane/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 33: // Box/circle.
            case 9: { // Convex/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, sa.radius);
                break;
            }
            case 17: { // Line/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleLine(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, 0, sa.radius);
                break;
            }
            case 65: { // Capsule/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 129: { // Heightfield/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleHeightfield(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius);
                break;
            }
            case 6: { // Plane/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 34: // Box/particle.
            case 10: { // Convex/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 10: { // Capsule/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 36: // Box/plane.
            case 12: { // Convex/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 20: { // Line/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeLine(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 68: { // Capsule/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 40: // Box/convex.
            case 8: { // Convex/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 24: { // Line/convex.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.convexLine(bodyA, sa, offsetA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle, 
                // 	justTest);
                break;
            }
            case 72: { // Capsule/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 136: { // Heightfield/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexHeightfield(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, justTest);
                break;
            }
            case 16: { // Line/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineLine(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 48: { // Box/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineBox(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 80: { // Capsule/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineCapsule(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 64: { // Capsule/capsule.
                var sa = shapeA;
                var sb = shapeB;
                result = this.capsuleCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
        }
        return result;
    };
    /**
     * Convex/line narrowphase
     * @method convexLine
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexOffset
     * @param  {Number}     convexAngle
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param {boolean}     justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.LINE] =
    Narrowphase.prototype.convexLine = function (
    /*
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Line/box narrowphase
     * @method lineBox
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param  {Body}       boxBody
     * @param  {Box}  boxShape
     * @param  {Array}      boxOffset
     * @param  {Number}     boxAngle
     * @param  {Boolean}    justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.BOX] =
    Narrowphase.prototype.lineBox = function (
    /*
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    boxBody,
    boxShape,
    boxOffset,
    boxAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Convex/capsule narrowphase
     * @method convexCapsule
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexPosition
     * @param  {Number}     convexAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.CAPSULE] =
    //Narrowphase.prototype[Shape.BOX | Shape.CAPSULE] =
    Narrowphase.prototype.convexCapsule = function (convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        var convexCapsule_tempRect = new Box_1.default({ width: 1, height: 1 });
        // Check the circles
        // Add offsets!
        var circlePos = convexCapsule_tempVec;
        var halfLength = capsuleShape.length / 2;
        vec2_1.default.set(circlePos, halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        vec2_1.default.set(circlePos, -halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        if (justTest && (result1 + result2) !== 0) {
            return 1;
        }
        // Check center rect
        var r = convexCapsule_tempRect;
        setConvexToCapsuleShapeMiddle(r, capsuleShape);
        var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
        return result + result1 + result2;
    };
    ;
    /**
     * Capsule/line narrowphase
     * @method lineCapsule
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      linePosition
     * @param  {Number}     lineAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.CAPSULE] =
    Narrowphase.prototype.lineCapsule = function (
    /*
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Capsule/capsule narrowphase
     * @method capsuleCapsule
     * @param  {Body}       bi
     * @param  {Capsule}    si
     * @param  {Array}      xi
     * @param  {Number}     ai
     * @param  {Body}       bj
     * @param  {Capsule}    sj
     * @param  {Array}      xj
     * @param  {Number}     aj
     */
    //Narrowphase.prototype[Shape.CAPSULE] =
    Narrowphase.prototype.capsuleCapsule = function (bi, si, xi, ai, bj, sj, xj, aj, justTest) {
        throw "Capsule-capsule collisions are not currently supported.";
        return 0;
        // let capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });
        // let enableFrictionBefore: boolean = false;
        // // Check the circles
        // // Add offsets!
        // let circlePosi = capsuleCapsule_tempVec1,
        // 	circlePosj = capsuleCapsule_tempVec2;
        // let numContacts = 0;
        // // Need 4 circle checks, between all
        // for(let i=0; i<2; i++){
        // 	vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        // 	vec2.toGlobalFrame(circlePosi, circlePosi, xi, ai);
        // 	for(let j=0; j<2; j++){
        // 		vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
        // 		vec2.toGlobalFrame(circlePosj, circlePosj, xj, aj);
        // 		// Temporarily turn off friction
        // 		if(this.enableFrictionReduction){
        // 			enableFrictionBefore = this.enableFriction;
        // 			this.enableFriction = false;
        // 		}
        // 		let result = this.circleCircle(bi,si,circlePosi, bj,sj,circlePosj, justTest, si.radius, sj.radius);
        // 		if(this.enableFrictionReduction){
        // 			this.enableFriction = enableFrictionBefore;
        // 		}
        // 		if(justTest && result !== 0){
        // 			return 1;
        // 		}
        // 		numContacts += result;
        // 	}
        // }
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // // Check circles against the center boxs
        // let rect = capsuleCapsule_tempRect1;
        // setConvexToCapsuleShapeMiddle(rect,si);
        // let result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result1 !== 0){
        // 	return 1;
        // }
        // numContacts += result1;
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	let enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // setConvexToCapsuleShapeMiddle(rect,sj);
        // let result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result2 !== 0){
        // 	return 1;
        // }
        // numContacts += result2;
        // if(this.enableFrictionReduction){
        // 	if(numContacts && this.enableFriction){
        // 		this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        // 	}
        // }
        // return numContacts;
    };
    ;
    /**
     * Line/line narrowphase
     * @method lineLine
     * @param  {Body}       bodyA
     * @param  {Line}       shapeA
     * @param  {Array}      positionA
     * @param  {Number}     angleA
     * @param  {Body}       bodyB
     * @param  {Line}       shapeB
     * @param  {Array}      positionB
     * @param  {Number}     angleB
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE] =
    Narrowphase.prototype.lineLine = function (
    /* bodyA,
        shapeA,
        positionA,
        angleA,
        bodyB,
        shapeB,
        positionB,
        angleB,
        justTest*/
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Plane/line Narrowphase
     * @method planeLine
     * @param  {Body}   planeBody
     * @param  {Plane}  planeShape
     * @param  {Array}  planeOffset
     * @param  {Number} planeAngle
     * @param  {Body}   lineBody
     * @param  {Line}   lineShape
     * @param  {Array}  lineOffset
     * @param  {Number} lineAngle
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
    Narrowphase.prototype.planeLine = function (planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -lineShape.length / 2, 0);
        vec2_1.default.set(worldVertex1, lineShape.length / 2, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        rotate(worldNormal, yAxis, planeAngle);
        // Check line ends
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, planeOffset);
            var d = dot(dist, worldNormal);
            if (d < 0) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                numContacts++;
                copy(c.normalA, worldNormal);
                normalize(c.normalA, c.normalA);
                // distance vector along plane normal
                scale(dist, worldNormal, d);
                // Vector from plane center to contact
                sub(c.contactPointA, v, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                // From line center to contact
                sub(c.contactPointB, v, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (justTest) {
            return 0;
        }
        if (!this.enableFrictionReduction) {
            if (numContacts && this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
            }
        }
        return numContacts;
    };
    ;
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
    Narrowphase.prototype.particleCapsule = function (particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        return this.circleLine(particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
    };
    ;
    /**
     * Circle/line Narrowphase
     * @method circleLine
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} lineBody
     * @param  {Line} lineShape
     * @param  {Array} lineOffset
     * @param  {Number} lineAngle
     * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
     * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
     * @param {Number} circleRadius If set, this value overrides the circle shape radius.
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
    Narrowphase.prototype.circleLine = function (circleBody, circleShape, circleOffset, 
    //circleAngle: f32,
    lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
        lineRadius = lineRadius !== null && lineRadius !== void 0 ? lineRadius : 0;
        var orthoDist = tmp1;
        var lineToCircleOrthoUnit = tmp2;
        var projectedPoint = tmp3;
        var centerDist = tmp4;
        var worldTangent = tmp5;
        var worldEdge = tmp6;
        var worldEdgeUnit = tmp7;
        var worldVertex0 = tmp8;
        var worldVertex1 = tmp9;
        var worldVertex01 = tmp10;
        var worldVertex11 = tmp11;
        var dist = tmp12;
        var lineToCircle = tmp13;
        var lineEndToLineRadius = tmp14;
        var verts = tmpArray;
        var halfLineLength = lineShape.length / 2;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -halfLineLength, 0);
        vec2_1.default.set(worldVertex1, halfLineLength, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        // Check distance from the plane spanned by the edge vs the circle
        sub(dist, circleOffset, worldVertex0);
        var d = dot(dist, worldTangent); // Distance from center of line to circle center
        sub(centerDist, worldVertex0, lineOffset);
        sub(lineToCircle, circleOffset, lineOffset);
        var radiusSum = circleRadius + lineRadius;
        if (Math.abs(d) < radiusSum) {
            // Now project the circle onto the edge
            scale(orthoDist, worldTangent, d);
            sub(projectedPoint, circleOffset, orthoDist);
            // Add the missing line radius
            scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
            normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
            scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
            add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
            // Check if the point is within the edge span
            var pos = dot(worldEdgeUnit, projectedPoint);
            var pos0 = dot(worldEdgeUnit, worldVertex0);
            var pos1 = dot(worldEdgeUnit, worldVertex1);
            if (pos > pos0 && pos < pos1) {
                // We got contact!
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                scale(c.normalA, orthoDist, -1);
                normalize(c.normalA, c.normalA);
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, projectedPoint, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        // Add corner
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, circleOffset);
            if (squaredLength(dist) < Math.pow(radiusSum, 2)) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                copy(c.normalA, dist);
                normalize(c.normalA, c.normalA);
                // Vector from circle to contact point is the normal times the circle radius
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, v, lineOffset);
                scale(lineEndToLineRadius, c.normalA, -lineRadius);
                add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        return 0;
    };
    ;
    /**
     * Circle/capsule Narrowphase
     * @method circleCapsule
     * @param  {Body}   bi
     * @param  {Circle} si
     * @param  {Array}  xi
     * @param  {Body}   bj
     * @param  {Line}   sj
     * @param  {Array}  xj
     * @param  {Number} aj
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
    Narrowphase.prototype.circleCapsule = function (bi, si, xi, bj, sj, xj, aj, justTest) {
        return this.circleLine(bi, si, xi, bj, sj, xj, aj, justTest, 0, si.radius);
    };
    ;
    /**
     * Circle/convex Narrowphase.
     * @method circleConvex
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param  {Boolean} justTest
     * @param  {Number} circleRadius
     * @return {number}
     * @todo Should probably do a separating axis test like https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2CollideCircle.cpp#L62
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =
    Narrowphase.prototype.circleConvex = function (circleBody, circleShape, circleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, edge = tmp3, edgeUnit = tmp4, normal = tmp5, zero = tmp6, localCirclePosition = tmp7, r = tmp8, dist = tmp10, worldVertex = tmp11, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, found = -1, minCandidateDistance = Infinity;
        vec2_1.default.set(zero, 0, 0);
        // New algorithm:
        // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        vec2_1.default.toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        var normals = convexShape.normals;
        var numVertices = vertices.length;
        var normalIndex = -1;
        // Find the min separating edge.
        var separation = -Infinity;
        var radius = convexShape.boundingRadius + circleRadius;
        for (var i = 0; i < numVertices; i++) {
            sub(r, localCirclePosition, vertices[i]);
            var s = dot(normals[i], r);
            if (s > radius) {
                // Early out.
                return 0;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        // Check edges first
        for (var i = normalIndex + numVertices - 1; i < normalIndex + numVertices + 2; i++) {
            var v0 = vertices[i % numVertices], n = normals[i % numVertices];
            // Get point on circle, closest to the convex
            scale(candidate, n, -circleRadius);
            add(candidate, candidate, localCirclePosition);
            if (pointInConvexLocal(candidate, convexShape)) {
                sub(candidateDist, v0, candidate);
                var candidateDistance = Math.abs(dot(candidateDist, n));
                if (candidateDistance < minCandidateDistance) {
                    minCandidateDistance = candidateDistance;
                    found = i;
                }
            }
        }
        if (found !== -1) {
            if (justTest) {
                return 1;
            }
            var v0 = vertices[found % numVertices], v1 = vertices[(found + 1) % numVertices];
            vec2_1.default.toGlobalFrame(worldVertex0, v0, convexOffset, convexAngle);
            vec2_1.default.toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);
            sub(edge, worldVertex1, worldVertex0);
            normalize(edgeUnit, edge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(normal, edgeUnit);
            // Get point on circle, closest to the convex
            scale(candidate, normal, -circleRadius);
            add(candidate, candidate, circleOffset);
            scale(closestEdgeProjectedPoint, normal, minCandidateDistance);
            add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
            sub(c.normalA, candidate, circleOffset);
            normalize(c.normalA, c.normalA);
            scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        // Check closest vertices
        if (circleRadius > 0 && normalIndex !== -1) {
            for (var i = normalIndex + numVertices; i < normalIndex + numVertices + 2; i++) {
                var localVertex = vertices[i % numVertices];
                sub(dist, localVertex, localCirclePosition);
                if (squaredLength(dist) < circleRadius * circleRadius) {
                    if (justTest) {
                        return 1;
                    }
                    vec2_1.default.toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);
                    sub(dist, worldVertex, circleOffset);
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    // Vector from circle to contact point is the normal times the circle radius
                    scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, worldVertex, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
            }
        }
        return 0;
    };
    ;
    /**
     * Particle/convex Narrowphase
     * @method particleConvex
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Number} particleAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo use pointInConvex and code more similar to circleConvex
     * @todo don't transform each vertex, but transform the particle position to convex-local instead
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =
    Narrowphase.prototype.particleConvex = function (particleBody, particleShape, particleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, closestEdgeProjectedPoint = tmp13, candidateDist = tmp14, minEdgeNormal = tmp15, minCandidateDistance = Infinity, found = false, verts = convexShape.vertices;
        // Check if the particle is in the polygon at all
        if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        // Check edges first
        for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            // Transform vertices to world
            // @todo transform point to local space instead
            rotate(worldVertex0, v0, convexAngle);
            rotate(worldVertex1, v1, convexAngle);
            add(worldVertex0, worldVertex0, convexOffset);
            add(worldVertex1, worldVertex1, convexOffset);
            // Get world edge
            sub(worldEdge, worldVertex1, worldVertex0);
            normalize(worldEdgeUnit, worldEdge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
            // Check distance from the infinite line (spanned by the edge) to the particle
            //sub(dist, particleOffset, worldVertex0);
            //let d = dot(dist, worldTangent);
            sub(centerDist, worldVertex0, convexOffset);
            sub(convexToparticle, particleOffset, convexOffset);
            sub(candidateDist, worldVertex0, particleOffset);
            var candidateDistance = Math.abs(dot(candidateDist, worldTangent));
            if (candidateDistance < minCandidateDistance) {
                minCandidateDistance = candidateDistance;
                scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                copy(minEdgeNormal, worldTangent);
                found = true;
            }
        }
        if (found) {
            var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
            scale(c.normalA, minEdgeNormal, -1);
            normalize(c.normalA, c.normalA);
            // Particle has no extent to the contact point
            vec2_1.default.set(c.contactPointA, 0, 0);
            add(c.contactPointA, c.contactPointA, particleOffset);
            sub(c.contactPointA, c.contactPointA, particleBody.position);
            // From convex center to point
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        return 0;
    };
    ;
    /**
     * Circle/circle Narrowphase
     * @method circleCircle
     * @param  {Body} bodyA
     * @param  {Circle} shapeA
     * @param  {Array} offsetA
     * @param  {Body} bodyB
     * @param  {Circle} shapeB
     * @param  {Array} offsetB
     * @param {Boolean} justTest
     * @param {Number} [radiusA] Optional radius to use for shapeA
     * @param {Number} [radiusB] Optional radius to use for shapeB
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE] =
    Narrowphase.prototype.circleCircle = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest, radiusA, radiusB) {
        var dist = tmp1;
        sub(dist, offsetA, offsetB);
        var r = radiusA + radiusB;
        if (squaredLength(dist) > r * r) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
        var cpA = c.contactPointA;
        var cpB = c.contactPointB;
        var normalA = c.normalA;
        sub(normalA, offsetB, offsetA);
        normalize(normalA, normalA);
        scale(cpA, normalA, radiusA);
        scale(cpB, normalA, -radiusB);
        addSub(cpA, cpA, offsetA, bodyA.position);
        addSub(cpB, cpB, offsetB, bodyB.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Plane/Convex Narrowphase
     * @method planeConvex
     * @param  {Body} planeBody
     * @param  {Plane} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo only use the deepest contact point + the contact point furthest away from it
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PLANE | Shape.BOX] =
    Narrowphase.prototype.planeConvex = function (planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3, localPlaneOffset = tmp4, localPlaneNormal = tmp5, localDist = tmp6;
        var numReported = 0;
        rotate(worldNormal, yAxis, planeAngle);
        // Get convex-local plane offset and normal
        vec2_1.default.vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);
        vec2_1.default.toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        for (var i = 0, numVerts = vertices.length; i !== numVerts; i++) {
            var v = vertices[i];
            sub(localDist, v, localPlaneOffset);
            if (dot(localDist, localPlaneNormal) <= 0) {
                if (justTest) {
                    return 1;
                }
                vec2_1.default.toGlobalFrame(worldVertex, v, convexOffset, convexAngle);
                sub(dist, worldVertex, planeOffset);
                // Found vertex
                numReported++;
                var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                sub(dist, worldVertex, planeOffset);
                copy(c.normalA, worldNormal);
                var d = dot(dist, c.normalA);
                scale(dist, c.normalA, d);
                // rj is from convex center to contact
                sub(c.contactPointB, worldVertex, convexBody.position);
                // ri is from plane center to contact
                sub(c.contactPointA, worldVertex, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (this.enableFrictionReduction) {
            if (this.enableFriction && numReported) {
                this.frictionEquations.push(this.createFrictionFromAverage(numReported));
            }
        }
        return numReported;
    };
    ;
    /**
     * Narrowphase for particle vs plane
     * @method particlePlane
     * @param  {Body}       particleBody
     * @param  {Particle}   particleShape
     * @param  {Array}      particleOffset
     * @param  {Body}       planeBody
     * @param  {Plane}      planeShape
     * @param  {Array}      planeOffset
     * @param  {Number}     planeAngle
     * @param {Boolean}     justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
    Narrowphase.prototype.particlePlane = function (particleBody, particleShape, particleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var dist = tmp1, worldNormal = tmp2;
        planeAngle = planeAngle || 0;
        sub(dist, particleOffset, planeOffset);
        rotate(worldNormal, yAxis, planeAngle);
        var d = dot(dist, worldNormal);
        if (d > 0) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
        copy(c.normalA, worldNormal);
        scale(dist, c.normalA, d);
        // dist is now the distance vector in the normal direction
        // ri is the particle position projected down onto the plane, from the plane center
        sub(c.contactPointA, particleOffset, dist);
        sub(c.contactPointA, c.contactPointA, planeBody.position);
        // rj is from the body center to the particle center
        sub(c.contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Circle/Particle Narrowphase
     * @method circleParticle
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
    Narrowphase.prototype.circleParticle = function (circleBody, circleShape, circleOffset, particleBody, particleShape, particleOffset, justTest) {
        var dist = tmp1;
        var circleRadius = circleShape.radius;
        sub(dist, particleOffset, circleOffset);
        if (squaredLength(dist) > circleRadius * circleRadius) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
        var normalA = c.normalA;
        var contactPointA = c.contactPointA;
        var contactPointB = c.contactPointB;
        copy(normalA, dist);
        normalize(normalA, normalA);
        // Vector from circle to contact point is the normal times the circle radius
        scale(contactPointA, normalA, circleRadius);
        add(contactPointA, contactPointA, circleOffset);
        sub(contactPointA, contactPointA, circleBody.position);
        // Vector from particle center to contact point is zero
        sub(contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * @method planeCapsule
     * @param  {Body} planeBody
     * @param  {Circle} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} capsuleBody
     * @param  {Particle} capsuleShape
     * @param  {Array} capsuleOffset
     * @param  {Number} capsuleAngle
     * @param {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
    Narrowphase.prototype.planeCapsule = function (planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
        var planeCapsule_tmpCircle = new Circle_1.default({ radius: 1 });
        var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, halfLength = capsuleShape.length / 2;
        // Compute world end positions
        vec2_1.default.set(end1, -halfLength, 0);
        vec2_1.default.set(end2, halfLength, 0);
        vec2_1.default.toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);
        vec2_1.default.toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);
        circle.radius = capsuleShape.radius;
        var enableFrictionBefore = this.enableFriction;
        // Temporarily turn off friction
        if (this.enableFrictionReduction) {
            this.enableFriction = false;
        }
        // Do Narrowphase as two circles
        var numContacts1 = this.circlePlane(capsuleBody, circle, end1, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, planeBody, planeShape, planeOffset, planeAngle, justTest);
        // Restore friction
        if (this.enableFrictionReduction) {
            this.enableFriction = enableFrictionBefore;
        }
        if (justTest) {
            return numContacts1 + numContacts2;
        }
        else {
            var numTotal = numContacts1 + numContacts2;
            if (this.enableFrictionReduction) {
                if (numTotal) {
                    this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                }
            }
            return numTotal;
        }
    };
    ;
    /**
     * @method circlePlane
     * @param  {Body}    circleBody
     * @param  {Circle}  circleShape
     * @param  {Array}   circleOffset
     * @param  {Body}    planeBody
     * @param  {Plane}   planeShape
     * @param  {Array}   planeOffset
     * @param  {Number}  planeAngle
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
    Narrowphase.prototype.circlePlane = function (circleBody, circleShape, circleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var circleRadius = circleShape.radius;
        // Vector from plane to circle
        var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
        sub(planeToCircle, circleOffset, planeOffset);
        // World plane normal
        rotate(worldNormal, yAxis, planeAngle);
        // Normal direction distance
        var d = dot(worldNormal, planeToCircle);
        if (d > circleRadius) {
            return 0; // No overlap. Abort.
        }
        if (justTest) {
            return 1;
        }
        // Create contact
        var contact = this.createContactEquation(planeBody, circleBody, planeShape, circleShape);
        // ni is the plane world normal
        copy(contact.normalA, worldNormal);
        // rj is the vector from circle center to the contact point
        var cpB = contact.contactPointB;
        scale(cpB, contact.normalA, -circleRadius);
        add(cpB, cpB, circleOffset);
        sub(cpB, cpB, circleBody.position);
        // ri is the distance from plane center to contact.
        var cpA = contact.contactPointA;
        scale(temp, contact.normalA, d);
        sub(cpA, planeToCircle, temp); // Subtract normal distance vector from the distance vector
        add(cpA, cpA, planeOffset);
        sub(cpA, cpA, planeBody.position);
        this.contactEquations.push(contact);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(contact));
        }
        return 1;
    };
    ;
    // Find edge normal of max separation on A - return if separating axis is found
    // Find edge normal of max separation on B - return if separation axis is found
    // Choose reference edge as min(minA, minB)
    // Find incident edge
    // Clip
    // The normal points from 1 to 2
    /*function collidePolygons(
        manifold,
        polyA, positionA, angleA,
        polyB, positionB, angleB,
        incidentEdge
    ) {*/
    /**
     * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
     * @method convexConvex
     * @param  {Body} bi
     * @param  {Convex} si
     * @param  {Array} xi
     * @param  {Number} ai
     * @param  {Body} bj
     * @param  {Convex} sj
     * @param  {Array} xj
     * @param  {Number} aj
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =
    //Narrowphase.prototype[Shape.BOX] =
    Narrowphase.prototype.convexConvex = function (bodyA, polyA, positionA, angleA, bodyB, polyB, positionB, angleB, justTest) {
        var maxManifoldPoints = 2;
        var totalRadius = 0;
        var dist = collidePolygons_dist;
        var tempVec = collidePolygons_tempVec;
        var tmpVec = collidePolygons_tmpVec;
        var edgeA = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);
        var separationA = tempVec[0];
        if (separationA > totalRadius) {
            return 0;
        }
        var edgeB = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);
        var separationB = tmpVec[0];
        if (separationB > totalRadius) {
            return 0;
        }
        var poly1; // reference polygon
        var poly2; // incident polygon
        var position1;
        var position2;
        var angle1;
        var angle2;
        var body1;
        var body2;
        var edge1; // reference edge
        var type;
        if (separationB > separationA) {
            poly1 = polyB;
            poly2 = polyA;
            body1 = bodyB;
            body2 = bodyA;
            position1 = positionB;
            angle1 = angleB;
            position2 = positionA;
            angle2 = angleA;
            edge1 = edgeB;
            type = 1; // faceB
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            body1 = bodyA;
            body2 = bodyB;
            position1 = positionA;
            angle1 = angleA;
            position2 = positionB;
            angle2 = angleB;
            edge1 = edgeA;
            type = 0; // faceA
        }
        var incidentEdge = collidePolygons_incidentEdge;
        findIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);
        var count1 = poly1.vertices.length;
        var vertices1 = poly1.vertices;
        var iv1 = edge1;
        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
        var v11 = collidePolygons_v11;
        var v12 = collidePolygons_v12;
        vec2_1.default.copy(v11, vertices1[iv1]);
        vec2_1.default.copy(v12, vertices1[iv2]);
        var localTangent = collidePolygons_localTangent;
        vec2_1.default.subtract(localTangent, v12, v11);
        vec2_1.default.normalize(localTangent, localTangent);
        var localNormal = collidePolygons_localNormal;
        vec2_1.default.crossVZ(localNormal, localTangent, 1.0);
        var planePoint = collidePolygons_planePoint;
        vec2_1.default.add(planePoint, v11, v12);
        vec2_1.default.scale(planePoint, planePoint, 0.5);
        var tangent = collidePolygons_tangent; // tangent in world space
        vec2_1.default.rotate(tangent, localTangent, angle1);
        var normal = collidePolygons_normal; // normal in world space
        vec2_1.default.crossVZ(normal, tangent, 1.0);
        vec2_1.default.toGlobalFrame(v11, v11, position1, angle1);
        vec2_1.default.toGlobalFrame(v12, v12, position1, angle1);
        // Face offset.
        var frontOffset = vec2_1.default.dot(normal, v11);
        // Side offsets, extended by polytope skin thickness.
        var sideOffset1 = -vec2_1.default.dot(tangent, v11) + totalRadius;
        var sideOffset2 = vec2_1.default.dot(tangent, v12) + totalRadius;
        // Clip incident edge against extruded edge1 side edges.
        var clipPoints1 = collidePolygons_clipPoints1;
        var clipPoints2 = collidePolygons_clipPoints2;
        var np = 0;
        // Clip to box side 1
        var negativeTangent = collidePolygons_negativeTangent;
        vec2_1.default.scale(negativeTangent, tangent, -1);
        np = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1 /*, iv1*/);
        if (np < 2) {
            return 0;
        }
        // Clip to negative box side 1
        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2 /*, iv2*/);
        if (np < 2) {
            return 0;
        }
        var pointCount = 0;
        for (var i = 0; i < maxManifoldPoints; ++i) {
            var separation = vec2_1.default.dot(normal, clipPoints2[i]) - frontOffset;
            if (separation <= totalRadius) {
                if (justTest) {
                    return 1;
                }
                ++pointCount;
                var c = this.createContactEquation(body1, body2, poly1, poly2);
                vec2_1.default.copy(c.normalA, normal);
                vec2_1.default.copy(c.contactPointB, clipPoints2[i]);
                sub(c.contactPointB, c.contactPointB, body2.position);
                vec2_1.default.scale(dist, normal, -separation);
                vec2_1.default.add(c.contactPointA, clipPoints2[i], dist);
                sub(c.contactPointA, c.contactPointA, body1.position);
                this.contactEquations.push(c);
                if (this.enableFriction && !this.enableFrictionReduction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        if (pointCount && this.enableFrictionReduction && this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromAverage(pointCount));
        }
        return pointCount;
    };
    ;
    //Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.circleHeightfield = function (circleBody, circleShape, circlePos, hfBody, hfShape, hfPos, justTest, radius) {
        var data = hfShape.heights, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
        // Get the index of the points to test against
        var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
        /*if(idxB < 0 || idxA >= data.length)
            return justTest ? false : 0;*/
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (circlePos[1] - radius > max) {
            return 0;
        }
        /*
        if(circlePos[1]+radius < min){
            // Below the minimum point... We can just guess.
            // TODO
        }
        */
        // 1. Check so center of circle is not inside the field. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        var found = false;
        // Check all edges first
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos); // @todo transform circle to local heightfield space instead
            add(v1, v1, hfPos);
            // Get normal
            sub(worldNormal, v1, v0);
            rotate(worldNormal, worldNormal, Math.PI / 2);
            normalize(worldNormal, worldNormal);
            // Get point on circle, closest to the edge
            scale(candidate, worldNormal, -radius);
            add(candidate, candidate, circlePos);
            // Distance from v0 to the candidate point
            sub(dist, candidate, v0);
            // Check if it is in the element "stick"
            var d = dot(dist, worldNormal);
            if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                if (justTest) {
                    return 1;
                }
                found = true;
                // Store the candidate point, projected to the edge
                scale(dist, worldNormal, -d);
                add(minCandidate, candidate, dist);
                copy(minCandidateNormal, worldNormal);
                var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                // Normal is out of the heightfield
                copy(c.normalA, minCandidateNormal);
                // Vector from circle to heightfield
                scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);
                copy(c.contactPointA, minCandidate);
                sub(c.contactPointA, c.contactPointA, hfBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        // Check all vertices
        found = false;
        if (radius > 0) {
            for (var i = idxA; i <= idxB; i++) {
                // Get point
                vec2_1.default.set(v0, i * w, data[i]);
                add(v0, v0, hfPos);
                sub(dist, circlePos, v0);
                if (squaredLength(dist) < Math.pow(radius, 2)) {
                    if (justTest) {
                        return 1;
                    }
                    found = true;
                    var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                    // Construct normal - out of heightfield
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    scale(c.contactPointB, c.normalA, -radius);
                    add(c.contactPointB, c.contactPointB, circlePos);
                    sub(c.contactPointB, c.contactPointB, circleBody.position);
                    sub(c.contactPointA, v0, hfPos);
                    add(c.contactPointA, c.contactPointA, hfPos);
                    sub(c.contactPointA, c.contactPointA, hfBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (found) {
            return 1;
        }
        return 0;
    };
    //Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.convexHeightfield = function (convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, justTest) {
        var data = hfShape.heights, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
        // Get the index of the points to test against
        var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (convexBody.aabb.lowerBound[1] > max) {
            return 0;
        }
        var numContacts = 0;
        // Loop over all edges
        // @todo If possible, construct a convex from several data points (need o check if the points make a convex shape)
        // @todo transform convex to local heightfield space.
        // @todo bail out if the heightfield tile is not tall enough.
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos);
            add(v1, v1, hfPos);
            // Construct a convex
            var tileHeight = 100; // todo
            vec2_1.default.set(tilePos, (v1[0] + v0[0]) * 0.5, (v1[1] + v0[1] - tileHeight) * 0.5);
            sub(tileConvex.vertices[0], v1, tilePos);
            sub(tileConvex.vertices[1], v0, tilePos);
            copy(tileConvex.vertices[2], tileConvex.vertices[1]);
            copy(tileConvex.vertices[3], tileConvex.vertices[0]);
            tileConvex.vertices[2][1] -= tileHeight;
            tileConvex.vertices[3][1] -= tileHeight;
            tileConvex.updateNormals();
            // Do convex collision
            numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
        }
        return numContacts;
    };
    return Narrowphase;
}());
exports.default = Narrowphase;

},{"../math/vec2":28,"../shapes/Box":35,"../shapes/Circle":36,"../shapes/Convex":37,"../utils/contact-equation-pool":49,"../utils/friction-equation-pool":50,"../utils/tuple-dictionary":55}],5:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectBody_worldPosition = vec2_1.default.create();
var v0 = vec2_1.default.create(), intersect = vec2_1.default.create();
var Ray = /** @class */ (function () {
    /**
     * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
     * @class Ray
     * @constructor
     * @param {object} [options]
     * @param {array} [options.from]
     * @param {array} [options.to]
     * @param {boolean} [options.checkCollisionResponse=true]
     * @param {boolean} [options.skipBackfaces=false]
     * @param {number} [options.collisionMask=-1]
     * @param {number} [options.collisionGroup=-1]
     * @param {number} [options.mode=Ray.ANY]
     * @param {Function} [options.callback]
     */
    function Ray(options) {
        /**
         * @readOnly
         * @property {array} direction
         */
        this.direction = vec2_1.default.create();
        /**
         * Length of the ray
         * @readOnly
         * @property {number} length
         */
        this.length = 1;
        options = options !== null && options !== void 0 ? options : {};
        this.from = options.from ? vec2_1.default.clone(options.from) : vec2_1.default.create();
        this.to = options.to ? vec2_1.default.clone(options.to) : vec2_1.default.create();
        this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
        this.skipBackfaces = !!options.skipBackfaces;
        this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
        this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
        this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
        this.callback = options.callback || function ( /*result*/) { };
        this.update();
    }
    /**
     * Should be called if you change the from or to point.
     * @method update
     */
    Ray.prototype.update = function () {
        // Update .direction and .length
        var d = this.direction;
        vec2_1.default.subtract(d, this.to, this.from);
        this.length = vec2_1.default.length(d);
        vec2_1.default.normalize(d, d);
    };
    ;
    /**
     * @method intersectBodies
     * @param {Array} bodies An array of Body objects.
     */
    Ray.prototype.intersectBodies = function (result, bodies) {
        for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
            var body = bodies[i];
            var aabb = body.getAABB();
            if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
                this.intersectBody(result, body);
            }
        }
    };
    ;
    /**
     * Shoot a ray at a body, get back information about the hit.
     * @method intersectBody
     * @private
     * @param {Body} body
     */
    Ray.prototype.intersectBody = function (result, body) {
        var checkCollisionResponse = this.checkCollisionResponse;
        if (checkCollisionResponse && !body.collisionResponse) {
            return;
        }
        var worldPosition = intersectBody_worldPosition;
        for (var i = 0, N = body.shapes.length; i < N; i++) {
            var shape = body.shapes[i];
            if (checkCollisionResponse && !shape.collisionResponse) {
                continue; // Skip
            }
            if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
                continue;
            }
            // Get world angle and position of the shape
            vec2_1.default.rotate(worldPosition, shape.position, body.angle);
            vec2_1.default.add(worldPosition, worldPosition, body.position);
            var worldAngle = shape.angle + body.angle;
            this.intersectShape(result, shape, worldAngle, worldPosition, body);
            if (result.shouldStop(this)) {
                break;
            }
        }
    };
    ;
    /**
     * @method intersectShape
     * @private
     * @param {Shape} shape
     * @param {number} angle
     * @param {array} position
     * @param {Body} body
     */
    Ray.prototype.intersectShape = function (result, shape, angle, position, body) {
        var from = this.from;
        // Checking radius
        var distance = distanceFromIntersectionSquared(from, this.direction, position);
        if (distance > shape.boundingRadius * shape.boundingRadius) {
            return;
        }
        this._currentBody = body;
        this._currentShape = shape;
        shape.raycast(result, this, position, angle);
        this._currentBody = undefined;
        this._currentShape = undefined;
    };
    ;
    /**
     * Get the AABB of the ray.
     * @method getAABB
     * @param  {AABB} aabb
     */
    Ray.prototype.getAABB = function (result) {
        var to = this.to;
        var from = this.from;
        vec2_1.default.set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
        vec2_1.default.set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
    };
    ;
    /**
     * @method reportIntersection
     * @private
     * @param  {number} fraction
     * @param  {array} normal
     * @param  {number} [faceIndex=-1]
     * @return {boolean} True if the intersections should continue // This never returned anything.
     */
    Ray.prototype.reportIntersection = function (result, fraction, normal, faceIndex) {
        var shape = this._currentShape;
        var body = this._currentBody;
        // Skip back faces?
        if (this.skipBackfaces && vec2_1.default.dot(normal, this.direction) > 0) {
            return;
        }
        switch (this.mode) {
            case Ray.ALL:
                result.set(normal, shape, body, fraction, faceIndex);
                this.callback(result);
                break;
            case Ray.CLOSEST:
                // Store if closer than current closest
                if (fraction < result.fraction || !result.hasHit()) {
                    result.set(normal, shape, body, fraction, faceIndex);
                }
                break;
            case Ray.ANY:
                // Report and stop.
                result.set(normal, shape, body, fraction, faceIndex);
                break;
        }
    };
    ;
    /**
     * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
     * @static
     * @property {Number} CLOSEST
     */
    Ray.CLOSEST = 1;
    /**
     * This raycasting mode will make the Ray stop when it finds the first intersection point.
     * @static
     * @property {Number} ANY
     */
    Ray.ANY = 2;
    /**
     * This raycasting mode will traverse all intersection points and executes a callback for each one.
     * @static
     * @property {Number} ALL
     */
    Ray.ALL = 4;
    return Ray;
}());
exports.default = Ray;
function distanceFromIntersectionSquared(from, direction, position) {
    // v0 is vector from from to position
    vec2_1.default.subtract(v0, position, from);
    var dot = vec2_1.default.dot(v0, direction);
    // intersect = direction * dot + from
    vec2_1.default.scale(intersect, direction, dot);
    vec2_1.default.add(intersect, intersect, from);
    return vec2_1.default.squaredDistance(position, intersect);
}

},{"../math/vec2":28}],6:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var ray_1 = __importDefault(_dereq_("./ray"));
var RaycastResult = /** @class */ (function () {
    /**
     * Storage for Ray casting hit data.
     * @class RaycastResult
     * @constructor
     */
    function RaycastResult() {
        /**
         * The normal of the hit, oriented in world space.
         * @property {array} normal
         */
        this.normal = vec2_1.default.create();
        /**
         * The index of the hit triangle, if the hit shape was indexable.
         * @property {number} faceIndex
         * @default -1
         */
        this.faceIndex = -1;
        /**
         * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
         * @property {number} fraction
         * @default -1
         */
        this.fraction = -1;
        /**
         * If the ray should stop traversing.
         * @readonly
         * @property {Boolean} isStopped
         */
        this.isStopped = false;
    }
    /**
     * Reset all result data. Must be done before re-using the result object.
     * @method reset
     */
    RaycastResult.prototype.reset = function () {
        vec2_1.default.set(this.normal, 0, 0);
        this.shape = undefined;
        this.body = undefined;
        this.faceIndex = -1;
        this.fraction = -1;
        this.isStopped = false;
    };
    /**
     * Get the distance to the hit point.
     * @method getHitDistance
     * @param {Ray} ray
     * @return {number}
     */
    RaycastResult.prototype.getHitDistance = function (ray) {
        return vec2_1.default.distance(ray.from, ray.to) * this.fraction;
    };
    /**
     * Returns true if the ray hit something since the last reset().
     * @method hasHit
     * @eturn {boolean}
     */
    RaycastResult.prototype.hasHit = function () {
        return this.fraction !== -1;
    };
    /**
     * Get world hit point.
     * @method getHitPoint
     * @param {array} out
     * @param {Ray} ray
     */
    RaycastResult.prototype.getHitPoint = function (out, ray) {
        vec2_1.default.lerp(out, ray.from, ray.to, this.fraction);
    };
    /**
     * Can be called while iterating over hits to stop searching for hit points.
     * @method stop
     */
    RaycastResult.prototype.stop = function () {
        this.isStopped = true;
    };
    /**
     * @method shouldStop
     * @private
     * @param {Ray} ray
     * @return {boolean}
     */
    RaycastResult.prototype.shouldStop = function (ray) {
        return this.isStopped || (this.fraction !== -1 && ray.mode === ray_1.default.ANY);
    };
    /**
     * @method set
     * @private
     * @param {array} normal
     * @param {Shape} shape
     * @param {Body} body
     * @param {number} fraction
     * @param {number} faceIndex
     */
    RaycastResult.prototype.set = function (normal, shape, body, fraction, faceIndex) {
        vec2_1.default.copy(this.normal, normal);
        this.shape = shape;
        this.body = body;
        this.fraction = fraction;
        this.faceIndex = faceIndex;
    };
    return RaycastResult;
}());
exports.default = RaycastResult;

},{"../math/vec2":28,"./ray":5}],7:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
// TODO: this appears to be a bubble sort. We could probably do better.
function sortAxisList(a, axisIndex) {
    for (var i = 1, l = a.length; i < l; i++) { // Why not i=0?
        var v = a[i];
        for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                break;
            }
            a[j + 1] = a[j];
        }
        a[j + 1] = v;
    }
    return a;
}
var SAPBroadphase = /** @class */ (function (_super) {
    __extends(SAPBroadphase, _super);
    /**
     * Sweep and prune broadphase along one axis.
     *
     * @class SAPBroadphase
     * @constructor
     * @extends Broadphase
     */
    function SAPBroadphase() {
        var _this = _super.call(this, broadphase_1.default.SAP) || this;
        _this.axisList = [];
        _this.axisIndex = 0;
        _this._addBodyHandler = function (e) {
            _this.axisList.push(e.body);
        };
        _this._removeBodyHandler = function (e) {
            // Remove from list
            var idx = _this.axisList.indexOf(e.body);
            if (idx !== -1) {
                _this.axisList.splice(idx, 1);
            }
        };
        return _this;
    }
    /**
     * Change the world
     * @method setWorld
     * @param {World} world
     */
    SAPBroadphase.prototype.setWorld = function (world) {
        // Clear the old axis array
        this.axisList.length = 0;
        // Add all bodies from the new world
        utils_1.default.appendArray(this.axisList, world.bodies);
        // Remove old handlers, if any
        world
            .off("addBody", this._addBodyHandler)
            .off("removeBody", this._removeBodyHandler);
        // Add handlers to update the list of bodies.
        // TODO: now that I've added context, we can test moving those inline functions to proper private methods.
        world.on("addBody", this._addBodyHandler, this)
            .on("removeBody", this._removeBodyHandler, this);
        this.world = world;
    };
    ;
    SAPBroadphase.prototype.sortList = function () {
        var bodies = this.axisList, axisIndex = this.axisIndex;
        // Sort the lists
        sortAxisList(bodies, axisIndex);
    };
    ;
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    SAPBroadphase.prototype.getCollisionPairs = function ( /*world*/) {
        var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
        result.length = 0;
        // Update all AABBs if needed
        var l = bodies.length;
        while (l--) {
            var b = bodies[l];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
        }
        // Sort the lists
        this.sortList();
        // Look through the X list
        for (var i = 0, N = bodies.length | 0; i !== N; i++) {
            var bi = bodies[i];
            for (var j = i + 1; j < N; j++) {
                var bj = bodies[j];
                // Bounds overlap?
                var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
                if (!overlaps) {
                    break;
                }
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     * @todo since the list is sorted, optimization can be done
     */
    SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        this.sortList();
        var axisList = this.axisList;
        for (var i = 0; i < axisList.length; i++) {
            var b = axisList[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return SAPBroadphase;
}(broadphase_1.default));
exports.default = SAPBroadphase;

},{"../utils/utils":56,"./broadphase":2}],8:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Constraint = /** @class */ (function () {
    /**
     * Base constraint class.
     *
     * @class Constraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} type
     * @param {Object} [options]
     * @param {Object} [options.collideConnected=true]
     */
    function Constraint(bodyA, bodyB, type, options) {
        var _a, _b;
        this.type = type;
        this.equations = [];
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.collideConnected = (_a = options === null || options === void 0 ? void 0 : options.collideConnected) !== null && _a !== void 0 ? _a : true;
        // Wake up bodies when connected
        if (((_b = options === null || options === void 0 ? void 0 : options.wakeUpBodies) !== null && _b !== void 0 ? _b : false) !== false) {
            if (bodyA) {
                bodyA.wakeUp();
            }
            if (bodyB) {
                bodyB.wakeUp();
            }
        }
    }
    /**
     * Updates the internal constraint parameters before solve.
     * @method update
     */
    Constraint.prototype.update = function () {
        throw new Error("method update() not implmemented in this Constraint subclass!");
    };
    ;
    /**
     * Set stiffness for this constraint.
     * @method setStiffness
     * @param {Number} stiffness
     */
    Constraint.prototype.setStiffness = function (stiffness) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.stiffness = stiffness;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * Set relaxation for this constraint.
     * @method setRelaxation
     * @param {Number} relaxation
     */
    Constraint.prototype.setRelaxation = function (relaxation) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.relaxation = relaxation;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * @method setMaxBias
     * @param {Number} maxBias
     */
    Constraint.prototype.setMaxBias = function (maxBias) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.maxBias = maxBias;
        }
    };
    ;
    /**
     * @static
     * @property {number} DISTANCE
     */
    Constraint.DISTANCE = 1;
    /**
     * @static
     * @property {number} GEAR
     */
    Constraint.GEAR = 2;
    /**
     * @static
     * @property {number} LOCK
     */
    Constraint.LOCK = 3;
    /**
     * @static
     * @property {number} PRISMATIC
     */
    Constraint.PRISMATIC = 4;
    /**
     * @static
     * @property {number} REVOLUTE
     */
    Constraint.REVOLUTE = 5;
    return Constraint;
}());
exports.default = Constraint;

},{}],9:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var n = vec2_1.default.create();
var ri = vec2_1.default.create(); // worldAnchorA
var rj = vec2_1.default.create(); // worldAnchorB
var DistanceConstraint = /** @class */ (function (_super) {
    __extends(DistanceConstraint, _super);
    // this.upperLimitEnabled = false;
    // this.upperLimit = 1;
    // this.lowerLimitEnabled = false;
    // this.lowerLimit = 0;
    // this.position = 0;
    /**
     * Constraint that tries to keep the distance between two bodies constant.
     *
     * @class DistanceConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {object} [options]
     * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
     * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
     * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
     * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
     * @extends Constraint
     *
     * @example
     *     // If distance is not given as an option, then the current distance between the bodies is used.
     *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     var constraint = new DistanceConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     // Manually set the distance and anchors
     *     var constraint = new DistanceConstraint(bodyA, bodyB, {
     *         distance: 1,          // Distance to keep between the points
     *         localAnchorA: [1, 0], // Point on bodyA
     *         localAnchorB: [-1, 0] // Point on bodyB
     *     });
     *     world.addConstraint(constraint);
     */
    function DistanceConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.DISTANCE, options) || this;
        /**
         * The distance to keep.
         * @property distance
         * @type {Number}
         */
        _this.distance = 0;
        /**
         * Max force to apply.
         * @property {number} maxForce
         */
        _this.maxForce = Infinity;
        /**
         * If the upper limit is enabled or not.
         * @property {Boolean} upperLimitEnabled
         */
        _this.upperLimitEnabled = false;
        /**
         * The upper constraint limit.
         * @property {number} upperLimit
         */
        _this.upperLimit = 1;
        /**
         * If the lower limit is enabled or not.
         * @property {Boolean} lowerLimitEnabled
         */
        _this.lowerLimitEnabled = false;
        /**
         * The lower constraint limit.
         * @property {number} lowerLimit
         */
        _this.lowerLimit = 0;
        /**
         * Current constraint position. This is equal to the current distance between the world anchor points.
         * @property {number} position
         */
        _this.position = 0;
        _this.localAnchorA = (options === null || options === void 0 ? void 0 : options.localAnchorA) ? vec2_1.default.clone(options.localAnchorA) : vec2_1.default.create();
        _this.localAnchorB = (options === null || options === void 0 ? void 0 : options.localAnchorB) ? vec2_1.default.clone(options.localAnchorB) : vec2_1.default.create();
        var localAnchorA = _this.localAnchorA;
        var localAnchorB = _this.localAnchorB;
        _this.distance = 0;
        if ((options === null || options === void 0 ? void 0 : options.distance) !== undefined) {
            _this.distance = options.distance;
        }
        else {
            // Use the current world distance between the world anchor points.
            var worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), r = vec2_1.default.create();
            // Transform local anchors to world
            vec2_1.default.rotate(worldAnchorA, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(worldAnchorB, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, bodyB.position, worldAnchorB);
            vec2_1.default.subtract(r, r, worldAnchorA);
            vec2_1.default.subtract(r, r, bodyA.position);
            _this.distance = vec2_1.default.length(r);
        }
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var normal = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce); // Just in the normal direction
        _this.equations = [normal];
        _this.maxForce = maxForce;
        // g = (xi - xj).dot(n)
        // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'
        // ...and if we were to include offset points:
        // g =
        //      (xj + rj - xi - ri).dot(n) - distance
        // dg/dt =
        //      (vj + wj x rj - vi - wi x ri).dot(n) =
        //      { term 2 is near zero } =
        //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
        //      G * W
        // => G = [-n -rixn n rjxn]
        var r = vec2_1.default.create();
        var ri = vec2_1.default.create(); // worldAnchorA
        var rj = vec2_1.default.create(); // worldAnchorB
        var that = _this;
        normal.computeGq = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
            // Transform local anchors to world
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, xj, rj);
            vec2_1.default.subtract(r, r, ri);
            vec2_1.default.subtract(r, r, xi);
            //vec2.subtract(r, bodyB.position, bodyA.position);
            return vec2_1.default.length(r) - that.distance;
        };
        // Make the contact constraint bilateral
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    DistanceConstraint.prototype.update = function () {
        var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
        // Transform local anchors to world
        vec2_1.default.rotate(ri, this.localAnchorA, bodyA.angle);
        vec2_1.default.rotate(rj, this.localAnchorB, bodyB.angle);
        // Get world anchor points and normal
        vec2_1.default.add(n, xj, rj);
        vec2_1.default.subtract(n, n, ri);
        vec2_1.default.subtract(n, n, xi);
        this.position = vec2_1.default.length(n);
        var violating = false;
        if (this.upperLimitEnabled) {
            if (this.position > this.upperLimit) {
                normalEquation.maxForce = 0;
                normalEquation.minForce = -this.maxForce;
                this.distance = this.upperLimit;
                violating = true;
            }
        }
        if (this.lowerLimitEnabled) {
            if (this.position < this.lowerLimit) {
                normalEquation.maxForce = this.maxForce;
                normalEquation.minForce = 0;
                this.distance = this.lowerLimit;
                violating = true;
            }
        }
        if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
            // No constraint needed.
            normalEquation.enabled = false;
            return;
        }
        normalEquation.enabled = true;
        vec2_1.default.normalize(n, n);
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
    };
    /**
     * Set the max force to be used
     * @method setMaxForce
     * @param {Number} maxForce
     */
    DistanceConstraint.prototype.setMaxForce = function (maxForce) {
        var normal = this.equations[0];
        normal.minForce = -maxForce;
        normal.maxForce = maxForce;
    };
    /**
     * Get the max force
     * @method getMaxForce
     * @return {Number}
     */
    DistanceConstraint.prototype.getMaxForce = function () {
        var normal = this.equations[0];
        return normal.maxForce;
    };
    return DistanceConstraint;
}(constraint_1.default));
exports.default = DistanceConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],10:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var angle_lock_equation_1 = __importDefault(_dereq_("../equations/angle-lock-equation"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var GearConstraint = /** @class */ (function (_super) {
    __extends(GearConstraint, _super);
    /**
     * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
     * @class GearConstraint
     * @constructor
     * @author schteppe
     * @param {Body}            bodyA
     * @param {Body}            bodyB
     * @param {Object}          [options]
     * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
     * @param {Number}          [options.ratio=1] Gear ratio.
     * @param {Number}          [options.maxTorque] Maximum torque to apply.
     * @extends Constraint
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB, {
     *         ratio: 2,
     *         maxTorque: 1000
     *     });
     *     world.addConstraint(constraint);
     */
    function GearConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = this;
        options = options || {};
        _this = _super.call(this, bodyA, bodyB, constraint_1.default.GEAR, options) || this;
        /**
         * The gear ratio.
         * @property ratio
         * @type {Number}
         */
        _this.ratio = (_a = options === null || options === void 0 ? void 0 : options.ratio) !== null && _a !== void 0 ? _a : 1;
        /**
         * The relative angle
         * @property angle
         * @type {Number}
         */
        _this.angle = options.angle !== undefined ? options.angle : bodyB.angle - _this.ratio * bodyA.angle;
        // Send same parameters to the equation
        _this.equations = [
            new angle_lock_equation_1.default(bodyA, bodyB, {
                ratio: _this.ratio,
                angle: _this.angle
            }),
        ];
        // Set max torque
        if (options.maxTorque !== undefined) {
            _this.setMaxTorque(options.maxTorque);
        }
        return _this;
    }
    GearConstraint.prototype.update = function () {
        var eq = this.equations[0];
        var ratio = this.ratio;
        if (eq.ratio !== ratio) {
            eq.setRatio(ratio);
        }
        eq.angle = this.angle;
    };
    /**
     * Set the max torque for the constraint.
     * @method setMaxTorque
     * @param {Number} torque
     */
    GearConstraint.prototype.setMaxTorque = function (torque) {
        this.equations[0].setMaxTorque(torque);
    };
    /**
     * Get the max torque for the constraint.
     * @method getMaxTorque
     * @return {Number}
     */
    GearConstraint.prototype.getMaxTorque = function () {
        return this.equations[0].maxForce;
    };
    return GearConstraint;
}(constraint_1.default));
exports.default = GearConstraint;

},{"../equations/angle-lock-equation":15,"./constraint":8}],11:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var l = vec2_1.default.create();
var r = vec2_1.default.create();
var t = vec2_1.default.create();
var xAxis = vec2_1.default.fromValues(1, 0);
var yAxis = vec2_1.default.fromValues(0, 1);
var LockConstraint = /** @class */ (function (_super) {
    __extends(LockConstraint, _super);
    /**
     * Locks the relative position and rotation between two bodies.
     *
     * @class LockConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
     * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
     * @param {number} [options.maxForce]
     * @extends Constraint
     *
     * @example
     *     // Locks the relative position and rotation between bodyA and bodyB
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    function LockConstraint(bodyA, bodyB, options) {
        //options = options || {};
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.LOCK, options) || this;
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Use 3 equations:
        // gx =   (xj - xi - l) * xhat = 0
        // gy =   (xj - xi - l) * yhat = 0
        // gr =   (xi - xj + r) * that = 0
        //
        // ...where:
        //   l is the localOffsetB vector rotated to world in bodyA frame
        //   r is the same vector but reversed and rotated from bodyB frame
        //   xhat, yhat are world axis vectors
        //   that is the tangent of r
        //
        // For the first two constraints, we get
        // G*W = (vj - vi - ldot  ) * xhat
        //     = (vj - vi - wi x l) * xhat
        //
        // Since (wi x l) * xhat = (l x xhat) * wi, we get
        // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
        //
        // The last constraint gives
        // GW = (vi - vj + wj x r) * that
        //    = [  that   0  -that  (r x t) ]
        var x = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), y = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), rot = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var l = vec2_1.default.create(), g = vec2_1.default.create(), that = _this;
        x.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[0];
        };
        y.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[1];
        };
        var r = vec2_1.default.create(), t = vec2_1.default.create();
        rot.computeGq = function () {
            vec2_1.default.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
            vec2_1.default.scale(r, r, -1);
            vec2_1.default.subtract(g, bodyA.position, bodyB.position);
            vec2_1.default.add(g, g, r);
            vec2_1.default.rotate(t, r, -Math.PI / 2);
            vec2_1.default.normalize(t, t);
            return vec2_1.default.dot(g, t);
        };
        /**
         * The offset of bodyB in bodyA's frame.
         * @property {Array} localOffsetB
         */
        _this.localOffsetB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localOffsetB) {
            vec2_1.default.copy(_this.localOffsetB, options.localOffsetB);
        }
        else {
            // Construct from current positions
            vec2_1.default.subtract(_this.localOffsetB, bodyB.position, bodyA.position);
            vec2_1.default.rotate(_this.localOffsetB, _this.localOffsetB, -bodyA.angle);
        }
        /**
         * The offset angle of bodyB in bodyA's frame.
         * @property {Number} localAngleB
         */
        _this.localAngleB = (_b = options === null || options === void 0 ? void 0 : options.localAngleB) !== null && _b !== void 0 ? _b : bodyB.angle - bodyA.angle;
        _this.equations.push(x);
        _this.equations.push(y);
        _this.equations.push(rot);
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Set the maximum force to be applied.
     * @method setMaxForce
     * @param {Number} force
     */
    LockConstraint.prototype.setMaxForce = function (force) {
        var eqs = this.equations;
        for (var i = 0; i < this.equations.length; i++) {
            eqs[i].maxForce = force;
            eqs[i].minForce = -force;
        }
    };
    /**
     * Get the max force.
     * @method getMaxForce
     * @return {Number}
     */
    LockConstraint.prototype.getMaxForce = function () {
        return this.equations[0].maxForce;
    };
    LockConstraint.prototype.update = function () {
        var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
        vec2_1.default.rotate(l, this.localOffsetB, bodyA.angle);
        vec2_1.default.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
        vec2_1.default.scale(r, r, -1);
        vec2_1.default.rotate(t, r, Math.PI / 2);
        vec2_1.default.normalize(t, t);
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[2] = -vec2_1.default.crossLength(l, xAxis);
        x.G[3] = 1;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[2] = -vec2_1.default.crossLength(l, yAxis);
        y.G[4] = 1;
        rot.G[0] = -t[0];
        rot.G[1] = -t[1];
        rot.G[3] = t[0];
        rot.G[4] = t[1];
        rot.G[5] = vec2_1.default.crossLength(r, t);
    };
    return LockConstraint;
}(constraint_1.default));
exports.default = LockConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],12:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var worldAxisA = vec2_1.default.create(), worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), orientedAnchorA = vec2_1.default.create(), orientedAnchorB = vec2_1.default.create(), tmp = vec2_1.default.create();
var PrismaticConstraint = /** @class */ (function (_super) {
    __extends(PrismaticConstraint, _super);
    /**
     * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
     *
     * @class PrismaticConstraint
     * @constructor
     * @extends Constraint
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.maxForce] Max force to be applied by the constraint
     * @param {Array} [options.localAnchorA] Body A's anchor point, defined in its own local frame.
     * @param {Array} [options.localAnchorB] Body B's anchor point, defined in its own local frame.
     * @param {Array} [options.localAxisA] An axis, defined in body A frame, that body B's anchor point may slide along.
     * @param {Boolean} [options.disableRotationalLock] If set to true, bodyB will be free to rotate around its anchor point.
     * @param {Number} [options.upperLimit]
     * @param {Number} [options.lowerLimit]
     * @todo Ability to create using only a point and a worldAxis
     * @example
     *     var constraint = new PrismaticConstraint(bodyA, bodyB, {
     *         localAxisA: [0, 1]
     *     });
     *     world.addConstraint(constraint);
     */
    function PrismaticConstraint(bodyA, bodyB, options) {
        var _a, _b, _c;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.PRISMATIC, options) || this;
        // Get anchors
        var localAnchorA = vec2_1.default.create(), localAxisA = vec2_1.default.fromValues(1, 0), localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAxisA) {
            vec2_1.default.copy(localAxisA, options.localAxisA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(localAnchorB, options.localAnchorB);
        }
        _this.localAnchorA = localAnchorA;
        _this.localAnchorB = localAnchorB;
        _this.localAxisA = localAxisA;
        /*

        The constraint violation for the common axis point is

            g = ( xj + rj - xi - ri ) * t   :=  gg*t

        where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

            gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

        Note the use of the chain rule. Now we identify the jacobian

            G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

        The rotational part is just a rotation lock.

        */
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Translational part
        var trans = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var ri = vec2_1.default.create(), rj = vec2_1.default.create(), gg = vec2_1.default.create(), t = vec2_1.default.create();
        // TODO: This is a bad practice.
        trans.computeGq = function () {
            // g = ( xj + rj - xi - ri ) * t
            return vec2_1.default.dot(gg, t);
        };
        // TODO: This is a bad practice.
        trans.updateJacobian = function () {
            var G = this.G, xi = bodyA.position, xj = bodyB.position;
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(gg, xj, rj);
            vec2_1.default.subtract(gg, gg, xi);
            vec2_1.default.subtract(gg, gg, ri);
            vec2_1.default.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
            G[0] = -t[0];
            G[1] = -t[1];
            G[2] = -vec2_1.default.crossLength(ri, t) + vec2_1.default.crossLength(t, gg);
            G[3] = t[0];
            G[4] = t[1];
            G[5] = vec2_1.default.crossLength(rj, t);
        };
        _this.equations.push(trans);
        // Rotational part
        if (!(options === null || options === void 0 ? void 0 : options.disableRotationalLock)) {
            var rot = new rotational_lock_equation_1.default(bodyA, bodyB);
            _this.equations.push(rot);
        }
        /**
         * The position of anchor A relative to anchor B, along the constraint axis.
         * @property position
         * @type {Number}
         */
        _this.position = 0;
        // Is this one used at all?
        _this.velocity = 0;
        /**
         * Set to true to enable lower limit.
         * @property lowerLimitEnabled
         * @type {Boolean}
         */
        _this.lowerLimitEnabled = (options === null || options === void 0 ? void 0 : options.lowerLimit) !== undefined ? true : false;
        /**
         * Set to true to enable upper limit.
         * @property upperLimitEnabled
         * @type {Boolean}
         */
        _this.upperLimitEnabled = (options === null || options === void 0 ? void 0 : options.upperLimit) !== undefined ? true : false;
        /**
         * Lower constraint limit. The constraint position is forced to be larger than this value.
         * @property lowerLimit
         * @type {Number}
         */
        _this.lowerLimit = (_b = options === null || options === void 0 ? void 0 : options.lowerLimit) !== null && _b !== void 0 ? _b : 0;
        /**
         * Upper constraint limit. The constraint position is forced to be smaller than this value.
         * @property upperLimit
         * @type {Number}
         */
        _this.upperLimit = (_c = options === null || options === void 0 ? void 0 : options.upperLimit) !== null && _c !== void 0 ? _c : 1;
        // Equations used for limits
        _this.upperLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        _this.lowerLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        // Set max/min forces
        _this.upperLimitEquation.minForce = _this.lowerLimitEquation.minForce = 0;
        _this.upperLimitEquation.maxForce = _this.lowerLimitEquation.maxForce = maxForce;
        /**
         * Equation used for the motor.
         * @property motorEquation
         * @type {Equation}
         */
        _this.motorEquation = new Equation_1.default(bodyA, bodyB);
        /**
         * The current motor state. Enable or disable the motor using .enableMotor
         * @property motorEnabled
         * @type {Boolean}
         */
        _this.motorEnabled = false;
        /**
         * Set the target speed for the motor.
         * @property motorSpeed
         * @type {Number}
         */
        _this.motorSpeed = 0;
        var that = _this;
        var motorEquation = _this.motorEquation;
        motorEquation.computeGq = function () { return 0; };
        motorEquation.computeGW = function () {
            var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
            return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
        };
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    PrismaticConstraint.prototype.update = function () {
        var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
        trans.updateJacobian();
        // Transform local things to world
        vec2_1.default.rotate(worldAxisA, localAxisA, bodyA.angle);
        vec2_1.default.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
        vec2_1.default.add(worldAnchorA, orientedAnchorA, bodyA.position);
        vec2_1.default.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
        vec2_1.default.add(worldAnchorB, orientedAnchorB, bodyB.position);
        var relPosition = this.position = vec2_1.default.dot(worldAnchorB, worldAxisA) - vec2_1.default.dot(worldAnchorA, worldAxisA);
        // Motor
        if (this.motorEnabled) {
            // G = [ a     a x ri   -a   -a x rj ]
            var G = this.motorEquation.G;
            G[0] = worldAxisA[0];
            G[1] = worldAxisA[1];
            G[2] = vec2_1.default.crossLength(worldAxisA, orientedAnchorB);
            G[3] = -worldAxisA[0];
            G[4] = -worldAxisA[1];
            G[5] = -vec2_1.default.crossLength(worldAxisA, orientedAnchorA);
        }
        /*
            Limits strategy:
            Add contact equation, with normal along the constraint axis.
            min/maxForce is set so the constraint is repulsive in the correct direction.
            Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                    ^
                    |
        upperLimit x
                    |    ------
            anchorB x<---|  B |
                    |    |    |
            ------   |    ------
            |    |   |
            |  A |-->x anchorA
            ------   |
                    x lowerLimit
                    |
                    axis
        */
        if (this.upperLimitEnabled && relPosition > upperLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(upperLimitEquation.normalA, worldAxisA, -1);
            vec2_1.default.subtract(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, upperLimit);
            vec2_1.default.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
            if (eqs.indexOf(upperLimitEquation) === -1) {
                eqs.push(upperLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(upperLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
        if (this.lowerLimitEnabled && relPosition < lowerLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(lowerLimitEquation.normalA, worldAxisA, 1);
            vec2_1.default.subtract(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, lowerLimit);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
            if (eqs.indexOf(lowerLimitEquation) === -1) {
                eqs.push(lowerLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(lowerLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
    };
    /**
     * Enable the motor
     * @method enableMotor
     */
    PrismaticConstraint.prototype.enableMotor = function () {
        if (this.motorEnabled) {
            return;
        }
        this.equations.push(this.motorEquation);
        this.motorEnabled = true;
    };
    /**
     * Disable the rotational motor
     * @method disableMotor
     */
    PrismaticConstraint.prototype.disableMotor = function () {
        if (!this.motorEnabled) {
            return;
        }
        var i = this.equations.indexOf(this.motorEquation);
        this.equations.splice(i, 1);
        this.motorEnabled = false;
    };
    /**
     * Set the constraint limits.
     * @method setLimits
     * @param {number} lower Lower limit.
     * @param {number} upper Upper limit.
     */
    PrismaticConstraint.prototype.setLimits = function (lower, upper) {
        if (typeof (lower) === 'number') {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = true;
        }
        else {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = false;
        }
        if (typeof (upper) === 'number') {
            this.upperLimit = upper;
            this.upperLimitEnabled = true;
        }
        else {
            this.upperLimit = upper;
            this.upperLimitEnabled = false;
        }
    };
    return PrismaticConstraint;
}(constraint_1.default));
exports.default = PrismaticConstraint;

},{"../equations/Equation":14,"../equations/contact-equation":16,"../equations/rotational-lock-equation":19,"../math/vec2":28,"./constraint":8}],13:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var rotational_velocity_equation_1 = __importDefault(_dereq_("../equations/rotational-velocity-equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var sub = vec2_1.default.subtract;
var add = vec2_1.default.add;
var dot = vec2_1.default.dot;
var rotate = vec2_1.default.rotate;
var copy = vec2_1.default.copy;
var crossLength = vec2_1.default.crossLength;
var worldPivotA = vec2_1.default.create(), worldPivotB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1), g = vec2_1.default.create();
var RevoluteConstraint = /** @class */ (function (_super) {
    __extends(RevoluteConstraint, _super);
    /**
     * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
     * @class RevoluteConstraint
     * @constructor
     * @author schteppe
     * @param {Body}    bodyA
     * @param {Body}    bodyB
     * @param {Object}  [options]
     * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
     * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
     * @param {Array}   [options.localPivotB] See localPivotA.
     * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
     * @extends Constraint
     *
     * @example
     *     // This will create a revolute constraint between two bodies with pivot point in between them.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     world.addBody(bodyA);
     *
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     world.addBody(bodyB);
     *
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         worldPivot: [0, 0]
     *     });
     *     world.addConstraint(constraint);
     *
     *     // Using body-local pivot points, the constraint could have been constructed like this:
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         localPivotA: [1, 0],
     *         localPivotB: [-1, 0]
     *     });
     */
    function RevoluteConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.REVOLUTE, options) || this;
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var pivotA = _this.pivotA = vec2_1.default.create();
        var pivotB = _this.pivotB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.worldPivot) {
            // Compute pivotA and pivotB
            sub(pivotA, options.worldPivot, bodyA.position);
            sub(pivotB, options.worldPivot, bodyB.position);
            // Rotate to local coordinate system
            rotate(pivotA, pivotA, -bodyA.angle);
            rotate(pivotB, pivotB, -bodyB.angle);
        }
        else {
            // Get pivotA and pivotB
            if (options === null || options === void 0 ? void 0 : options.localPivotA) {
                copy(pivotA, options.localPivotA);
            }
            if (options === null || options === void 0 ? void 0 : options.localPivotB) {
                copy(pivotB, options.localPivotB);
            }
        }
        var motorEquation = _this.motorEquation = new rotational_velocity_equation_1.default(bodyA, bodyB);
        motorEquation.enabled = false;
        var upperLimitEquation = _this.upperLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        var lowerLimitEquation = _this.lowerLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        upperLimitEquation.minForce = lowerLimitEquation.maxForce = 0;
        // Equations to be fed to the solver
        var eqs = _this.equations = [
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            motorEquation,
            upperLimitEquation,
            lowerLimitEquation
        ];
        var x = eqs[0];
        var y = eqs[1];
        // TODO: bad practice.
        x.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, xAxis);
        };
        y.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, yAxis);
        };
        y.minForce = x.minForce = -maxForce;
        y.maxForce = x.maxForce = maxForce;
        // These never change but the angular parts do
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[3] = 1;
        x.G[4] = 0;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[3] = 0;
        y.G[4] = 1;
        _this.angle = 0;
        _this.lowerLimitEnabled = false;
        _this.upperLimitEnabled = false;
        _this.lowerLimit = 0;
        _this.upperLimit = 0;
        return _this;
    }
    /**
     * Set the constraint angle limits, and enable them.
     * @method setLimits
     * @param {number} lower Lower angle limit.
     * @param {number} upper Upper angle limit.
     */
    RevoluteConstraint.prototype.setLimits = function (lower, upper) {
        this.lowerLimit = lower;
        this.upperLimit = upper;
        this.lowerLimitEnabled = this.upperLimitEnabled = true;
    };
    RevoluteConstraint.prototype.update = function () {
        var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
        var relAngle = this.angle = bodyB.angle - bodyA.angle;
        upperLimitEquation.angle = upperLimit;
        upperLimitEquation.enabled = this.upperLimitEnabled && relAngle > upperLimit;
        lowerLimitEquation.angle = lowerLimit;
        lowerLimitEquation.enabled = this.lowerLimitEnabled && relAngle < lowerLimit;
        /*

        The constraint violation is

            g = xj + rj - xi - ri

        ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

            gdot = vj + wj x rj - vi - wi x ri

        We split this into x and y directions. (let x and y be unit vectors along the respective axes)

            gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                    = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                    = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                    = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                    = G*W

        ...and similar for y. We have then identified the jacobian entries for x and y directions:

            Gx = [ x   (rj x x)   -x   -(ri x x)]
            Gy = [ y   (rj x y)   -y   -(ri x y)]

        So for example, in the X direction we would get in 2 dimensions

            G = [ [1   0   (rj x [1,0])   -1   0   -(ri x [1,0])]
                [0   1   (rj x [0,1])    0  -1   -(ri x [0,1])]
        */
        rotate(worldPivotA, pivotA, bodyA.angle);
        rotate(worldPivotB, pivotB, bodyB.angle);
        // @todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc
        var xG = x.G;
        xG[2] = -crossLength(worldPivotA, xAxis);
        xG[5] = crossLength(worldPivotB, xAxis);
        var yG = y.G;
        yG[2] = -crossLength(worldPivotA, yAxis);
        yG[5] = crossLength(worldPivotB, yAxis);
    };
    Object.defineProperty(RevoluteConstraint.prototype, "motorEnabled", {
        /**
         * @property {boolean} motorEnabled
         */
        get: function () {
            return this.motorEquation.enabled;
        },
        set: function (value) {
            this.motorEquation.enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorSpeed", {
        /**
         * @property {number} motorSpeed
         */
        get: function () {
            return this.motorEquation.relativeVelocity;
        },
        set: function (value) {
            this.motorEquation.relativeVelocity = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorMaxForce", {
        /**
         * @property {number} motorMaxForce
         */
        get: function () {
            return this.motorEquation.maxForce;
        },
        set: function (value) {
            var eq = this.motorEquation;
            eq.maxForce = value;
            eq.minForce = -value;
        },
        enumerable: false,
        configurable: true
    });
    return RevoluteConstraint;
}(constraint_1.default));
exports.default = RevoluteConstraint;

},{"../equations/Equation":14,"../equations/rotational-lock-equation":19,"../equations/rotational-velocity-equation":20,"../math/vec2":28,"./constraint":8}],14:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
// Shortcuts.
var scale = vec2_1.default.scale, multiply = vec2_1.default.multiply, createVec2 = vec2_1.default.create;
var Equation = /** @class */ (function () {
    /**
     * Base class for constraint equations.
     * @class Equation
     * @constructor
     * @param {Body} bodyA First body participating in the equation
     * @param {Body} bodyB Second body participating in the equation
     * @param {number} minForce Minimum force to apply. Default: -Infinity
     * @param {number} maxForce Maximum force to apply. Default: Infinity
     */
    function Equation(bodyA, bodyB, minForce, maxForce) {
        /**
         * Cap the constraint violation (G*q) to this value.
         * @property maxBias
         * @type {Number}
         */
        this.maxBias = Infinity;
        /**
         * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        /**
         * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.offset = 0;
        this.a = 0;
        this.b = 0;
        this.epsilon = 0;
        this.timeStep = 1 / 60;
        /**
         * Indicates if stiffness or relaxation was changed.
         * @property {Boolean} needsUpdate
         */
        this.needsUpdate = true;
        /**
         * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
         * @property multiplier
         * @type {Number}
         */
        this.multiplier = 0;
        /**
         * Relative velocity.
         * @property {Number} relativeVelocity
         */
        this.relativeVelocity = 0;
        /**
         * Whether this equation is enabled or not. If true, it will be added to the solver.
         * @property {Boolean} enabled
         */
        this.enabled = true;
        // Temp stuff
        this.maxForceDt = 0;
        this.minForceDt = 0;
        this.invC = 0;
        this.B = 0;
        this.lambda = 0;
        this.index = -1;
        this.minForce = minForce !== null && minForce !== void 0 ? minForce : -Infinity;
        this.maxForce = maxForce !== null && maxForce !== void 0 ? maxForce : Infinity;
        this.maxBias = Infinity;
        this.bodyA = bodyA !== null && bodyA !== void 0 ? bodyA : null;
        this.bodyB = bodyB !== null && bodyB !== void 0 ? bodyB : null;
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.G = new Float32Array(6);
        for (var i = 0; i < 6; i++) {
            this.G[i] = 0;
        }
    }
    /**
     * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
     * @method update
     */
    Equation.prototype.update = function () {
        var k = this.stiffness, d = this.relaxation, h = this.timeStep;
        this.a = 4 / (h * (1 + 4 * d));
        this.b = (4 * d) / (1 + 4 * d);
        this.epsilon = 4 / (h * h * k * (1 + 4 * d));
        this.needsUpdate = false;
    };
    /**
     * Multiply a jacobian entry with corresponding positions or velocities
     * @method gmult
     * @return {Number}
     */
    Equation.prototype.gmult = function (G, vi, wi, vj, wj) {
        return G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
    };
    /**
     * Computes the RHS of the SPOOK equation
     * @method computeB
     * @return {Number}
     */
    Equation.prototype.computeB = function (a, b, h) {
        var GW = this.computeGW();
        var Gq = this.computeGq();
        var maxBias = this.maxBias;
        if (Math.abs(Gq) > maxBias) {
            Gq = Gq > 0 ? maxBias : -maxBias;
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - GiMf * h;
        return B;
    };
    /**
     * Computes G\*q, where q are the generalized body coordinates
     * @method computeGq
     * @return {Number}
     */
    Equation.prototype.computeGq = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var ai = bi.angle, aj = bj.angle;
        var qi = createVec2(), qj = createVec2();
        return this.gmult(G, qi, ai, qj, aj) + this.offset;
    };
    /**
     * Computes G\*W, where W are the body velocities
     * @method computeGW
     * @return {Number}
     */
    Equation.prototype.computeGW = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
        return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
    };
    /**
     * Computes G\*Wlambda, where W are the body velocities
     * @method computeGWlambda
     * @return {Number}
     */
    Equation.prototype.computeGWlambda = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
        return this.gmult(G, vi, wi, vj, wj);
    };
    /**
     * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
     * @method computeGiMf
     * @return {Number}
     */
    Equation.prototype.computeGiMf = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        var iMfi = createVec2(), iMfj = createVec2();
        scale(iMfi, fi, invMassi);
        multiply(iMfi, bi.massMultiplier, iMfi);
        scale(iMfj, fj, invMassj);
        multiply(iMfj, bj.massMultiplier, iMfj);
        return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
    };
    /**
     * Computes G\*inv(M)\*G'
     * @method computeGiMGt
     * @return {Number}
     */
    Equation.prototype.computeGiMGt = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        return G[0] * G[0] * invMassi * bi.massMultiplier[0] +
            G[1] * G[1] * invMassi * bi.massMultiplier[1] +
            G[2] * G[2] * invIi +
            G[3] * G[3] * invMassj * bj.massMultiplier[0] +
            G[4] * G[4] * invMassj * bj.massMultiplier[1] +
            G[5] * G[5] * invIj;
    };
    Equation.prototype.updateJacobian = function () { };
    ;
    /**
     * Add constraint velocity to the bodies.
     * @method addToWlambda
     * @param {Number} deltalambda
     */
    Equation.prototype.addToWlambda = function (deltalambda) {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        // v_lambda = G * inv(M) * delta_lambda
        addToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);
        bi.wlambda += invIi * G[2] * deltalambda;
        addToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);
        bj.wlambda += invIj * G[5] * deltalambda;
    };
    /**
     * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
     * @method computeInvC
     * @param  {Number} eps
     * @return {Number}
     */
    Equation.prototype.computeInvC = function (eps) {
        var invC = 1 / (this.computeGiMGt() + eps);
        return invC;
    };
    /**
     * The default stiffness when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_STIFFNESS
     * @default 1e6
     */
    Equation.DEFAULT_STIFFNESS = 1e6;
    /**
     * The default relaxation when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_RELAXATION
     * @default 4
     */
    Equation.DEFAULT_RELAXATION = 4;
    return Equation;
}());
exports.default = Equation;
function addToVLambda(vlambda, Gx, Gy, invMass, deltalambda, massMultiplier) {
    vlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];
    vlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];
}

},{"../math/vec2":28}],15:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var AngleLockEquation = /** @class */ (function (_super) {
    __extends(AngleLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class AngleLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in body A.
     * @param {Number} [options.ratio] Gear ratio
     */
    function AngleLockEquation(bodyA, bodyB, options) {
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        _this.ratio = (_b = options === null || options === void 0 ? void 0 : options.ratio) !== null && _b !== void 0 ? _b : 1;
        _this.setRatio(_this.ratio);
        return _this;
    }
    AngleLockEquation.prototype.computeGq = function () {
        return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
    };
    /**
     * Set the gear ratio for this equation
     * @method setRatio
     * @param {Number} ratio
     */
    AngleLockEquation.prototype.setRatio = function (ratio) {
        var G = this.G;
        G[2] = ratio;
        G[5] = -1;
        this.ratio = ratio;
    };
    /**
     * Set the max force for the equation.
     * @method setMaxTorque
     * @param {Number} torque
     */
    AngleLockEquation.prototype.setMaxTorque = function (torque) {
        this.maxForce = torque;
        this.minForce = -torque;
    };
    return AngleLockEquation;
}(Equation_1.default));
exports.default = AngleLockEquation;

},{"./Equation":14}],16:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
function addSubSub(out, a, b, c, d) {
    out[0] = a[0] + b[0] - c[0] - d[0];
    out[1] = a[1] + b[1] - c[1] - d[1];
}
var vi = vec2_1.default.create();
var vj = vec2_1.default.create();
var relVel = vec2_1.default.create();
var ContactEquation = /** @class */ (function (_super) {
    __extends(ContactEquation, _super);
    /**
     * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
     *
     * @class ContactEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function ContactEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, 0, Infinity) || this;
        /**
         * Vector from body i center of mass to the contact point.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        _this.penetrationVec = vec2_1.default.create();
        /**
         * World-oriented vector from body A center of mass to the contact point.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * The normal vector, pointing out of body i
         * @property normalA
         * @type {Array}
         */
        _this.normalA = vec2_1.default.create();
        /**
         * The restitution to use (0=no bounciness, 1=max bounciness).
         * @property restitution
         * @type {Number}
         */
        _this.restitution = 0;
        /**
         * This property is set to true if this is the first impact between the bodies (not persistant contact).
         * @property firstImpact
         * @type {Boolean}
         * @readOnly
         */
        _this.firstImpact = false;
        /**
         * The shape in body i that triggered this contact.
         * @property shapeA
         * @type {Shape}
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this contact.
         * @property shapeB
         * @type {Shape}
         */
        _this.shapeB = null;
        return _this;
    }
    ContactEquation.prototype.computeB = function (a, b, h) {
        var _a, _b;
        var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = (_a = bi === null || bi === void 0 ? void 0 : bi.position) !== null && _a !== void 0 ? _a : new Float32Array(2), xj = (_b = bj === null || bj === void 0 ? void 0 : bj.position) !== null && _b !== void 0 ? _b : new Float32Array(2);
        var n = this.normalA, G = this.G;
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
        // Compute iteration
        var GW, Gq;
        if (this.firstImpact && this.restitution !== 0) {
            Gq = 0;
            GW = (1 / b) * (1 + this.restitution) * this.computeGW();
        }
        else {
            // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
            var penetrationVec = this.penetrationVec;
            addSubSub(penetrationVec, xj, rj, xi, ri);
            Gq = vec2_1.default.dot(n, penetrationVec) + this.offset;
            GW = this.computeGW();
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - h * GiMf;
        return B;
    };
    ;
    /**
     * Get the relative velocity along the normal vector.
     * @method getVelocityAlongNormal
     * @return {number}
     */
    ContactEquation.prototype.getVelocityAlongNormal = function () {
        this.bodyA && this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
        this.bodyB && this.bodyB.getVelocityAtPoint(vj, this.contactPointB);
        vec2_1.default.subtract(relVel, vi, vj);
        return vec2_1.default.dot(this.normalA, relVel);
    };
    ;
    return ContactEquation;
}(Equation_1.default));
exports.default = ContactEquation;

},{"../math/vec2":28,"./Equation":14}],17:[function(_dereq_,module,exports){
module.exports=_dereq_(14)
},{"../math/vec2":28}],18:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Equation_1 = __importDefault(_dereq_("./Equation"));
var FrictionEquation = /** @class */ (function (_super) {
    __extends(FrictionEquation, _super);
    /**
     * Constrains the slipping in a contact along a tangent
     *
     * @class FrictionEquation
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} slipForce
     * @extends Equation
     */
    function FrictionEquation(bodyA, bodyB, slipForce) {
        if (slipForce === void 0) { slipForce = Infinity; }
        var _this = _super.call(this, bodyA, bodyB, -slipForce, slipForce) || this;
        /**
         * Relative vector from center of body A to the contact point, world oriented.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        /**
         * Relative vector from center of body B to the contact point, world oriented.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * Tangent vector that the friction force will act along. World oriented.
         * @property t
         * @type {Array}
         */
        _this.t = vec2_1.default.create();
        /**
         * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
         * @property contactEquations
         * @type {ContactEquation[]}
         */
        _this.contactEquations = [];
        /**
         * The shape in body i that triggered this friction.
         * @property shapeA
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeA...
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this friction.
         * @property shapeB
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeB...
         */
        _this.shapeB = null;
        /**
         * The friction coefficient to use.
         * @property frictionCoefficient
         * @type {Number}
         */
        _this.frictionCoefficient = 0.3;
        return _this;
    }
    /**
     * Set the slipping condition for the constraint. The friction force cannot be
     * larger than this value.
     * @method setSlipForce
     * @param  {Number} slipForce
     */
    FrictionEquation.prototype.setSlipForce = function (slipForce) {
        this.maxForce = slipForce;
        this.minForce = -slipForce;
    };
    ;
    /**
     * Get the max force for the constraint.
     * @method getSlipForce
     * @return {Number}
     */
    FrictionEquation.prototype.getSlipForce = function () {
        return this.maxForce;
    };
    ;
    FrictionEquation.prototype.computeB = function (a, b, h) {
        var ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
        // G = [-t -rixt t rjxt]
        // And remember, this is a pure velocity constraint, g is always zero!
        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2_1.default.crossLength(ri, t);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2_1.default.crossLength(rj, t);
        var GW = this.computeGW(), GiMf = this.computeGiMf();
        var B = /* - g * a  */ -GW * b - h * GiMf;
        return B;
    };
    ;
    return FrictionEquation;
}(Equation_1.default));
exports.default = FrictionEquation;

},{"../math/vec2":28,"./Equation":14}],19:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var worldVectorA = vec2_1.default.create(), worldVectorB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1);
var RotationalLockEquation = /** @class */ (function (_super) {
    __extends(RotationalLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class RotationalLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
     */
    function RotationalLockEquation(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        var G = _this.G;
        G[2] = 1;
        G[5] = -1;
        return _this;
    }
    RotationalLockEquation.prototype.computeGq = function () {
        vec2_1.default.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
        vec2_1.default.rotate(worldVectorB, yAxis, this.bodyB.angle);
        return vec2_1.default.dot(worldVectorA, worldVectorB);
    };
    ;
    return RotationalLockEquation;
}(Equation_1.default));
exports.default = RotationalLockEquation;

},{"../math/vec2":28,"./Equation":14}],20:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var RotationalVelocityEquation = /** @class */ (function (_super) {
    __extends(RotationalVelocityEquation, _super);
    /**
     * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
     *
     * @class RotationalVelocityEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function RotationalVelocityEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.relativeVelocity = 1;
        _this.ratio = 1;
        return _this;
    }
    RotationalVelocityEquation.prototype.computeB = function (a, b, h) {
        var G = this.G;
        G[2] = -1;
        G[5] = this.ratio;
        var GiMf = this.computeGiMf();
        var GW = this.computeGW();
        var B = -GW * b - h * GiMf;
        return B;
    };
    return RotationalVelocityEquation;
}(Equation_1.default));
exports.default = RotationalVelocityEquation;

},{"./Equation":14}],21:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @example
 *     var emitter = new EventEmitter();
 *     emitter.on('myEvent', function(evt){
 *         console.log(evt.message);
 *     });
 *     emitter.emit({
 *         type: 'myEvent',
 *         message: 'Hello world!'
 *     });
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._listeners = {};
        this._contexts = {};
    }
    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', function(evt){
     *         console.log('myEvt was triggered!');
     *     });
     */
    EventEmitter.prototype.on = function (type, listener, context) {
        if (this._listeners[type] === undefined) {
            this._listeners[type] = [];
            this._contexts[type] = [];
        }
        if (this._listeners[type].indexOf(listener) === -1) {
            this._listeners[type].push(listener);
            this._contexts[type].push(context);
        }
        return this;
    };
    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', handler); // Add handler
     *     emitter.off('myEvent', handler); // Remove handler
     */
    EventEmitter.prototype.off = function (type, listener) {
        if (!this._listeners || !this._listeners[type]) {
            return this;
        }
        var index = this._listeners[type].indexOf(listener);
        if (index !== -1) {
            this._listeners[type].splice(index, 1);
            this._contexts[type].splice(index, 1);
        }
        return this;
    };
    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    EventEmitter.prototype.has = function (type, listener) {
        if (this._listeners === undefined) {
            return false;
        }
        var listeners = this._listeners;
        if (listener) {
            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                return true;
            }
        }
        else {
            if (listeners[type] !== undefined) {
                return true;
            }
        }
        return false;
    };
    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.emit({
     *         type: 'myEvent',
     *         customData: 123
     *     });
     */
    // TODO: the unknown type here is disturbing.
    EventEmitter.prototype.emit = function (event) {
        if (this._listeners === undefined) {
            return this;
        }
        var listenerArray = this._listeners[event.type];
        var contextArray = this._contexts[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Need to copy the listener array, in case some listener was added/removed inside a listener
            var tmpListenerArray = [];
            var tmpContextArray = [];
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                tmpListenerArray.push(listenerArray[i]);
                tmpContextArray.push(contextArray[i]);
            }
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                var listener = listenerArray[i];
                var context = contextArray[i];
                listener.call(context, event);
            }
        }
        return this;
    };
    return EventEmitter;
}());
exports.default = EventEmitter;

},{}],22:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.vec2 = exports.World = exports.Utils = exports.RotationalSpring = exports.LinearSpring = exports.TopDownVehicle = exports.Spring = exports.Solver = exports.Shape = exports.SAPBroadphase = exports.RotationalVelocityEquation = exports.Box = exports.RaycastResult = exports.Ray = exports.PrismaticConstraint = exports.RevoluteConstraint = exports.Pool = exports.Plane = exports.Particle = exports.NaiveBroadphase = exports.Narrowphase = exports.Material = exports.LockConstraint = exports.Line = exports.Heightfield = exports.GSSolver = exports.GearConstraint = exports.FrictionEquationPool = exports.FrictionEquation = exports.EventEmitter = exports.Equation = exports.DistanceConstraint = exports.Convex = exports.ContactMaterial = exports.ContactEquationPool = exports.ContactEquation = exports.Constraint = exports.Circle = exports.Capsule = exports.Broadphase = exports.Body = exports.AngleLockEquation = exports.AABB = void 0;
var version = "0.0.1";
exports.version = version;
var aabb_1 = __importDefault(_dereq_("./collision/aabb"));
exports.AABB = aabb_1.default;
var angle_lock_equation_1 = __importDefault(_dereq_("./equations/angle-lock-equation"));
exports.AngleLockEquation = angle_lock_equation_1.default;
var body_1 = __importDefault(_dereq_("./objects/body"));
exports.Body = body_1.default;
var broadphase_1 = __importDefault(_dereq_("./collision/broadphase"));
exports.Broadphase = broadphase_1.default;
var capsule_1 = __importDefault(_dereq_("./shapes/capsule"));
exports.Capsule = capsule_1.default;
var circle_1 = __importDefault(_dereq_("./shapes/circle"));
exports.Circle = circle_1.default;
var constraint_1 = __importDefault(_dereq_("./constraints/constraint"));
exports.Constraint = constraint_1.default;
var contact_equation_1 = __importDefault(_dereq_("./equations/contact-equation"));
exports.ContactEquation = contact_equation_1.default;
var contact_equation_pool_1 = __importDefault(_dereq_("./utils/contact-equation-pool"));
exports.ContactEquationPool = contact_equation_pool_1.default;
var contact_material_1 = __importDefault(_dereq_("./material/contact-material"));
exports.ContactMaterial = contact_material_1.default;
var convex_1 = __importDefault(_dereq_("./shapes/convex"));
exports.Convex = convex_1.default;
var distance_constraint_1 = __importDefault(_dereq_("./constraints/distance-constraint"));
exports.DistanceConstraint = distance_constraint_1.default;
var equation_1 = __importDefault(_dereq_("./equations/equation"));
exports.Equation = equation_1.default;
var event_emitter_1 = __importDefault(_dereq_("./events/event-emitter"));
exports.EventEmitter = event_emitter_1.default;
var friction_equation_1 = __importDefault(_dereq_("./equations/friction-equation"));
exports.FrictionEquation = friction_equation_1.default;
var friction_equation_pool_1 = __importDefault(_dereq_("./utils/friction-equation-pool"));
exports.FrictionEquationPool = friction_equation_pool_1.default;
var gear_constraint_1 = __importDefault(_dereq_("./constraints/gear-constraint"));
exports.GearConstraint = gear_constraint_1.default;
var gs_solver_1 = __importDefault(_dereq_("./solver/gs-solver"));
exports.GSSolver = gs_solver_1.default;
var heightfield_1 = __importDefault(_dereq_("./shapes/heightfield"));
exports.Heightfield = heightfield_1.default;
var line_1 = __importDefault(_dereq_("./shapes/line"));
exports.Line = line_1.default;
var lock_constraint_1 = __importDefault(_dereq_("./constraints/lock-constraint"));
exports.LockConstraint = lock_constraint_1.default;
var material_1 = __importDefault(_dereq_("./material/material"));
exports.Material = material_1.default;
var narrowphase_1 = __importDefault(_dereq_("./collision/narrowphase"));
exports.Narrowphase = narrowphase_1.default;
var naive_broadphase_1 = __importDefault(_dereq_("./collision/naive-broadphase"));
exports.NaiveBroadphase = naive_broadphase_1.default;
var particle_1 = __importDefault(_dereq_("./shapes/particle"));
exports.Particle = particle_1.default;
var plane_1 = __importDefault(_dereq_("./shapes/plane"));
exports.Plane = plane_1.default;
var pool_1 = __importDefault(_dereq_("./utils/pool"));
exports.Pool = pool_1.default;
var revolute_constraint_1 = __importDefault(_dereq_("./constraints/revolute-constraint"));
exports.RevoluteConstraint = revolute_constraint_1.default;
var prismatic_constraint_1 = __importDefault(_dereq_("./constraints/prismatic-constraint"));
exports.PrismaticConstraint = prismatic_constraint_1.default;
var ray_1 = __importDefault(_dereq_("./collision/ray"));
exports.Ray = ray_1.default;
var raycast_result_1 = __importDefault(_dereq_("./collision/raycast-result"));
exports.RaycastResult = raycast_result_1.default;
var Box_1 = __importDefault(_dereq_("./shapes/Box"));
exports.Box = Box_1.default;
var rotational_velocity_equation_1 = __importDefault(_dereq_("./equations/rotational-velocity-equation"));
exports.RotationalVelocityEquation = rotational_velocity_equation_1.default;
var sap_broadphase_1 = __importDefault(_dereq_("./collision/sap-broadphase"));
exports.SAPBroadphase = sap_broadphase_1.default;
var shape_1 = __importDefault(_dereq_("./shapes/shape"));
exports.Shape = shape_1.default;
var solver_1 = __importDefault(_dereq_("./solver/solver"));
exports.Solver = solver_1.default;
var spring_1 = __importDefault(_dereq_("./objects/spring"));
exports.Spring = spring_1.default;
var top_down_vehicle_1 = __importDefault(_dereq_("./objects/top-down-vehicle"));
exports.TopDownVehicle = top_down_vehicle_1.default;
var linear_spring_1 = __importDefault(_dereq_("./objects/linear-spring"));
exports.LinearSpring = linear_spring_1.default;
var rotational_spring_1 = __importDefault(_dereq_("./objects/rotational-spring"));
exports.RotationalSpring = rotational_spring_1.default;
var utils_1 = __importDefault(_dereq_("./utils/utils"));
exports.Utils = utils_1.default;
var world_1 = __importDefault(_dereq_("./world/world"));
exports.World = world_1.default;
var vec2_1 = __importDefault(_dereq_("./math/vec2"));
exports.vec2 = vec2_1.default;

},{"./collision/aabb":1,"./collision/broadphase":2,"./collision/naive-broadphase":3,"./collision/narrowphase":4,"./collision/ray":5,"./collision/raycast-result":6,"./collision/sap-broadphase":7,"./constraints/constraint":8,"./constraints/distance-constraint":9,"./constraints/gear-constraint":10,"./constraints/lock-constraint":11,"./constraints/prismatic-constraint":12,"./constraints/revolute-constraint":13,"./equations/angle-lock-equation":15,"./equations/contact-equation":16,"./equations/equation":17,"./equations/friction-equation":18,"./equations/rotational-velocity-equation":20,"./events/event-emitter":21,"./material/contact-material":24,"./material/material":25,"./math/vec2":28,"./objects/body":30,"./objects/linear-spring":31,"./objects/rotational-spring":32,"./objects/spring":33,"./objects/top-down-vehicle":34,"./shapes/Box":35,"./shapes/capsule":39,"./shapes/circle":40,"./shapes/convex":41,"./shapes/heightfield":42,"./shapes/line":43,"./shapes/particle":44,"./shapes/plane":45,"./shapes/shape":46,"./solver/gs-solver":47,"./solver/solver":48,"./utils/contact-equation-pool":49,"./utils/friction-equation-pool":50,"./utils/pool":54,"./utils/utils":56,"./world/world":58}],23:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Material = /** @class */ (function () {
    /**
     * Defines a physics material. To be used with {{#crossLink "ContactMaterial"}}{{/crossLink}}.
     * @class Material
     * @constructor
     * @author schteppe
     * @example
     *     // Create a wooden box
     *     var woodMaterial = new Material();
     *     var boxShape = new Box({
     *         material: woodMaterial
     *     });
     *     body.addShape(boxShape);
     */
    function Material() {
        /**
         * The material identifier. Read only.
         * @readonly
         * @property id
         * @type {Number}
         */
        this.id = ++Material.idCounter;
    }
    Material.idCounter = 0;
    return Material;
}());
exports.default = Material;

},{}],24:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Material_1 = __importDefault(_dereq_("./Material"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var ContactMaterial = /** @class */ (function () {
    /**
     * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters. Also see {{#crossLink "Material"}}{{/crossLink}}.
     * @class ContactMaterial
     * @constructor
     * @param {Material} materialA
     * @param {Material} materialB
     * @param {Object}   [options]
     * @param {Number}   [options.friction=0.3]       Friction coefficient.
     * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
     * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
     * @param {Number}   [options.relaxation]         ContactEquation relaxation.
     * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
     * @param {Number}   [options.stiffness]          ContactEquation stiffness.
     * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
     * @author schteppe
     * @example
     *     var ice = new Material();
     *     var wood = new Material();
     *     var iceWoodContactMaterial = new ContactMaterial(ice, wood, {
     *         friction: 0.2,
     *         restitution: 0.3
     *     });
     *     world.addContactMaterial(iceWoodContactMaterial);
     */
    function ContactMaterial(materialA, materialB, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.
         * @property friction
         * @type {Number}
         * @default 0.3
         */
        this.friction = 0.3;
        /**
         * Restitution, or "bounciness" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.
         * @property restitution
         * @type {Number}
         * @default 0
         */
        this.restitution = 0;
        /**
         * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property frictionStiffness
         * @type {Number}
         */
        this.frictionStiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property frictionRelaxation
         * @type {Number}
         */
        this.frictionRelaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
         * @property {Number} surfaceVelocity
         * @default 0
         */
        this.surfaceVelocity = 0;
        /**
         * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
         * @property contactSkinSize
         * @type {Number}
         */
        this.contactSkinSize = 0.005;
        if (!(materialA instanceof Material_1.default) || !(materialB instanceof Material_1.default)) {
            throw new Error("First two arguments must be Material instances.");
        }
        this.id = ++ContactMaterial.idCounter;
        this.materialA = materialA;
        this.materialB = materialB;
        this.friction = (_a = options === null || options === void 0 ? void 0 : options.friction) !== null && _a !== void 0 ? _a : 0.3;
        this.restitution = (_b = options === null || options === void 0 ? void 0 : options.restitution) !== null && _b !== void 0 ? _b : 0;
        this.stiffness = (_c = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _c !== void 0 ? _c : Equation_1.default.DEFAULT_STIFFNESS;
        this.relaxation = (_d = options === null || options === void 0 ? void 0 : options.relaxation) !== null && _d !== void 0 ? _d : Equation_1.default.DEFAULT_RELAXATION;
        this.frictionStiffness = (_e = options === null || options === void 0 ? void 0 : options.frictionStiffness) !== null && _e !== void 0 ? _e : Equation_1.default.DEFAULT_STIFFNESS;
        this.frictionRelaxation = (_f = options === null || options === void 0 ? void 0 : options.frictionRelaxation) !== null && _f !== void 0 ? _f : Equation_1.default.DEFAULT_RELAXATION;
        this.surfaceVelocity = (_g = options === null || options === void 0 ? void 0 : options.surfaceVelocity) !== null && _g !== void 0 ? _g : 0;
        this.contactSkinSize = 0.005;
    }
    ContactMaterial.idCounter = 0;
    return ContactMaterial;
}());
exports.default = ContactMaterial;

},{"../equations/Equation":14,"./Material":23}],25:[function(_dereq_,module,exports){
module.exports=_dereq_(23)
},{}],26:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1, l2, precision) {
    if (precision === void 0) { precision = 0; }
    var i = new Float32Array(2); // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}
/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da = q2[0] - q1[0];
    var db = q2[1] - q1[1];
    // segments are parallel
    if ((da * dy - db * dx) === 0) {
        return false;
    }
    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
    return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
}
/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a, b, c) {
    return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1])));
}
function isLeft(a, b, c) {
    return triangleArea(a, b, c) > 0;
}
function isLeftOn(a, b, c) {
    return triangleArea(a, b, c) >= 0;
}
function isRight(a, b, c) {
    return triangleArea(a, b, c) < 0;
}
function isRightOn(a, b, c) {
    return triangleArea(a, b, c) <= 0;
}
var tmpPoint1 = new Float32Array(2), tmpPoint2 = new Float32Array(2);
/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
        return triangleArea(a, b, c) === 0;
    }
    else {
        var ab = tmpPoint1, bc = tmpPoint2;
        ab[0] = b[0] - a[0];
        ab[1] = b[1] - a[1];
        bc[0] = c[0] - b[0];
        bc[1] = c[1] - b[1];
        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
        return angle < thresholdAngle;
    }
}
function sqdist(a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}
/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i) {
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}
/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon) {
    polygon.length = 0;
}
/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to) {
    for (var i = from; i < to; i++) {
        polygon.push(poly[i]);
    }
}
/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon) {
    var br = 0, v = polygon;
    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }
    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon) {
    var tmp = [];
    var N = polygon.length;
    for (var i = 0; i !== N; i++) {
        var p = polygon.pop();
        tmp.push(p);
    }
    for (var i = 0; i !== N; i++) {
        polygon[i] = tmp[i];
    }
}
/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i) {
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}
var tmpLine1 = [], tmpLine2 = [];
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a, b) {
    var p, dist, l1 = tmpLine1, l2 = tmpLine2;
    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a) { // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1, l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }
    return true;
}
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee2(polygon, a, b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
        // ignore incident edges
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
            continue;
        }
        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
            return false;
        }
    }
    return true;
}
/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i, j, targetPoly) {
    var p = targetPoly !== null && targetPoly !== void 0 ? targetPoly : [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for (var k = i; k <= j; k++) {
            p.push(polygon[k]);
        }
    }
    else {
        // Insert vertices 0 to j
        for (var k = 0; k <= j; k++) {
            p.push(polygon[k]);
        }
        // Insert vertices i to end
        for (var k = i; k < polygon.length; k++) {
            p.push(polygon[k]);
        }
    }
    return p;
}
/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
    var nDiags = Infinity;
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                    for (var k = 0; k < tmp2.length; k++) {
                        tmp1.push(tmp2[k]);
                    }
                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        var p = [polygonAt(polygon, i), polygonAt(polygon, j)];
                        min.push(p);
                    }
                }
            }
        }
    }
    return min;
}
/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon) {
    var edges = polygonGetCutEdges(polygon);
    if (edges.length > 0) {
        return polygonSlice(polygon, edges);
    }
    else {
        return [polygon];
    }
}
/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @warning The inner workings of this function was massively modified when switching to typescript. Needs thorough testing.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges) {
    if (cutEdges.length === 0) {
        return [polygon];
    }
    if (cutEdges[0].length === 2) {
        var polys = [polygon];
        for (var i = 0; i < cutEdges.length; i++) {
            var cutEdge = [cutEdges[i]];
            // Cut all polys
            for (var j = 0; j < polys.length; j++) {
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if (result) {
                    // Found poly! Cut and quit
                    polys.splice(j, 1);
                    polys.push(result[0]);
                    polys.push(result[1]);
                    break;
                }
            }
        }
        return polys;
    }
    else {
        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0][0]);
        var j = polygon.indexOf(cutEdge[0][1]);
        if (i !== -1 && j !== -1) {
            return [polygonCopy(polygon, i, j),
                polygonCopy(polygon, j, i)];
        }
        else {
            return new Array();
        }
    }
}
/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon) {
    var path = polygon, i;
    // Check
    for (i = 0; i < path.length - 1; i++) {
        for (var j = 0; j < i - 1; j++) {
            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                return false;
            }
        }
    }
    // Check the segment between the last and the first point to all others
    for (i = 1; i < path.length - 2; i++) {
        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
            return false;
        }
    }
    return true;
}
function getIntersectionPoint(p1, p2, q1, q2, delta) {
    if (delta === void 0) { delta = 0; }
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = (a1 * p1[0]) + (b1 * p1[1]);
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = (a2 * q1[0]) + (b2 * q1[1]);
    var det = (a1 * b2) - (a2 * b1);
    var pt = new Float32Array(2);
    if (!scalar_eq(det, 0, delta)) {
        pt[0] = ((b2 * c1) - (b1 * c2)) / det;
        pt[1] = ((a1 * c2) - (a2 * c1)) / det;
        return pt;
    }
    else {
        pt[0] = 0;
        pt[1] = 0;
        return pt;
    }
}
/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    if (result === void 0) { result = new Array(); }
    if (reflexVertices === void 0) { reflexVertices = []; }
    if (steinerPoints === void 0) { steinerPoints = []; }
    if (delta === void 0) { delta = 25; }
    if (maxlevel === void 0) { maxlevel = 100; }
    if (level === void 0) { level = 0; }
    // TODO: should upperInt really be initialized here? It looks like it's overwritten.
    var upperInt = new Float32Array(2), lowerInt = new Float32Array(2), p = new Float32Array(2); // Points
    upperInt[0] = 0;
    upperInt[1] = 0;
    lowerInt[0] = 0;
    lowerInt[1] = 0;
    p[0] = 0;
    p[1] = 0;
    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars
    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers
    var lowerPoly = new Array(), upperPoly = new Array(); // polygons
    var poly = polygon, v = polygon;
    if (v.length < 3) {
        return result;
    }
    level++;
    if (level > maxlevel) {
        //console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Infinity;
            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }
            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);
                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0) {
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly, i, poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                }
            }
            else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");
                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Infinity;
                if (upperIndex < lowerIndex) {
                    return result;
                }
                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&
                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }
                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                    if (closestIndex !== 0) {
                        polygonAppend(upperPoly, poly, closestIndex, v.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        polygonAppend(lowerPoly, poly, i, v.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                    polygonAppend(upperPoly, poly, closestIndex, i + 1);
                }
            }
            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            else {
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            return result;
        }
    }
    result.push(polygon);
    return result;
}
/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision) {
    var num = 0;
    for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
        if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
            // Remove the middle point
            polygon.splice(i % polygon.length, 1);
            num++;
        }
    }
    return num;
}
/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */
function polygonRemoveDuplicatePoints(polygon, precision) {
    for (var i = polygon.length - 1; i >= 1; --i) {
        var pi = polygon[i];
        for (var j = i - 1; j >= 0; --j) {
            if (points_eq(pi, polygon[j], precision)) {
                polygon.splice(i, 1);
                continue;
            }
        }
    }
}
/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a, b, precision) {
    precision = precision || 0;
    return Math.abs(a - b) <= precision;
}
/**
 * Check if two points are equal
 * @static
 * @method points_eq
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function points_eq(a, b, precision) {
    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
}
exports.default = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
};

},{}],27:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
var PolyK = /** @class */ (function () {
    function PolyK() {
    }
    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    IsSimple(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new this._P(), a2 = new this._P();
        var b1 = new this._P(), b2 = new this._P();
        var c = new this._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(this._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    IsConvex(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!this._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!this._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!this._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.prototype.GetArea = function (p) {
        if (p.length < 6)
            return 0;
        var l = p.length - 2;
        var sum = 0;
        for (var i = 0; i < l; i += 2)
            sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
        sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
        return -sum * 0.5;
    };
    /*
    GetAABB(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */
    PolyK.prototype.Triangulate = function (p) {
        var n = p.length >> 1;
        if (n < 3)
            return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++)
            avl.push(i);
        var i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (this._convex(ax, ay, bx, by, cx, cy)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi == i0 || vi == i1 || vi == i2)
                        continue;
                    if (this._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0);
                tgs.push(i1);
                tgs.push(i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            }
            else if (i++ > 3 * al)
                break; // no convex angles :(
        }
        tgs.push(avl[0]);
        tgs.push(avl[1]);
        tgs.push(avl[2]);
        return tgs;
    };
    /*
    ContainsPoint(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    Slice(p, ax, ay, bx, by)
    {
        if(this.ContainsPoint(p, ax, ay) || this.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new this._P(ax, ay);
        var b = new this._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new this._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new this._P(0,0);
            isc = this._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp(u,v) {return this._P.dist(a,u) - this._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = this._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = this._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    Raycast(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    ClosestEdge(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            this._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        this._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    _pointLineDist(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    _updateISC(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = this._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/this._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    _getPoints(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    _firstWithFlag(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK.prototype._PointInTriangle = function (px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    };
    /*
    _RayLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!this._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    _GetLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(this._InRect(I, a1, a2) && this._InRect(I, b1, b2)) return I;
        return null;
    }

    _InRect(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK.prototype._convex = function (ax, ay, bx, by, cx, cy) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
    };
    return PolyK;
}());
exports.default = new PolyK();

},{}],28:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */
var Vec2 = /** @class */ (function () {
    function Vec2() {
    }
    /**
     * Make a cross product and only return the z component
     * @method crossLength
     * @static
     * @param  {Array} a
     * @param  {Array} b
     * @return {Number}
     */
    Vec2.prototype.crossLength = function (a, b) {
        return a[0] * b[1] - a[1] * b[0];
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossVZ
     * @static
     * @param  {Array} out
     * @param  {Array} vec
     * @param  {Number} zcomp
     * @return {Array}
     */
    Vec2.prototype.crossVZ = function (out, vec, zcomp) {
        this.rotate(out, vec, -Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossZV
     * @static
     * @param  {Array} out
     * @param  {Number} zcomp
     * @param  {Array} vec
     * @return {Array}
     */
    Vec2.prototype.crossZV = function (out, zcomp, vec) {
        this.rotate(out, vec, Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Rotate a vector by an angle
     * @method rotate
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Number} angle
     * @return {Array}
     */
    Vec2.prototype.rotate = function (out, a, angle) {
        if (angle !== 0) {
            var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
            out[0] = c * x - s * y;
            out[1] = s * x + c * y;
        }
        else {
            out[0] = a[0];
            out[1] = a[1];
        }
        return out;
    };
    ;
    /**
     * Rotate a vector 90 degrees clockwise
     * @method rotate90cw
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @return {Array}
     */
    Vec2.prototype.rotate90cw = function (out, a) {
        var x = a[0];
        var y = a[1];
        out[0] = y;
        out[1] = -x;
        return out;
    };
    ;
    /**
     * Transform a point position to local frame.
     * @method toLocalFrame
     * @param  {Array} out
     * @param  {Array} worldPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.toLocalFrame = function (out, worldPoint, framePosition, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldPoint[0] - framePosition[0], y = worldPoint[1] - framePosition[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /**
     * Transform a point position to global frame.
     * @method toGlobalFrame
     * @param  {Array} out
     * @param  {Array} localPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     */
    Vec2.prototype.toGlobalFrame = function (out, localPoint, framePosition, frameAngle) {
        var c = Math.cos(frameAngle), s = Math.sin(frameAngle), x = localPoint[0], y = localPoint[1], addX = framePosition[0], addY = framePosition[1];
        out[0] = c * x - s * y + addX;
        out[1] = s * x + c * y + addY;
    };
    ;
    /**
     * Transform a vector to local frame.
     * @method vectorToLocalFrame
     * @param  {Array} out
     * @param  {Array} worldVector
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.vectorToLocalFrame = function (out, worldVector, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldVector[0], y = worldVector[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /*
     * Transform a vector to global frame.
     * @method vectorToGlobalFrame
     * @param  {Array} out
     * @param  {Array} localVector
     * @param  {Number} frameAngle
     */
    //vectorToGlobalFrame = vec2.rotate;
    /**
     * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
     * @method centroid
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Array} b
     * @param  {Array} c
     * @return  {Array} The "out" vector.
     */
    Vec2.prototype.centroid = function (out, a, b, c) {
        this.add(out, a, b);
        this.add(out, out, c);
        this.scale(out, out, 1 / 3);
        return out;
    };
    ;
    /**
     * Creates a new, empty vec2
     * @static
     * @method create
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.create = function () {
        var out = new Float32Array(2);
        out[0] = 0;
        out[1] = 0;
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with values from an existing vector
     * @static
     * @method clone
     * @param {Array} a vector to clone
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.clone = function (a) {
        var out = new Float32Array(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with the given values
     * @static
     * @method fromValues
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.fromValues = function (x, y) {
        var out = new Float32Array(2);
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Copy the values from one vec2 to another
     * @static
     * @method copy
     * @param {Array} out the receiving vector
     * @param {Array} a the source vector
     * @return {Array} out
     */
    Vec2.prototype.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Set the components of a vec2 to the given values
     * @static
     * @method set
     * @param {Array} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} out
     */
    Vec2.prototype.set = function (out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Adds two vec2's
     * @static
     * @method add
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.add = function (out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
    };
    ;
    /**
     * Subtracts two vec2's
     * @static
     * @method subtract
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.subtract = function (out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
    };
    ;
    /**
     * Multiplies two vec2's
     * @static
     * @method multiply
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.multiply = function (out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
    };
    ;
    /**
     * Divides two vec2's
     * @static
     * @method divide
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.divide = function (out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
    };
    ;
    /**
     * Scales a vec2 by a scalar number
     * @static
     * @method scale
     * @param {Array} out the receiving vector
     * @param {Array} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @return {Array} out
     */
    Vec2.prototype.scale = function (out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
    };
    ;
    /**
     * Calculates the euclidian distance between two vec2's
     * @static
     * @method distance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} distance between a and b
     */
    Vec2.prototype.distance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared euclidian distance between two vec2's
     * @static
     * @method squaredDistance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} squared distance between a and b
     */
    Vec2.prototype.squaredDistance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Calculates the length of a vec2
     * @static
     * @method length
     * @param {Array} a vector to calculate length of
     * @return {Number} length of a
     */
    Vec2.prototype.length = function (a) {
        var x = a[0], y = a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared length of a vec2
     * @static
     * @method squaredLength
     * @param {Array} a vector to calculate squared length of
     * @return {Number} squared length of a
     */
    Vec2.prototype.squaredLength = function (a) {
        var x = a[0], y = a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Negates the components of a vec2
     * @static
     * @method negate
     * @param {Array} out the receiving vector
     * @param {Array} a vector to negate
     * @return {Array} out
     */
    Vec2.prototype.negate = function (out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
    };
    ;
    /**
     * Normalize a vec2
     * @static
     * @method normalize
     * @param {Array} out the receiving vector
     * @param {Array} a vector to normalize
     * @return {Array} out
     */
    Vec2.prototype.normalize = function (out, a) {
        var x = a[0], y = a[1];
        var len = x * x + y * y;
        if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
        }
        return out;
    };
    ;
    /**
     * Calculates the dot product of two vec2's
     * @static
     * @method dot
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} dot product of a and b
     */
    Vec2.prototype.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1];
    };
    ;
    /**
     * Returns a string representation of a vector
     * @static
     * @method str
     * @param {Array} vec vector to represent as a string
     * @return {String} string representation of the vector
     */
    Vec2.prototype.str = function (a) {
        throw "vec2.str is not supported in the typescript version of p2.";
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
    };
    ;
    /**
     * Linearly interpolate/mix two vectors.
     * @static
     * @method lerp
     * @param {Array} out
     * @param {Array} a First vector
     * @param {Array} b Second vector
     * @param {number} t Lerp factor
     * @return {array}
     */
    Vec2.prototype.lerp = function (out, a, b, t) {
        var ax = a[0], ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
    };
    ;
    /**
     * Reflect a vector along a normal.
     * @static
     * @method reflect
     * @param {Array} out
     * @param {Array} vector
     * @param {Array} normal
     */
    Vec2.prototype.reflect = function (out, vector, normal) {
        var dot = vector[0] * normal[0] + vector[1] * normal[1];
        out[0] = vector[0] - 2 * normal[0] * dot;
        out[1] = vector[1] - 2 * normal[1] * dot;
    };
    ;
    /**
     * Get the intersection point between two line segments.
     * @static
     * @method getLineSegmentsIntersection
     * @param  {Array} out
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {boolean} True if there was an intersection, otherwise false.
     */
    Vec2.prototype.getLineSegmentsIntersection = function (out, p0, p1, p2, p3) {
        var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
        if (t < 0) {
            return false;
        }
        else {
            out[0] = p0[0] + (t * (p1[0] - p0[0]));
            out[1] = p0[1] + (t * (p1[1] - p0[1]));
            return true;
        }
    };
    ;
    /**
     * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
     * @static
     * @method getLineSegmentsIntersectionFraction
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
     */
    Vec2.prototype.getLineSegmentsIntersectionFraction = function (p0, p1, p2, p3) {
        var s1_x = p1[0] - p0[0];
        var s1_y = p1[1] - p0[1];
        var s2_x = p3[0] - p2[0];
        var s2_y = p3[1] - p2[1];
        var s, t;
        s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
        t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
            return t;
        }
        return -1; // No collision
    };
    ;
    return Vec2;
}());
var vec2 = new Vec2();
exports.default = vec2;

},{}],29:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var add = vec2_1.default.add, sub = vec2_1.default.subtract, vec2create = vec2_1.default.create;
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var poly_decomp_1 = __importDefault(_dereq_("../math/poly-decomp"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var ray_1 = __importDefault(_dereq_("../collision/ray"));
var raycast_result_1 = __importDefault(_dereq_("../collision/raycast-result"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
//decomp = require('poly-decomp')
var integrate_fhMinv = vec2create();
var integrate_velodt = vec2create();
var _tmp = vec2create();
var _idCounter = 0;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    /**
     * A rigid body. Has got a center of mass, position, velocity and a number of
     * shapes that are used for collisions.
     *
     * @class Body
     * @constructor
     * @extends EventEmitter
     * @param {Object} [options]
     * @param {Boolean} [options.allowSleep=true]
     * @param {Number} [options.angle=0]
     * @param {Number} [options.angularDamping=0.1]
     * @param {Number} [options.angularForce=0]
     * @param {Number} [options.angularVelocity=0]
     * @param {Number} [options.ccdIterations=10]
     * @param {Number} [options.ccdSpeedThreshold=-1]
     * @param {Boolean} [options.collisionResponse]
     * @param {Number} [options.damping=0.1]
     * @param {Boolean} [options.fixedRotation=false]
     * @param {Boolean} [options.fixedX=false]
     * @param {Boolean} [options.fixedY=false]
     * @param {Array} [options.force]
     * @param {Number} [options.gravityScale=1]
     * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
     * @param {Array} [options.position]
     * @param {Number} [options.sleepSpeedLimit]
     * @param {Number} [options.sleepTimeLimit]
     * @param {Number} [options.type] See {{#crossLink "Body/type:property"}}{{/crossLink}}
     * @param {Array} [options.velocity]
     *
     * @example
     *
     *     // Create a typical dynamic body
     *     var body = new Body({
     *         mass: 1, // non-zero mass will set type to Body.DYNAMIC
     *         position: [0, 5],
     *         angle: 0,
     *         velocity: [0, 0],
     *         angularVelocity: 0
     *     });
     *
     *     // Add a circular shape to the body
     *     var circleShape = new Circle({ radius: 0.5 });
     *     body.addShape(circleShape);
     *
     *     // Add the body to the world
     *     world.addBody(body);
     *
     * @example
     *
     *     // Create a static plane body
     *     var planeBody = new Body({
     *         mass: 0, // zero mass will set type to Body.STATIC
     *         position: [0, 0]
     *     });
     *     var planeShape = new Plane();
     *     planeBody.addShape(planeShape);
     *     world.addBody(planeBody);
     *
     * @example
     *
     *     // Create a moving kinematic box body
     *     var platformBody = new Body({
     *         type: Body.KINEMATIC,
     *         position: [0, 3],
     *         velocity: [1, 0]
     *     });
     *     var boxShape = new Box({ width: 2, height: 0.5 });
     *     platformBody.addShape(boxShape);
     *     world.addBody(platformBody);
     */
    function Body(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        var _this = _super.call(this) || this;
        /**
         * The body identifier. Read only!
         * @readonly
         * @property id
         * @type {Number}
        */
        _this.id = -1;
        /**
         * Index of the body in the World .bodies array. Is set to -1 if the body isn't added to a World.
         * @readonly
         * @property index
         * @type {Number}
         */
        _this.index = 0;
        /**
         * The world that this body is added to (read only). This property is set to NULL if the body is not added to any world.
         * @readonly
         * @property world
         * @type {World}
         */
        _this.world = null;
        /**
         * The shapes of the body.
         *
         * @property shapes
         * @type {Array}
         */
        _this.shapes = [];
        /**
         * The mass of the body. If you change this number, you should call {{#crossLink "Body/updateMassProperties:method"}}{{/crossLink}}.
         *
         * @property mass
         * @type {number}
         *
         * @example
         *     body.mass = 1;
         *     body.updateMassProperties();
         */
        _this.mass = 0;
        /**
         * The inverse mass of the body.
         *
         * @readonly
         * @property invMass
         * @type {number}
         */
        _this.invMass = 0;
        /**
         * The inertia of the body around the Z axis.
         * @readonly
         * @property inertia
         * @type {number}
         */
        _this.inertia = 0;
        /**
         * The inverse inertia of the body.
         * @readonly
         * @property invInertia
         * @type {number}
         */
        _this.invInertia = 0;
        _this.invMassSolve = 0;
        _this.invInertiaSolve = 0;
        /**
         * Set to true if you want to fix the rotation of the body.
         *
         * @property fixedRotation
         * @type {Boolean}
         *
         * @example
         *     // Fix rotation during runtime
         *     body.fixedRotation = true;
         *     body.updateMassProperties();
         */
        _this.fixedRotation = true;
        /**
         * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
         * @property {Boolean} fixedX
         *
         * @example
         *     // Fix X movement on body creation
         *     var body = new Body({ mass: 1, fixedX: true });
         *
         * @example
         *     // Fix X movement during runtime
         *     body.fixedX = true;
         *     body.updateMassProperties();
         */
        _this.fixedX = false;
        /**
         * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X. See .fixedX
         * @property {Boolean} fixedY
         */
        _this.fixedY = false;
        /**
         * Angular constraint velocity that was added to the body during last step.
         * @readonly
         * @property wlambda
         * @type {Array} // This was array before the port, but hte assignment was always 0.
         */
        _this.wlambda = 0;
        /**
         * The angle of the body, in radians.
         * @property angle
         * @type {number}
         * @example
         *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
         *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
         *     function normalizeAngle(angle){
         *         angle = angle % (2*Math.PI);
         *         if(angle < 0){
         *             angle += (2*Math.PI);
         *         }
         *         return angle;
         *     }
         */
        _this.angle = 0;
        /**
         * The previous angle of the body.
         * @readonly
         * @property previousAngle
         * @type {Number}
         */
        _this.previousAngle = 0;
        /**
         * The interpolated angle of the body. Use this for rendering.
         * @readonly
         * @property interpolatedAngle
         * @type {Number}
         */
        _this.interpolatedAngle = 0;
        /**
         * The angular velocity of the body, in radians per second.
         * @property angularVelocity
         * @type {number}
         */
        _this.angularVelocity = 0;
        /**
         * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
         * @property angularForce
         * @type {number}
         */
        _this.angularForce = 0;
        /**
         * The angular force acting on the body. Should be a value between 0 and 1.
         * @property angularDamping
         * @type {Number}
         * @default 0.1
         */
        _this.angularDamping = 0.1;
        /**
         * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
         *
         * * Static bodies do not move, and they do not respond to forces or collision.
         * * Dynamic bodies body can move and respond to collisions and forces.
         * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
         *
         * @property type
         * @type {number}
         *
         * @example
         *     // Bodies are static by default. Static bodies will never move.
         *     var body = new Body();
         *     console.log(body.type == Body.STATIC); // true
         *
         * @example
         *     // By setting the mass of a body to a nonzero number, the body
         *     // will become dynamic and will move and interact with other bodies.
         *     var dynamicBody = new Body({
         *         mass : 1
         *     });
         *     console.log(dynamicBody.type == Body.DYNAMIC); // true
         *
         * @example
         *     // Kinematic bodies will only move if you change their velocity.
         *     var kinematicBody = new Body({
         *         type: Body.KINEMATIC // Type can be set via the options object.
         *     });
         */
        _this.type = Body.STATIC;
        /**
         * Bounding circle radius. Update with {{#crossLink "Body/updateBoundingRadius:method"}}{{/crossLink}}.
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        /**
         * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}{{/crossLink}}.
         * @property aabbNeedsUpdate
         * @type {Boolean}
         * @see updateAABB
         *
         * @example
         *     // Force update the AABB
         *     body.aabbNeedsUpdate = true;
         *     body.updateAABB();
         *     console.log(body.aabbNeedsUpdate); // false
         */
        _this.aabbNeedsUpdate = true;
        /**
         * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
         * @property allowSleep
         * @type {Boolean}
         * @default true
         */
        _this.allowSleep = true;
        _this.wantsToSleep = false;
        /**
         * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
         *
         * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
         *
         * @property sleepState
         * @type {Number}
         * @default Body.AWAKE
         */
        _this.sleepState = Body.AWAKE;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @property sleepSpeedLimit
         * @type {Number}
         * @default 0.2
         */
        _this.sleepSpeedLimit = 0.2;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @property sleepTimeLimit
         * @type {Number}
         * @default 1
         */
        _this.sleepTimeLimit = 1;
        /**
         * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
         * @property {Number} gravityScale
         * @default 1
         */
        _this.gravityScale = 1;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
         * @property {Boolean} collisionResponse
         */
        _this.collisionResponse = true;
        /**
         * How long the body has been sleeping.
         * @readonly
         * @property {Number} idleTime
         */
        _this.idleTime = 0;
        /**
         * The last time when the body went to SLEEPY state.
         * @readonly
         * @property {Number} timeLastSleepy
         * @private
         */
        _this.timeLastSleepy = 0;
        /**
         * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
         * @property {number} ccdSpeedThreshold
         * @default -1
         */
        _this.ccdSpeedThreshold = -1;
        /**
         * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
         * @property {number} ccdIterations
         * @default 10
         */
        _this.ccdIterations = 10;
        /**
         * @property {number} islandId
         */
        _this.islandId = -1;
        _this.concavePath = [];
        // Should be private, but used by world.
        _this._wakeUpAfterNarrowphase = false;
        _this._shapeAABB = new aabb_1.default();
        _this.id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : ++_idCounter;
        _this.mass = (_b = options === null || options === void 0 ? void 0 : options.mass) !== null && _b !== void 0 ? _b : 0;
        _this.fixedRotation = (_c = options === null || options === void 0 ? void 0 : options.fixedRotation) !== null && _c !== void 0 ? _c : false;
        _this.fixedX = (_d = options === null || options === void 0 ? void 0 : options.fixedX) !== null && _d !== void 0 ? _d : false;
        _this.fixedY = (_e = options === null || options === void 0 ? void 0 : options.fixedY) !== null && _e !== void 0 ? _e : false;
        _this.massMultiplier = vec2create();
        _this.position = (options === null || options === void 0 ? void 0 : options.position) ? vec2_1.default.clone(options.position) : vec2create();
        _this.interpolatedPosition = vec2_1.default.clone(_this.position);
        _this.previousPosition = vec2_1.default.clone(_this.position);
        _this.velocity = (options === null || options === void 0 ? void 0 : options.velocity) ? vec2_1.default.clone(options.velocity) : vec2create();
        _this.vlambda = vec2create();
        _this.angle = (_f = options === null || options === void 0 ? void 0 : options.angle) !== null && _f !== void 0 ? _f : 0;
        _this.previousAngle = _this.angle;
        _this.interpolatedAngle = _this.angle;
        _this.angularVelocity = (_g = options === null || options === void 0 ? void 0 : options.angularVelocity) !== null && _g !== void 0 ? _g : 0;
        _this.force = (options === null || options === void 0 ? void 0 : options.force) ? vec2_1.default.clone(options.force) : vec2create();
        _this.angularForce = (_h = options === null || options === void 0 ? void 0 : options.angularForce) !== null && _h !== void 0 ? _h : 0;
        _this.damping = (_j = options === null || options === void 0 ? void 0 : options.damping) !== null && _j !== void 0 ? _j : 0.1;
        _this.angularDamping = (_k = options === null || options === void 0 ? void 0 : options.angularDamping) !== null && _k !== void 0 ? _k : 0.1;
        _this.sleepTimeLimit = (_l = options === null || options === void 0 ? void 0 : options.sleepTimeLimit) !== null && _l !== void 0 ? _l : 1;
        if ((options === null || options === void 0 ? void 0 : options.type) !== undefined) {
            _this.type = options.type;
        }
        else if (!(options === null || options === void 0 ? void 0 : options.mass)) {
            _this.type = Body.STATIC;
        }
        else {
            _this.type = Body.DYNAMIC;
        }
        _this.aabb = new aabb_1.default();
        _this.allowSleep = (_m = options === null || options === void 0 ? void 0 : options.allowSleep) !== null && _m !== void 0 ? _m : true;
        _this.sleepSpeedLimit = (_o = options === null || options === void 0 ? void 0 : options.sleepSpeedLimit) !== null && _o !== void 0 ? _o : 0.2;
        _this.gravityScale = (_p = options === null || options === void 0 ? void 0 : options.gravityScale) !== null && _p !== void 0 ? _p : 1;
        _this.collisionResponse = (_q = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _q !== void 0 ? _q : true;
        _this.ccdSpeedThreshold = (_r = options === null || options === void 0 ? void 0 : options.ccdSpeedThreshold) !== null && _r !== void 0 ? _r : -1;
        _this.ccdIterations = (_s = options === null || options === void 0 ? void 0 : options.ccdIterations) !== null && _s !== void 0 ? _s : 10;
        _this.updateMassProperties();
        return _this;
    }
    /**
     * @private
     * @method updateSolveMassProperties
     */
    Body.prototype.updateSolveMassProperties = function () {
        if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
            this.invMassSolve = 0;
            this.invInertiaSolve = 0;
        }
        else {
            this.invMassSolve = this.invMass;
            this.invInertiaSolve = this.invInertia;
        }
    };
    ;
    /**
     * Set the total density of the body
     * @method setDensity
     * @param {number} density
     */
    Body.prototype.setDensity = function (density) {
        var totalArea = this.getArea();
        this.mass = totalArea * density;
        this.updateMassProperties();
    };
    ;
    /**
     * Get the total area of all shapes in the body
     * @method getArea
     * @return {Number}
     */
    Body.prototype.getArea = function () {
        var totalArea = 0;
        for (var i = 0; i < this.shapes.length; i++) {
            totalArea += this.shapes[i].area;
        }
        return totalArea;
    };
    ;
    /**
     * Get the AABB from the body. The AABB is updated if necessary.
     * @method getAABB
     * @return {AABB} The AABB instance from the body.
     */
    Body.prototype.getAABB = function () {
        if (this.aabbNeedsUpdate) {
            this.updateAABB();
        }
        return this.aabb;
    };
    ;
    /**
     * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
     * @method updateAABB
     */
    Body.prototype.updateAABB = function () {
        var shapes = this.shapes, N = shapes.length, offset = _tmp, bodyAngle = this.angle;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], angle = shape.angle + bodyAngle;
            // Get shape world offset
            vec2_1.default.rotate(offset, shape.position, bodyAngle);
            vec2_1.default.add(offset, offset, this.position);
            // Get shape AABB
            shape.computeAABB(this._shapeAABB, offset, angle);
            if (i === 0) {
                this.aabb.copy(this._shapeAABB);
            }
            else {
                this.aabb.extend(this._shapeAABB);
            }
        }
        this.aabbNeedsUpdate = false;
    };
    ;
    /**
     * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
     * @method updateBoundingRadius
     */
    Body.prototype.updateBoundingRadius = function () {
        var shapes = this.shapes, N = shapes.length, radius = 0;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], offset = vec2_1.default.length(shape.position), r = shape.boundingRadius;
            if (offset + r > radius) {
                radius = offset + r;
            }
        }
        this.boundingRadius = radius;
    };
    ;
    /**
     * Add a shape to the body. You can pass a local transform when adding a shape,
     * so that the shape gets an offset and angle relative to the body center of mass.
     * Will automatically update the mass properties and bounding radius.
     *
     * @method addShape
     * @param  {Shape}              shape
     * @param  {Array} [offset] Local body offset of the shape.
     * @param  {Number}             [angle]  Local body angle.
     *
     * @example
     *     var body = new Body(),
     *         shape = new Circle({ radius: 1 });
     *
     *     // Add the shape to the body, positioned in the center
     *     body.addShape(shape);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
     *     body.addShape(shape,[1,0]);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
     *     body.addShape(shape,[0,1],Math.PI/2);
     */
    Body.prototype.addShape = function (shape, offset, angle) {
        if (angle === void 0) { angle = 0; }
        if (shape.body) {
            throw new Error('A shape can only be added to one body.');
        }
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be added during step.');
        }
        shape.body = this;
        // Copy the offset vector
        if (offset) {
            vec2_1.default.copy(shape.position, offset);
        }
        else {
            vec2_1.default.set(shape.position, 0, 0);
        }
        shape.angle = angle || 0;
        this.shapes.push(shape);
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.aabbNeedsUpdate = true;
    };
    ;
    /**
     * Remove a shape.
     * @method removeShape
     * @param  {Shape} shape
     * @return {Boolean} True if the shape was found and removed, else false.
     */
    Body.prototype.removeShape = function (shape) {
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be removed during step.');
        }
        var idx = this.shapes.indexOf(shape);
        if (idx !== -1) {
            this.shapes.splice(idx, 1);
            this.aabbNeedsUpdate = true;
            shape.body = undefined;
            return true;
        }
        else {
            return false;
        }
    };
    ;
    /**
     * Updates .inertia, .invMass, .invInertia for this Body. Should be called when changing the structure or mass of the Body.
     *
     * @method updateMassProperties
     *
     * @example
     *     body.mass += 1;
     *     body.updateMassProperties();
     */
    Body.prototype.updateMassProperties = function () {
        if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
            // Consider making it infinity.
            this.mass = Infinity;
            this.invMass = 0;
            this.inertia = Infinity;
            this.invInertia = 0;
        }
        else {
            var shapes = this.shapes, N = shapes.length, I = 0;
            if (!this.fixedRotation) {
                for (var i = 0; i < N; i++) {
                    var shape = shapes[i], r2 = vec2_1.default.squaredLength(shape.position), Icm = shape.computeMomentOfInertia();
                    I += Icm + r2;
                }
                this.inertia = this.mass * I;
                this.invInertia = I > 0 ? 1 / I : 0;
            }
            else {
                this.inertia = Infinity;
                this.invInertia = 0;
            }
            // Inverse mass properties are easy
            this.invMass = 1 / this.mass;
            vec2_1.default.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForce
     * @param  {Array} force The force vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [1, 0]; // Will apply the force at [body.position[0] + 1, body.position[1]]
     *     var force = [0, 1]; // up
     *     body.applyForce(force, relativePoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForce = function (force, relativePoint) {
        // Add linear force
        add(this.force, this.force, force);
        if (relativePoint) {
            // Compute produced rotational force
            var rotForce = vec2_1.default.crossLength(relativePoint, force);
            // Add rotational force
            this.angularForce += rotForce;
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForceLocal
     * @param  {Array} localForce The force vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1 locally in the body
     *     var localForce = [0, 1]; // up, locally in the body
     *     body.applyForceLocal(localForce, localPoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForceLocal = function (localForce, localPoint) {
        // These 3 lines were originally outside of this function. Not sure why.
        var Body_applyForce_forceWorld = vec2create();
        var Body_applyForce_pointWorld = vec2create();
        var Body_applyForce_pointLocal = vec2create();
        localPoint = localPoint || Body_applyForce_pointLocal;
        var worldForce = Body_applyForce_forceWorld;
        var worldPoint = Body_applyForce_pointWorld;
        this.vectorToWorldFrame(worldForce, localForce);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyForce(worldForce, worldPoint);
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulse
     * @param  {Array} impulseVector The impulse vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [0, 0]; // center of the body
     *     var impulseVector = [0, 1]; // world up
     *     body.applyImpulse(impulseVector, relativePoint);
     */
    Body.prototype.applyImpulse = function (impulseVector, relativePoint) {
        var Body_applyImpulse_velo = vec2create(); // Was originally outside of this function. 
        if (this.type !== Body.DYNAMIC) {
            return;
        }
        // Compute produced central impulse velocity
        var velo = Body_applyImpulse_velo;
        vec2_1.default.scale(velo, impulseVector, this.invMass);
        vec2_1.default.multiply(velo, this.massMultiplier, velo);
        // Add linear impulse
        add(this.velocity, velo, this.velocity);
        if (relativePoint) {
            // Compute produced rotational impulse velocity
            var rotVelo = vec2_1.default.crossLength(relativePoint, impulseVector);
            rotVelo *= this.invInertia;
            // Add rotational Impulse
            this.angularVelocity += rotVelo;
        }
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulseLocal
     * @param  {Array} localImpulse The impulse vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1, locally in the body
     *     var localImpulse = [0, 1]; // up, locally in the body
     *     body.applyImpulseLocal(localImpulse, localPoint);
     *     console.log(body.velocity); // [1, 0]
     *     console.log(body.angularVelocity); // 1
     */
    Body.prototype.applyImpulseLocal = function (localImpulse, localPoint) {
        // Originally outside of this function.
        var Body_applyImpulse_impulseWorld = vec2create();
        var Body_applyImpulse_pointWorld = vec2create();
        var Body_applyImpulse_pointLocal = vec2create();
        localPoint = localPoint || Body_applyImpulse_pointLocal;
        var worldImpulse = Body_applyImpulse_impulseWorld;
        var worldPoint = Body_applyImpulse_pointWorld;
        this.vectorToWorldFrame(worldImpulse, localImpulse);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyImpulse(worldImpulse, worldPoint);
    };
    ;
    /**
     * Transform a world point to local body frame.
     * @method toLocalFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} worldPoint   The input world point
     */
    Body.prototype.toLocalFrame = function (out, worldPoint) {
        vec2_1.default.toLocalFrame(out, worldPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a local point to world frame.
     * @method toWorldFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} localPoint   The input local point
     */
    Body.prototype.toWorldFrame = function (out, localPoint) {
        vec2_1.default.toGlobalFrame(out, localPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a world vector to local body frame.
     * @method vectorToLocalFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} worldVector  The input world vector
     */
    Body.prototype.vectorToLocalFrame = function (out, worldVector) {
        vec2_1.default.vectorToLocalFrame(out, worldVector, this.angle);
    };
    ;
    /**
     * Transform a local vector to world frame.
     * @method vectorToWorldFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} localVector  The input local vector
     */
    Body.prototype.vectorToWorldFrame = function (out, localVector) {
        vec2_1.default.rotate(out, localVector, this.angle);
    };
    ;
    /**
     * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
     * @method fromPolygon
     * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
     * @param {Object} [options]
     * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
     * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
     * @param {Number} [options.removeCollinearPoints=0] Set to a number (angle threshold value) to remove collinear points, or 0 to keep all points.
     * @return {Boolean} True on success, else false.
     * @example
     *     var body = new Body();
     *     var path = [
     *         [-1, 1],
     *         [-1, 0],
     *         [1, 0],
     *         [1, 1],
     *         [0.5, 0.5]
     *     ];
     *     body.fromPolygon(path);
     *     console.log(body.shapes); // [Convex, Convex, ...]
     */
    Body.prototype.fromPolygon = function (path, options) {
        var _a, _b, _c;
        // Remove all shapes
        for (var i = this.shapes.length; i >= 0; --i) {
            this.removeShape(this.shapes[i]);
        }
        // Copy the path
        var p = [];
        for (var i = 0; i < path.length; i++) {
            p[i] = vec2_1.default.clone(path[i]);
        }
        // Make it counter-clockwise
        poly_decomp_1.default.makeCCW(p);
        if ((options === null || options === void 0 ? void 0 : options.removeCollinearPoints) != 0) {
            poly_decomp_1.default.removeCollinearPoints(p, (_a = options === null || options === void 0 ? void 0 : options.removeCollinearPoints) !== null && _a !== void 0 ? _a : 0);
        }
        // Check if any line segment intersects the path itself
        if (!(options === null || options === void 0 ? void 0 : options.skipSimpleCheck)) {
            if (!poly_decomp_1.default.isSimple(p)) {
                return false;
            }
        }
        // Save this path for later
        this.concavePath = [];
        for (var i = 0; i < p.length; i++) {
            this.concavePath[i] = vec2_1.default.clone(p[i]);
        }
        // Slow or fast decomp?
        var convexes;
        if (options === null || options === void 0 ? void 0 : options.optimalDecomp) {
            convexes = (_b = poly_decomp_1.default.decomp(p)) !== null && _b !== void 0 ? _b : new Array();
        }
        else {
            convexes = (_c = poly_decomp_1.default.quickDecomp(p)) !== null && _c !== void 0 ? _c : new Array();
        }
        var cm = vec2create();
        // Add convexes
        for (var i = 0; i !== convexes.length; i++) {
            // Create convex
            var c = new Convex_1.default(undefined, convexes[i]);
            // Move all vertices so its center of mass is in the local center of the convex
            for (var j = 0; j !== c.vertices.length; j++) {
                var v = c.vertices[j];
                sub(v, v, c.centerOfMass);
            }
            vec2_1.default.copy(cm, c.centerOfMass);
            c = new Convex_1.default(undefined, c.vertices);
            // Add the shape
            this.addShape(c, cm);
        }
        this.adjustCenterOfMass();
        this.aabbNeedsUpdate = true;
        return true;
    };
    /**
     * Moves the shape offsets so their center of mass becomes the body center of mass.
     * @method adjustCenterOfMass
     * @example
     *     var body = new Body({ position: [0, 0] });
     *     var shape = new Circle({ radius: 1 });
     *     body.addShape(shape, [1, 0], 0);
     *     body.adjustCenterOfMass();
     *     console.log(body.position); // [1, 0]
     *     console.log(shape.position); // [0, 0]
     */
    Body.prototype.adjustCenterOfMass = function () {
        var adjustCenterOfMass_tmp2 = vec2create(), adjustCenterOfMass_tmp3 = vec2create(), adjustCenterOfMass_tmp4 = vec2create();
        var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
        vec2_1.default.set(sum, 0, 0);
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            vec2_1.default.scale(offset_times_area, s.position, s.area);
            add(sum, sum, offset_times_area);
            totalArea += s.area;
        }
        vec2_1.default.scale(cm, sum, 1 / totalArea);
        // Now move all shapes
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            sub(s.position, s.position, cm);
        }
        // Move the body position too
        add(this.position, this.position, cm);
        // And concave path
        for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
            sub(this.concavePath[i], this.concavePath[i], cm);
        }
        this.updateMassProperties();
        this.updateBoundingRadius();
    };
    /**
     * Sets the force on the body to zero.
     * @method setZeroForce
     */
    Body.prototype.setZeroForce = function () {
        var f = this.force;
        f[0] = f[1] = this.angularForce = 0;
    };
    Body.prototype.resetConstraintVelocity = function () {
        var b = this, vlambda = b.vlambda;
        vec2_1.default.set(vlambda, 0, 0);
        b.wlambda = 0;
    };
    Body.prototype.addConstraintVelocity = function () {
        var b = this, v = b.velocity;
        add(v, v, b.vlambda);
        b.angularVelocity += b.wlambda;
    };
    /**
     * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
     * @method applyDamping
     * @param  {number} dt Current time step
     */
    Body.prototype.applyDamping = function (dt) {
        if (this.type === Body.DYNAMIC) { // Only for dynamic bodies
            var v = this.velocity;
            vec2_1.default.scale(v, v, Math.pow(1 - this.damping, dt));
            this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
        }
    };
    /**
     * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
     * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
     * @method wakeUp
     */
    Body.prototype.wakeUp = function () {
        var s = this.sleepState;
        this.sleepState = Body.AWAKE;
        this.idleTime = 0;
        if (s !== Body.AWAKE) {
            _super.prototype.emit.call(this, wakeUpEvent);
        }
    };
    /**
     * Force body sleep
     * @method sleep
     */
    Body.prototype.sleep = function () {
        this.sleepState = Body.SLEEPING;
        this.angularVelocity = this.angularForce = 0;
        vec2_1.default.set(this.velocity, 0, 0);
        vec2_1.default.set(this.force, 0, 0);
        _super.prototype.emit.call(this, sleepEvent);
    };
    /**
     * Called every timestep to update internal sleep timer and change sleep state if needed.
     * @method sleepTick
     * @param {number} time The world time in seconds
     * @param {boolean} dontSleep
     * @param {number} dt
     */
    Body.prototype.sleepTick = function (time, dontSleep, dt) {
        if (!this.allowSleep || this.type === Body.SLEEPING) {
            return;
        }
        this.wantsToSleep = false;
        var speedSquared = vec2_1.default.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
        // Add to idle time
        if (speedSquared >= speedLimitSquared) {
            this.idleTime = 0;
            this.sleepState = Body.AWAKE;
        }
        else {
            this.idleTime += dt;
            if (this.sleepState !== Body.SLEEPY) {
                this.sleepState = Body.SLEEPY;
                _super.prototype.emit.call(this, sleepyEvent);
            }
        }
        if (this.idleTime > this.sleepTimeLimit) {
            if (!dontSleep) {
                this.sleep();
            }
            else {
                this.wantsToSleep = true;
            }
        }
    };
    /**
     * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
     * @method overlaps
     * @param  {Body} body
     * @return {boolean}
     */
    Body.prototype.overlaps = function (body) {
        if (!this.world)
            return false;
        return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
    };
    /**
     * Move the body forward in time given its current velocity.
     * @method integrate
     * @param  {Number} dt
     */
    Body.prototype.integrate = function (dt) {
        var minv = this.invMass, f = this.force, pos = this.position, velo = this.velocity;
        // Save old position
        vec2_1.default.copy(this.previousPosition, this.position);
        this.previousAngle = this.angle;
        // Velocity update
        if (!this.fixedRotation) {
            this.angularVelocity += this.angularForce * this.invInertia * dt;
        }
        vec2_1.default.scale(integrate_fhMinv, f, dt * minv);
        vec2_1.default.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
        add(velo, integrate_fhMinv, velo);
        // CCD
        if (!this.integrateToTimeOfImpact(dt)) {
            // Regular position update
            vec2_1.default.scale(integrate_velodt, velo, dt);
            add(pos, pos, integrate_velodt);
            if (!this.fixedRotation) {
                this.angle += this.angularVelocity * dt;
            }
        }
        this.aabbNeedsUpdate = true;
    };
    Body.prototype.integrateToTimeOfImpact = function (dt) {
        var _a;
        if (!this.world)
            return false;
        var result = new raycast_result_1.default();
        var ray = new ray_1.default({
            mode: ray_1.default.CLOSEST,
            skipBackfaces: true
        });
        var direction = vec2create();
        var end = vec2create();
        var startToEnd = vec2create();
        var rememberPosition = vec2create();
        if (this.ccdSpeedThreshold < 0 || vec2_1.default.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
            return false;
        }
        // Ignore all the ignored body pairs
        // This should probably be done somewhere else for optimization
        var ignoreBodies = [];
        var disabledPairs = this.world.disabledBodyCollisionPairs;
        for (var i = 0; i < disabledPairs.length; i += 2) {
            var bodyA = disabledPairs[i];
            var bodyB = disabledPairs[i + 1];
            if (bodyA === this) {
                ignoreBodies.push(bodyB);
            }
            else if (bodyB === this) {
                ignoreBodies.push(bodyA);
            }
        }
        vec2_1.default.normalize(direction, this.velocity);
        vec2_1.default.scale(end, this.velocity, dt);
        add(end, end, this.position);
        sub(startToEnd, end, this.position);
        var startToEndAngle = this.angularVelocity * dt;
        var len = vec2_1.default.length(startToEnd);
        var timeOfImpact = 1;
        var hitBody = null;
        vec2_1.default.copy(ray.from, this.position);
        vec2_1.default.copy(ray.to, end);
        ray.update();
        for (var i = 0; i < this.shapes.length; i++) {
            var shape = this.shapes[i];
            result.reset();
            ray.collisionGroup = shape.collisionGroup;
            ray.collisionMask = shape.collisionMask;
            this.world.raycast(result, ray);
            hitBody = (_a = result.body) !== null && _a !== void 0 ? _a : null;
            if (!hitBody)
                continue;
            if (hitBody === this || ignoreBodies.indexOf(hitBody) !== -1) {
                hitBody = null;
            }
            if (hitBody) {
                break;
            }
        }
        if (!hitBody || !timeOfImpact) {
            return false;
        }
        result.getHitPoint(end, ray);
        sub(startToEnd, end, this.position);
        timeOfImpact = vec2_1.default.distance(end, this.position) / len; // guess
        var rememberAngle = this.angle;
        vec2_1.default.copy(rememberPosition, this.position);
        // Got a start and end point. Approximate time of impact using binary search
        var iter = 0;
        var tmin = 0;
        var tmid = timeOfImpact;
        var tmax = 1;
        while (tmax >= tmin && iter < this.ccdIterations) {
            iter++;
            // calculate the midpoint
            tmid = (tmax + tmin) / 2;
            // Move the body to that point
            vec2_1.default.scale(integrate_velodt, startToEnd, tmid);
            add(this.position, rememberPosition, integrate_velodt);
            this.angle = rememberAngle + startToEndAngle * tmid;
            this.updateAABB();
            // check overlap
            var overlaps = this.aabb.overlaps(hitBody.aabb) && this.world.narrowphase.bodiesOverlap(this, hitBody, true);
            if (overlaps) {
                // change max to search lower interval
                tmax = tmid;
            }
            else {
                // change min to search upper interval
                tmin = tmid;
            }
        }
        timeOfImpact = tmax; // Need to guarantee overlap to resolve collisions
        vec2_1.default.copy(this.position, rememberPosition);
        this.angle = rememberAngle;
        // move to TOI
        vec2_1.default.scale(integrate_velodt, startToEnd, timeOfImpact);
        add(this.position, this.position, integrate_velodt);
        if (!this.fixedRotation) {
            this.angle += startToEndAngle * timeOfImpact;
        }
        return true;
    };
    /**
     * Get velocity of a point in the body.
     * @method getVelocityAtPoint
     * @param  {Array} result A vector to store the result in
     * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
     * @return {Array} The result vector
     * @example
     *     var body = new Body({
     *         mass: 1,
     *         velocity: [1, 0],
     *         angularVelocity: 1
     *     });
     *     var result = [];
     *     var point = [1, 0];
     *     body.getVelocityAtPoint(result, point);
     *     console.log(result); // [1, 1]
     */
    Body.prototype.getVelocityAtPoint = function (result, relativePoint) {
        vec2_1.default.crossVZ(result, relativePoint, this.angularVelocity);
        vec2_1.default.subtract(result, this.velocity, result);
        return result;
    };
    /**
     * Dynamic body.
     * @property DYNAMIC
     * @type {Number}
     * @static
     */
    Body.DYNAMIC = 1;
    /**
     * Static body.
     * @property STATIC
     * @type {Number}
     * @static
     */
    Body.STATIC = 2;
    /**
     * Kinematic body.
     * @property KINEMATIC
     * @type {Number}
     * @static
     */
    Body.KINEMATIC = 4;
    /**
     * @property AWAKE
     * @type {Number}
     * @static
     */
    Body.AWAKE = 0;
    /**
     * @property SLEEPY
     * @type {Number}
     * @static
     */
    Body.SLEEPY = 1;
    /**
     * @property SLEEPING
     * @type {Number}
     * @static
     */
    Body.SLEEPING = 2;
    return Body;
}(event_emitter_1.default));
exports.default = Body;
/**
 * @event sleepy
 */
var sleepyEvent = {
    type: "sleepy"
};
/**
 * @event sleep
 */
var sleepEvent = {
    type: "sleep"
};
/**
 * @event wakeup
 */
var wakeUpEvent = {
    type: "wakeup"
};

},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],30:[function(_dereq_,module,exports){
module.exports=_dereq_(29)
},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],31:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var spring_1 = __importDefault(_dereq_("./spring"));
var applyForce_r = vec2_1.default.create(), applyForce_r_unit = vec2_1.default.create(), applyForce_u = vec2_1.default.create(), applyForce_f = vec2_1.default.create(), applyForce_worldAnchorA = vec2_1.default.create(), applyForce_worldAnchorB = vec2_1.default.create(), applyForce_ri = vec2_1.default.create(), applyForce_rj = vec2_1.default.create(), applyForce_tmp = vec2_1.default.create();
var LinearSpring = /** @class */ (function (_super) {
    __extends(LinearSpring, _super);
    /**
     * A spring, connecting two bodies.
     *
     * The Spring explicitly adds force and angularForce to the bodies.
     *
     * @class LinearSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     *
     * @example
     *     var spring = new LinearSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1,
     *         localAnchorA: [0,0], // center of bodyA
     *         localAnchorB: [0,0] // center of bodyB
     *     });
     *     world.addSpring(spring);
     */
    function LinearSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        _this.localAnchorA = vec2_1.default.create();
        _this.localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(_this.localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(_this.localAnchorB, options.localAnchorB);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorA) {
            _this.setWorldAnchorA(options.worldAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorB) {
            _this.setWorldAnchorB(options.worldAnchorB);
        }
        var worldAnchorA = vec2_1.default.create();
        var worldAnchorB = vec2_1.default.create();
        _this.getWorldAnchorA(worldAnchorA);
        _this.getWorldAnchorB(worldAnchorB);
        var worldDistance = vec2_1.default.distance(worldAnchorA, worldAnchorB);
        _this.restLength = (_a = options === null || options === void 0 ? void 0 : options.restLength) !== null && _a !== void 0 ? _a : worldDistance;
        return _this;
    }
    /**
     * Set the anchor point on body A, using world coordinates.
     * @method setWorldAnchorA
     * @param {Array} worldAnchorA
     */
    LinearSpring.prototype.setWorldAnchorA = function (worldAnchorA) {
        this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
    };
    /**
     * Set the anchor point on body B, using world coordinates.
     * @method setWorldAnchorB
     * @param {Array} worldAnchorB
     */
    LinearSpring.prototype.setWorldAnchorB = function (worldAnchorB) {
        this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
    };
    /**
     * Get the anchor point on body A, in world coordinates.
     * @method getWorldAnchorA
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorA = function (result) {
        this.bodyA.toWorldFrame(result, this.localAnchorA);
    };
    /**
     * Get the anchor point on body B, in world coordinates.
     * @method getWorldAnchorB
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorB = function (result) {
        this.bodyB.toWorldFrame(result, this.localAnchorB);
    };
    /**
     * Apply the spring force to the connected bodies.
     * @private
     * @method applyForce
     */
    LinearSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
        var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
        // Get world anchors
        this.getWorldAnchorA(worldAnchorA);
        this.getWorldAnchorB(worldAnchorB);
        // Get offset points
        vec2_1.default.subtract(ri, worldAnchorA, bodyA.position);
        vec2_1.default.subtract(rj, worldAnchorB, bodyB.position);
        // Compute distance vector between world anchor points
        vec2_1.default.subtract(r, worldAnchorB, worldAnchorA);
        var rlen = vec2_1.default.length(r);
        vec2_1.default.normalize(r_unit, r);
        // Compute relative velocity of the anchor points, u
        vec2_1.default.subtract(u, bodyB.velocity, bodyA.velocity);
        vec2_1.default.crossZV(tmp, bodyB.angularVelocity, rj);
        vec2_1.default.add(u, u, tmp);
        vec2_1.default.crossZV(tmp, bodyA.angularVelocity, ri);
        vec2_1.default.subtract(u, u, tmp);
        // F = - k * ( x - L ) - D * ( u )
        vec2_1.default.scale(f, r_unit, -k * (rlen - l) - d * vec2_1.default.dot(u, r_unit));
        // Add forces to bodies
        vec2_1.default.subtract(bodyA.force, bodyA.force, f);
        vec2_1.default.add(bodyB.force, bodyB.force, f);
        // Angular force
        var ri_x_f = vec2_1.default.crossLength(ri, f);
        var rj_x_f = vec2_1.default.crossLength(rj, f);
        bodyA.angularForce -= ri_x_f;
        bodyB.angularForce += rj_x_f;
    };
    return LinearSpring;
}(spring_1.default));
exports.default = LinearSpring;

},{"../math/vec2":28,"./spring":33}],32:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var spring_1 = __importDefault(_dereq_("./spring"));
var RotationalSpring = /** @class */ (function (_super) {
    __extends(RotationalSpring, _super);
    /**
     * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
     *
     * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
     *
     * @class RotationalSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
     * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1] A number >= 0.
     *
     * @example
     *     var spring = new RotationalSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1
     *     });
     *     world.addSpring(spring);
     */
    function RotationalSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        /**
         * Rest angle of the spring.
         * @property restAngle
         * @type {number}
         */
        _this.restAngle = (_a = options === null || options === void 0 ? void 0 : options.restAngle) !== null && _a !== void 0 ? _a : bodyB.angle - bodyA.angle;
        return _this;
    }
    /**
     * Apply the spring force to the connected bodies.
     * @method applyForce
     */
    RotationalSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
        var torque = -k * (x - l) - d * u;
        bodyA.angularForce -= torque;
        bodyB.angularForce += torque;
    };
    ;
    return RotationalSpring;
}(spring_1.default));
exports.default = RotationalSpring;

},{"./spring":33}],33:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Spring = /** @class */ (function () {
    /**
     * Base class for {{#crossLink "LinearSpring"}}{{/crossLink}} and {{#crossLink "RotationalSpring"}}{{/crossLink}}. Not supposed to be used directly.
     *
     * @class Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     */
    function Spring(bodyA, bodyB, options) {
        var _a, _b;
        this.stiffness = (_a = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _a !== void 0 ? _a : 100;
        this.damping = (_b = options === null || options === void 0 ? void 0 : options.damping) !== null && _b !== void 0 ? _b : 1;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    }
    return Spring;
}());
exports.default = Spring;

},{}],34:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var body_1 = __importDefault(_dereq_("./body"));
var constraint_1 = __importDefault(_dereq_("../constraints/constraint"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var worldVelocity = vec2_1.default.create();
var relativePoint = vec2_1.default.create();
var tmpVec = vec2_1.default.create();
var TopDownVehicle = /** @class */ (function () {
    /**
     * @class TopDownVehicle
     * @constructor
     *
     * @deprecated This class will be moved out of the core library in future versions.
     *
     * @param {Body} chassisBody A dynamic body, already added to the world.
     * @param {Object} [options]
     *
     * @example
     *
     *     // Create a dynamic body for the chassis
     *     var chassisBody = new Body({
     *         mass: 1
     *     });
     *     var boxShape = new Box({ width: 0.5, height: 1 });
     *     chassisBody.addShape(boxShape);
     *     world.addBody(chassisBody);
     *
     *     // Create the vehicle
     *     var vehicle = new TopDownVehicle(chassisBody);
     *
     *     // Add one front wheel and one back wheel - we don't actually need four :)
     *     var frontWheel = vehicle.addWheel({
     *         localPosition: [0, 0.5] // front
     *     });
     *     frontWheel.setSideFriction(4);
     *
     *     // Back wheel
     *     var backWheel = vehicle.addWheel({
     *         localPosition: [0, -0.5] // back
     *     });
     *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
     *     vehicle.addToWorld(world);
     *
     *     // Steer value zero means straight forward. Positive is left and negative right.
     *     frontWheel.steerValue = Math.PI / 16;
     *
     *     // Engine force forward
     *     backWheel.engineForce = 10;
     *     backWheel.setBrakeForce(0);
     */
    function TopDownVehicle(chassisBody, options) {
        var _this = this;
        // A dummy body to constrain the chassis to
        this.groundBody = new body_1.default({ mass: 0 });
        this.wheels = [];
        this.chassisBody = chassisBody;
        this.preStepCallback = function () {
            _this.update();
        };
    }
    /**
     * @method addToWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.addToWorld = function (world) {
        this.world = world;
        world.addBody(this.groundBody);
        world.on("preStep", this.preStepCallback, this);
        for (var i = 0; i < this.wheels.length; i++) {
            var wheel = this.wheels[i];
            world.addConstraint(wheel);
        }
    };
    ;
    /**
     * @method removeFromWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.removeFromWorld = function () {
        var world = this.world;
        if (world) {
            world.removeBody(this.groundBody);
            world.off('preStep', this.preStepCallback);
            for (var i = 0; i < this.wheels.length; i++) {
                var wheel = this.wheels[i];
                world.removeConstraint(wheel);
            }
            this.world = undefined;
        }
    };
    ;
    /**
     * @method addWheel
     * @param {object} [wheelOptions]
     * @return {WheelConstraint}
     */
    TopDownVehicle.prototype.addWheel = function (wheelOptions) {
        var wheel = new WheelConstraint(this, wheelOptions);
        this.wheels.push(wheel);
        return wheel;
    };
    ;
    /**
     * @method update
     */
    TopDownVehicle.prototype.update = function () {
        for (var i = 0; i < this.wheels.length; i++) {
            this.wheels[i].update();
        }
    };
    ;
    return TopDownVehicle;
}());
exports.default = TopDownVehicle;
var WheelConstraint = /** @class */ (function (_super) {
    __extends(WheelConstraint, _super);
    /**
     * @class WheelConstraint
     * @constructor
     * @extends {Constraint}
     * @param {Vehicle} vehicle
     * @param {object} [options]
     * @param {Array} [options.localForwardVector] The local wheel forward vector in local body space. Default is zero.
     * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
     * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
     */
    function WheelConstraint(vehicle, options) {
        var _a;
        var _this = 
        // TODO: I have no idea what kind of constraint this is supposed to be. It seems this was undefined in the original code.
        _super.call(this, vehicle.chassisBody, vehicle.groundBody, 0) || this;
        _this.steerValue = 0;
        /**
         * @property {number} engineForce
         */
        _this.engineForce = 0;
        _this.vehicle = vehicle;
        _this.forwardEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.sideEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.setSideFriction((_a = options === null || options === void 0 ? void 0 : options.sideFriction) !== null && _a !== void 0 ? _a : 5);
        /**
         * @property {Array} localForwardVector
         */
        _this.localForwardVector = vec2_1.default.fromValues(0, 1);
        if (options === null || options === void 0 ? void 0 : options.localForwardVector) {
            vec2_1.default.copy(_this.localForwardVector, options.localForwardVector);
        }
        /**
         * @property {Array} localPosition
         */
        _this.localPosition = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localPosition) {
            vec2_1.default.copy(_this.localPosition, options.localPosition);
        }
        _this.equations.push(_this.forwardEquation);
        _this.equations.push(_this.sideEquation);
        _this.setBrakeForce(0);
        return _this;
    }
    /**
     * @method setBrakeForce
     */
    WheelConstraint.prototype.setBrakeForce = function (force) {
        this.forwardEquation.setSlipForce(force);
    };
    /**
     * @method setSideFriction
     */
    WheelConstraint.prototype.setSideFriction = function (force) {
        this.sideEquation.setSlipForce(force);
    };
    /**
     * @method getSpeed
     */
    WheelConstraint.prototype.getSpeed = function () {
        var body = this.vehicle.chassisBody;
        body.vectorToWorldFrame(relativePoint, this.localForwardVector);
        body.getVelocityAtPoint(worldVelocity, relativePoint);
        return vec2_1.default.dot(worldVelocity, relativePoint);
    };
    /**
     * @method update
     */
    WheelConstraint.prototype.update = function () {
        var body = this.vehicle.chassisBody;
        var forwardEquation = this.forwardEquation;
        var sideEquation = this.sideEquation;
        var steerValue = this.steerValue;
        // Directional
        body.vectorToWorldFrame(forwardEquation.t, this.localForwardVector);
        vec2_1.default.rotate(sideEquation.t, this.localForwardVector, Math.PI / 2);
        body.vectorToWorldFrame(sideEquation.t, sideEquation.t);
        vec2_1.default.rotate(forwardEquation.t, forwardEquation.t, steerValue);
        vec2_1.default.rotate(sideEquation.t, sideEquation.t, steerValue);
        // Attachment point
        body.toWorldFrame(forwardEquation.contactPointB, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointB, forwardEquation.contactPointB);
        body.vectorToWorldFrame(forwardEquation.contactPointA, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointA, forwardEquation.contactPointA);
        // Add engine force
        vec2_1.default.normalize(tmpVec, forwardEquation.t);
        vec2_1.default.scale(tmpVec, tmpVec, this.engineForce);
        this.vehicle.chassisBody.applyForce(tmpVec, forwardEquation.contactPointA);
    };
    return WheelConstraint;
}(constraint_1.default));

},{"../constraints/constraint":8,"../equations/friction-equation":18,"../math/vec2":28,"./body":30}],35:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var vec2 = require('../math/vec2')
// ,   Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   Convex = require('./Convex');
var Convex_1 = __importDefault(_dereq_("./Convex"));
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Box = /** @class */ (function (_super) {
    __extends(Box, _super);
    /**
     * Box shape class.
     * @class Box
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.width=1] Total width of the box
     * @param {Number} [options.height=1] Total height of the box
     * @extends Convex
     * @example
     *     var body = new Body({ mass: 1 });
     *     var boxShape = new Box({
     *         width: 2,
     *         height: 1
     *     });
     *     body.addShape(boxShape);
     */
    function Box(options) {
        var _a, _b;
        var _this = this;
        var width = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : 1;
        var height = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : 1;
        var hw = width / 2;
        var hh = height / 2;
        _this = _super.call(this, shape_1.default.BOX, [
            vec2_1.default.fromValues(-hw, -hh),
            vec2_1.default.fromValues(hw, -hh),
            vec2_1.default.fromValues(hw, hh),
            vec2_1.default.fromValues(-hw, hh)
        ], options) || this;
        _this.height = height;
        _this.width = width;
        return _this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Box.prototype.computeMomentOfInertia = function () {
        var w = this.width, h = this.height;
        return (h * h + w * w) / 12;
    };
    ;
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Box.prototype.updateBoundingRadius = function () {
        var w = this.width, h = this.height;
        this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Box.prototype.computeAABB = function (out, position, angle) {
        var c = Math.abs(Math.cos(angle)), s = Math.abs(Math.sin(angle)), w = this.width, h = this.height;
        var height = (w * s + h * c) * 0.5;
        var width = (h * s + w * c) * 0.5;
        var l = out.lowerBound;
        var u = out.upperBound;
        var px = position[0];
        var py = position[1];
        l[0] = px - width;
        l[1] = py - height;
        u[0] = px + width;
        u[1] = py + height;
    };
    ;
    Box.prototype.updateArea = function () {
        this.area = this.width * this.height;
        return this.area;
    };
    ;
    Box.prototype.pointTest = function (localPoint) {
        return Math.abs(localPoint[0]) <= this.width * 0.5 && Math.abs(localPoint[1]) <= this.height * 0.5;
    };
    ;
    return Box;
}(Convex_1.default));
exports.default = Box;

},{"../math/vec2":28,"./Convex":37,"./shape":46}],36:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Ray_intersectSphere_intersectionPoint = vec2_1.default.create();
var Ray_intersectSphere_normal = vec2_1.default.create();
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * Circle shape class.
     * @class Circle
     * @extends Shape
     * @constructor
     * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {number} [options.radius=1] The radius of this circle
     *
     * @example
     *     var body = new Body({ mass: 1 });
     *     var circleShape = new Circle({
     *         radius: 1
     *     });
     *     body.addShape(circleShape);
     */
    function Circle(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.CIRCLE, options) || this;
        /**
         * The radius of the circle.
         * @property radius
         * @type {number}
         */
        _this.radius = (_a = options === null || options === void 0 ? void 0 : options.radius) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Circle.prototype.computeMomentOfInertia = function () {
        var r = this.radius;
        return r * r / 2;
    };
    /**
     * @method updateBoundingRadius
     * @return {Number}
     */
    Circle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     * @return {Number}
     */
    Circle.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Circle.prototype.computeAABB = function (out, position /*, angle: f32*/) {
        var r = this.radius;
        vec2_1.default.set(out.upperBound, r, r);
        vec2_1.default.set(out.lowerBound, -r, -r);
        if (position) {
            vec2_1.default.add(out.lowerBound, out.lowerBound, position);
            vec2_1.default.add(out.upperBound, out.upperBound, position);
        }
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Circle.prototype.raycast = function (result, ray, position /*, angle: f32*/) {
        var from = ray.from, to = ray.to, r = this.radius;
        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
        var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
        var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;
        var intersectionPoint = Ray_intersectSphere_intersectionPoint;
        var normal = Ray_intersectSphere_normal;
        if (delta < 0) {
            // No intersection
            return;
        }
        else if (delta === 0) {
            // single intersection point
            vec2_1.default.lerp(intersectionPoint, from, to, delta);
            vec2_1.default.subtract(normal, intersectionPoint, position);
            vec2_1.default.normalize(normal, normal);
            ray.reportIntersection(result, delta, normal, -1);
        }
        else {
            var sqrtDelta = Math.sqrt(delta);
            var inv2a = 1 / (2 * a);
            var d1 = (-b - sqrtDelta) * inv2a;
            var d2 = (-b + sqrtDelta) * inv2a;
            if (d1 >= 0 && d1 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d1);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d1, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
            if (d2 >= 0 && d2 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d2);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d2, normal, -1);
            }
        }
    };
    Circle.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        return vec2_1.default.squaredLength(localPoint) <= radius * radius;
    };
    return Circle;
}(Shape_1.default));
exports.default = Circle;

},{"../math/vec2":28,"./Shape":38}],37:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Shape_1 = __importDefault(_dereq_("./Shape"));
var polyk_1 = __importDefault(_dereq_("../math/polyk"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var dot = vec2_1.default.dot;
var updateCenterOfMass_centroid = vec2_1.default.create(), updateCenterOfMass_centroid_times_mass = vec2_1.default.create(), updateCenterOfMass_a = vec2_1.default.create(), updateCenterOfMass_b = vec2_1.default.create(), updateCenterOfMass_c = vec2_1.default.create();
var tmpVec1 = vec2_1.default.create();
var intersectConvex_rayStart = vec2_1.default.create();
var intersectConvex_rayEnd = vec2_1.default.create();
var intersectConvex_normal = vec2_1.default.create();
var pic_r0 = vec2_1.default.create();
var pic_r1 = vec2_1.default.create();
var tmpVec2 = vec2_1.default.create();
var worldAxis = tmpVec2;
var Convex = /** @class */ (function (_super) {
    __extends(Convex, _super);
    /**
     * Convex shape class.
     * @class Convex
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
     *     var convexShape = new Convex({
     *         vertices: vertices
     *     });
     *     body.addShape(convexShape);
     */
    function Convex(type, vertices, options) {
        var _this = _super.call(this, type !== null && type !== void 0 ? type : Shape_1.default.CONVEX, options) || this;
        // TODO: this would be more efficient if I didn't use float32array[]s. Just convert to a big float32array with double the size.
        // Let's get this working first then switch it.
        /**
         * Vertices defined in the local frame.
         * @property vertices
         * @type {Array}
         */
        _this.vertices = [];
        /**
         * Edge normals defined in the local frame, pointing out of the shape.
         * @property normals
         * @type {Array}
         */
        _this.normals = [];
        /**
         * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
         * @property triangles
         * @type {Array}
         */
        _this.triangles = [];
        // Copy the verts
        var newVertices = vertices !== null && vertices !== void 0 ? vertices : [];
        _this.vertices = [];
        _this.normals = [];
        for (var i = 0; i < newVertices.length; i++) {
            _this.vertices.push(vec2_1.default.clone(newVertices[i]));
            _this.normals.push(vec2_1.default.create());
        }
        // These are called in the shape constructor, but need to call again here because verts weren't set up yet!
        _this.updateBoundingRadius();
        _this.updateArea();
        _this.updateNormals();
        _this.centerOfMass = vec2_1.default.create();
        _this.triangles = [];
        if (_this.vertices.length) {
            _this.updateTriangles();
            _this.updateCenterOfMass();
        }
        /**
         * The bounding radius of the convex
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        _this.updateBoundingRadius();
        _this.updateArea();
        if (_this.area < 0) {
            throw new Error("Convex vertices must be given in counter-clockwise winding.");
        }
        return _this;
    }
    Convex.prototype.updateNormals = function () {
        var vertices = this.vertices;
        var normals = this.normals;
        for (var i = 0; i < vertices.length; i++) {
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i + 1) % vertices.length];
            var normal = normals[i];
            vec2_1.default.subtract(normal, worldPoint1, worldPoint0);
            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2_1.default.rotate90cw(normal, normal);
            vec2_1.default.normalize(normal, normal);
        }
    };
    /**
     * Project a Convex onto a world-oriented axis
     * @method projectOntoAxis
     * @static
     * @param  {Array} offset
     * @param  {Array} localAxis
     * @param  {Array} result
     */
    Convex.prototype.projectOntoLocalAxis = function (localAxis, result) {
        var max = -Infinity, min = Infinity, v, value, localAxis = tmpVec1;
        // Get projected position of all vertices
        for (var i = 0; i < this.vertices.length; i++) {
            v = this.vertices[i];
            value = dot(v, localAxis);
            if (value > max) {
                max = value;
            }
            if (value < min) {
                min = value;
            }
        }
        if (min > max) {
            var t = min;
            min = max;
            max = t;
        }
        vec2_1.default.set(result, min, max);
    };
    Convex.prototype.ConvexprojectOntoWorldAxis = function (localAxis, shapeOffset, shapeAngle, result) {
        this.projectOntoLocalAxis(localAxis, result);
        // Project the position of the body onto the axis - need to add this to the result
        if (shapeAngle !== 0) {
            vec2_1.default.rotate(worldAxis, localAxis, shapeAngle);
        }
        else {
            worldAxis = localAxis;
        }
        var offset = dot(shapeOffset, worldAxis);
        vec2_1.default.set(result, result[0] + offset, result[1] + offset);
    };
    /**
     * Update the .triangles property
     * @method updateTriangles
     */
    Convex.prototype.updateTriangles = function () {
        this.triangles.length = 0;
        // Rewrite on polyk notation, array of numbers
        var polykVerts = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var v = this.vertices[i];
            polykVerts.push(v[0]);
            polykVerts.push(v[1]);
        }
        // Triangulate
        var triangles = polyk_1.default.Triangulate(polykVerts);
        // Loop over all triangles, add their inertia contributions to I
        for (var i = 0; i < triangles.length; i += 3) {
            var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
            // Add to triangles
            var T = new Float32Array(3);
            T[0] = id1;
            T[1] = id2;
            T[2] = id3;
            this.triangles.push(T);
        }
    };
    /**
     * Update the .centerOfMass property.
     * @method updateCenterOfMass
     */
    Convex.prototype.updateCenterOfMass = function () {
        var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
        vec2_1.default.set(cm, 0, 0);
        var totalArea = 0;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            vec2_1.default.centroid(centroid, a, b, c);
            // Get mass for the triangle (density=1 in this case)
            // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
            var m = Convex.triangleArea(a, b, c);
            totalArea += m;
            // Add to center of mass
            vec2_1.default.scale(centroid_times_mass, centroid, m);
            vec2_1.default.add(cm, cm, centroid_times_mass);
        }
        vec2_1.default.scale(cm, cm, 1 / totalArea);
    };
    /**
     * Compute the moment of inertia of the Convex.
     * @method computeMomentOfInertia
     * @return {Number}
     * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
     */
    Convex.prototype.computeMomentOfInertia = function () {
        var denom = 0.0, numer = 0.0, N = this.vertices.length;
        for (var j = N - 1, i = 0; i < N; j = i, i++) {
            var p0 = this.vertices[j];
            var p1 = this.vertices[i];
            var a = Math.abs(vec2_1.default.crossLength(p0, p1));
            var b = dot(p1, p1) + dot(p1, p0) + dot(p0, p0);
            denom += a * b;
            numer += a;
        }
        return (1.0 / 6.0) * (denom / numer);
    };
    /**
     * Updates the .boundingRadius property
     * @method updateBoundingRadius
     */
    Convex.prototype.updateBoundingRadius = function () {
        var verts = this.vertices, r2 = 0;
        if (!verts || verts.length == 0)
            return 0;
        for (var i = 0; i !== verts.length; i++) {
            var l2 = vec2_1.default.squaredLength(verts[i]);
            if (l2 > r2) {
                r2 = l2;
            }
        }
        this.boundingRadius = Math.sqrt(r2);
        return this.boundingRadius;
    };
    /**
     * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
     * @static
     * @method triangleArea
     * @param {Array} a
     * @param {Array} b
     * @param {Array} c
     * @return {Number}
     * @deprecated
     */
    Convex.triangleArea = function (a, b, c) {
        return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1]))) * 0.5;
    };
    /**
     * Update the .area
     * @method updateArea
     */
    Convex.prototype.updateArea = function () {
        if (!this.vertices)
            return 0;
        this.updateTriangles();
        this.area = 0;
        var triangles = this.triangles, verts = this.vertices;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            // Get mass for the triangle (density=1 in this case)
            var m = Convex.triangleArea(a, b, c);
            this.area += m;
        }
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     * @todo: approximate with a local AABB?
     */
    Convex.prototype.computeAABB = function (out, position, angle) {
        out.setFromPoints(this.vertices, position, angle, 0);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Convex.prototype.raycast = function (result, ray, position, angle) {
        var rayStart = intersectConvex_rayStart;
        var rayEnd = intersectConvex_rayEnd;
        var normal = intersectConvex_normal;
        var vertices = this.vertices;
        // Transform to local shape space
        vec2_1.default.toLocalFrame(rayStart, ray.from, position, angle);
        vec2_1.default.toLocalFrame(rayEnd, ray.to, position, angle);
        var n = vertices.length;
        for (var i = 0; i < n && !result.shouldStop(ray); i++) {
            var q1 = vertices[i];
            var q2 = vertices[(i + 1) % n];
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
            if (delta >= 0) {
                vec2_1.default.subtract(normal, q2, q1);
                vec2_1.default.rotate(normal, normal, -Math.PI / 2 + angle);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, delta, normal, i);
            }
        }
    };
    Convex.prototype.pointTest = function (localPoint) {
        var r0 = pic_r0, r1 = pic_r1, verts = this.vertices, lastCross = null, numVerts = verts.length;
        for (var i = 0; i < numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            vec2_1.default.subtract(r0, v0, localPoint);
            vec2_1.default.subtract(r1, v1, localPoint);
            var cross = vec2_1.default.crossLength(r0, r1);
            if (lastCross === null) {
                lastCross = cross;
            }
            // If we got a different sign of the distance vector, the point is out of the polygon
            if (cross * lastCross < 0) {
                return false;
            }
            lastCross = cross;
        }
        return true;
    };
    return Convex;
}(Shape_1.default));
exports.default = Convex;

},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],38:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Shape = /** @class */ (function () {
    /**
     * Base class for shapes. Not to be used directly.
     * @class Shape
     * @constructor
     * @param {object} [options]
     * @param {number} [options.angle=0]
     * @param {number} [options.collisionGroup=1]
     * @param {number} [options.collisionMask=1]
     * @param {number} [options.id] Optional - specify an ID for this shape. Possibly useful for replacing shapes. Careful to avoid duplicates!
     * @param {boolean} [options.collisionResponse=true]
     * @param {Material} [options.material=null]
     * @param {array} [options.position]
     * @param {boolean} [options.sensor=false]
     * @param {object} [options.type=0]
     */
    function Shape(type, options) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Body-local position of the shape.
         * @property {Array} position
         */
        this.position = vec2_1.default.create();
        /**
         * Body-local angle of the shape.
         * @property {number} angle
         */
        this.angle = 0;
        /**
         * The type of the shape. One of:
         *
         * <ul>
         * <li><a href="Shape.html#property_CIRCLE">Shape.CIRCLE</a></li>
         * <li><a href="Shape.html#property_PARTICLE">Shape.PARTICLE</a></li>
         * <li><a href="Shape.html#property_PLANE">Shape.PLANE</a></li>
         * <li><a href="Shape.html#property_CONVEX">Shape.CONVEX</a></li>
         * <li><a href="Shape.html#property_LINE">Shape.LINE</a></li>
         * <li><a href="Shape.html#property_BOX">Shape.BOX</a></li>
         * <li><a href="Shape.html#property_CAPSULE">Shape.CAPSULE</a></li>
         * <li><a href="Shape.html#property_HEIGHTFIELD">Shape.HEIGHTFIELD</a></li>
         * </ul>
         *
         * @property {number} type
         */
        this.type = 0;
        /**
         * Shape object identifier. Read only.
         * @readonly
         * @type {Number}
         * @property id
         */
        this.id = 0;
        /**
         * Bounding circle radius of this shape
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        this.boundingRadius = 0;
        /**
         * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
         * @property collisionGroup
         * @type {Number}
         * @example
         *     // Setup bits for each available group
         *     var PLAYER = Math.pow(2,0),
         *         ENEMY =  Math.pow(2,1),
         *         GROUND = Math.pow(2,2)
         *
         *     // Put shapes into their groups
         *     player1Shape.collisionGroup = PLAYER;
         *     player2Shape.collisionGroup = PLAYER;
         *     enemyShape  .collisionGroup = ENEMY;
         *     groundShape .collisionGroup = GROUND;
         *
         *     // Assign groups that each shape collide with.
         *     // Note that the players can collide with ground and enemies, but not with other players.
         *     player1Shape.collisionMask = ENEMY | GROUND;
         *     player2Shape.collisionMask = ENEMY | GROUND;
         *     enemyShape  .collisionMask = PLAYER | GROUND;
         *     groundShape .collisionMask = PLAYER | ENEMY;
         *
         * @example
         *     // How collision check is done
         *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
         *         // The shapes will collide
         *     }
         */
        this.collisionGroup = 1;
        /**
         * Area of this shape.
         * @property area
         * @type {Number}
         */
        this.area = 0;
        if (options === null || options === void 0 ? void 0 : options.position) {
            vec2_1.default.copy(this.position, options.position);
        }
        this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        this.type = type;
        this.id = (_b = options === null || options === void 0 ? void 0 : options.id) !== null && _b !== void 0 ? _b : ++Shape.idCounter;
        this.collisionGroup = (_c = options === null || options === void 0 ? void 0 : options.collisionGroup) !== null && _c !== void 0 ? _c : 1;
        this.collisionResponse = (_d = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _d !== void 0 ? _d : true;
        this.collisionMask = (_e = options === null || options === void 0 ? void 0 : options.collisionMask) !== null && _e !== void 0 ? _e : 1;
        this.material = options === null || options === void 0 ? void 0 : options.material;
        this.sensor = (_f = options === null || options === void 0 ? void 0 : options.sensor) !== null && _f !== void 0 ? _f : false;
        if (this.type) {
            this.updateBoundingRadius();
        }
        this.updateArea();
    }
    /**
     * Test if a point is inside this shape.
     * @method pointTest
     * @param {array} localPoint
     * @return {boolean}
     */
    Shape.prototype.pointTest = function (localPoint) { return false; };
    /**
     * Transform a world point to local shape space (assumed the shape is transformed by both itself and the body).
     * @method worldPointToLocal
     * @param {array} out
     * @param {array} worldPoint
     */
    Shape.prototype.worldPointToLocal = function (out, worldPoint) {
        var shapeWorldPosition = vec2_1.default.create();
        var body = this.body;
        if (!body)
            return;
        vec2_1.default.rotate(shapeWorldPosition, this.position, body.angle);
        vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
        vec2_1.default.toLocalFrame(out, worldPoint, shapeWorldPosition, body.angle + this.angle);
    };
    Shape.idCounter = 0;
    /**
     * @static
     * @property {Number} CIRCLE
     */
    Shape.CIRCLE = 1;
    /**
     * @static
     * @property {Number} PARTICLE
     */
    Shape.PARTICLE = 2;
    /**
     * @static
     * @property {Number} PLANE
     */
    Shape.PLANE = 4;
    /**
     * @static
     * @property {Number} CONVEX
     */
    Shape.CONVEX = 8;
    /**
     * @static
     * @property {Number} LINE
     */
    Shape.LINE = 16;
    /**
     * @static
     * @property {Number} BOX
     */
    Shape.BOX = 32;
    /**
     * @static
     * @property {Number} CAPSULE
     */
    Shape.CAPSULE = 64;
    /**
     * @static
     * @property {Number} HEIGHTFIELD
     */
    Shape.HEIGHTFIELD = 128;
    return Shape;
}());
exports.default = Shape;

},{"../math/vec2":28}],39:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
var shape_1 = __importDefault(_dereq_("./shape"));
var shallowClone = utils_1.default.shallowClone;
function boxI(w, h) {
    return w * h * (Math.pow(w, 2) + Math.pow(h, 2)) / 12;
}
function semiA(r) {
    return Math.PI * Math.pow(r, 2) / 2;
}
// http://www.efunda.com/math/areas/CircleHalf.cfm
function semiI(r) {
    return ((Math.PI / 4) - (8 / (9 * Math.PI))) * Math.pow(r, 4);
}
function semiC(r) {
    return (4 * r) / (3 * Math.PI);
}
// https://en.wikipedia.org/wiki/Second_moment_of_area#Parallel_axis_theorem
function capsuleA(l, r) {
    return l * 2 * r + Math.PI * Math.pow(r, 2);
}
function capsuleI(l, r) {
    var d = l / 2 + semiC(r);
    return boxI(l, 2 * r) + 2 * (semiI(r) + semiA(r) * Math.pow(d, 2));
}
var intersectCapsule_hitPointWorld = vec2_1.default.create();
var intersectCapsule_normal = vec2_1.default.create();
var intersectCapsule_l0 = vec2_1.default.create();
var intersectCapsule_l1 = vec2_1.default.create();
var intersectCapsule_unit_y = vec2_1.default.fromValues(0, 1);
var Capsule = /** @class */ (function (_super) {
    __extends(Capsule, _super);
    /**
     * Capsule shape.
     * @class Capsule
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The distance between the end points, extends along the X axis.
     * @param {Number} [options.radius=1] Radius of the capsule.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var capsuleShape = new Capsule({
     *         length: 1,
     *         radius: 2
     *     });
     *     body.addShape(capsuleShape);
     */
    function Capsule(options) {
        var _a, _b;
        var _this = _super.call(this, shape_1.default.CAPSULE, options) || this;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        _this.radius = (_b = options === null || options === void 0 ? void 0 : options.radius) !== null && _b !== void 0 ? _b : 1;
        return _this;
    }
    /**
     * Compute the mass moment of inertia of the Capsule.
     * @method conputeMomentOfInertia
     * @return {Number}
     * @todo
     */
    Capsule.prototype.computeMomentOfInertia = function () {
        // http://www.efunda.com/math/areas/rectangle.cfm
        var r = this.radius, l = this.length, area = capsuleA(l, r);
        return (area > 0) ? capsuleI(l, r) / area : 0;
    };
    /**
     * @method updateBoundingRadius
     */
    Capsule.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius + this.length / 2;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     */
    Capsule.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Capsule.prototype.computeAABB = function (out, position, angle) {
        var r = vec2_1.default.create();
        var radius = this.radius;
        // Compute center position of one of the the circles, world oriented, but with local offset
        vec2_1.default.set(r, this.length / 2, 0);
        if (angle !== 0) {
            vec2_1.default.rotate(r, r, angle);
        }
        // Get bounds
        vec2_1.default.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
        vec2_1.default.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
        // Add offset
        vec2_1.default.add(out.lowerBound, out.lowerBound, position);
        vec2_1.default.add(out.upperBound, out.upperBound, position);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Capsule.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var hitPointWorld = intersectCapsule_hitPointWorld;
        var normal = intersectCapsule_normal;
        var l0 = intersectCapsule_l0;
        var l1 = intersectCapsule_l1;
        // The sides
        var halfLen = this.length / 2;
        for (var i = 0; i < 2; i++) {
            // get start and end of the line
            var y = this.radius * (i * 2 - 1);
            vec2_1.default.set(l0, -halfLen, y);
            vec2_1.default.set(l1, halfLen, y);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            vec2_1.default.toGlobalFrame(l1, l1, position, angle);
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(from, to, l0, l1);
            if (delta >= 0) {
                vec2_1.default.rotate(normal, intersectCapsule_unit_y, angle);
                vec2_1.default.scale(normal, normal, (i * 2 - 1));
                ray.reportIntersection(result, delta, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
        // Circles
        var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
        for (var i = 0; i < 2; i++) {
            vec2_1.default.set(l0, halfLen * (i * 2 - 1), 0);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
            var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
            var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
            var delta = Math.pow(b, 2) - 4 * a * c;
            if (delta < 0) {
                // No intersection
                continue;
            }
            else if (delta === 0) {
                // single intersection point
                vec2_1.default.lerp(hitPointWorld, from, to, delta);
                if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                    vec2_1.default.subtract(normal, hitPointWorld, l0);
                    vec2_1.default.normalize(normal, normal);
                    ray.reportIntersection(result, delta, normal, -1);
                    if (result.shouldStop(ray)) {
                        return;
                    }
                }
            }
            else {
                var sqrtDelta = Math.sqrt(delta);
                var inv2a = 1 / (2 * a);
                var d1 = (-b - sqrtDelta) * inv2a;
                var d2 = (-b + sqrtDelta) * inv2a;
                if (d1 >= 0 && d1 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d1);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d1, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
                if (d2 >= 0 && d2 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d2);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d2, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
            }
        }
    };
    Capsule.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        var halfLength = this.length * 0.5;
        if ((Math.abs(localPoint[0]) <= halfLength && Math.abs(localPoint[1]) <= radius)) {
            return true;
        }
        if (Math.pow(localPoint[0] - halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        if (Math.pow(localPoint[0] + halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        return false;
    };
    return Capsule;
}(shape_1.default));
exports.default = Capsule;

},{"../math/vec2":28,"../utils/utils":56,"./shape":46}],40:[function(_dereq_,module,exports){
module.exports=_dereq_(36)
},{"../math/vec2":28,"./Shape":38}],41:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],42:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectHeightfield_worldNormal = vec2_1.default.create();
var intersectHeightfield_l0 = vec2_1.default.create();
var intersectHeightfield_l1 = vec2_1.default.create();
var intersectHeightfield_localFrom = vec2_1.default.create();
var intersectHeightfield_localTo = vec2_1.default.create();
var Heightfield = /** @class */ (function (_super) {
    __extends(Heightfield, _super);
    /**
     * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
     * @class Heightfield
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
     * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
     * @param {Number} [options.maxValue] Maximum value.
     * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
     *
     * @example
     *     // Generate some height data (y-values).
     *     var heights = [];
     *     for(var i = 0; i < 1000; i++){
     *         var y = 0.5 * Math.cos(0.2 * i);
     *         heights.push(y);
     *     }
     *
     *     // Create the heightfield shape
     *     var shape = new Heightfield({
     *         heights: heights,
     *         elementWidth: 1 // Distance between the data points in X direction
     *     });
     *     var body = new Body();
     *     body.addShape(shape);
     *     world.addBody(body);
     *
     * @todo Should use a scale property with X and Y direction instead of just elementWidth
     */
    function Heightfield(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.HEIGHTFIELD, options) || this;
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         * @property {array} heights
         */
        _this.heights = [];
        /**
         * Max value of the heights
         * @property {number} maxValue
         */
        _this.maxValue = 0;
        /**
         * Max value of the heights
         * @property {number} minValue
         */
        _this.minValue = 0;
        /**
         * The width of each element
         * @property {number} elementWidth
         */
        _this.elementWidth = 0;
        _this.heights = (options === null || options === void 0 ? void 0 : options.heights) ? options.heights.slice(0) : [];
        _this.elementWidth = (_a = options === null || options === void 0 ? void 0 : options.elementWidth) !== null && _a !== void 0 ? _a : 0.1;
        _this.updateArea();
        if ((options === null || options === void 0 ? void 0 : options.maxValue) && (options === null || options === void 0 ? void 0 : options.minValue)) {
            _this.maxValue = options === null || options === void 0 ? void 0 : options.maxValue;
            _this.minValue = options === null || options === void 0 ? void 0 : options.minValue;
        }
        else
            _this.updateMaxMinValues();
        return _this;
    }
    /**
     * Update the .minValue and the .maxValue
     * @method updateMaxMinValues
     */
    Heightfield.prototype.updateMaxMinValues = function () {
        var data = this.heights;
        var maxValue = data[0];
        var minValue = data[0];
        for (var i = 0; i !== data.length; i++) {
            var v = data[i];
            if (v > maxValue) {
                maxValue = v;
            }
            if (v < minValue) {
                minValue = v;
            }
        }
        this.maxValue = maxValue;
        this.minValue = minValue;
    };
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Heightfield.prototype.computeMomentOfInertia = function () {
        return Infinity;
    };
    Heightfield.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return this.boundingRadius;
    };
    Heightfield.prototype.updateArea = function () {
        var data = this.heights, area = 0;
        if (!data)
            return 0;
        for (var i = 0; i < data.length - 1; i++) {
            area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
        }
        this.area = area;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Heightfield.prototype.computeAABB = function (out, position, angle) {
        var points = [
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create()
        ];
        vec2_1.default.set(points[0], 0, this.maxValue);
        vec2_1.default.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
        vec2_1.default.set(points[2], this.elementWidth * this.heights.length, this.minValue);
        vec2_1.default.set(points[3], 0, this.minValue);
        out.setFromPoints(points, position, angle);
    };
    /**
     * Get a line segment in the heightfield
     * @method getLineSegment
     * @param  {array} start Where to store the resulting start point
     * @param  {array} end Where to store the resulting end point
     * @param  {number} i
     */
    Heightfield.prototype.getLineSegment = function (start, end, i) {
        var data = this.heights;
        var width = this.elementWidth;
        vec2_1.default.set(start, i * width, data[i]);
        vec2_1.default.set(end, (i + 1) * width, data[i + 1]);
    };
    Heightfield.prototype.getSegmentIndex = function (position) {
        return Math.floor(position[0] / this.elementWidth);
    };
    Heightfield.prototype.getClampedSegmentIndex = function (position) {
        var i = this.getSegmentIndex(position);
        i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
        return i;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Heightfield.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var worldNormal = intersectHeightfield_worldNormal;
        var l0 = intersectHeightfield_l0;
        var l1 = intersectHeightfield_l1;
        var localFrom = intersectHeightfield_localFrom;
        var localTo = intersectHeightfield_localTo;
        // get local ray start and end
        vec2_1.default.toLocalFrame(localFrom, from, position, angle);
        vec2_1.default.toLocalFrame(localTo, to, position, angle);
        // Get the segment range
        var i0 = this.getClampedSegmentIndex(localFrom);
        var i1 = this.getClampedSegmentIndex(localTo);
        if (i0 > i1) {
            var tmp = i0;
            i0 = i1;
            i1 = tmp;
        }
        // The segments
        for (var i = 0; i < this.heights.length - 1; i++) {
            this.getLineSegment(l0, l1, i);
            var t = vec2_1.default.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
            if (t >= 0) {
                vec2_1.default.subtract(worldNormal, l1, l0);
                vec2_1.default.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
                vec2_1.default.normalize(worldNormal, worldNormal);
                ray.reportIntersection(result, t, worldNormal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
    };
    return Heightfield;
}(Shape_1.default));
exports.default = Heightfield;

},{"../math/vec2":28,"./Shape":38}],43:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var raycast_normal = vec2_1.default.create();
var raycast_l0 = vec2_1.default.create();
var raycast_l1 = vec2_1.default.create();
var raycast_unit_y = vec2_1.default.fromValues(0, 1);
var Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    /**
     * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
     * @class Line
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The total length of the line
     * @extends Shape
     * @constructor
     * @example
     *     var body = new Body();
     *     var lineShape = new Line({
     *         length: 1
     *     });
     *     body.addShape(lineShape);
     */
    function Line(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.LINE, options) || this;
        /**
         * Length of this line
         * @property {Number} length
         * @default 1
         */
        _this.length = 1;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    Line.prototype.computeMomentOfInertia = function () {
        return Math.pow(this.length, 2) / 12;
    };
    ;
    Line.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.length / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Line.prototype.computeAABB = function (out, position, angle) {
        var points = [vec2_1.default.create(), vec2_1.default.create()];
        var l2 = this.length / 2;
        vec2_1.default.set(points[0], -l2, 0);
        vec2_1.default.set(points[1], l2, 0);
        out.setFromPoints(points, position, angle, 0);
    };
    ;
    Line.prototype.updateArea = function () { return 0; };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {number} angle
     * @param  {array} position
     */
    Line.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var l0 = raycast_l0;
        var l1 = raycast_l1;
        // get start and end of the line
        var halfLen = this.length / 2;
        vec2_1.default.set(l0, -halfLen, 0);
        vec2_1.default.set(l1, halfLen, 0);
        vec2_1.default.toGlobalFrame(l0, l0, position, angle);
        vec2_1.default.toGlobalFrame(l1, l1, position, angle);
        var fraction = vec2_1.default.getLineSegmentsIntersectionFraction(l0, l1, from, to);
        if (fraction >= 0) {
            var normal = raycast_normal;
            vec2_1.default.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
            ray.reportIntersection(result, fraction, normal, -1);
        }
    };
    ;
    return Line;
}(Shape_1.default));
exports.default = Line;

},{"../math/vec2":28,"./Shape":38}],44:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   copy = require('../math/vec2').copy;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var copy = vec2_1.default.copy;
var Particle = /** @class */ (function (_super) {
    __extends(Particle, _super);
    /**
     * Particle shape class.
     * @class Particle
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @extends Shape
     * @example
     *     var body = new Body();
     *     var shape = new Particle();
     *     body.addShape(shape);
     */
    function Particle(options) {
        return _super.call(this, Shape_1.default.PARTICLE, options) || this;
    }
    Particle.prototype.computeMomentOfInertia = function () {
        return 0; // Can't rotate a particle
    };
    ;
    Particle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = 0;
        return 0;
    };
    ;
    Particle.prototype.updateArea = function () { return 0; };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Particle.prototype.computeAABB = function (out, position /*, angle*/) {
        copy(out.lowerBound, position);
        copy(out.upperBound, position);
    };
    ;
    Particle.prototype.raycast = function (result, ray, position, angle) { 1; };
    return Particle;
}(Shape_1.default));
exports.default = Particle;

},{"../math/vec2":28,"./Shape":38}],45:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectPlane_planePointToFrom = vec2_1.default.create();
var intersectPlane_normal = vec2_1.default.create();
var intersectPlane_len = vec2_1.default.create();
var Plane = /** @class */ (function (_super) {
    __extends(Plane, _super);
    /**
     * Plane shape class. The plane is facing in the Y direction.
     * @class Plane
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @example
     *     var body = new Body();
     *     var shape = new Plane();
     *     body.addShape(shape);
     */
    function Plane(options) {
        return _super.call(this, shape_1.default.PLANE, options) || this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     */
    Plane.prototype.computeMomentOfInertia = function () {
        return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
    };
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Plane.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return Infinity;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Plane.prototype.computeAABB = function (out, position, angle) {
        var a = angle % (2 * Math.PI);
        var set = vec2_1.default.set;
        var max = 1e7;
        var lowerBound = out.lowerBound;
        var upperBound = out.upperBound;
        // Set max bounds
        set(lowerBound, -max, -max);
        set(upperBound, max, max);
        if (a === 0) {
            // y goes from -inf to 0
            upperBound[1] = position[1];
        }
        else if (a === Math.PI / 2) {
            // x goes from 0 to inf
            lowerBound[0] = position[0];
        }
        else if (a === Math.PI) {
            // y goes from 0 to inf
            lowerBound[1] = position[1];
        }
        else if (a === 3 * Math.PI / 2) {
            // x goes from -inf to 0
            upperBound[0] = position[0];
        }
    };
    Plane.prototype.updateArea = function () {
        this.area = Infinity;
        return Infinity;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Plane.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var direction = ray.direction;
        var planePointToFrom = intersectPlane_planePointToFrom;
        var normal = intersectPlane_normal;
        var len = intersectPlane_len;
        // Get plane normal
        vec2_1.default.set(normal, 0, 1);
        vec2_1.default.rotate(normal, normal, angle);
        vec2_1.default.subtract(len, from, position);
        var planeToFrom = vec2_1.default.dot(len, normal);
        vec2_1.default.subtract(len, to, position);
        var planeToTo = vec2_1.default.dot(len, normal);
        if (planeToFrom * planeToTo > 0) {
            // "from" and "to" are on the same side of the plane... bail out
            return;
        }
        if (vec2_1.default.squaredDistance(from, to) < planeToFrom * planeToFrom) {
            return;
        }
        var n_dot_dir = vec2_1.default.dot(normal, direction);
        vec2_1.default.subtract(planePointToFrom, from, position);
        var t = -vec2_1.default.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
        ray.reportIntersection(result, t, normal, -1);
    };
    ;
    Plane.prototype.pointTest = function (localPoint) {
        return localPoint[1] <= 0;
    };
    return Plane;
}(shape_1.default));
exports.default = Plane;

},{"../math/vec2":28,"./shape":46}],46:[function(_dereq_,module,exports){
module.exports=_dereq_(38)
},{"../math/vec2":28}],47:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var solver_1 = __importDefault(_dereq_("./solver"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
// Sets the .multiplier property of each equation
function updateMultipliers(equations, invDt) {
    var l = equations.length;
    while (l--) {
        var eq = equations[l];
        eq.multiplier = eq.lambda * invDt;
    }
}
function iterateEquation(eq) {
    // Compute iteration
    var B = eq.B, eps = eq.epsilon, invC = eq.invC, lambdaj = eq.lambda, GWlambda = eq.computeGWlambda(), maxForce_dt = eq.maxForceDt, minForce_dt = eq.minForceDt;
    var deltalambda = invC * (B - GWlambda - eps * lambdaj);
    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if (lambdaj_plus_deltalambda < minForce_dt) {
        deltalambda = minForce_dt - lambdaj;
    }
    else if (lambdaj_plus_deltalambda > maxForce_dt) {
        deltalambda = maxForce_dt - lambdaj;
    }
    eq.lambda += deltalambda;
    eq.addToWlambda(deltalambda);
    return deltalambda;
}
var GSSolver = /** @class */ (function (_super) {
    __extends(GSSolver, _super);
    /**
     * Iterative Gauss-Seidel constraint equation solver.
     *
     * @class GSSolver
     * @constructor
     * @extends Solver
     * @param {Object} [options]
     * @param {Number} [options.iterations=10]
     * @param {Number} [options.tolerance=0]
     */
    function GSSolver(options) {
        var _a, _b, _c;
        var _this = _super.call(this, options, solver_1.default.GS) || this;
        /**
         * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
         * @property {Number} usedIterations
         */
        _this.usedIterations = 0;
        _this.iterations = (_a = options === null || options === void 0 ? void 0 : options.iterations) !== null && _a !== void 0 ? _a : 10;
        _this.tolerance = (_b = options === null || options === void 0 ? void 0 : options.tolerance) !== null && _b !== void 0 ? _b : 1e-7;
        _this.frictionIterations = (_c = options === null || options === void 0 ? void 0 : options.frictionIterations) !== null && _c !== void 0 ? _c : 0;
        return _this;
    }
    /**
     * Solve the system of equations
     * @method solve
     * @param  {Number}  h       Time step
     * @param  {World}   world    World to solve
     */
    GSSolver.prototype.solve = function (h, world) {
        this.sortEquations();
        var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = bodies.length;
        this.usedIterations = 0;
        if (Neq) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Update solve mass
                b.updateSolveMassProperties();
            }
        }
        for (var i_1 = 0; i_1 !== Neq; i_1++) {
            var c_1 = equations[i_1];
            c_1.lambda = 0;
            if (c_1.timeStep !== h || c_1.needsUpdate) {
                c_1.timeStep = h;
                c_1.update();
            }
            c_1.B = c_1.computeB(c_1.a, c_1.b, h);
            c_1.invC = c_1.computeInvC(c_1.epsilon);
            c_1.maxForceDt = c_1.maxForce * h;
            c_1.minForceDt = c_1.minForce * h;
        }
        var c, deltalambdaTot, j;
        if (Neq !== 0) {
            for (i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Reset vlambda
                b.resetConstraintVelocity();
            }
            if (maxFrictionIter) {
                // Iterate over contact equations to get normal forces
                for (iter = 0; iter !== maxFrictionIter; iter++) {
                    // Accumulate the total error for each iteration.
                    deltalambdaTot = 0.0;
                    for (j = 0; j !== Neq; j++) {
                        c = equations[j];
                        var deltalambda = iterateEquation(c);
                        deltalambdaTot += Math.abs(deltalambda);
                    }
                    this.usedIterations++;
                    // If the total error is small enough - stop iterate
                    if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                        break;
                    }
                }
                updateMultipliers(equations, 1 / h);
                // Set computed friction force
                for (j = 0; j !== Neq; j++) {
                    var eq = equations[j];
                    if (eq instanceof friction_equation_1.default) {
                        var f = 0.0;
                        for (var k = 0; k !== eq.contactEquations.length; k++) {
                            f += eq.contactEquations[k].multiplier;
                        }
                        f *= eq.frictionCoefficient / eq.contactEquations.length;
                        eq.maxForce = f;
                        eq.minForce = -f;
                        eq.maxForceDt = f * h;
                        eq.minForceDt = -f * h;
                    }
                }
            }
            // Iterate over all equations
            for (iter = 0; iter !== maxIter; iter++) {
                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;
                for (j = 0; j !== Neq; j++) {
                    c = equations[j];
                    var deltalambda = iterateEquation(c);
                    deltalambdaTot += Math.abs(deltalambda);
                }
                this.usedIterations++;
                // If the total error is small enough - stop iterate
                if (deltalambdaTot * deltalambdaTot < tolSquared) {
                    break;
                }
            }
            // Add result to velocity
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].addConstraintVelocity();
            }
            updateMultipliers(equations, 1 / h);
        }
    };
    ;
    return GSSolver;
}(solver_1.default));
exports.default = GSSolver;

},{"../equations/friction-equation":18,"./solver":48}],48:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var Solver = /** @class */ (function (_super) {
    __extends(Solver, _super);
    /**
     * Base class for constraint solvers.
     * @class Solver
     * @constructor
     * @extends EventEmitter
     */
    function Solver(options, type) {
        var _a;
        var _this = _super.call(this) || this;
        _this.type = type;
        /**
         * Current equations in the solver.
         *
         * @property equations
         * @type {Array}
         */
        _this.equations = [];
        /**
         * Function that is used to sort all equations before each solve.
         * @property equationSortFunction
         * @type {function|boolean}
         */
        _this.equationSortFunction = (_a = options === null || options === void 0 ? void 0 : options.equationSortFunction) !== null && _a !== void 0 ? _a : undefined;
        return _this;
    }
    /**
     * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
     * @method sortEquations
     */
    Solver.prototype.sortEquations = function () {
        if (this.equationSortFunction) {
            this.equations.sort(this.equationSortFunction);
        }
    };
    ;
    /**
     * Add an equation to be solved.
     *
     * @method addEquation
     * @param {Equation} eq
     */
    Solver.prototype.addEquation = function (eq) {
        if (eq.enabled) {
            this.equations.push(eq);
        }
    };
    ;
    /**
     * Add equations. Same as .addEquation, but this time the argument is an array of Equations
     *
     * @method addEquations
     * @param {Array} eqs
     */
    Solver.prototype.addEquations = function (eqs) {
        for (var i = 0, N = eqs.length; i !== N; i++) {
            var eq = eqs[i];
            if (eq.enabled) {
                this.equations.push(eq);
            }
        }
    };
    ;
    /**
     * Remove an equation.
     *
     * @method removeEquation
     * @param {Equation} eq
     */
    Solver.prototype.removeEquation = function (eq) {
        var i = this.equations.indexOf(eq);
        if (i !== -1) {
            this.equations.splice(i, 1);
        }
    };
    ;
    /**
     * Remove all currently added equations.
     *
     * @method removeAllEquations
     */
    Solver.prototype.removeAllEquations = function () {
        this.equations.length = 0;
    };
    ;
    /**
     * Gauss-Seidel solver.
     * @property GS
     * @type {Number}
     * @static
     */
    Solver.GS = 1;
    return Solver;
}(event_emitter_1.default));
exports.default = Solver;

},{"../events/event-emitter":21}],49:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var ContactEquationPool = /** @class */ (function (_super) {
    __extends(ContactEquationPool, _super);
    /**
     * @class
     */
    function ContactEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {ContactEquation}
     */
    ContactEquationPool.prototype.create = function () {
        return new contact_equation_1.default();
    };
    /**
     * @method destroy
     * @param {ContactEquation} equation
     * @return {ContactEquationPool}
     */
    ContactEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    return ContactEquationPool;
}(pool_1.default));
exports.default = ContactEquationPool;

},{"../equations/contact-equation":16,"./pool":54}],50:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var FrictionEquationPool = /** @class */ (function (_super) {
    __extends(FrictionEquationPool, _super);
    /**
     * @class
     */
    function FrictionEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {FrictionEquation}
     */
    FrictionEquationPool.prototype.create = function () {
        return new friction_equation_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {FrictionEquation} equation
     * @return {FrictionEquationPool}
     */
    FrictionEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    ;
    return FrictionEquationPool;
}(pool_1.default));
exports.default = FrictionEquationPool;

},{"../equations/friction-equation":18,"./pool":54}],51:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var overlap_keeper_record_1 = __importDefault(_dereq_("./overlap-keeper-record"));
var OverlapKeeperRecordPool = /** @class */ (function (_super) {
    __extends(OverlapKeeperRecordPool, _super);
    /**
     * @class
     */
    function OverlapKeeperRecordPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {OverlapKeeperRecord}
     */
    OverlapKeeperRecordPool.prototype.create = function () {
        return new overlap_keeper_record_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {OverlapKeeperRecord} record
     * @return {OverlapKeeperRecordPool}
     */
    OverlapKeeperRecordPool.prototype.destroy = function (record) {
        record.set(undefined, undefined, undefined, undefined);
        return this;
    };
    ;
    return OverlapKeeperRecordPool;
}(pool_1.default));
exports.default = OverlapKeeperRecordPool;

},{"./overlap-keeper-record":52,"./pool":54}],52:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OverlapKeeperRecord = /** @class */ (function () {
    /**
     * Overlap data container for the OverlapKeeper
     * @class OverlapKeeperRecord
     * @constructor
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
        this.set(bodyA, shapeA, bodyB, shapeB);
    }
    /**
     * Set the data for the record
     * @method set
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    OverlapKeeperRecord.prototype.set = function (bodyA, shapeA, bodyB, shapeB) {
        this.shapeA = shapeA;
        this.shapeB = shapeB;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    };
    ;
    return OverlapKeeperRecord;
}());
exports.default = OverlapKeeperRecord;

},{}],53:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tuple_dictionary_1 = __importDefault(_dereq_("./tuple-dictionary"));
var overlap_keeper_record_pool_1 = __importDefault(_dereq_("./overlap-keeper-record-pool"));
var OverlapKeeper = /** @class */ (function () {
    /**
     * Keeps track of overlaps in the current state and the last step state.
     * @class OverlapKeeper
     * @constructor
     */
    function OverlapKeeper() {
        this.overlappingShapesLastState = new tuple_dictionary_1.default();
        this.overlappingShapesCurrentState = new tuple_dictionary_1.default();
        this.recordPool = new overlap_keeper_record_pool_1.default({ size: 16 });
        this.tmpDict = new tuple_dictionary_1.default();
        this.tmpArray1 = [];
    }
    /**
     * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
     * @method tick
     */
    OverlapKeeper.prototype.tick = function () {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Save old objects into pool
        var l = last.keys.length;
        while (l--) {
            var key = last.keys[l];
            var lastObject = last.getByKey(key);
            if (lastObject) {
                // The record is only used in the "last" dict, and will be removed. We might as well pool it.
                this.recordPool.release(lastObject);
            }
        }
        // Clear last object
        last.reset();
        // Transfer from new object to old
        last.copy(current);
        // Clear current object
        current.reset();
    };
    /**
     * @method setOverlapping
     * @param {Body} bodyA
     * @param {Body} shapeA
     * @param {Body} bodyB
     * @param {Body} shapeB
     */
    OverlapKeeper.prototype.setOverlapping = function (bodyA, shapeA, bodyB, shapeB) {
        var current = this.overlappingShapesCurrentState;
        // Store current contact state
        if (!current.get(shapeA.id, shapeB.id)) {
            var data = this.recordPool.get();
            data.set(bodyA, shapeA, bodyB, shapeB);
            current.set(shapeA.id, shapeB.id, data);
        }
    };
    OverlapKeeper.prototype.getNewOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
    };
    OverlapKeeper.prototype.getEndOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
    };
    /**
     * Checks if two bodies are currently overlapping.
     * @method bodiesAreOverlapping
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {boolean}
     */
    OverlapKeeper.prototype.bodiesAreOverlapping = function (bodyA, bodyB) {
        var current = this.overlappingShapesCurrentState;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if ((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA) {
                return true;
            }
        }
        return false;
    };
    OverlapKeeper.prototype.getDiff = function (dictA, dictB, result) {
        var result = result || [];
        var last = dictA;
        var current = dictB;
        result.length = 0;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if (!data) {
                throw new Error('Key ' + key + ' had no data!');
            }
            var lastData = last.data[key];
            if (!lastData) {
                // Not overlapping in last state, but in current.
                result.push(data);
            }
        }
        return result;
    };
    OverlapKeeper.prototype.isNewOverlap = function (shapeA, shapeB) {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Not in last but in new
        return !last.get(shapeA.id, shapeB.id) && !!current.get(shapeA.id, shapeB.id);
    };
    OverlapKeeper.prototype.getNewBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getNewOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getEndBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getEndOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getBodyDiff = function (overlaps, result) {
        result = result || [];
        var accumulator = this.tmpDict;
        var l = overlaps.length;
        while (l--) {
            var data = overlaps[l];
            // Since we use body id's for the accumulator, these will be a subset of the original one
            accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
        }
        l = accumulator.keys.length;
        while (l--) {
            var data = accumulator.getByKey(accumulator.keys[l]);
            if (data) {
                result.push(data.bodyA);
                result.push(data.bodyB);
            }
        }
        accumulator.reset();
        return result;
    };
    return OverlapKeeper;
}());
exports.default = OverlapKeeper;

},{"./overlap-keeper-record-pool":51,"./tuple-dictionary":55}],54:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool = /** @class */ (function () {
    /**
     * Object pooling utility.
     * @class Pool
     * @constructor
     */
    function Pool(options) {
        /**
         * @property {Array} objects
         * @type {Array}
         */
        this.objects = [];
        if (options === null || options === void 0 ? void 0 : options.size) {
            this.resize(options === null || options === void 0 ? void 0 : options.size);
        }
    }
    /**
     * @method resize
     * @param {number} size
     * @return {Pool} Self, for chaining
     */
    Pool.prototype.resize = function (size) {
        var objects = this.objects;
        while (objects.length > size) {
            objects.pop();
        }
        while (objects.length < size) {
            objects.push(this.create());
        }
        return this;
    };
    /**
     * Get an object from the pool or create a new instance.
     * @method get
     * @return {Object}
     */
    Pool.prototype.get = function () {
        var objects = this.objects;
        return objects.length ? objects.pop() : this.create();
    };
    /**
     * Clean up and put the object back into the pool for later use.
     * @method release
     * @param {Object} object
     * @return {Pool} Self for chaining
     */
    Pool.prototype.release = function (object) {
        this.destroy(object);
        this.objects.push(object);
        return this;
    };
    return Pool;
}());
exports.default = Pool;

},{}],55:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __importDefault(_dereq_("./utils"));
var TupleDictionary = /** @class */ (function () {
    /**
     * @class TupleDictionary
     * @constructor
     */
    function TupleDictionary() {
        /**
         * The data storage
         * @property data
         * @type {Object}
         */
        this.data = {};
        /**
         * Keys that are currently used.
         * @property {Array} keys
         */
        this.keys = [];
    }
    /**
     * Generate a key given two integers
     * @method getKey
     * @param  {number} i
     * @param  {number} j
     * @return {number}
     */
    TupleDictionary.prototype.getKey = function (id1, id2) {
        if ((id1) === (id2)) {
            return -1;
        }
        // valid for values < 2^16
        return ((id1) > (id2) ?
            (id1 << 16) | (id2 & 0xFFFF) :
            (id2 << 16) | (id1 & 0xFFFF)) | 0;
    };
    /**
     * @method getByKey
     * @param  {Number} key
     * @return {Object}
     */
    TupleDictionary.prototype.getByKey = function (key) {
        key = key;
        return this.data[key];
    };
    /**
     * @method get
     * @param  {Number} i
     * @param  {Number} j
     * @return {Number}
     */
    TupleDictionary.prototype.get = function (i, j) {
        return this.data[this.getKey(i, j)];
    };
    /**
     * Set a value.
     * @method set
     * @param  {Number} i
     * @param  {Number} j
     * @param {Number} value
     */
    TupleDictionary.prototype.set = function (i, j, value) {
        if (!value) {
            throw new Error("No data!");
        }
        var key = this.getKey(i, j);
        // Check if key already exists
        if (!this.data[key]) {
            this.keys.push(key);
        }
        this.data[key] = value;
        return key;
    };
    /**
     * Remove all data.
     * @method reset
     */
    TupleDictionary.prototype.reset = function () {
        var data = this.data, keys = this.keys;
        var l = keys.length;
        while (l--) {
            delete data[keys[l]];
        }
        keys.length = 0;
    };
    /**
     * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
     * @method copy
     * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
     */
    TupleDictionary.prototype.copy = function (dict) {
        this.reset();
        utils_1.default.appendArray(this.keys, dict.keys);
        var l = dict.keys.length;
        while (l--) {
            var key = dict.keys[l];
            this.data[key] = dict.data[key];
        }
    };
    return TupleDictionary;
}());
exports.default = TupleDictionary;

},{"./utils":56}],56:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* global P2_ARRAY_TYPE */
/**
 * Misc utility functions
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
     * @method appendArray
     * @static
     * @param  {Array} a
     * @param  {Array} b
     */
    Utils.prototype.appendArray = function (a, b) {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    };
    /**
     * Garbage free Array.splice(). Does not allocate a new array.
     * @method splice
     * @static
     * @param  {Array} array
     * @param  {Number} index
     * @param  {Number} howmany
     */
    Utils.prototype.splice = function (array, index, howmany) {
        howmany = howmany || 1;
        for (var i = index, len = array.length - howmany; i < len; i++) {
            array[i] = array[i + howmany];
        }
        array.length = len;
    };
    /**
     * Remove an element from an array, if the array contains the element.
     * @method arrayRemove
     * @static
     * @param  {Array} array
     * @param  {Number} element
     */
    Utils.prototype.arrayRemove = function (array, element) {
        var idx = array.indexOf(element);
        if (idx !== -1) {
            this.splice(array, idx, 1);
        }
    };
    /**
     * Extend an object with the properties of another
     * @static
     * @method extend
     * @param  {object} a
     * @param  {object} b
     */
    Utils.prototype.extend = function (a, b) {
        for (var key in b) {
            a[key] = b[key];
        }
    };
    /**
     * Shallow clone an object. Returns a new object instance with the same properties as the input instance.
     * @static
     * @method shallowClone
     * @param  {object} obj
     */
    Utils.prototype.shallowClone = function (obj) {
        var newObj = {};
        this.extend(newObj, obj);
        return newObj;
    };
    return Utils;
}());
exports.default = new Utils();

},{}],57:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnionFind = /** @class */ (function () {
    /**
     * Weighted Quick Union-Find with Path Compression. Based on https://github.com/juzerali/unionfind, but optimized for performance.
     * @class UnionFind
     * @constructor
     * @param {number} size
     */
    function UnionFind(size) {
        this.id = [];
        this.sz = [];
        /**
         * The number of elements.
         * @property {number} size
         */
        this.size = size;
        /**
         * The number of distinct groups.
         * @property {number} count
         */
        this.count = size;
        this.resize(size);
    }
    /**
     * Initialize the UnionFind data structure with number of distinct groups to begin with. Each group will be referred to as index of the array of size size starting at 0.
     * @method resize
     * @param {number} size
     */
    UnionFind.prototype.resize = function (size) {
        this.count = this.size = size;
        var sz = this.sz;
        var id = this.id;
        for (var i = 0; i < size; i++) {
            id[i] = i;
            sz[i] = 1;
        }
    };
    /**
     * Return the root (value) of the group in which p is.
     * @method find
     * @param {number} p
     */
    UnionFind.prototype.find = function (p) {
        var id = this.id;
        while (p !== id[p]) {
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    };
    /**
     * Combine elements in groups p and q into a single group. In other words connect the two groups.
     * @method union
     * @param {number} p
     * @param {number} q
     */
    UnionFind.prototype.union = function (p, q) {
        var i = this.find(p), j = this.find(q);
        if (i === j) {
            return;
        }
        var sz = this.sz;
        var id = this.id;
        if (sz[i] < sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        }
        else {
            id[j] = i;
            sz[i] += sz[j];
        }
        this.count--;
        return;
    };
    return UnionFind;
}());
exports.default = UnionFind;

},{}],58:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gs_solver_1 = __importDefault(_dereq_("../solver/gs-solver"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var shape_1 = __importDefault(_dereq_("../shapes/shape"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var body_1 = __importDefault(_dereq_("../objects/body"));
var material_1 = __importDefault(_dereq_("../material/material"));
var contact_material_1 = __importDefault(_dereq_("../material/contact-material"));
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var sap_broadphase_1 = __importDefault(_dereq_("../collision/sap-broadphase"));
var narrowphase_1 = __importDefault(_dereq_("../collision/narrowphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
//import arrayRemove from  "ayRemo"; // Get rid of this dependency!
var overlap_keeper_1 = __importDefault(_dereq_("../utils/overlap-keeper"));
var union_find_1 = __importDefault(_dereq_("./union-find"));
//import f32 from "f32";
/**
 * Fired after the step().
 * @event postStep
 */
var postStepEvent = {
    type: "postStep"
};
/**
 * Fired when a body is added to the world.
 * @event addBody
 * @param {Body} body
 */
var AddBodyEvent = /** @class */ (function () {
    function AddBodyEvent() {
        this.type = "addBody";
        this.body = null;
    }
    return AddBodyEvent;
}());
var addBodyEvent = new AddBodyEvent();
/**
 * Fired when a body is removed from the world.
 * @event removeBody
 * @param {Body} body
 */
var RemoveBodyEvent = /** @class */ (function () {
    function RemoveBodyEvent() {
        this.type = "removeBody";
        this.body = null;
    }
    return RemoveBodyEvent;
}());
var removeBodyEvent = new RemoveBodyEvent();
/**
 * Fired when a spring is added to the world.
 * @event addSpring
 * @param {Spring} spring
 */
var AddSpringEvent = /** @class */ (function () {
    function AddSpringEvent() {
        this.type = "addSpring";
        this.spring = null;
    }
    return AddSpringEvent;
}());
var addSpringEvent = new AddSpringEvent();
/**
 * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
 * @event impact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @deprecated Impact event will be removed. Use beginContact instead.
 */
var ImpactEvent = /** @class */ (function () {
    function ImpactEvent() {
        this.type = "impact";
        this.bodyA = null;
        this.bodyB = null;
        this.shapeA = null;
        this.shapeB = null;
        this.contactEquation = null;
    }
    return ImpactEvent;
}());
var impactEvent = new ImpactEvent();
/**
 * Fired after the Broadphase has collected collision pairs in the world.
 * Inside the event handler, you can modify the pairs array as you like, to
 * prevent collisions between objects that you don't want.
 * @event postBroadphase
 * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
 */
var PostBroadphaseEvent = /** @class */ (function () {
    function PostBroadphaseEvent() {
        this.type = "postBroadphase";
        this.pairs = null;
    }
    return PostBroadphaseEvent;
}());
var postBroadphaseEvent = new PostBroadphaseEvent;
var BeginContactEvent = /** @class */ (function () {
    function BeginContactEvent() {
        this.type = "beginContact";
        this.shapeA = null;
        this.shapeB = null;
        this.bodyA = null;
        this.bodyB = null;
        this.contactEquations = [];
    }
    return BeginContactEvent;
}());
/**
 * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
 * @event beginContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 * @param {Array} contactEquations
 */
var beginContactEvent = new BeginContactEvent();
/**
 * Fired when two shapes stop overlapping, after the narrowphase (during step).
 * @event endContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 */
var endContactEvent = {
    type: "endContact",
    shapeA: null,
    shapeB: null,
    bodyA: null,
    bodyB: null
};
var hitTest_tmp1 = vec2_1.default.create(), hitTest_tmp2 = vec2_1.default.create();
/**
 * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
 * @event preSolve
 * @param {Array} contactEquations  An array of contacts to be solved.
 * @param {Array} frictionEquations An array of friction equations to be solved.
 */
var PreSolveEvent = /** @class */ (function () {
    function PreSolveEvent() {
        this.type = "preSolve";
        this.contactEquations = null;
        this.frictionEquations = null;
    }
    return PreSolveEvent;
}());
var preSolveEvent = new PreSolveEvent();
function sortBodiesByIsland(a, b) {
    return a.islandId - b.islandId;
}
function sortEquationsByIsland(equationA, equationB) {
    if (!(equationA === null || equationA === void 0 ? void 0 : equationA.bodyA) || !(equationA === null || equationA === void 0 ? void 0 : equationA.bodyB) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyA) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyB))
        return 0;
    var islandA = equationA.bodyA.islandId > 0 ? equationA.bodyA.islandId : equationA.bodyB.islandId;
    var islandB = equationB.bodyA.islandId > 0 ? equationB.bodyA.islandId : equationB.bodyB.islandId;
    if (islandA !== islandB) {
        return islandA - islandB;
    }
    else {
        // Sort by equation type if same island
        return equationA.index - equationB.index;
    }
}
// Why not just make this a private method in world?
// What are all these props???
function runNarrowphase(world, np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
    var xiw = vec2_1.default.create();
    var xjw = vec2_1.default.create();
    // Check collision groups and masks
    if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
        return;
    }
    // Get world position and angle of each shape
    vec2_1.default.toGlobalFrame(xiw, xi, bi.position, bi.angle);
    vec2_1.default.toGlobalFrame(xjw, xj, bj.position, bj.angle);
    if (vec2_1.default.distance(xiw, xjw) > si.boundingRadius + sj.boundingRadius) {
        return;
    }
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;
    np.enableFriction = cm.friction > 0;
    var reducedMass;
    if (bi.type === body_1.default.STATIC || bi.type === body_1.default.KINEMATIC) {
        reducedMass = bj.mass;
    }
    else if (bj.type === body_1.default.STATIC || bj.type === body_1.default.KINEMATIC) {
        reducedMass = bi.mass;
    }
    else {
        reducedMass = (bi.mass * bj.mass) / (bi.mass + bj.mass);
    }
    np.slipForce = cm.friction * glen * reducedMass;
    np.currentContactMaterial = cm;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    var sensor = si.sensor || sj.sensor;
    var numFrictionBefore = np.frictionEquations.length;
    var numContacts = np.testContact(bi, si, xiw, bj, sj, xjw, sensor);
    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
    if (numContacts) {
        if (bi.allowSleep &&
            bi.type === body_1.default.DYNAMIC &&
            bi.sleepState === body_1.default.SLEEPING &&
            bj.sleepState === body_1.default.AWAKE &&
            bj.type !== body_1.default.STATIC) {
            var speedSquaredB = vec2_1.default.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
            if (speedSquaredB >= speedLimitSquaredB * 2) {
                bi._wakeUpAfterNarrowphase = true;
            }
        }
        if (bj.allowSleep &&
            bj.type === body_1.default.DYNAMIC &&
            bj.sleepState === body_1.default.SLEEPING &&
            bi.sleepState === body_1.default.AWAKE &&
            bi.type !== body_1.default.STATIC) {
            var speedSquaredA = vec2_1.default.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
            if (speedSquaredA >= speedLimitSquaredA * 2) {
                bj._wakeUpAfterNarrowphase = true;
            }
        }
        world.overlapKeeper.setOverlapping(bi, si, bj, sj);
        if (world.has('beginContact') && world.overlapKeeper.isNewOverlap(si, sj)) {
            // Report new shape overlap
            var e = beginContactEvent;
            e.shapeA = si;
            e.shapeB = sj;
            e.bodyA = bi;
            e.bodyB = bj;
            // Reset contact equations
            e.contactEquations.length = 0;
            if (!sensor) {
                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                    e.contactEquations.push(np.contactEquations[i]);
                }
            }
            world.emit(e);
        }
        // divide the max friction force by the number of contacts
        if (!sensor && numFrictionEquations > 1) { // Why divide by 1?
            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                var f = np.frictionEquations[i];
                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
            }
        }
    }
}
function setGlobalEquationParams(world, params) {
    var _a, _b;
    var constraints = world.constraints;
    for (var i = 0; i !== constraints.length; i++) {
        var c = constraints[i];
        var eqs = c.equations;
        for (var j = 0; j !== eqs.length; j++) {
            var eq = eqs[j];
            eq.relaxation = (_a = params === null || params === void 0 ? void 0 : params.relaxation) !== null && _a !== void 0 ? _a : eq.relaxation;
            eq.stiffness = (_b = params === null || params === void 0 ? void 0 : params.stiffness) !== null && _b !== void 0 ? _b : eq.stiffness;
            eq.needsUpdate = true;
        }
    }
}
var World = /** @class */ (function (_super) {
    __extends(World, _super);
    /**
     * The dynamics world, where all bodies and constraints live.
     *
     * @class World
     * @constructor
     * @param {Object} [options]
     * @param {Solver} [options.solver] Defaults to GSSolver.
     * @param {Array} [options.gravity] Defaults to y=-9.78.
     * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
     * @param {Boolean} [options.islandSplit=true]
     * @extends EventEmitter
     *
     * @example
     *     var world = new World({
     *         gravity: [0, -10],
     *         broadphase: new SAPBroadphase()
     *     });
     *     world.addBody(new Body());
     */
    function World(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this) || this;
        /**
         * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
         *
         * @property springs
         * @type {Array}
         */
        _this.springs = [];
        /**
         * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
         * @property {Array} bodies
         */
        _this.bodies = [];
        /**
         * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
         * @private
         * @property {Array} disabledBodyCollisionPairs
         */
        _this.disabledBodyCollisionPairs = [];
        /**
         * The narrowphase to use to generate contacts.
         *
         * @property narrowphase
         * @type {Narrowphase}
         */
        _this.narrowphase = new narrowphase_1.default();
        /**
         * Gravity in the world. This is applied on all bodies in the beginning of each step().
         *
         * @property gravity
         * @type {Array}
         */
        _this.gravity = vec2_1.default.fromValues(0, -9.78);
        /**
         * Gravity to use when approximating the friction max force (mu*mass*gravity).
         * @property {Number} frictionGravity
         */
        _this.frictionGravity = 10;
        /**
         * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
         * @property {Boolean} useWorldGravityAsFrictionGravity
         * @default true
         */
        _this.useWorldGravityAsFrictionGravity = true;
        /**
         * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
         * @property {Boolean} useFrictionGravityOnZeroGravity
         * @default true
         */
        _this.useFrictionGravityOnZeroGravity = true;
        /**
         * User-added constraints.
         *
         * @property constraints
         * @type {Array}
         */
        _this.constraints = [];
        /**
         * Dummy default material in the world, used in .defaultContactMaterial
         * @property {Material} defaultMaterial
         */
        _this.defaultMaterial = new material_1.default();
        /**
         * For keeping track of what time step size we used last step
         * @property lastTimeStep
         * @type {Number}
         */
        _this.lastTimeStep = 1 / 60;
        /**
         * Enable to automatically apply spring forces each step.
         * @property applySpringForces
         * @type {Boolean}
         * @default true
         */
        _this.applySpringForces = true;
        /**
         * Enable to automatically apply body damping each step.
         * @property applyDamping
         * @type {Boolean}
         * @default true
         */
        _this.applyDamping = true;
        /**
         * Enable to automatically apply gravity each step.
         * @property applyGravity
         * @type {Boolean}
         * @default true
         */
        _this.applyGravity = true;
        /**
         * Enable/disable constraint solving in each step.
         * @property solveConstraints
         * @type {Boolean}
         * @default true
         */
        _this.solveConstraints = true;
        /**
         * The ContactMaterials added to the World.
         * @property contactMaterials
         * @type {Array}
         */
        _this.contactMaterials = [];
        /**
         * World time.
         * @property time
         * @type {Number}
         */
        _this.time = 0.0;
        _this.accumulator = 0;
        /**
         * Is true during step().
         * @property {Boolean} stepping
         */
        _this.stepping = false;
        /**
         * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance.
         * @property {Boolean} islandSplit
         * @default false
         */
        _this.islandSplit = true;
        /**
         * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
         * @property emitImpactEvent
         * @type {Boolean}
         * @default true
         * @deprecated Impact event will be removed. Use beginContact instead.
         */
        _this.emitImpactEvent = true;
        /**
         * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
         * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
         * @property sleepMode
         * @type {number}
         * @default World.NO_SLEEPING
         */
        _this.sleepMode = World.NO_SLEEPING;
        /**
         * @property {UnionFind} unionFind
         */
        _this.unionFind = new union_find_1.default(1);
        // Id counters
        _this._constraintIdCounter = 0;
        _this._bodyIdCounter = 0;
        /**
         * @property {OverlapKeeper} overlapKeeper
         */
        _this.overlapKeeper = new overlap_keeper_1.default();
        _this.solver = (_a = options === null || options === void 0 ? void 0 : options.solver) !== null && _a !== void 0 ? _a : new gs_solver_1.default();
        if (options === null || options === void 0 ? void 0 : options.gravity) {
            vec2_1.default.copy(_this.gravity, options.gravity);
        }
        _this.frictionGravity = (_b = vec2_1.default.length(_this.gravity)) !== null && _b !== void 0 ? _b : 10;
        _this.broadphase = (_c = options === null || options === void 0 ? void 0 : options.broadphase) !== null && _c !== void 0 ? _c : new sap_broadphase_1.default();
        _this.broadphase.setWorld(_this);
        _this.defaultContactMaterial = new contact_material_1.default(_this.defaultMaterial, _this.defaultMaterial);
        _this.islandSplit = (_d = options === null || options === void 0 ? void 0 : options.islandSplit) !== null && _d !== void 0 ? _d : true;
        return _this;
    }
    /**
     * Add a constraint to the simulation. Note that both bodies connected to the constraint must be added to the world first. Also note that you can't run this method during step.
     *
     * @method addConstraint
     * @param {Constraint} constraint
     * @example
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    World.prototype.addConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be added during step.');
        }
        var bodies = this.bodies;
        if (bodies.indexOf(constraint.bodyA) === -1) {
            throw new Error('Cannot add Constraint: bodyA is not added to the World.');
        }
        if (bodies.indexOf(constraint.bodyB) === -1) {
            throw new Error('Cannot add Constraint: bodyB is not added to the World.');
        }
        this.constraints.push(constraint);
    };
    /**
     * Add a ContactMaterial to the simulation.
     * @method addContactMaterial
     * @param {ContactMaterial} contactMaterial
     */
    World.prototype.addContactMaterial = function (contactMaterial) {
        this.contactMaterials.push(contactMaterial);
    };
    /**
     * Removes a contact material
     *
     * @method removeContactMaterial
     * @param {ContactMaterial} cm
     */
    World.prototype.removeContactMaterial = function (cm) {
        utils_1.default.arrayRemove(this.contactMaterials, cm);
    };
    /**
     * Get a contact material given two materials
     * @method getContactMaterial
     * @param {Material} materialA
     * @param {Material} materialB
     * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
     * @todo Use faster hash map to lookup from material id's
     */
    World.prototype.getContactMaterial = function (materialA, materialB) {
        var cmats = this.contactMaterials;
        for (var i = 0, N = cmats.length; i !== N; i++) {
            var cm = cmats[i];
            if ((cm.materialA === materialA && cm.materialB === materialB) || (cm.materialA === materialB && cm.materialB === materialA)) {
                return cm;
            }
        }
        return null;
    };
    /**
     * Removes a constraint. Note that you can't run this method during step.
     *
     * @method removeConstraint
     * @param {Constraint} constraint
     */
    World.prototype.removeConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.constraints, constraint);
    };
    /**
     * Step the physics world forward in time.
     *
     * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
     *
     * @method step
     * @param {Number} dt                       The fixed time step size to use.
     * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
     * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
     *
     * @example
     *     // Simple fixed timestepping without interpolation
     *     var fixedTimeStep = 1 / 60;
     *     var world = new World();
     *     var body = new Body({ mass: 1 });
     *     world.addBody(body);
     *
     *     function animate(){
     *         requestAnimationFrame(animate);
     *         world.step(fixedTimeStep);
     *         renderBody(body.position, body.angle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @example
     *     // Fixed timestepping with interpolation
     *     var maxSubSteps = 10;
     *     var lastTimeSeconds;
     *
     *     function animate(time){
     *         requestAnimationFrame(animate);
     *         var timeSeconds = time / 1000;
     *
     *         if(lastTimeSeconds){
     *             var deltaTime = timeSeconds - lastTimeSeconds;
     *             world.step(fixedTimeStep, deltaTime, maxSubSteps);
     *         }
     *
     *         lastTimeSeconds = timeSeconds;
     *
     *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
     */
    World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
        maxSubSteps = maxSubSteps || 10;
        timeSinceLastCalled = timeSinceLastCalled || 0;
        if (timeSinceLastCalled === 0) { // Fixed, simple stepping
            this.internalStep(dt);
            // Increment time
            this.time += dt;
        }
        else {
            this.accumulator += timeSinceLastCalled;
            var substeps = 0;
            while (this.accumulator >= dt && substeps < maxSubSteps) {
                // Do fixed steps to catch up
                this.internalStep(dt);
                this.time += dt;
                this.accumulator -= dt;
                substeps++;
            }
            var t = (this.accumulator % dt) / dt;
            for (var j = 0; j !== this.bodies.length; j++) {
                var b = this.bodies[j];
                vec2_1.default.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
                b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
            }
        }
    };
    /**
     * Make a fixed step.
     * @method internalStep
     * @param  {number} dt
     * @private
     */
    World.prototype.internalStep = function (dt) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var step_mg = vec2_1.default.create();
        var endOverlaps = [];
        this.stepping = true;
        var Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, mg = step_mg, add = vec2_1.default.add;
        this.overlapKeeper.tick();
        this.lastTimeStep = dt;
        // Update approximate friction gravity.
        if (this.useWorldGravityAsFrictionGravity) {
            var gravityLen = vec2_1.default.length(this.gravity);
            if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                // Nonzero gravity. Use it.
                this.frictionGravity = gravityLen;
            }
        }
        // Add gravity to bodies
        if (this.applyGravity) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i], fi = b.force;
                if (b.type !== body_1.default.DYNAMIC || b.sleepState === body_1.default.SLEEPING) {
                    continue;
                }
                vec2_1.default.scale(mg, g, b.mass * b.gravityScale); // F=m*g
                add(fi, fi, mg);
            }
        }
        // Add spring forces
        if (this.applySpringForces) {
            for (var i = 0; i !== Nsprings; i++) {
                var s = springs[i];
                s.applyForce();
            }
        }
        if (this.applyDamping) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                if (b.type === body_1.default.DYNAMIC) {
                    b.applyDamping(dt);
                }
            }
        }
        // Broadphase
        var result = broadphase.getCollisionPairs(this);
        // Remove ignored collision pairs
        var ignoredPairs = this.disabledBodyCollisionPairs;
        for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
            for (var j = result.length - 2; j >= 0; j -= 2) {
                if ((ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1]) ||
                    (ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1])) {
                    result.splice(j, 2);
                }
            }
        }
        // Remove constrained pairs with collideConnected == false
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            var c = constraints[i];
            if (!c.collideConnected) {
                for (var j = result.length - 2; j >= 0; j -= 2) {
                    if ((c.bodyA === result[j] && c.bodyB === result[j + 1]) ||
                        (c.bodyB === result[j] && c.bodyA === result[j + 1])) {
                        result.splice(j, 2);
                    }
                }
            }
        }
        // postBroadphase event
        postBroadphaseEvent.pairs = result;
        this.emit(postBroadphaseEvent);
        postBroadphaseEvent.pairs = null;
        // Narrowphase
        np.reset();
        var defaultContactMaterial = this.defaultContactMaterial;
        var frictionGravity = this.frictionGravity;
        for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
            var bi = result[i], bj = result[i + 1];
            // Loop over all shapes of body i
            for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                var si = bi.shapes[k], xi = si.position, ai = si.angle;
                // All shapes of body j
                for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                    var sj = bj.shapes[l], xj = sj.position, aj = sj.angle;
                    var contactMaterial = null;
                    if (si.material && sj.material) {
                        contactMaterial = this.getContactMaterial(si.material, sj.material);
                    }
                    runNarrowphase(this, np, bi, si, xi, ai, bj, sj, xj, aj, contactMaterial !== null && contactMaterial !== void 0 ? contactMaterial : defaultContactMaterial, frictionGravity);
                }
            }
        }
        // Wake up bodies
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body._wakeUpAfterNarrowphase) {
                body.wakeUp();
                body._wakeUpAfterNarrowphase = false;
            }
        }
        // Emit end overlap events
        if (_super.prototype.has.call(this, "endContact")) {
            this.overlapKeeper.getEndOverlaps(endOverlaps);
            var e = endContactEvent;
            var l = endOverlaps.length;
            while (l--) {
                var data = endOverlaps[l];
                e.shapeA = data.shapeA;
                e.shapeB = data.shapeB;
                e.bodyA = data.bodyA;
                e.bodyB = data.bodyB;
                this.emit(e);
            }
            endOverlaps.length = 0;
        }
        preSolveEvent.contactEquations = np.contactEquations;
        preSolveEvent.frictionEquations = np.frictionEquations;
        this.emit(preSolveEvent);
        preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
        // update constraint equations
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            constraints[i].update();
        }
        if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
            // Get all equations
            var equations = [];
            utils_1.default.appendArray(equations, np.contactEquations);
            utils_1.default.appendArray(equations, np.frictionEquations);
            for (i = 0; i !== Nconstraints; i++) {
                utils_1.default.appendArray(equations, constraints[i].equations);
            }
            if (this.islandSplit) {
                // Initialize the UnionFind
                var unionFind = this.unionFind;
                unionFind.resize(this.bodies.length + 1);
                // Update equation index
                for (var i = 0; i < equations.length; i++) {
                    equations[i].index = i;
                }
                // Unite bodies if they are connected by an equation
                for (var i = 0; i < equations.length; i++) {
                    var bodyA = equations[i].bodyA;
                    var bodyB = equations[i].bodyB;
                    if (!bodyA || !bodyB)
                        continue;
                    if (bodyA.type === body_1.default.DYNAMIC && bodyB.type === body_1.default.DYNAMIC) {
                        unionFind.union(bodyA.index, bodyB.index);
                    }
                }
                // Find the body islands
                for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    body.islandId = body.type === body_1.default.DYNAMIC ? unionFind.find(body.index) : -1;
                }
                // Sort equations by island
                equations = equations.sort(sortEquationsByIsland);
                var equationIndex = 0;
                while (equationIndex < equations.length) {
                    var equation = equations[equationIndex++];
                    solver.addEquation(equation);
                    if (!equation.bodyA || !equation.bodyB)
                        continue;
                    var currentIslandId = equation.bodyA.islandId > 0 ? equation.bodyA.islandId : equation.bodyB.islandId;
                    var nextIslandId = -1;
                    var ei = equations[equationIndex];
                    if (ei) {
                        if (ei.bodyA && ei.bodyB)
                            continue;
                        nextIslandId = ((_b = (_a = ei.bodyA) === null || _a === void 0 ? void 0 : _a.islandId) !== null && _b !== void 0 ? _b : 0) > 0 ? (_d = (_c = ei.bodyA) === null || _c === void 0 ? void 0 : _c.islandId) !== null && _d !== void 0 ? _d : 0 : (_f = (_e = ei.bodyB) === null || _e === void 0 ? void 0 : _e.islandId) !== null && _f !== void 0 ? _f : 0;
                    }
                    if (nextIslandId !== currentIslandId || equationIndex === equations.length) {
                        // Solve this island
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
            }
            else {
                // Solve all as one island
                solver.addEquations(equations);
                if (this.solveConstraints) {
                    solver.solve(dt, this);
                }
                solver.removeAllEquations();
            }
        }
        // Step forward
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body.type === body_1.default.DYNAMIC || body.type === body_1.default.KINEMATIC) {
                body.integrate(dt);
            }
        }
        // Reset force
        for (var i = 0; i !== Nbodies; i++) {
            bodies[i].setZeroForce();
        }
        // Emit impact event
        if (this.emitImpactEvent && this.has('impact')) {
            var ev = impactEvent;
            for (var i = 0; i !== np.contactEquations.length; i++) {
                var eq = np.contactEquations[i];
                if (eq.firstImpact) {
                    ev.bodyA = (_g = eq.bodyA) !== null && _g !== void 0 ? _g : null;
                    ev.bodyB = (_h = eq.bodyB) !== null && _h !== void 0 ? _h : null;
                    ev.shapeA = eq.shapeA;
                    ev.shapeB = eq.shapeB;
                    ev.contactEquation = eq;
                    this.emit(ev);
                }
            }
        }
        // Sleeping update
        if (this.sleepMode === World.BODY_SLEEPING) {
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, false, dt);
            }
        }
        else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
            // Tell all bodies to sleep tick but dont sleep yet
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, true, dt);
            }
            // Sleep islands
            var bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);
            var islandEnd = 1;
            for (var islandStart = 0; islandStart < bodiesSortedByIsland.length; islandStart = islandEnd) {
                var islandId = bodiesSortedByIsland[islandStart].islandId;
                // Get islandEnd index
                /* jshint ignore:start */
                for (islandEnd = islandStart + 1; islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++) { }
                /* jshint ignore:end */
                // Don't check static objects
                if (islandId === -1) {
                    continue;
                }
                var islandShouldSleep = true;
                for (var i = islandStart; i < islandEnd; i++) {
                    if (!bodiesSortedByIsland[i].wantsToSleep) {
                        islandShouldSleep = false;
                        break;
                    }
                }
                if (islandShouldSleep) {
                    for (var i = islandStart; i < islandEnd; i++) {
                        bodiesSortedByIsland[i].sleep();
                    }
                }
            }
        }
        this.stepping = false;
        _super.prototype.emit.call(this, postStepEvent);
    };
    /**
     * Add a spring to the simulation. Note that this operation can't be done during step.
     *
     * @method addSpring
     * @param {Spring} spring
     */
    World.prototype.addSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be added during step.');
        }
        this.springs.push(spring);
        addSpringEvent.spring = spring;
        this.emit(addSpringEvent);
        addSpringEvent.spring = null;
    };
    /**
     * Remove a spring. Note that this operation can't be done during step.
     *
     * @method removeSpring
     * @param {Spring} spring
     */
    World.prototype.removeSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.springs, spring);
    };
    /**
     * Add a body to the simulation. Note that you can't add a body during step: you have to wait until after the step (see the postStep event).
     * Also note that bodies can only be added to one World at a time.
     *
     * @method addBody
     * @param {Body} body
     *
     * @example
     *     var world = new World(),
     *         body = new Body();
     *     world.addBody(body);
     */
    World.prototype.addBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be added during step.');
        }
        // Already added?
        if (body.world) {
            throw new Error('Body is already added to a World.');
        }
        body.index = this.bodies.length;
        this.bodies.push(body);
        body.world = this;
        addBodyEvent.body = body;
        this.emit(addBodyEvent);
        addBodyEvent.body = null;
    };
    /**
     * Remove a body from the simulation. Note that bodies cannot be removed during step (for example, inside the beginContact event). In that case you need to wait until the step is done (see the postStep event).
     *
     * Also note that any constraints connected to the body must be removed before the body.
     *
     * @method removeBody
     * @param {Body} body
     *
     * @example
     *     var removeBody;
     *     world.on("beginContact",function(event){
     *         // We cannot remove the body here since the world is still stepping.
     *         // Instead, schedule the body to be removed after the step is done.
     *         removeBody = body;
     *     });
     *     world.on("postStep",function(event){
     *         if(removeBody){
     *             // Safely remove the body from the world.
     *             world.removeBody(removeBody);
     *             removeBody = null;
     *         }
     *     });
     */
    World.prototype.removeBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be removed during step.');
        }
        // TODO: would it be smart to have a .constraints array on the body?
        var constraints = this.constraints;
        var l = constraints.length;
        while (l--) {
            if (constraints[l].bodyA === body || constraints[l].bodyB === body) {
                throw new Error('Cannot remove Body from World: it still has constraints connected to it.');
            }
        }
        body.world = null;
        var bodies = this.bodies;
        utils_1.default.arrayRemove(bodies, body);
        body.index = -1;
        var l = bodies.length;
        while (l--) {
            bodies[l].index = l;
        }
        // Emit removeBody event
        removeBodyEvent.body = body;
        body.resetConstraintVelocity();
        this.emit(removeBodyEvent);
        removeBodyEvent.body = null;
        // Remove disabled body collision pairs that involve body
        var pairs = this.disabledBodyCollisionPairs;
        var i = 0;
        while (i < pairs.length) {
            if (pairs[i] === body || pairs[i + 1] === body) {
                pairs.splice(i, 2);
            }
            else {
                i += 2;
            }
        }
    };
    /**
     * Get a body by its id.
     * @method getBodyById
     * @param {number} id
     * @return {Body} The body, or false if it was not found.
     */
    World.prototype.getBodyById = function (id) {
        var bodies = this.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.id === id) {
                return b;
            }
        }
        return null;
    };
    /**
     * Disable collision between two bodies
     * @method disableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.disableBodyCollision = function (bodyA, bodyB) {
        this.disabledBodyCollisionPairs.push(bodyA);
        this.disabledBodyCollisionPairs.push(bodyB);
    };
    /**
     * Enable collisions between the given two bodies, if they were previously disabled using .disableBodyCollision().
     * @method enableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.enableBodyCollision = function (bodyA, bodyB) {
        var pairs = this.disabledBodyCollisionPairs;
        for (var i = 0; i < pairs.length; i += 2) {
            if ((pairs[i] === bodyA && pairs[i + 1] === bodyB) || (pairs[i + 1] === bodyA && pairs[i] === bodyB)) {
                pairs.splice(i, 2);
                return;
            }
        }
    };
    /**
     * Removes all bodies, constraints, springs, and contact materials from the world.
     * @method clear
     */
    World.prototype.clear = function () {
        // Remove all solver equations
        this.solver.removeAllEquations();
        // Remove all constraints
        var cs = this.constraints;
        var i = cs.length;
        while (i--) {
            this.removeConstraint(cs[i]);
        }
        // Remove all bodies
        var bodies = this.bodies;
        i = bodies.length;
        while (i--) {
            this.removeBody(bodies[i]);
        }
        // Remove all springs
        var springs = this.springs;
        i = springs.length;
        while (i--) {
            this.removeSpring(springs[i]);
        }
        // Remove all contact materials
        var cms = this.contactMaterials;
        i = cms.length;
        while (i--) {
            this.removeContactMaterial(cms[i]);
        }
    };
    /**
     * Test if a world point overlaps bodies
     * @method hitTest
     * @param  {Array} worldPoint Point to use for intersection tests
     * @param  {Array} bodies A list of objects to check for intersection
     * @param  {Number} precision Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
     * @return {Array} Array of bodies that overlap the point
     * @todo Should use an api similar to the raycast function
     * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
     * @todo Should use the broadphase
     * @todo Returning the hit shape would be fine - it carries a reference to the body now
     */
    World.prototype.hitTest = function (worldPoint, bodies, precision) {
        precision = precision || 0;
        // Create a dummy particle body with a particle shape to test against the bodies
        var shapeWorldPosition = hitTest_tmp1, shapeLocalPoint = hitTest_tmp2;
        var result = [];
        // Check bodies
        for (var i = 0, N = bodies.length; i !== N; i++) {
            var body = bodies[i];
            for (var j = 0, NS = body.shapes.length; j !== NS; j++) {
                var shape = body.shapes[j];
                // Get local point position in the shape
                shape.worldPointToLocal(shapeLocalPoint, worldPoint);
                if (shape.pointTest(shapeLocalPoint)) {
                    result.push(body);
                }
                else {
                    // Get shape world position
                    vec2_1.default.rotate(shapeWorldPosition, shape.position, body.angle);
                    vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
                    if (shape.type === shape_1.default.PARTICLE && vec2_1.default.squaredDistance(shapeWorldPosition, worldPoint) < precision * precision) {
                        result.push(body);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Set the stiffness for all equations and contact materials.
     * @method setGlobalStiffness
     * @param {Number} stiffness
     */
    World.prototype.setGlobalStiffness = function (stiffness) {
        setGlobalEquationParams(this, { stiffness: stiffness });
        // Set for all contact materials
        var contactMaterials = this.contactMaterials;
        for (var i = 0; i !== contactMaterials.length; i++) {
            var c = contactMaterials[i];
            c.stiffness = c.frictionStiffness = stiffness;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.stiffness = c.frictionStiffness = stiffness;
    };
    /**
     * Set the relaxation for all equations and contact materials.
     * @method setGlobalRelaxation
     * @param {Number} relaxation
     */
    World.prototype.setGlobalRelaxation = function (relaxation) {
        setGlobalEquationParams(this, { relaxation: relaxation });
        // Set for all contact materials
        for (var i = 0; i !== this.contactMaterials.length; i++) {
            var c = this.contactMaterials[i];
            c.relaxation = c.frictionRelaxation = relaxation;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.relaxation = c.frictionRelaxation = relaxation;
    };
    /**
     * Ray cast against all bodies in the world.
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @return {boolean} True if any body was hit.
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.CLOSEST, // or ANY
     *         from: [0, 0],
     *         to: [10, 0],
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     *
     *     // Get the hit point
     *     var hitPoint = vec2.create();
     *     result.getHitPoint(hitPoint, ray);
     *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.ALL,
     *         from: [0, 0],
     *         to: [10, 0],
     *         callback: function(result){
     *
     *             // Print some info about the hit
     *             console.log('Hit body and shape: ', result.body, result.shape);
     *
     *             // Get the hit point
     *             var hitPoint = vec2.create();
     *             result.getHitPoint(hitPoint, ray);
     *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     *             // If you are happy with the hits you got this far, you can stop the traversal here:
     *             result.stop();
     *         }
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     */
    World.prototype.raycast = function (result, ray) {
        var tmpAABB = new aabb_1.default();
        var tmpArray = [];
        // Get all bodies within the ray AABB
        ray.getAABB(tmpAABB);
        this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
        ray.intersectBodies(result, tmpArray);
        tmpArray.length = 0;
        return result.hasHit();
    };
    /**
     * Never deactivate bodies.
     * @static
     * @property {number} NO_SLEEPING
     */
    World.NO_SLEEPING = 1;
    /**
     * Deactivate individual bodies if they are sleepy.
     * @static
     * @property {number} BODY_SLEEPING
     */
    World.BODY_SLEEPING = 2;
    /**
     * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
     * @static
     * @property {number} ISLAND_SLEEPING
     */
    World.ISLAND_SLEEPING = 4;
    return World;
}(event_emitter_1.default));
exports.default = World;

},{"../collision/aabb":1,"../collision/narrowphase":4,"../collision/sap-broadphase":7,"../events/event-emitter":21,"../material/contact-material":24,"../material/material":25,"../math/vec2":28,"../objects/body":30,"../shapes/shape":46,"../solver/gs-solver":47,"../utils/overlap-keeper":53,"../utils/utils":56,"./union-find":57}]},{},[22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcam9zaF9cXE9uZURyaXZlXFxEZXNrdG9wXFxQUk9KRUNUU1xcR0lUSFVCXFxnZWFyYm94MmRcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYWFiYi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFpdmUtYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFycm93cGhhc2UuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3JheS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vcmF5Y2FzdC1yZXN1bHQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3NhcC1icm9hZHBoYXNlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL2NvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvZGlzdGFuY2UtY29uc3RyYWludC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb25zdHJhaW50cy9nZWFyLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvbG9jay1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3ByaXNtYXRpYy1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3Jldm9sdXRlLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvZXF1YXRpb25zL0VxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9hbmdsZS1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvbi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9lcXVhdGlvbnMvcm90YXRpb25hbC1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9yb3RhdGlvbmFsLXZlbG9jaXR5LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2V2ZW50cy9ldmVudC1lbWl0dGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2luZGV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL01hdGVyaWFsLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWwuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvbWF0aC9wb2x5LWRlY29tcC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9tYXRoL3BvbHlrLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGgvdmVjMi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9vYmplY3RzL0JvZHkuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9saW5lYXItc3ByaW5nLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL29iamVjdHMvcm90YXRpb25hbC1zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy90b3AtZG93bi12ZWhpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9Cb3guanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL0NpcmNsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvQ29udmV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9TaGFwZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvY2Fwc3VsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvaGVpZ2h0ZmllbGQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL2xpbmUuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL3BhcnRpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9wbGFuZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zb2x2ZXIvZ3Mtc29sdmVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NvbHZlci9zb2x2ZXIuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvY29udGFjdC1lcXVhdGlvbi1wb29sLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL292ZXJsYXAta2VlcGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL3Bvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvdHVwbGUtZGljdGlvbmFyeS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC91dGlscy91dGlscy5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC93b3JsZC91bmlvbi1maW5kLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3dvcmxkL3dvcmxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBBQUJCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGNsYXNzLlxyXG4gICAgICogQGNsYXNzIEFBQkJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMudXBwZXJCb3VuZF1cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG93ZXJCb3VuZF1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGFhYmIgPSBuZXcgQUFCQih7XHJcbiAgICAgKiAgICAgICAgIHVwcGVyQm91bmQ6IFsxLCAxXSxcclxuICAgICAqICAgICAgICAgbG93ZXJCb3VuZDogWy0xLCAtMV1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQUFCQihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50bXAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kID0gb3B0aW9ucy5sb3dlckJvdW5kID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5sb3dlckJvdW5kKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB1cHBlckJvdW5kXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IG9wdGlvbnMudXBwZXJCb3VuZCA/IHZlYzJfMS5kZWZhdWx0LmNsb25lKG9wdGlvbnMudXBwZXJCb3VuZCkgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cywgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBhbmdsZS5cclxuICAgICAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIHZlYzIncy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlPTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NraW5TaXplPTBdIFNvbWUgbWFyZ2luIHRvIGJlIGFkZGVkIHRvIHRoZSBBQUJCLlxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlLCBza2luU2l6ZSkge1xyXG4gICAgICAgIGlmIChza2luU2l6ZSA9PT0gdm9pZCAwKSB7IHNraW5TaXplID0gMDsgfVxyXG4gICAgICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLCB1ID0gdGhpcy51cHBlckJvdW5kO1xyXG4gICAgICAgIGFuZ2xlID0gYW5nbGUgfHwgMDtcclxuICAgICAgICAvLyBTZXQgdG8gdGhlIGZpcnN0IHBvaW50XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShsLCBwb2ludHNbMF0sIGFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkobCwgcG9pbnRzWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh1LCBsKTtcclxuICAgICAgICAvLyBDb21wdXRlIGNvc2luZXMgYW5kIHNpbmVzIGp1c3Qgb25jZVxyXG4gICAgICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKSwgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBwWzBdLCB5ID0gcFsxXTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG1wWzBdID0gY29zQW5nbGUgKiB4IC0gc2luQW5nbGUgKiB5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bXBbMV0gPSBzaW5BbmdsZSAqIHggKyBjb3NBbmdsZSAqIHk7XHJcbiAgICAgICAgICAgICAgICBwID0gdGhpcy50bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChwW2pdID4gdVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVbal0gPSBwW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBbal0gPCBsW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbFtqXSA9IHBbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIG9mZnNldFxyXG4gICAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQobCwgbCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQodSwgdSwgcG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2tpblNpemUpIHtcclxuICAgICAgICAgICAgbFswXSAtPSBza2luU2l6ZTtcclxuICAgICAgICAgICAgbFsxXSAtPSBza2luU2l6ZTtcclxuICAgICAgICAgICAgdVswXSArPSBza2luU2l6ZTtcclxuICAgICAgICAgICAgdVsxXSArPSBza2luU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXHJcbiAgICAgKiBAbWV0aG9kIGNvcHlcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChhYWJiKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnVwcGVyQm91bmQsIGFhYmIudXBwZXJCb3VuZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby5cclxuICAgICAqIEBtZXRob2QgZXh0ZW5kXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICAgKi9cclxuICAgIEFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChhYWJiKSB7XHJcbiAgICAgICAgdmFyIGxvd2VyID0gdGhpcy5sb3dlckJvdW5kLCB1cHBlciA9IHRoaXMudXBwZXJCb3VuZDtcclxuICAgICAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxyXG4gICAgICAgIHZhciBpID0gMjtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVuZCBsb3dlciBib3VuZFxyXG4gICAgICAgICAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZFtpXTtcclxuICAgICAgICAgICAgaWYgKGxvd2VyW2ldID4gbCkge1xyXG4gICAgICAgICAgICAgICAgbG93ZXJbaV0gPSBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwcGVyXHJcbiAgICAgICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xyXG4gICAgICAgICAgICBpZiAodXBwZXJbaV0gPCB1KSB7XHJcbiAgICAgICAgICAgICAgICB1cHBlcltpXSA9IHU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLlxyXG4gICAgICogQG1ldGhvZCBvdmVybGFwc1xyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQUFCQi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbiAoYWFiYikge1xyXG4gICAgICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCwgdTEgPSB0aGlzLnVwcGVyQm91bmQsIGwyID0gYWFiYi5sb3dlckJvdW5kLCB1MiA9IGFhYmIudXBwZXJCb3VuZDtcclxuICAgICAgICAvLyAgICAgIGwyICAgICAgICB1MlxyXG4gICAgICAgIC8vICAgICAgfC0tLS0tLS0tLXxcclxuICAgICAgICAvLyB8LS0tLS0tLS18XHJcbiAgICAgICAgLy8gbDEgICAgICAgdTFcclxuICAgICAgICByZXR1cm4gKChsMlswXSA8PSB1MVswXSAmJiB1MVswXSA8PSB1MlswXSkgfHwgKGwxWzBdIDw9IHUyWzBdICYmIHUyWzBdIDw9IHUxWzBdKSkgJiZcclxuICAgICAgICAgICAgKChsMlsxXSA8PSB1MVsxXSAmJiB1MVsxXSA8PSB1MlsxXSkgfHwgKGwxWzFdIDw9IHUyWzFdICYmIHUyWzFdIDw9IHUxWzFdKSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zUG9pbnRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwb2ludFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQUFCQi5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLCB1ID0gdGhpcy51cHBlckJvdW5kO1xyXG4gICAgICAgIHJldHVybiBsWzBdIDw9IHBvaW50WzBdICYmIHBvaW50WzBdIDw9IHVbMF0gJiYgbFsxXSA8PSBwb2ludFsxXSAmJiBwb2ludFsxXSA8PSB1WzFdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIEFBQkIgaXMgaGl0IGJ5IGEgcmF5LlxyXG4gICAgICogQG1ldGhvZCBvdmVybGFwc1JheVxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgaWYgbm8gaGl0LCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgaWYgaGl0LCBpbmRpY2F0aW5nIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIHRoZSBcImZyb21cIiBhbmQgXCJ0b1wiIHBvaW50cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGFhYmIgPSBuZXcgQUFCQih7XHJcbiAgICAgKiAgICAgICAgIHVwcGVyQm91bmQ6IFsxLCAxXSxcclxuICAgICAqICAgICAgICAgbG93ZXJCb3VuZDogWy0xLCAtMV1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XHJcbiAgICAgKiAgICAgICAgIGZyb206IFstMiwgMF0sXHJcbiAgICAgKiAgICAgICAgIHRvOiBbMCwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgZnJhY3Rpb24gPSBhYWJiLm92ZXJsYXBzUmF5KHJheSk7IC8vIGZyYWN0aW9uID09IDAuNVxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5vdmVybGFwc1JheSA9IGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICAvLyByYXkuZGlyZWN0aW9uIGlzIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBvZiByYXlcclxuICAgICAgICB2YXIgZGlyRnJhY1ggPSAxIC8gcmF5LmRpcmVjdGlvblswXTtcclxuICAgICAgICB2YXIgZGlyRnJhY1kgPSAxIC8gcmF5LmRpcmVjdGlvblsxXTtcclxuICAgICAgICAvLyB0aGlzLmxvd2VyQm91bmQgaXMgdGhlIGNvcm5lciBvZiBBQUJCIHdpdGggbWluaW1hbCBjb29yZGluYXRlcyAtIGxlZnQgYm90dG9tLCBydCBpcyBtYXhpbWFsIGNvcm5lclxyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIGxvd2VyQm91bmQgPSB0aGlzLmxvd2VyQm91bmQ7XHJcbiAgICAgICAgdmFyIHVwcGVyQm91bmQgPSB0aGlzLnVwcGVyQm91bmQ7XHJcbiAgICAgICAgdmFyIHQxID0gKGxvd2VyQm91bmRbMF0gLSBmcm9tWzBdKSAqIGRpckZyYWNYO1xyXG4gICAgICAgIHZhciB0MiA9ICh1cHBlckJvdW5kWzBdIC0gZnJvbVswXSkgKiBkaXJGcmFjWDtcclxuICAgICAgICB2YXIgdDMgPSAobG93ZXJCb3VuZFsxXSAtIGZyb21bMV0pICogZGlyRnJhY1k7XHJcbiAgICAgICAgdmFyIHQ0ID0gKHVwcGVyQm91bmRbMV0gLSBmcm9tWzFdKSAqIGRpckZyYWNZO1xyXG4gICAgICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSk7XHJcbiAgICAgICAgdmFyIHRtYXggPSBNYXRoLm1pbihNYXRoLm1heCh0MSwgdDIpLCBNYXRoLm1heCh0MywgdDQpKTtcclxuICAgICAgICAvLyBpZiB0bWF4IDwgMCwgcmF5IChsaW5lKSBpcyBpbnRlcnNlY3RpbmcgQUFCQiwgYnV0IHdob2xlIEFBQkIgaXMgYmVoaW5nIHVzXHJcbiAgICAgICAgaWYgKHRtYXggPCAwKSB7XHJcbiAgICAgICAgICAgIC8vdCA9IHRtYXg7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCXHJcbiAgICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7XHJcbiAgICAgICAgICAgIC8vdCA9IHRtYXg7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRtaW4gLyByYXkubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBQUJCO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBQUJCO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgQm9keV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9vYmplY3RzL0JvZHlcIikpO1xyXG4vLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgYWJzdHJhY3QuXHJcbnZhciBCcm9hZHBoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9ucy4gRG9uJ3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkuXHJcbiAgICAgKiBAY2xhc3MgQnJvYWRwaGFzZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZXN1bHRpbmcgb3ZlcmxhcHBpbmcgcGFpcnMuIFdpbGwgYmUgZmlsbGVkIHdpdGggcmVzdWx0cyBkdXJpbmcgLmdldENvbGxpc2lvblBhaXJzKCkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJlc3VsdFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbiBwYWlycyBpbi4gVG8gY2hhbmdlIGl0LCB1c2UgLnNldFdvcmxkKClcclxuICAgICAgICAgKiBAcHJvcGVydHkgd29ybGRcclxuICAgICAgICAgKiBAdHlwZSB7V29ybGR9XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53b3JsZCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLiBTaG91bGQgYmUgc2V0IHRvIEJyb2FkcGhhc2UuQUFCQiBvciBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdWb2x1bWVUeXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUgPSBCcm9hZHBoYXNlLkFBQkI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHdvcmxkIHRoYXQgd2UgYXJlIHNlYXJjaGluZyBmb3IgY29sbGlzaW9uIHBhaXJzIGluLlxyXG4gICAgICogQG1ldGhvZCBzZXRXb3JsZFxyXG4gICAgICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IG1vdmUgdG8gY29uc3RydWN0b3IhXHJcbiAgICBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKlxyXG4gICAgICogR2V0IGFsbCBwb3RlbnRpYWwgaW50ZXJzZWN0aW5nIGJvZHkgcGFpcnMuXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgYm9kaWVzLCBvcmRlcmVkIGluIHBhaXJzLiBFeGFtcGxlOiBBIHJlc3VsdCBvZiBbYSxiLGMsZF0gbWVhbnMgdGhhdCB0aGUgcG90ZW50aWFsIHBhaXJzIGFyZTogKGEsYiksIChjLGQpLlxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIC8vIEkgZ3Vlc3MgdGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbj9cclxuICAgICAgICAvLyBUT0RPOiBwb3NzaWJsZSBhYnN0cmFjdCBtZXRob2QuXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cclxuICAgICAqIEBtZXRob2QgIGJvdW5kaW5nUmFkaXVzQ2hlY2tcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBkMiA9IHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShib2R5QS5wb3NpdGlvbiwgYm9keUIucG9zaXRpb24pLCByID0gYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cztcclxuICAgICAgICByZXR1cm4gZDIgPD0gciAqIHI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBBQUJCIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cclxuICAgICAqIEBtZXRob2QgIGFhYmJDaGVja1xyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLmFhYmJDaGVjayA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICByZXR1cm4gYm9keUEuZ2V0QUFCQigpLm92ZXJsYXBzKGJvZHlCLmdldEFBQkIoKSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyB2b2x1bWVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cclxuICAgICAqIEBtZXRob2QgIGJvdW5kaW5nVm9sdW1lQ2hlY2tcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuYm91bmRpbmdWb2x1bWVDaGVjayA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRTpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEJyb2FkcGhhc2UuYm91bmRpbmdSYWRpdXNDaGVjayhib2R5QSwgYm9keUIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQnJvYWRwaGFzZS5BQUJCOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5hYWJiQ2hlY2soYm9keUEsIGJvZHlCKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZGluZyB2b2x1bWUgdHlwZSBub3QgcmVjb2duaXplZDogJyArIHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgYWxsb3dlZCB0byBjb2xsaWRlIGF0IGFsbC5cclxuICAgICAqIEBtZXRob2QgIGNhbkNvbGxpZGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5jYW5Db2xsaWRlID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBLSU5FTUFUSUMgPSBCb2R5XzEuZGVmYXVsdC5LSU5FTUFUSUM7XHJcbiAgICAgICAgdmFyIFNUQVRJQyA9IEJvZHlfMS5kZWZhdWx0LlNUQVRJQztcclxuICAgICAgICB2YXIgdHlwZUEgPSBib2R5QS50eXBlO1xyXG4gICAgICAgIHZhciB0eXBlQiA9IGJvZHlCLnR5cGU7XHJcbiAgICAgICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xyXG4gICAgICAgIGlmICh0eXBlQSA9PT0gU1RBVElDICYmIHR5cGVCID09PSBTVEFUSUMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBzdGF0aWMgdnMga2luZW1hdGljIGJvZGllc1xyXG4gICAgICAgIGlmICgodHlwZUEgPT09IEtJTkVNQVRJQyAmJiB0eXBlQiA9PT0gU1RBVElDKSB8fFxyXG4gICAgICAgICAgICAodHlwZUEgPT09IFNUQVRJQyAmJiB0eXBlQiA9PT0gS0lORU1BVElDKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm5vdCBjb2xsaWRlIGtpbmVtYXRpYyB2cyBraW5lbWF0aWNcclxuICAgICAgICBpZiAodHlwZUEgPT09IEtJTkVNQVRJQyAmJiB0eXBlQiA9PT0gS0lORU1BVElDKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2Fubm90IGNvbGxpZGUgYm90aCBzbGVlcGluZyBib2RpZXNcclxuICAgICAgICBpZiAoYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiYgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keV8xLmRlZmF1bHQuU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBpZiBvbmUgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgc2xlZXBpbmdcclxuICAgICAgICBpZiAoKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HICYmIHR5cGVCID09PSBTVEFUSUMpIHx8XHJcbiAgICAgICAgICAgIChib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5XzEuZGVmYXVsdC5TTEVFUElORyAmJiB0eXBlQSA9PT0gU1RBVElDKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cclxuICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uICh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vIE1vZGU6XHJcbiAgICBCcm9hZHBoYXNlLk5BSVZFID0gMTtcclxuICAgIEJyb2FkcGhhc2UuU0FQID0gMjtcclxuICAgIC8vIEJvdW5kaW5nIGJveDpcclxuICAgIC8qKlxyXG4gICAgICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0eXBlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEFBQkJcclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5BQUJCID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQm91bmRpbmcgY2lyY2xlIHR5cGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQk9VTkRJTkdfQ0lSQ0xFXHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFID0gMjtcclxuICAgIHJldHVybiBCcm9hZHBoYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCcm9hZHBoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb2FkcGhhc2VcIikpO1xyXG52YXIgTmFpdmVCcm9hZHBoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5haXZlQnJvYWRwaGFzZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBOXjIgdGVzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5haXZlQnJvYWRwaGFzZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYnJvYWRwaGFzZV8xLmRlZmF1bHQuTkFJVkUpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBOYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKHdvcmxkKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcywgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XHJcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIE5jb2xsaWRpbmcgPSBib2RpZXMubGVuZ3RoOyBpICE9PSBOY29sbGlkaW5nOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJyb2FkcGhhc2VfMS5kZWZhdWx0LmNhbkNvbGxpZGUoYmksIGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksIGJqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXHJcbiAgICAgKiBAbWV0aG9kIGFhYmJRdWVyeVxyXG4gICAgICogQHBhcmFtICB7V29ybGR9IHdvcmxkXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cclxuICAgICAqIEByZXR1cm4ge2FycmF5fVxyXG4gICAgICovXHJcbiAgICBOYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uICh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG4gICAgICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIuYWFiYi5vdmVybGFwcyhhYWJiKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gTmFpdmVCcm9hZHBoYXNlO1xyXG59KGJyb2FkcGhhc2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE5haXZlQnJvYWRwaGFzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIHN1YiA9IHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0LCBhZGQgPSB2ZWMyXzEuZGVmYXVsdC5hZGQsIGRvdCA9IHZlYzJfMS5kZWZhdWx0LmRvdCwgcm90YXRlID0gdmVjMl8xLmRlZmF1bHQucm90YXRlLCBub3JtYWxpemUgPSB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUsIGNvcHkgPSB2ZWMyXzEuZGVmYXVsdC5jb3B5LCBzY2FsZSA9IHZlYzJfMS5kZWZhdWx0LnNjYWxlLCBzcXVhcmVkTGVuZ3RoID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aCwgY3JlYXRlVmVjMiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZTtcclxudmFyIENpcmNsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvQ2lyY2xlXCIpKTtcclxudmFyIENvbnZleF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29udmV4XCIpKTtcclxudmFyIEJveF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvQm94XCIpKTtcclxudmFyIGNvbnRhY3RfZXF1YXRpb25fcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9jb250YWN0LWVxdWF0aW9uLXBvb2xcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9mcmljdGlvbi1lcXVhdGlvbi1wb29sXCIpKTtcclxudmFyIHR1cGxlX2RpY3Rpb25hcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvdHVwbGUtZGljdGlvbmFyeVwiKSk7XHJcbnZhciB5QXhpcyA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMCwgMSk7XHJcbnZhciB0bXAxID0gY3JlYXRlVmVjMigpLCB0bXAyID0gY3JlYXRlVmVjMigpLCB0bXAzID0gY3JlYXRlVmVjMigpLCB0bXA0ID0gY3JlYXRlVmVjMigpLCB0bXA1ID0gY3JlYXRlVmVjMigpLCB0bXA2ID0gY3JlYXRlVmVjMigpLCB0bXA3ID0gY3JlYXRlVmVjMigpLCB0bXA4ID0gY3JlYXRlVmVjMigpLCB0bXA5ID0gY3JlYXRlVmVjMigpLCB0bXAxMCA9IGNyZWF0ZVZlYzIoKSwgdG1wMTEgPSBjcmVhdGVWZWMyKCksIHRtcDEyID0gY3JlYXRlVmVjMigpLCB0bXAxMyA9IGNyZWF0ZVZlYzIoKSwgdG1wMTQgPSBjcmVhdGVWZWMyKCksIHRtcDE1ID0gY3JlYXRlVmVjMigpLCB0bXBBcnJheSA9IFtdO1xyXG52YXIgZmluZE1heFNlcGFyYXRpb25fbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgZmluZE1heFNlcGFyYXRpb25fdjEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGZpbmRNYXhTZXBhcmF0aW9uX3RtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgZmluZE1heFNlcGFyYXRpb25fdG1wMiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgZmluZEluY2lkZW50RWRnZV9ub3JtYWwxID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfdGVtcFZlYyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3RtcFZlYyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2xvY2FsVGFuZ2VudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2xvY2FsTm9ybWFsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfcGxhbmVQb2ludCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3RhbmdlbnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19uZWdhdGl2ZVRhbmdlbnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc192MTEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc192MTIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19kaXN0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfY2xpcFBvaW50czEgPSBbdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpXTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19jbGlwUG9pbnRzMiA9IFt2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCldO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2luY2lkZW50RWRnZSA9IFt2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCldO1xyXG52YXIgcGljX2xvY2FsUG9pbnQgPSBjcmVhdGVWZWMyKCksIHBpY19yMCA9IGNyZWF0ZVZlYzIoKSwgcGljX3IxID0gY3JlYXRlVmVjMigpO1xyXG52YXIgYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQSA9IGNyZWF0ZVZlYzIoKSwgYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQiA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gY3JlYXRlVmVjMigpLCBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIGNvbnZleENhcHN1bGVfdGVtcFZlYyA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIHBsYW5lQ2Fwc3VsZV90bXAxID0gY3JlYXRlVmVjMigpLCBwbGFuZUNhcHN1bGVfdG1wMiA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIGNpcmNsZUhlaWdodGZpZWxkX2NhbmRpZGF0ZSA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfdjAgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX3YxID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGVOb3JtYWwgPSBjcmVhdGVWZWMyKCk7XHJcbnZhciBjb252ZXhIZWlnaHRmaWVsZF92MCA9IGNyZWF0ZVZlYzIoKSwgY29udmV4SGVpZ2h0ZmllbGRfdjEgPSBjcmVhdGVWZWMyKCksIGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MgPSBjcmVhdGVWZWMyKCksIGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZSA9IG5ldyBDb252ZXhfMS5kZWZhdWx0KHVuZGVmaW5lZCwgW2NyZWF0ZVZlYzIoKSwgY3JlYXRlVmVjMigpLCBjcmVhdGVWZWMyKCksIGNyZWF0ZVZlYzIoKV0pO1xyXG5mdW5jdGlvbiBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShjb252ZXhTaGFwZSwgY2Fwc3VsZVNoYXBlKSB7XHJcbiAgICB2YXIgY2Fwc3VsZVJhZGl1cyA9IGNhcHN1bGVTaGFwZS5yYWRpdXM7XHJcbiAgICB2YXIgaGFsZkNhcHN1bGVMZW5ndGggPSBjYXBzdWxlU2hhcGUubGVuZ3RoICogMC41O1xyXG4gICAgdmFyIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXM7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbMF0sIC1oYWxmQ2Fwc3VsZUxlbmd0aCwgLWNhcHN1bGVSYWRpdXMpO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQuc2V0KHZlcnRzWzFdLCBoYWxmQ2Fwc3VsZUxlbmd0aCwgLWNhcHN1bGVSYWRpdXMpO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQuc2V0KHZlcnRzWzJdLCBoYWxmQ2Fwc3VsZUxlbmd0aCwgY2Fwc3VsZVJhZGl1cyk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbM10sIC1oYWxmQ2Fwc3VsZUxlbmd0aCwgY2Fwc3VsZVJhZGl1cyk7XHJcbn1cclxuLypcclxuKiBDaGVjayBpZiBhIHBvaW50IGlzIGluIGEgcG9seWdvblxyXG4qL1xyXG5mdW5jdGlvbiBwb2ludEluQ29udmV4KHdvcmxkUG9pbnQsIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKSB7XHJcbiAgICB2YXIgbG9jYWxQb2ludCA9IHBpY19sb2NhbFBvaW50LCByMCA9IHBpY19yMCwgcjEgPSBwaWNfcjEsIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXMsIGxhc3RDcm9zcyA9IG51bGw7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxQb2ludCwgd29ybGRQb2ludCwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVmVydHMgPSB2ZXJ0cy5sZW5ndGg7IGkgIT09IG51bVZlcnRzICsgMTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSAlIG51bVZlcnRzXSwgdjEgPSB2ZXJ0c1soaSArIDEpICUgbnVtVmVydHNdO1xyXG4gICAgICAgIHN1YihyMCwgdjAsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgIHN1YihyMSwgdjEsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgIHZhciBjcm9zcyA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHIwLCByMSk7XHJcbiAgICAgICAgaWYgKGxhc3RDcm9zcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgZ290IGEgZGlmZmVyZW50IHNpZ24gb2YgdGhlIGRpc3RhbmNlIHZlY3RvciwgdGhlIHBvaW50IGlzIG91dCBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgIGlmIChjcm9zcyAqIGxhc3RDcm9zcyA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qXHJcbiogQ2hlY2sgaWYgYSBwb2ludCBpcyBpbiBhIHBvbHlnb25cclxuKi9cclxuZnVuY3Rpb24gcG9pbnRJbkNvbnZleExvY2FsKGxvY2FsUG9pbnQsIGNvbnZleFNoYXBlKSB7XHJcbiAgICB2YXIgcjAgPSBwaWNfcjAsIHIxID0gcGljX3IxLCB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzLCBsYXN0Q3Jvc3MgPSBudWxsLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpICUgbnVtVmVydHNdLCB2MSA9IHZlcnRzWyhpICsgMSkgJSBudW1WZXJ0c107XHJcbiAgICAgICAgc3ViKHIwLCB2MCwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgc3ViKHIxLCB2MSwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocjAsIHIxKTtcclxuICAgICAgICBpZiAobGFzdENyb3NzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgaWYgKGNyb3NzICogbGFzdENyb3NzIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gYWRkU3ViKG91dCwgYSwgYiwgYykge1xyXG4gICAgb3V0WzBdID0gYVswXSArIGJbMF0gLSBjWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV0gLSBjWzFdO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRNYXhTZXBhcmF0aW9uKG1heFNlcGFyYXRpb25PdXQsIHBvbHkxLCBwb3NpdGlvbjEsIGFuZ2xlMSwgcG9seTIsIHBvc2l0aW9uMiwgYW5nbGUyKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBtYXggc2VwYXJhdGlvbiBiZXR3ZWVuIHBvbHkxIGFuZCBwb2x5MiB1c2luZyBlZGdlIG5vcm1hbHMgZnJvbSBwb2x5MS5cclxuICAgIHZhciBjb3VudDEgPSBwb2x5MS52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgY291bnQyID0gcG9seTIudmVydGljZXMubGVuZ3RoO1xyXG4gICAgdmFyIG4xcyA9IHBvbHkxLm5vcm1hbHM7XHJcbiAgICB2YXIgdjFzID0gcG9seTEudmVydGljZXM7XHJcbiAgICB2YXIgdjJzID0gcG9seTIudmVydGljZXM7XHJcbiAgICB2YXIgbiA9IGZpbmRNYXhTZXBhcmF0aW9uX247XHJcbiAgICB2YXIgdjEgPSBmaW5kTWF4U2VwYXJhdGlvbl92MTtcclxuICAgIHZhciB0bXAgPSBmaW5kTWF4U2VwYXJhdGlvbl90bXA7XHJcbiAgICB2YXIgdG1wMiA9IGZpbmRNYXhTZXBhcmF0aW9uX3RtcDI7XHJcbiAgICB2YXIgYW5nbGUgPSBhbmdsZTEgLSBhbmdsZTI7XHJcbiAgICB2YXIgYmVzdEluZGV4ID0gMDtcclxuICAgIHZhciBtYXhTZXBhcmF0aW9uID0gLUluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDE7ICsraSkge1xyXG4gICAgICAgIC8vIEdldCBwb2x5MSBub3JtYWwgaW4gZnJhbWUyLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShuLCBuMXNbaV0sIGFuZ2xlKTtcclxuICAgICAgICAvLyBHZXQgcG9seTEgdmVydGV4IGluIGZyYW1lMlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUodG1wMiwgdjFzW2ldLCBwb3NpdGlvbjEsIGFuZ2xlMSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKHYxLCB0bXAyLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbiAgICAgICAgLy8gRmluZCBkZWVwZXN0IHBvaW50IGZvciBub3JtYWwgaS5cclxuICAgICAgICB2YXIgc2kgPSBJbmZpbml0eTtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50MjsgKytqKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHRtcCwgdjJzW2pdLCB2MSk7XHJcbiAgICAgICAgICAgIHZhciBzaWogPSB2ZWMyXzEuZGVmYXVsdC5kb3QobiwgdG1wKTtcclxuICAgICAgICAgICAgaWYgKHNpaiA8IHNpKSB7XHJcbiAgICAgICAgICAgICAgICBzaSA9IHNpajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2kgPiBtYXhTZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIG1heFNlcGFyYXRpb24gPSBzaTtcclxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVc2UgYSB2ZWMyIGZvciBzdG9yaW5nIHRoZSBmbG9hdCB2YWx1ZSBhbmQgYWx3YXlzIHJldHVybiBpbnQsIGZvciBwZXJmXHJcbiAgICBtYXhTZXBhcmF0aW9uT3V0WzBdID0gbWF4U2VwYXJhdGlvbjtcclxuICAgIHJldHVybiBiZXN0SW5kZXg7XHJcbn1cclxuZnVuY3Rpb24gZmluZEluY2lkZW50RWRnZShjbGlwVmVydGljZXNPdXQsIHBvbHkxLCBwb3NpdGlvbjEsIGFuZ2xlMSwgZWRnZTEsIHBvbHkyLCBwb3NpdGlvbjIsIGFuZ2xlMikge1xyXG4gICAgdmFyIG5vcm1hbHMxID0gcG9seTEubm9ybWFscztcclxuICAgIHZhciBjb3VudDIgPSBwb2x5Mi52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgdmVydGljZXMyID0gcG9seTIudmVydGljZXM7XHJcbiAgICB2YXIgbm9ybWFsczIgPSBwb2x5Mi5ub3JtYWxzO1xyXG4gICAgLy8gR2V0IHRoZSBub3JtYWwgb2YgdGhlIHJlZmVyZW5jZSBlZGdlIGluIHBvbHkyJ3MgZnJhbWUuXHJcbiAgICB2YXIgbm9ybWFsMSA9IGZpbmRJbmNpZGVudEVkZ2Vfbm9ybWFsMTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwxLCBub3JtYWxzMVtlZGdlMV0sIGFuZ2xlMSAtIGFuZ2xlMik7XHJcbiAgICAvLyBGaW5kIHRoZSBpbmNpZGVudCBlZGdlIG9uIHBvbHkyLlxyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHZhciBtaW5Eb3QgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQyOyArK2kpIHtcclxuICAgICAgICB2YXIgZG90XzEgPSB2ZWMyXzEuZGVmYXVsdC5kb3Qobm9ybWFsMSwgbm9ybWFsczJbaV0pO1xyXG4gICAgICAgIGlmIChkb3RfMSA8IG1pbkRvdCkge1xyXG4gICAgICAgICAgICBtaW5Eb3QgPSBkb3RfMTtcclxuICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEJ1aWxkIHRoZSBjbGlwIHZlcnRpY2VzIGZvciB0aGUgaW5jaWRlbnQgZWRnZS5cclxuICAgIHZhciBpMSA9IGluZGV4O1xyXG4gICAgdmFyIGkyID0gaTEgKyAxIDwgY291bnQyID8gaTEgKyAxIDogMDtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2xpcFZlcnRpY2VzT3V0WzBdLCB2ZXJ0aWNlczJbaTFdLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGNsaXBWZXJ0aWNlc091dFsxXSwgdmVydGljZXMyW2kyXSwgcG9zaXRpb24yLCBhbmdsZTIpO1xyXG59XHJcbmZ1bmN0aW9uIGNsaXBTZWdtZW50VG9MaW5lKHZPdXQsIHZJbiwgbm9ybWFsLCBvZmZzZXQpIHtcclxuICAgIC8vIFN0YXJ0IHdpdGggbm8gb3V0cHV0IHBvaW50c1xyXG4gICAgdmFyIG51bU91dCA9IDA7XHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIGVuZCBwb2ludHMgdG8gdGhlIGxpbmVcclxuICAgIHZhciBkaXN0YW5jZTAgPSB2ZWMyXzEuZGVmYXVsdC5kb3Qobm9ybWFsLCB2SW5bMF0pIC0gb2Zmc2V0O1xyXG4gICAgdmFyIGRpc3RhbmNlMSA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHZJblsxXSkgLSBvZmZzZXQ7XHJcbiAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBiZWhpbmQgdGhlIHBsYW5lXHJcbiAgICBpZiAoZGlzdGFuY2UwIDw9IDAuMCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodk91dFtudW1PdXQrK10sIHZJblswXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlzdGFuY2UxIDw9IDAuMCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodk91dFtudW1PdXQrK10sIHZJblsxXSk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBvbiBkaWZmZXJlbnQgc2lkZXMgb2YgdGhlIHBsYW5lXHJcbiAgICBpZiAoZGlzdGFuY2UwICogZGlzdGFuY2UxIDwgMC4wKSB7XHJcbiAgICAgICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgZWRnZSBhbmQgcGxhbmVcclxuICAgICAgICB2YXIgaW50ZXJwID0gZGlzdGFuY2UwIC8gKGRpc3RhbmNlMCAtIGRpc3RhbmNlMSk7XHJcbiAgICAgICAgdmFyIHYgPSB2T3V0W251bU91dF07XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodiwgdkluWzFdLCB2SW5bMF0pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHYsIHYsIGludGVycCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHYsIHYsIHZJblswXSk7XHJcbiAgICAgICAgKytudW1PdXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtT3V0O1xyXG59XHJcbnZhciBOYXJyb3dwaGFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogTmFycm93cGhhc2UuIENyZWF0ZXMgY29udGFjdHMgYW5kIGZyaWN0aW9uIGdpdmVuIHNoYXBlcyBhbmQgdHJhbnNmb3Jtcy5cclxuICAgICAqIEBjbGFzcyBOYXJyb3dwaGFzZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE5hcnJvd3BoYXNlKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkVxdWF0aW9uc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBtYWtlIGZyaWN0aW9uIGVxdWF0aW9ucyBpbiB0aGUgdXBjb21pbmcgY29udGFjdHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVuYWJsZUZyaWN0aW9uXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBtYWtlIGVxdWF0aW9ucyBlbmFibGVkIGluIHVwY29taW5nIGNvbnRhY3RzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkRXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkRXF1YXRpb25zID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnJpY3Rpb24gc2xpcCBmb3JjZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmcmljdGlvbiBlcXVhdGlvbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNsaXBGb3JjZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zbGlwRm9yY2UgPSAxMC4wO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhbGxvY2F0ZWQgQ29udGFjdEVxdWF0aW9ucy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvblBvb2x9IGNvbnRhY3RFcXVhdGlvblBvb2xcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gQWxsb2NhdGUgYSBmZXcgZXF1YXRpb25zIGJlZm9yZSBzdGFydGluZyB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAgICAgKiAgICAgLy8gVGhpcyB3YXksIG5vIGNvbnRhY3Qgb2JqZWN0cyBuZWVkIHRvIGJlIGNyZWF0ZWQgb24gdGhlIGZseSBpbiB0aGUgZ2FtZSBsb29wLlxyXG4gICAgICAgICAqICAgICB3b3JsZC5uYXJyb3dwaGFzZS5jb250YWN0RXF1YXRpb25Qb29sLnJlc2l6ZSgxMDI0KTtcclxuICAgICAgICAgKiAgICAgd29ybGQubmFycm93cGhhc2UuZnJpY3Rpb25FcXVhdGlvblBvb2wucmVzaXplKDEwMjQpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9uUG9vbCA9IG5ldyBjb250YWN0X2VxdWF0aW9uX3Bvb2xfMS5kZWZhdWx0KHsgc2l6ZTogMzIgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFsbG9jYXRlZCBDb250YWN0RXF1YXRpb25zLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RnJpY3Rpb25FcXVhdGlvblBvb2x9IGZyaWN0aW9uRXF1YXRpb25Qb29sXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IG5ldyBmcmljdGlvbl9lcXVhdGlvbl9wb29sXzEuZGVmYXVsdCh7IHNpemU6IDY0IH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSByZWR1Y3Rpb24gb2YgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBkaXNhYmxlZCwgYSBib3ggb24gYSBwbGFuZSB3aWxsIGdlbmVyYXRlIDIgY29udGFjdCBlcXVhdGlvbnMgYW5kIDIgZnJpY3Rpb24gZXF1YXRpb25zLiBJZiBlbmFibGVkLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGZyaWN0aW9uIGVxdWF0aW9uLiBTYW1lIGtpbmQgb2Ygc2ltcGxpZmljYXRpb25zIGFyZSBtYWRlICBmb3IgYWxsIGNvbGxpc2lvbiB0eXBlcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGZlYXR1cmUgaXMgc3RhYmxlIGVub3VnaC5cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGNvbGxpZGluZyBib2RpZXMgbGFzdCBzdGVwLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbGxpZGluZ0JvZGllc0xhc3RTdGVwXHJcbiAgICAgICAgICogQHR5cGUge1R1cGxlRGljdGlvbmFyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwID0gbmV3IHR1cGxlX2RpY3Rpb25hcnlfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWN0TWF0ZXJpYWxcclxuICAgICAgICAgKiBAdHlwZSB7Q29udGFjdE1hdGVyaWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYm9kaWVzT3ZlcmxhcFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbY2hlY2tDb2xsaXNpb25NYXNrcz1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib2RpZXNPdmVybGFwID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5QiwgY2hlY2tDb2xsaXNpb25NYXNrcykge1xyXG4gICAgICAgIGlmIChjaGVja0NvbGxpc2lvbk1hc2tzID09PSB2b2lkIDApIHsgY2hlY2tDb2xsaXNpb25NYXNrcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHNoYXBlUG9zaXRpb25BID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQTtcclxuICAgICAgICB2YXIgc2hhcGVQb3NpdGlvbkIgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHlBXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIE5zaGFwZXNpID0gYm9keUEuc2hhcGVzLmxlbmd0aDsgayAhPT0gTnNoYXBlc2k7IGsrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVBID0gYm9keUEuc2hhcGVzW2tdO1xyXG4gICAgICAgICAgICAvLyBBbGwgc2hhcGVzIG9mIGJvZHkgalxyXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMCwgTnNoYXBlc2ogPSBib2R5Qi5zaGFwZXMubGVuZ3RoOyBsICE9PSBOc2hhcGVzajsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uIGdyb3VwcyBhbmQgbWFza3NcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja0NvbGxpc2lvbk1hc2tzICYmICEoKHNoYXBlQS5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQi5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2hhcGVCLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVBLmNvbGxpc2lvbk1hc2spICE9PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvZHlBLnRvV29ybGRGcmFtZShzaGFwZVBvc2l0aW9uQSwgc2hhcGVBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnRvV29ybGRGcmFtZShzaGFwZVBvc2l0aW9uQiwgc2hhcGVCLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRlc3RDb250YWN0KGJvZHlBLCBzaGFwZUEsIHNoYXBlUG9zaXRpb25BLCBib2R5Qiwgc2hhcGVCLCBzaGFwZVBvc2l0aW9uQiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBib2RpZXMgd2VyZSBpbiBjb250YWN0IHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXHJcbiAgICAgKiBAbWV0aG9kIGNvbGxpZGVkTGFzdFN0ZXBcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNvbGxpZGVkTGFzdFN0ZXAgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIGlkMSA9IGJvZHlBLmlkIHwgMCwgaWQyID0gYm9keUIuaWQgfCAwO1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuZ2V0KGlkMSwgaWQyKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRocm93cyBhd2F5IHRoZSBvbGQgZXF1YXRpb25zIGFuZCBnZXRzIHJlYWR5IHRvIGNyZWF0ZSBuZXdcclxuICAgICAqIEBtZXRob2QgcmVzZXRcclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAucmVzZXQoKTtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5jb250YWN0RXF1YXRpb25zO1xyXG4gICAgICAgIHZhciBsID0gZXFzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tsXSwgaWQxID0gZXEuYm9keUEuaWQsIGlkMiA9IGVxLmJvZHlCLmlkO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLnNldChpZDEsIGlkMiwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucywgZmUgPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25Qb29sLnJlbGVhc2UoY2VbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wucmVsZWFzZShmZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlc2V0XHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBDb250YWN0RXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XHJcbiAgICAgKi9cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVDb250YWN0RXF1YXRpb24gPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQikge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25Qb29sLmdldCgpO1xyXG4gICAgICAgIHZhciBjdXJyZW50Q29udGFjdE1hdGVyaWFsID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO1xyXG4gICAgICAgIGMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICBjLmJvZHlCID0gYm9keUI7XHJcbiAgICAgICAgYy5zaGFwZUEgPSBzaGFwZUE7XHJcbiAgICAgICAgYy5zaGFwZUIgPSBzaGFwZUI7XHJcbiAgICAgICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xyXG4gICAgICAgIGMuZmlyc3RJbXBhY3QgPSAhdGhpcy5jb2xsaWRlZExhc3RTdGVwKGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgYy5yZXN0aXR1dGlvbiA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwucmVzdGl0dXRpb247XHJcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLnN0aWZmbmVzcztcclxuICAgICAgICBjLnJlbGF4YXRpb24gPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLnJlbGF4YXRpb247XHJcbiAgICAgICAgYy5vZmZzZXQgPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLmNvbnRhY3RTa2luU2l6ZTtcclxuICAgICAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBGcmljdGlvbkVxdWF0aW9uLCBlaXRoZXIgYnkgcmV1c2luZyBhbiBleGlzdGluZyBvYmplY3Qgb3IgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVGcmljdGlvbkVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XHJcbiAgICAgKi9cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkVxdWF0aW9uID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wuZ2V0KCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgYy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIGMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICBjLnNoYXBlQSA9IHNoYXBlQTtcclxuICAgICAgICBjLnNoYXBlQiA9IHNoYXBlQjtcclxuICAgICAgICBjLnNldFNsaXBGb3JjZSh0aGlzLnNsaXBGb3JjZSk7XHJcbiAgICAgICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xyXG4gICAgICAgIGMuZnJpY3Rpb25Db2VmZmljaWVudCA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuZnJpY3Rpb247XHJcbiAgICAgICAgYy5yZWxhdGl2ZVZlbG9jaXR5ID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5zdXJmYWNlVmVsb2NpdHk7XHJcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLmZyaWN0aW9uU3RpZmZuZXNzO1xyXG4gICAgICAgIGMucmVsYXhhdGlvbiA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuZnJpY3Rpb25SZWxheGF0aW9uO1xyXG4gICAgICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIGMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24gZ2l2ZW4gdGhlIGRhdGEgaW4gdGhlIENvbnRhY3RFcXVhdGlvbi4gVXNlcyBzYW1lIG9mZnNldCB2ZWN0b3JzIHJpIGFuZCByaiwgYnV0IHRoZSB0YW5nZW50IHZlY3RvciB3aWxsIGJlIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbGxpc2lvbiBub3JtYWwuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3RcclxuICAgICAqIEBwYXJhbSAge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdEVxdWF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxyXG4gICAgICovXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIGVxID0gdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uKGMuYm9keUEsIGMuYm9keUIsIGMuc2hhcGVBLCBjLnNoYXBlQik7XHJcbiAgICAgICAgY29weShlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgIGNvcHkoZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KGVxLnQsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgZXEuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgIHJldHVybiBlcTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UgPSBmdW5jdGlvbiAobnVtQ29udGFjdHMpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGVxID0gdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uKGMuYm9keUEsIGMuYm9keUIsIGMuc2hhcGVBLCBjLnNoYXBlQik7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gYy5ib2R5QTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoZXEuY29udGFjdFBvaW50QSwgMCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGVxLmNvbnRhY3RQb2ludEIsIDAsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlcS50LCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvbnRhY3RzOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uc1t0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIC0gMSAtIGldO1xyXG4gICAgICAgICAgICBpZiAoYy5ib2R5QSA9PT0gYm9keUEpIHtcclxuICAgICAgICAgICAgICAgIGFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN1YihlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50Qik7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnZOdW1Db250YWN0cyA9IDEgLyBudW1Db250YWN0cztcclxuICAgICAgICBzY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XHJcbiAgICAgICAgc2NhbGUoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgaW52TnVtQ29udGFjdHMpO1xyXG4gICAgICAgIG5vcm1hbGl6ZShlcS50LCBlcS50KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KGVxLnQsIGVxLnQpO1xyXG4gICAgICAgIHJldHVybiBlcTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUudGVzdENvbnRhY3QgPSBmdW5jdGlvbiAoYm9keUEsIHNoYXBlQSwgb2Zmc2V0QSwgYm9keUIsIHNoYXBlQiwgb2Zmc2V0QiwganVzdFRlc3RcclxuICAgIC8vIG1ldGE/OiB7XHJcbiAgICAvLyBcdHJhZGl1c0E/OiBmMzIsXHJcbiAgICAvLyBcdHJhZGl1c0I/OiBmMzJcclxuICAgIC8vIH1cclxuICAgICkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgICAgIGlmIChzaGFwZUEudHlwZSA+IHNoYXBlQi50eXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBiVG1wID0gYm9keUI7XHJcbiAgICAgICAgICAgIGJvZHlCID0gYm9keUE7XHJcbiAgICAgICAgICAgIGJvZHlBID0gYlRtcDtcclxuICAgICAgICAgICAgdmFyIHNUbXAgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgIHNoYXBlQiA9IHNoYXBlQTtcclxuICAgICAgICAgICAgc2hhcGVBID0gc1RtcDtcclxuICAgICAgICAgICAgdmFyIHBUbXAgPSBvZmZzZXRCO1xyXG4gICAgICAgICAgICBvZmZzZXRCID0gb2Zmc2V0QTtcclxuICAgICAgICAgICAgb2Zmc2V0QSA9IHBUbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoc2hhcGVBLnR5cGUgfCBzaGFwZUIudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDE6IHsgLy8gQ2lyY2xlL2NpcmNsZVxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGp1c3RUZXN0LCBzYS5yYWRpdXMsIHNiLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDM6IHsgLy8gUGFydGljbGUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVQYXJ0aWNsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA1OiB7IC8vIFBsYW5lL2NpcmNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2lyY2xlUGxhbmUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzM6IC8vIEJveC9jaXJjbGUuXHJcbiAgICAgICAgICAgIGNhc2UgOTogeyAvLyBDb252ZXgvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVDb252ZXgoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0LCBzYS5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxNzogeyAvLyBMaW5lL2NpcmNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2lyY2xlTGluZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QsIDAsIHNhLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDY1OiB7IC8vIENhcHN1bGUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVDYXBzdWxlKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDEyOTogeyAvLyBIZWlnaHRmaWVsZC9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUhlaWdodGZpZWxkKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBqdXN0VGVzdCwgc2EucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjogeyAvLyBQbGFuZS9wYXJ0aWNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFydGljbGVQbGFuZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gQm94L3BhcnRpY2xlLlxyXG4gICAgICAgICAgICBjYXNlIDEwOiB7IC8vIENvbnZleC9wYXJ0aWNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFydGljbGVDb252ZXgoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTA6IHsgLy8gQ2Fwc3VsZS9wYXJ0aWNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFydGljbGVDYXBzdWxlKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDM2OiAvLyBCb3gvcGxhbmUuXHJcbiAgICAgICAgICAgIGNhc2UgMTI6IHsgLy8gQ29udmV4L3BsYW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wbGFuZUNvbnZleChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAyMDogeyAvLyBMaW5lL3BsYW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wbGFuZUxpbmUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjg6IHsgLy8gQ2Fwc3VsZS9wbGFuZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGxhbmVDYXBzdWxlKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDQwOiAvLyBCb3gvY29udmV4LlxyXG4gICAgICAgICAgICBjYXNlIDg6IHsgLy8gQ29udmV4L2NvbnZleC5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udmV4Q29udmV4KGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDI0OiB7IC8vIExpbmUvY29udmV4LlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UIFNVUFBPUlRFRCFcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCA9IHRoaXMuY29udmV4TGluZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNzI6IHsgLy8gQ2Fwc3VsZS9jb252ZXguXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnZleENhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTM2OiB7IC8vIEhlaWdodGZpZWxkL2NvbnZleC5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udmV4SGVpZ2h0ZmllbGQoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTY6IHsgLy8gTGluZS9saW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UIFNVUFBPUlRFRCFcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCA9IHRoaXMubGluZUxpbmUoYm9keUEsIHNhLCBzaGFwZVBvc2l0aW9uQSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0Ym9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDQ4OiB7IC8vIEJveC9saW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UIFNVUFBPUlRFRCFcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCA9IHRoaXMubGluZUJveChib2R5QSwgc2EsIHNoYXBlUG9zaXRpb25BLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgODA6IHsgLy8gQ2Fwc3VsZS9saW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9UIFNVUFBPUlRFRCFcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCA9IHRoaXMubGluZUNhcHN1bGUoYm9keUEsIHNhLCBzaGFwZVBvc2l0aW9uQSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0Ym9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDY0OiB7IC8vIENhcHN1bGUvY2Fwc3VsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2Fwc3VsZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXgvbGluZSBuYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBjb252ZXhMaW5lXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5MSU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4TGluZSA9IGZ1bmN0aW9uIChcclxuICAgIC8qXHJcbiAgICBjb252ZXhCb2R5LFxyXG4gICAgY29udmV4U2hhcGUsXHJcbiAgICBjb252ZXhPZmZzZXQsXHJcbiAgICBjb252ZXhBbmdsZSxcclxuICAgIGxpbmVCb2R5LFxyXG4gICAgbGluZVNoYXBlLFxyXG4gICAgbGluZU9mZnNldCxcclxuICAgIGxpbmVBbmdsZSxcclxuICAgIGp1c3RUZXN0XHJcbiAgICAqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTGluZS9ib3ggbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgbGluZUJveFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib3hCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtCb3h9ICBib3hTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgYm94T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBib3hBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIEltcGxlbWVudCBtZSFcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkJPWF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVCb3ggPSBmdW5jdGlvbiAoXHJcbiAgICAvKlxyXG4gICAgbGluZUJvZHksXHJcbiAgICBsaW5lU2hhcGUsXHJcbiAgICBsaW5lT2Zmc2V0LFxyXG4gICAgbGluZUFuZ2xlLFxyXG4gICAgYm94Qm9keSxcclxuICAgIGJveFNoYXBlLFxyXG4gICAgYm94T2Zmc2V0LFxyXG4gICAgYm94QW5nbGUsXHJcbiAgICBqdXN0VGVzdFxyXG4gICAgKi9cclxuICAgICkge1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZleC9jYXBzdWxlIG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNvbnZleENhcHN1bGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNhcHN1bGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBjYXBzdWxlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNhcHN1bGVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgY2Fwc3VsZUFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkJPWCB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24gKGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhQb3NpdGlvbiwgY29udmV4QW5nbGUsIGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBjb252ZXhDYXBzdWxlX3RlbXBSZWN0ID0gbmV3IEJveF8xLmRlZmF1bHQoeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0pO1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXHJcbiAgICAgICAgLy8gQWRkIG9mZnNldHMhXHJcbiAgICAgICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcclxuICAgICAgICB2YXIgaGFsZkxlbmd0aCA9IGNhcHN1bGVTaGFwZS5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChjaXJjbGVQb3MsIGhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zLCBjaXJjbGVQb3MsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlKTtcclxuICAgICAgICB2YXIgcmVzdWx0MSA9IHRoaXMuY2lyY2xlQ29udmV4KGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNpcmNsZVBvcywgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChjaXJjbGVQb3MsIC1oYWxmTGVuZ3RoLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGNpcmNsZVBvcywgY2lyY2xlUG9zLCBjYXBzdWxlUG9zaXRpb24sIGNhcHN1bGVBbmdsZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNpcmNsZUNvbnZleChjYXBzdWxlQm9keSwgY2Fwc3VsZVNoYXBlLCBjaXJjbGVQb3MsIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhQb3NpdGlvbiwgY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcclxuICAgICAgICBpZiAoanVzdFRlc3QgJiYgKHJlc3VsdDEgKyByZXN1bHQyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcclxuICAgICAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XHJcbiAgICAgICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUociwgY2Fwc3VsZVNoYXBlKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwgY2Fwc3VsZUJvZHksIHIsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHJlc3VsdDEgKyByZXN1bHQyO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmVDYXBzdWxlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIEltcGxlbWVudCBtZSFcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uIChcclxuICAgIC8qXHJcbiAgICBsaW5lQm9keSxcclxuICAgIGxpbmVTaGFwZSxcclxuICAgIGxpbmVQb3NpdGlvbixcclxuICAgIGxpbmVBbmdsZSxcclxuICAgIGNhcHN1bGVCb2R5LFxyXG4gICAgY2Fwc3VsZVNoYXBlLFxyXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxyXG4gICAgY2Fwc3VsZUFuZ2xlLFxyXG4gICAganVzdFRlc3RcclxuICAgICovXHJcbiAgICApIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXBzdWxlL2NhcHN1bGUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2Fwc3VsZUNhcHN1bGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXHJcbiAgICAgKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzaVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFpXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxyXG4gICAgICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2pcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhqXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhalxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2Fwc3VsZUNhcHN1bGUgPSBmdW5jdGlvbiAoYmksIHNpLCB4aSwgYWksIGJqLCBzaiwgeGosIGFqLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHRocm93IFwiQ2Fwc3VsZS1jYXBzdWxlIGNvbGxpc2lvbnMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLlwiO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIC8vIGxldCBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDEgPSBuZXcgQm94KHsgd2lkdGg6IDEsIGhlaWdodDogMSB9KTtcclxuICAgICAgICAvLyBsZXQgZW5hYmxlRnJpY3Rpb25CZWZvcmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAvLyAvLyBDaGVjayB0aGUgY2lyY2xlc1xyXG4gICAgICAgIC8vIC8vIEFkZCBvZmZzZXRzIVxyXG4gICAgICAgIC8vIGxldCBjaXJjbGVQb3NpID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEsXHJcbiAgICAgICAgLy8gXHRjaXJjbGVQb3NqID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzI7XHJcbiAgICAgICAgLy8gbGV0IG51bUNvbnRhY3RzID0gMDtcclxuICAgICAgICAvLyAvLyBOZWVkIDQgY2lyY2xlIGNoZWNrcywgYmV0d2VlbiBhbGxcclxuICAgICAgICAvLyBmb3IobGV0IGk9MDsgaTwyOyBpKyspe1xyXG4gICAgICAgIC8vIFx0dmVjMi5zZXQoY2lyY2xlUG9zaSwoaT09PTA/LTE6MSkqc2kubGVuZ3RoLzIsMCk7XHJcbiAgICAgICAgLy8gXHR2ZWMyLnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zaSwgY2lyY2xlUG9zaSwgeGksIGFpKTtcclxuICAgICAgICAvLyBcdGZvcihsZXQgaj0wOyBqPDI7IGorKyl7XHJcbiAgICAgICAgLy8gXHRcdHZlYzIuc2V0KGNpcmNsZVBvc2osKGo9PT0wPy0xOjEpKnNqLmxlbmd0aC8yLCAwKTtcclxuICAgICAgICAvLyBcdFx0dmVjMi50b0dsb2JhbEZyYW1lKGNpcmNsZVBvc2osIGNpcmNsZVBvc2osIHhqLCBhaik7XHJcbiAgICAgICAgLy8gXHRcdC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXHJcbiAgICAgICAgLy8gXHRcdGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0XHRcdGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcclxuICAgICAgICAvLyBcdFx0XHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gXHRcdH1cclxuICAgICAgICAvLyBcdFx0bGV0IHJlc3VsdCA9IHRoaXMuY2lyY2xlQ2lyY2xlKGJpLHNpLGNpcmNsZVBvc2ksIGJqLHNqLGNpcmNsZVBvc2osIGp1c3RUZXN0LCBzaS5yYWRpdXMsIHNqLnJhZGl1cyk7XHJcbiAgICAgICAgLy8gXHRcdGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0XHRcdHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcclxuICAgICAgICAvLyBcdFx0fVxyXG4gICAgICAgIC8vIFx0XHRpZihqdXN0VGVzdCAmJiByZXN1bHQgIT09IDApe1xyXG4gICAgICAgIC8vIFx0XHRcdHJldHVybiAxO1xyXG4gICAgICAgIC8vIFx0XHR9XHJcbiAgICAgICAgLy8gXHRcdG51bUNvbnRhY3RzICs9IHJlc3VsdDtcclxuICAgICAgICAvLyBcdH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHQvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxyXG4gICAgICAgIC8vIFx0ZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xyXG4gICAgICAgIC8vIFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyAvLyBDaGVjayBjaXJjbGVzIGFnYWluc3QgdGhlIGNlbnRlciBib3hzXHJcbiAgICAgICAgLy8gbGV0IHJlY3QgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDE7XHJcbiAgICAgICAgLy8gc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaSk7XHJcbiAgICAgICAgLy8gbGV0IHJlc3VsdDEgPSB0aGlzLmNvbnZleENhcHN1bGUoYmkscmVjdCx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KTtcclxuICAgICAgICAvLyBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcclxuICAgICAgICAvLyBcdHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gaWYoanVzdFRlc3QgJiYgcmVzdWx0MSAhPT0gMCl7XHJcbiAgICAgICAgLy8gXHRyZXR1cm4gMTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gbnVtQ29udGFjdHMgKz0gcmVzdWx0MTtcclxuICAgICAgICAvLyBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcclxuICAgICAgICAvLyBcdC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXHJcbiAgICAgICAgLy8gXHRsZXQgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xyXG4gICAgICAgIC8vIFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNqKTtcclxuICAgICAgICAvLyBsZXQgcmVzdWx0MiA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaixyZWN0LHhqLGFqLCBiaSxzaSx4aSxhaSwganVzdFRlc3QpO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZihqdXN0VGVzdCAmJiByZXN1bHQyICE9PSAwKXtcclxuICAgICAgICAvLyBcdHJldHVybiAxO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBudW1Db250YWN0cyArPSByZXN1bHQyO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0aWYobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbil7XHJcbiAgICAgICAgLy8gXHRcdHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcclxuICAgICAgICAvLyBcdH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gcmV0dXJuIG51bUNvbnRhY3RzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTGluZS9saW5lIG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmVMaW5lXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkFcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUJcclxuICAgICAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25CXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIEltcGxlbWVudCBtZSFcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVMaW5lID0gZnVuY3Rpb24gKFxyXG4gICAgLyogYm9keUEsXHJcbiAgICAgICAgc2hhcGVBLFxyXG4gICAgICAgIHBvc2l0aW9uQSxcclxuICAgICAgICBhbmdsZUEsXHJcbiAgICAgICAgYm9keUIsXHJcbiAgICAgICAgc2hhcGVCLFxyXG4gICAgICAgIHBvc2l0aW9uQixcclxuICAgICAgICBhbmdsZUIsXHJcbiAgICAgICAganVzdFRlc3QqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGxhbmUvbGluZSBOYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBwbGFuZUxpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgcGxhbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQbGFuZX0gIHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcGxhbmVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICBsaW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgbGluZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsaW5lQW5nbGVcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5MSU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVMaW5lID0gZnVuY3Rpb24gKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGxpbmVCb2R5LCBsaW5lU2hhcGUsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSwganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSwgd29ybGRWZXJ0ZXgxID0gdG1wMiwgd29ybGRWZXJ0ZXgwMSA9IHRtcDMsIHdvcmxkVmVydGV4MTEgPSB0bXA0LCB3b3JsZEVkZ2UgPSB0bXA1LCB3b3JsZEVkZ2VVbml0ID0gdG1wNiwgZGlzdCA9IHRtcDcsIHdvcmxkTm9ybWFsID0gdG1wOCwgd29ybGRUYW5nZW50ID0gdG1wOSwgdmVydHMgPSB0bXBBcnJheSwgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoIC8gMiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHdvcmxkVmVydGV4MSwgbGluZVNoYXBlLmxlbmd0aCAvIDIsIDApO1xyXG4gICAgICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgY29weSh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MDEpO1xyXG4gICAgICAgIGNvcHkod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDExKTtcclxuICAgICAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXHJcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgIG5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xyXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcclxuICAgICAgICByb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcclxuICAgICAgICAvLyBDaGVjayBsaW5lIGVuZHNcclxuICAgICAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcclxuICAgICAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdmVydHNbaV07XHJcbiAgICAgICAgICAgIHN1YihkaXN0LCB2LCBwbGFuZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgaWYgKGQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBsaW5lQm9keSwgcGxhbmVTaGFwZSwgbGluZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XHJcbiAgICAgICAgICAgICAgICBjb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIHZlY3RvciBhbG9uZyBwbGFuZSBub3JtYWxcclxuICAgICAgICAgICAgICAgIHNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCBkKTtcclxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2LCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIEZyb20gbGluZSBjZW50ZXIgdG8gY29udGFjdFxyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgdiwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobnVtQ29udGFjdHMgJiYgdGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1Db250YWN0cztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNhcHN1bGUgPSBmdW5jdGlvbiAocGFydGljbGVCb2R5LCBwYXJ0aWNsZVNoYXBlLCBwYXJ0aWNsZVBvc2l0aW9uLCBjYXBzdWxlQm9keSwgY2Fwc3VsZVNoYXBlLCBjYXBzdWxlUG9zaXRpb24sIGNhcHN1bGVBbmdsZSwganVzdFRlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKHBhcnRpY2xlQm9keSwgcGFydGljbGVTaGFwZSwgcGFydGljbGVQb3NpdGlvbiwgY2Fwc3VsZUJvZHksIGNhcHN1bGVTaGFwZSwgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzLCAwKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZS9saW5lIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZUxpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGxpbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSBsaW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdCBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IChpbnRlcnNlY3Rpb24gb3Igbm90KSB3aXRob3V0IGFkZGluZyBlcXVhdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZVJhZGl1cyBSYWRpdXMgdG8gYWRkIHRvIHRoZSBsaW5lLiBDYW4gYmUgdXNlZCB0byB0ZXN0IENhcHN1bGVzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNpcmNsZVJhZGl1cyBJZiBzZXQsIHRoaXMgdmFsdWUgb3ZlcnJpZGVzIHRoZSBjaXJjbGUgc2hhcGUgcmFkaXVzLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5MSU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlTGluZSA9IGZ1bmN0aW9uIChjaXJjbGVCb2R5LCBjaXJjbGVTaGFwZSwgY2lyY2xlT2Zmc2V0LCBcclxuICAgIC8vY2lyY2xlQW5nbGU6IGYzMixcclxuICAgIGxpbmVCb2R5LCBsaW5lU2hhcGUsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSwganVzdFRlc3QsIGxpbmVSYWRpdXMsIGNpcmNsZVJhZGl1cykge1xyXG4gICAgICAgIGxpbmVSYWRpdXMgPSBsaW5lUmFkaXVzICE9PSBudWxsICYmIGxpbmVSYWRpdXMgIT09IHZvaWQgMCA/IGxpbmVSYWRpdXMgOiAwO1xyXG4gICAgICAgIHZhciBvcnRob0Rpc3QgPSB0bXAxO1xyXG4gICAgICAgIHZhciBsaW5lVG9DaXJjbGVPcnRob1VuaXQgPSB0bXAyO1xyXG4gICAgICAgIHZhciBwcm9qZWN0ZWRQb2ludCA9IHRtcDM7XHJcbiAgICAgICAgdmFyIGNlbnRlckRpc3QgPSB0bXA0O1xyXG4gICAgICAgIHZhciB3b3JsZFRhbmdlbnQgPSB0bXA1O1xyXG4gICAgICAgIHZhciB3b3JsZEVkZ2UgPSB0bXA2O1xyXG4gICAgICAgIHZhciB3b3JsZEVkZ2VVbml0ID0gdG1wNztcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wODtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgxID0gdG1wOTtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwMSA9IHRtcDEwO1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDExID0gdG1wMTE7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAxMjtcclxuICAgICAgICB2YXIgbGluZVRvQ2lyY2xlID0gdG1wMTM7XHJcbiAgICAgICAgdmFyIGxpbmVFbmRUb0xpbmVSYWRpdXMgPSB0bXAxNDtcclxuICAgICAgICB2YXIgdmVydHMgPSB0bXBBcnJheTtcclxuICAgICAgICB2YXIgaGFsZkxpbmVMZW5ndGggPSBsaW5lU2hhcGUubGVuZ3RoIC8gMjtcclxuICAgICAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQod29ybGRWZXJ0ZXgwLCAtaGFsZkxpbmVMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh3b3JsZFZlcnRleDEsIGhhbGZMaW5lTGVuZ3RoLCAwKTtcclxuICAgICAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwLCBsaW5lT2Zmc2V0LCBsaW5lQW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxLCBsaW5lT2Zmc2V0LCBsaW5lQW5nbGUpO1xyXG4gICAgICAgIGNvcHkod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAxKTtcclxuICAgICAgICBjb3B5KHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxMSk7XHJcbiAgICAgICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxyXG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICBub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcclxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS5cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgcGxhbmUgc3Bhbm5lZCBieSB0aGUgZWRnZSB2cyB0aGUgY2lyY2xlXHJcbiAgICAgICAgc3ViKGRpc3QsIGNpcmNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZFRhbmdlbnQpOyAvLyBEaXN0YW5jZSBmcm9tIGNlbnRlciBvZiBsaW5lIHRvIGNpcmNsZSBjZW50ZXJcclxuICAgICAgICBzdWIoY2VudGVyRGlzdCwgd29ybGRWZXJ0ZXgwLCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICBzdWIobGluZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgIHZhciByYWRpdXNTdW0gPSBjaXJjbGVSYWRpdXMgKyBsaW5lUmFkaXVzO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhkKSA8IHJhZGl1c1N1bSkge1xyXG4gICAgICAgICAgICAvLyBOb3cgcHJvamVjdCB0aGUgY2lyY2xlIG9udG8gdGhlIGVkZ2VcclxuICAgICAgICAgICAgc2NhbGUob3J0aG9EaXN0LCB3b3JsZFRhbmdlbnQsIGQpO1xyXG4gICAgICAgICAgICBzdWIocHJvamVjdGVkUG9pbnQsIGNpcmNsZU9mZnNldCwgb3J0aG9EaXN0KTtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBtaXNzaW5nIGxpbmUgcmFkaXVzXHJcbiAgICAgICAgICAgIHNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgd29ybGRUYW5nZW50LCBkb3Qod29ybGRUYW5nZW50LCBsaW5lVG9DaXJjbGUpKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcclxuICAgICAgICAgICAgc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQocHJvamVjdGVkUG9pbnQsIHByb2plY3RlZFBvaW50LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBlZGdlIHNwYW5cclxuICAgICAgICAgICAgdmFyIHBvcyA9IGRvdCh3b3JsZEVkZ2VVbml0LCBwcm9qZWN0ZWRQb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBwb3MwID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgICAgIHZhciBwb3MxID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MSk7XHJcbiAgICAgICAgICAgIGlmIChwb3MgPiBwb3MwICYmIHBvcyA8IHBvczEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGdvdCBjb250YWN0IVxyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksIGxpbmVCb2R5LCBjaXJjbGVTaGFwZSwgbGluZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgIHNjYWxlKGMubm9ybWFsQSwgb3J0aG9EaXN0LCAtMSk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgcHJvamVjdGVkUG9pbnQsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGNvcm5lclxyXG4gICAgICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xyXG4gICAgICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuICAgICAgICAgICAgc3ViKGRpc3QsIHYsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzU3VtLCAyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksIGxpbmVCb2R5LCBjaXJjbGVTaGFwZSwgbGluZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHNjYWxlKGxpbmVFbmRUb0xpbmVSYWRpdXMsIGMubm9ybWFsQSwgLWxpbmVSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lRW5kVG9MaW5lUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL2NhcHN1bGUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlQ2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICBiaVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBzaVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICB4aVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICBialxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICBzalxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICB4alxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhalxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DQVBTVUxFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uIChiaSwgc2ksIHhpLCBiaiwgc2osIHhqLCBhaiwganVzdFRlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKGJpLCBzaSwgeGksIGJqLCBzaiwgeGosIGFqLCBqdXN0VGVzdCwgMCwgc2kucmFkaXVzKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZS9jb252ZXggTmFycm93cGhhc2UuXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZUNvbnZleFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlUmFkaXVzXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyBTaG91bGQgcHJvYmFibHkgZG8gYSBzZXBhcmF0aW5nIGF4aXMgdGVzdCBsaWtlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcmluY2F0dG8vQm94MkQvYmxvYi9tYXN0ZXIvQm94MkQvQm94MkQvQ29sbGlzaW9uL2IyQ29sbGlkZUNpcmNsZS5jcHAjTDYyXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNPTlZFWF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ29udmV4ID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVPZmZzZXQsIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCwgY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsIHdvcmxkVmVydGV4MSA9IHRtcDIsIGVkZ2UgPSB0bXAzLCBlZGdlVW5pdCA9IHRtcDQsIG5vcm1hbCA9IHRtcDUsIHplcm8gPSB0bXA2LCBsb2NhbENpcmNsZVBvc2l0aW9uID0gdG1wNywgciA9IHRtcDgsIGRpc3QgPSB0bXAxMCwgd29ybGRWZXJ0ZXggPSB0bXAxMSwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLCBjYW5kaWRhdGUgPSB0bXAxNCwgY2FuZGlkYXRlRGlzdCA9IHRtcDE1LCBmb3VuZCA9IC0xLCBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IEluZmluaXR5O1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh6ZXJvLCAwLCAwKTtcclxuICAgICAgICAvLyBOZXcgYWxnb3JpdGhtOlxyXG4gICAgICAgIC8vIDEuIENoZWNrIHNvIGNlbnRlciBvZiBjaXJjbGUgaXMgbm90IGluc2lkZSB0aGUgcG9seWdvbi4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXHJcbiAgICAgICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxyXG4gICAgICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxyXG4gICAgICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxDaXJjbGVQb3NpdGlvbiwgY2lyY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgbm9ybWFscyA9IGNvbnZleFNoYXBlLm5vcm1hbHM7XHJcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBub3JtYWxJbmRleCA9IC0xO1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIG1pbiBzZXBhcmF0aW5nIGVkZ2UuXHJcbiAgICAgICAgdmFyIHNlcGFyYXRpb24gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IGNvbnZleFNoYXBlLmJvdW5kaW5nUmFkaXVzICsgY2lyY2xlUmFkaXVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydGljZXM7IGkrKykge1xyXG4gICAgICAgICAgICBzdWIociwgbG9jYWxDaXJjbGVQb3NpdGlvbiwgdmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcyA9IGRvdChub3JtYWxzW2ldLCByKTtcclxuICAgICAgICAgICAgaWYgKHMgPiByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVhcmx5IG91dC5cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzID4gc2VwYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZWRnZXMgZmlyc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gbm9ybWFsSW5kZXggKyBudW1WZXJ0aWNlcyAtIDE7IGkgPCBub3JtYWxJbmRleCArIG51bVZlcnRpY2VzICsgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IHZlcnRpY2VzW2kgJSBudW1WZXJ0aWNlc10sIG4gPSBub3JtYWxzW2kgJSBudW1WZXJ0aWNlc107XHJcbiAgICAgICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIGNvbnZleFxyXG4gICAgICAgICAgICBzY2FsZShjYW5kaWRhdGUsIG4sIC1jaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQoY2FuZGlkYXRlLCBjYW5kaWRhdGUsIGxvY2FsQ2lyY2xlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRJbkNvbnZleExvY2FsKGNhbmRpZGF0ZSwgY29udmV4U2hhcGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdWIoY2FuZGlkYXRlRGlzdCwgdjAsIGNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyhkb3QoY2FuZGlkYXRlRGlzdCwgbikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydGljZXNbZm91bmQgJSBudW1WZXJ0aWNlc10sIHYxID0gdmVydGljZXNbKGZvdW5kICsgMSkgJSBudW1WZXJ0aWNlc107XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgIHN1YihlZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZShlZGdlVW5pdCwgZWRnZSk7XHJcbiAgICAgICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlOTBjdyhub3JtYWwsIGVkZ2VVbml0KTtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgY29udmV4XHJcbiAgICAgICAgICAgIHNjYWxlKGNhbmRpZGF0ZSwgbm9ybWFsLCAtY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgYWRkKGNhbmRpZGF0ZSwgY2FuZGlkYXRlLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICBzY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBub3JtYWwsIG1pbkNhbmRpZGF0ZURpc3RhbmNlKTtcclxuICAgICAgICAgICAgYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgY29udmV4Qm9keSwgY2lyY2xlU2hhcGUsIGNvbnZleFNoYXBlKTtcclxuICAgICAgICAgICAgc3ViKGMubm9ybWFsQSwgY2FuZGlkYXRlLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGNsb3Nlc3QgdmVydGljZXNcclxuICAgICAgICBpZiAoY2lyY2xlUmFkaXVzID4gMCAmJiBub3JtYWxJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5vcm1hbEluZGV4ICsgbnVtVmVydGljZXM7IGkgPCBub3JtYWxJbmRleCArIG51bVZlcnRpY2VzICsgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxWZXJ0ZXggPSB2ZXJ0aWNlc1tpICUgbnVtVmVydGljZXNdO1xyXG4gICAgICAgICAgICAgICAgc3ViKGRpc3QsIGxvY2FsVmVydGV4LCBsb2NhbENpcmNsZVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpIDwgY2lyY2xlUmFkaXVzICogY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4LCBsb2NhbFZlcnRleCwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkVmVydGV4LCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgY29udmV4Qm9keSwgY2lyY2xlU2hhcGUsIGNvbnZleFNoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3B5KGMubm9ybWFsQSwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGFydGljbGUvY29udmV4IE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIHBhcnRpY2xlQ29udmV4XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gdXNlIHBvaW50SW5Db252ZXggYW5kIGNvZGUgbW9yZSBzaW1pbGFyIHRvIGNpcmNsZUNvbnZleFxyXG4gICAgICogQHRvZG8gZG9uJ3QgdHJhbnNmb3JtIGVhY2ggdmVydGV4LCBidXQgdHJhbnNmb3JtIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiB0byBjb252ZXgtbG9jYWwgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNPTlZFWF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5CT1hdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNvbnZleCA9IGZ1bmN0aW9uIChwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSwganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSwgd29ybGRWZXJ0ZXgxID0gdG1wMiwgd29ybGRFZGdlID0gdG1wMywgd29ybGRFZGdlVW5pdCA9IHRtcDQsIHdvcmxkVGFuZ2VudCA9IHRtcDUsIGNlbnRlckRpc3QgPSB0bXA2LCBjb252ZXhUb3BhcnRpY2xlID0gdG1wNywgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLCBjYW5kaWRhdGVEaXN0ID0gdG1wMTQsIG1pbkVkZ2VOb3JtYWwgPSB0bXAxNSwgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBJbmZpbml0eSwgZm91bmQgPSBmYWxzZSwgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGFydGljbGUgaXMgaW4gdGhlIHBvbHlnb24gYXQgYWxsXHJcbiAgICAgICAgaWYgKCFwb2ludEluQ29udmV4KHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhTaGFwZSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZWRnZXMgZmlyc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtVmVydHMgPSB2ZXJ0cy5sZW5ndGg7IGkgIT09IG51bVZlcnRzICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IHZlcnRzW2kgJSBudW1WZXJ0c10sIHYxID0gdmVydHNbKGkgKyAxKSAlIG51bVZlcnRzXTtcclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXHJcbiAgICAgICAgICAgIC8vIEB0b2RvIHRyYW5zZm9ybSBwb2ludCB0byBsb2NhbCBzcGFjZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgZWRnZVxyXG4gICAgICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xyXG4gICAgICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgaW5maW5pdGUgbGluZSAoc3Bhbm5lZCBieSB0aGUgZWRnZSkgdG8gdGhlIHBhcnRpY2xlXHJcbiAgICAgICAgICAgIC8vc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgICAgICAvL2xldCBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIHN1Yihjb252ZXhUb3BhcnRpY2xlLCBwYXJ0aWNsZU9mZnNldCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGNhbmRpZGF0ZURpc3QsIHdvcmxkVmVydGV4MCwgcGFydGljbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlRGlzdGFuY2UgPSBNYXRoLmFicyhkb3QoY2FuZGlkYXRlRGlzdCwgd29ybGRUYW5nZW50KSk7XHJcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgd29ybGRUYW5nZW50LCBjYW5kaWRhdGVEaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgcGFydGljbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgY29weShtaW5FZGdlTm9ybWFsLCB3b3JsZFRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBhcnRpY2xlQm9keSwgY29udmV4Qm9keSwgcGFydGljbGVTaGFwZSwgY29udmV4U2hhcGUpO1xyXG4gICAgICAgICAgICBzY2FsZShjLm5vcm1hbEEsIG1pbkVkZ2VOb3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgLy8gUGFydGljbGUgaGFzIG5vIGV4dGVudCB0byB0aGUgY29udGFjdCBwb2ludFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoYy5jb250YWN0UG9pbnRBLCAwLCAwKTtcclxuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy8gRnJvbSBjb252ZXggY2VudGVyIHRvIHBvaW50XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUvY2lyY2xlIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZUNpcmNsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVCXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNBXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQl0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNpcmNsZSA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBvZmZzZXRBLCBib2R5Qiwgc2hhcGVCLCBvZmZzZXRCLCBqdXN0VGVzdCwgcmFkaXVzQSwgcmFkaXVzQikge1xyXG4gICAgICAgIHZhciBkaXN0ID0gdG1wMTtcclxuICAgICAgICBzdWIoZGlzdCwgb2Zmc2V0QSwgb2Zmc2V0Qik7XHJcbiAgICAgICAgdmFyIHIgPSByYWRpdXNBICsgcmFkaXVzQjtcclxuICAgICAgICBpZiAoc3F1YXJlZExlbmd0aChkaXN0KSA+IHIgKiByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQik7XHJcbiAgICAgICAgdmFyIGNwQSA9IGMuY29udGFjdFBvaW50QTtcclxuICAgICAgICB2YXIgY3BCID0gYy5jb250YWN0UG9pbnRCO1xyXG4gICAgICAgIHZhciBub3JtYWxBID0gYy5ub3JtYWxBO1xyXG4gICAgICAgIHN1Yihub3JtYWxBLCBvZmZzZXRCLCBvZmZzZXRBKTtcclxuICAgICAgICBub3JtYWxpemUobm9ybWFsQSwgbm9ybWFsQSk7XHJcbiAgICAgICAgc2NhbGUoY3BBLCBub3JtYWxBLCByYWRpdXNBKTtcclxuICAgICAgICBzY2FsZShjcEIsIG5vcm1hbEEsIC1yYWRpdXNCKTtcclxuICAgICAgICBhZGRTdWIoY3BBLCBjcEEsIG9mZnNldEEsIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICBhZGRTdWIoY3BCLCBjcEIsIG9mZnNldEIsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFuZS9Db252ZXggTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgcGxhbmVDb252ZXhcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IHBsYW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7UGxhbmV9IHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyBvbmx5IHVzZSB0aGUgZGVlcGVzdCBjb250YWN0IHBvaW50ICsgdGhlIGNvbnRhY3QgcG9pbnQgZnVydGhlc3QgYXdheSBmcm9tIGl0XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkJPWF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24gKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleCA9IHRtcDEsIHdvcmxkTm9ybWFsID0gdG1wMiwgZGlzdCA9IHRtcDMsIGxvY2FsUGxhbmVPZmZzZXQgPSB0bXA0LCBsb2NhbFBsYW5lTm9ybWFsID0gdG1wNSwgbG9jYWxEaXN0ID0gdG1wNjtcclxuICAgICAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xyXG4gICAgICAgIC8vIEdldCBjb252ZXgtbG9jYWwgcGxhbmUgb2Zmc2V0IGFuZCBub3JtYWxcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC52ZWN0b3JUb0xvY2FsRnJhbWUobG9jYWxQbGFuZU5vcm1hbCwgd29ybGROb3JtYWwsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxQbGFuZU9mZnNldCwgcGxhbmVPZmZzZXQsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0cyA9IHZlcnRpY2VzLmxlbmd0aDsgaSAhPT0gbnVtVmVydHM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICBzdWIobG9jYWxEaXN0LCB2LCBsb2NhbFBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGRvdChsb2NhbERpc3QsIGxvY2FsUGxhbmVOb3JtYWwpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleCwgdiwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIHZlcnRleFxyXG4gICAgICAgICAgICAgICAgbnVtUmVwb3J0ZWQrKztcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjb252ZXhCb2R5LCBwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcclxuICAgICAgICAgICAgICAgIC8vIHJqIGlzIGZyb20gY29udmV4IGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4Qm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAvLyByaSBpcyBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB3b3JsZFZlcnRleCwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbiAmJiBudW1SZXBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1SZXBvcnRlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1SZXBvcnRlZDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5hcnJvd3BoYXNlIGZvciBwYXJ0aWNsZSB2cyBwbGFuZVxyXG4gICAgICogQG1ldGhvZCBwYXJ0aWNsZVBsYW5lXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwYXJ0aWNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BhcnRpY2xlfSAgIHBhcnRpY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBhcnRpY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BsYW5lfSAgICAgIHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlBMQU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVQbGFuZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlT2Zmc2V0LCBwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBkaXN0ID0gdG1wMSwgd29ybGROb3JtYWwgPSB0bXAyO1xyXG4gICAgICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XHJcbiAgICAgICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XHJcbiAgICAgICAgcm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XHJcbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgIGlmIChkID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSwgcGFydGljbGVCb2R5LCBwbGFuZVNoYXBlLCBwYXJ0aWNsZVNoYXBlKTtcclxuICAgICAgICBjb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgIHNjYWxlKGRpc3QsIGMubm9ybWFsQSwgZCk7XHJcbiAgICAgICAgLy8gZGlzdCBpcyBub3cgdGhlIGRpc3RhbmNlIHZlY3RvciBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxyXG4gICAgICAgIC8vIHJpIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgZG93biBvbnRvIHRoZSBwbGFuZSwgZnJvbSB0aGUgcGxhbmUgY2VudGVyXHJcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQsIGRpc3QpO1xyXG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAvLyByaiBpcyBmcm9tIHRoZSBib2R5IGNlbnRlciB0byB0aGUgcGFydGljbGUgY2VudGVyXHJcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL1BhcnRpY2xlIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZVBhcnRpY2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBBUlRJQ0xFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGFydGljbGUgPSBmdW5jdGlvbiAoY2lyY2xlQm9keSwgY2lyY2xlU2hhcGUsIGNpcmNsZU9mZnNldCwgcGFydGljbGVCb2R5LCBwYXJ0aWNsZVNoYXBlLCBwYXJ0aWNsZU9mZnNldCwganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgZGlzdCA9IHRtcDE7XHJcbiAgICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IGNpcmNsZVNoYXBlLnJhZGl1cztcclxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgaWYgKHNxdWFyZWRMZW5ndGgoZGlzdCkgPiBjaXJjbGVSYWRpdXMgKiBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LCBwYXJ0aWNsZUJvZHksIGNpcmNsZVNoYXBlLCBwYXJ0aWNsZVNoYXBlKTtcclxuICAgICAgICB2YXIgbm9ybWFsQSA9IGMubm9ybWFsQTtcclxuICAgICAgICB2YXIgY29udGFjdFBvaW50QSA9IGMuY29udGFjdFBvaW50QTtcclxuICAgICAgICB2YXIgY29udGFjdFBvaW50QiA9IGMuY29udGFjdFBvaW50QjtcclxuICAgICAgICBjb3B5KG5vcm1hbEEsIGRpc3QpO1xyXG4gICAgICAgIG5vcm1hbGl6ZShub3JtYWxBLCBub3JtYWxBKTtcclxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXHJcbiAgICAgICAgc2NhbGUoY29udGFjdFBvaW50QSwgbm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICBhZGQoY29udGFjdFBvaW50QSwgY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICBzdWIoY29udGFjdFBvaW50QSwgY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgLy8gVmVjdG9yIGZyb20gcGFydGljbGUgY2VudGVyIHRvIGNvbnRhY3QgcG9pbnQgaXMgemVyb1xyXG4gICAgICAgIHN1Yihjb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHBsYW5lQ2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjYXBzdWxlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9IGNhcHN1bGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNhcHN1bGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2Fwc3VsZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uIChwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLCBjYXBzdWxlQm9keSwgY2Fwc3VsZVNoYXBlLCBjYXBzdWxlT2Zmc2V0LCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUgPSBuZXcgQ2lyY2xlXzEuZGVmYXVsdCh7IHJhZGl1czogMSB9KTtcclxuICAgICAgICB2YXIgZW5kMSA9IHBsYW5lQ2Fwc3VsZV90bXAxLCBlbmQyID0gcGxhbmVDYXBzdWxlX3RtcDIsIGNpcmNsZSA9IHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUsIGhhbGZMZW5ndGggPSBjYXBzdWxlU2hhcGUubGVuZ3RoIC8gMjtcclxuICAgICAgICAvLyBDb21wdXRlIHdvcmxkIGVuZCBwb3NpdGlvbnNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoZW5kMSwgLWhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlbmQyLCBoYWxmTGVuZ3RoLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGVuZDEsIGVuZDEsIGNhcHN1bGVPZmZzZXQsIGNhcHN1bGVBbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShlbmQyLCBlbmQyLCBjYXBzdWxlT2Zmc2V0LCBjYXBzdWxlQW5nbGUpO1xyXG4gICAgICAgIGNpcmNsZS5yYWRpdXMgPSBjYXBzdWxlU2hhcGUucmFkaXVzO1xyXG4gICAgICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XHJcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIE5hcnJvd3BoYXNlIGFzIHR3byBjaXJjbGVzXHJcbiAgICAgICAgdmFyIG51bUNvbnRhY3RzMSA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksIGNpcmNsZSwgZW5kMSwgcGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwganVzdFRlc3QpLCBudW1Db250YWN0czIgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LCBjaXJjbGUsIGVuZDIsIHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAvLyBSZXN0b3JlIGZyaWN0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzMSArIG51bUNvbnRhY3RzMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBudW1Ub3RhbCA9IG51bUNvbnRhY3RzMSArIG51bUNvbnRhY3RzMjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChudW1Ub3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtVG90YWwpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVtVG90YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjaXJjbGVQbGFuZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgY2lyY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSAgY2lyY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIGNpcmNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgcGxhbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQbGFuZX0gICBwbGFuZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICBwbGFuZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgcGxhbmVBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUExBTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQbGFuZSA9IGZ1bmN0aW9uIChjaXJjbGVCb2R5LCBjaXJjbGVTaGFwZSwgY2lyY2xlT2Zmc2V0LCBwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBjaXJjbGVSYWRpdXMgPSBjaXJjbGVTaGFwZS5yYWRpdXM7XHJcbiAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgdG8gY2lyY2xlXHJcbiAgICAgICAgdmFyIHBsYW5lVG9DaXJjbGUgPSB0bXAxLCB3b3JsZE5vcm1hbCA9IHRtcDIsIHRlbXAgPSB0bXAzO1xyXG4gICAgICAgIHN1YihwbGFuZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAvLyBXb3JsZCBwbGFuZSBub3JtYWxcclxuICAgICAgICByb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcclxuICAgICAgICAvLyBOb3JtYWwgZGlyZWN0aW9uIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsIHBsYW5lVG9DaXJjbGUpO1xyXG4gICAgICAgIGlmIChkID4gY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBObyBvdmVybGFwLiBBYm9ydC5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgY29udGFjdFxyXG4gICAgICAgIHZhciBjb250YWN0ID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjaXJjbGVCb2R5LCBwbGFuZVNoYXBlLCBjaXJjbGVTaGFwZSk7XHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIHBsYW5lIHdvcmxkIG5vcm1hbFxyXG4gICAgICAgIGNvcHkoY29udGFjdC5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgLy8gcmogaXMgdGhlIHZlY3RvciBmcm9tIGNpcmNsZSBjZW50ZXIgdG8gdGhlIGNvbnRhY3QgcG9pbnRcclxuICAgICAgICB2YXIgY3BCID0gY29udGFjdC5jb250YWN0UG9pbnRCO1xyXG4gICAgICAgIHNjYWxlKGNwQiwgY29udGFjdC5ub3JtYWxBLCAtY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICBhZGQoY3BCLCBjcEIsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgc3ViKGNwQiwgY3BCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAvLyByaSBpcyB0aGUgZGlzdGFuY2UgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdC5cclxuICAgICAgICB2YXIgY3BBID0gY29udGFjdC5jb250YWN0UG9pbnRBO1xyXG4gICAgICAgIHNjYWxlKHRlbXAsIGNvbnRhY3Qubm9ybWFsQSwgZCk7XHJcbiAgICAgICAgc3ViKGNwQSwgcGxhbmVUb0NpcmNsZSwgdGVtcCk7IC8vIFN1YnRyYWN0IG5vcm1hbCBkaXN0YW5jZSB2ZWN0b3IgZnJvbSB0aGUgZGlzdGFuY2UgdmVjdG9yXHJcbiAgICAgICAgYWRkKGNwQSwgY3BBLCBwbGFuZU9mZnNldCk7XHJcbiAgICAgICAgc3ViKGNwQSwgY3BBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGNvbnRhY3QpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoY29udGFjdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvLyBGaW5kIGVkZ2Ugbm9ybWFsIG9mIG1heCBzZXBhcmF0aW9uIG9uIEEgLSByZXR1cm4gaWYgc2VwYXJhdGluZyBheGlzIGlzIGZvdW5kXHJcbiAgICAvLyBGaW5kIGVkZ2Ugbm9ybWFsIG9mIG1heCBzZXBhcmF0aW9uIG9uIEIgLSByZXR1cm4gaWYgc2VwYXJhdGlvbiBheGlzIGlzIGZvdW5kXHJcbiAgICAvLyBDaG9vc2UgcmVmZXJlbmNlIGVkZ2UgYXMgbWluKG1pbkEsIG1pbkIpXHJcbiAgICAvLyBGaW5kIGluY2lkZW50IGVkZ2VcclxuICAgIC8vIENsaXBcclxuICAgIC8vIFRoZSBub3JtYWwgcG9pbnRzIGZyb20gMSB0byAyXHJcbiAgICAvKmZ1bmN0aW9uIGNvbGxpZGVQb2x5Z29ucyhcclxuICAgICAgICBtYW5pZm9sZCxcclxuICAgICAgICBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEsXHJcbiAgICAgICAgcG9seUIsIHBvc2l0aW9uQiwgYW5nbGVCLFxyXG4gICAgICAgIGluY2lkZW50RWRnZVxyXG4gICAgKSB7Ki9cclxuICAgIC8qKlxyXG4gICAgICogQ29udmV4L2NvbnZleCBOYXJyb3dwaGFzZS5TZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWx0ZGV2YmxvZ2FkYXkuY29tLzIwMTEvMDUvMTMvY29udGFjdC1nZW5lcmF0aW9uLWJldHdlZW4tM2QtY29udmV4LW1lc2hlcy9cIj50aGlzIGFydGljbGU8L2E+IGZvciBtb3JlIGluZm8uXHJcbiAgICAgKiBAbWV0aG9kIGNvbnZleENvbnZleFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYmlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gc2lcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB4aVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhaVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYmpcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gc2pcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB4alxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhalxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5CT1hdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkJPWF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uIChib2R5QSwgcG9seUEsIHBvc2l0aW9uQSwgYW5nbGVBLCBib2R5QiwgcG9seUIsIHBvc2l0aW9uQiwgYW5nbGVCLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBtYXhNYW5pZm9sZFBvaW50cyA9IDI7XHJcbiAgICAgICAgdmFyIHRvdGFsUmFkaXVzID0gMDtcclxuICAgICAgICB2YXIgZGlzdCA9IGNvbGxpZGVQb2x5Z29uc19kaXN0O1xyXG4gICAgICAgIHZhciB0ZW1wVmVjID0gY29sbGlkZVBvbHlnb25zX3RlbXBWZWM7XHJcbiAgICAgICAgdmFyIHRtcFZlYyA9IGNvbGxpZGVQb2x5Z29uc190bXBWZWM7XHJcbiAgICAgICAgdmFyIGVkZ2VBID0gZmluZE1heFNlcGFyYXRpb24odGVtcFZlYywgcG9seUEsIHBvc2l0aW9uQSwgYW5nbGVBLCBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIpO1xyXG4gICAgICAgIHZhciBzZXBhcmF0aW9uQSA9IHRlbXBWZWNbMF07XHJcbiAgICAgICAgaWYgKHNlcGFyYXRpb25BID4gdG90YWxSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlZGdlQiA9IGZpbmRNYXhTZXBhcmF0aW9uKHRtcFZlYywgcG9seUIsIHBvc2l0aW9uQiwgYW5nbGVCLCBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEpO1xyXG4gICAgICAgIHZhciBzZXBhcmF0aW9uQiA9IHRtcFZlY1swXTtcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkIgPiB0b3RhbFJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvbHkxOyAvLyByZWZlcmVuY2UgcG9seWdvblxyXG4gICAgICAgIHZhciBwb2x5MjsgLy8gaW5jaWRlbnQgcG9seWdvblxyXG4gICAgICAgIHZhciBwb3NpdGlvbjE7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uMjtcclxuICAgICAgICB2YXIgYW5nbGUxO1xyXG4gICAgICAgIHZhciBhbmdsZTI7XHJcbiAgICAgICAgdmFyIGJvZHkxO1xyXG4gICAgICAgIHZhciBib2R5MjtcclxuICAgICAgICB2YXIgZWRnZTE7IC8vIHJlZmVyZW5jZSBlZGdlXHJcbiAgICAgICAgdmFyIHR5cGU7XHJcbiAgICAgICAgaWYgKHNlcGFyYXRpb25CID4gc2VwYXJhdGlvbkEpIHtcclxuICAgICAgICAgICAgcG9seTEgPSBwb2x5QjtcclxuICAgICAgICAgICAgcG9seTIgPSBwb2x5QTtcclxuICAgICAgICAgICAgYm9keTEgPSBib2R5QjtcclxuICAgICAgICAgICAgYm9keTIgPSBib2R5QTtcclxuICAgICAgICAgICAgcG9zaXRpb24xID0gcG9zaXRpb25CO1xyXG4gICAgICAgICAgICBhbmdsZTEgPSBhbmdsZUI7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMiA9IHBvc2l0aW9uQTtcclxuICAgICAgICAgICAgYW5nbGUyID0gYW5nbGVBO1xyXG4gICAgICAgICAgICBlZGdlMSA9IGVkZ2VCO1xyXG4gICAgICAgICAgICB0eXBlID0gMTsgLy8gZmFjZUJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvbHkxID0gcG9seUE7XHJcbiAgICAgICAgICAgIHBvbHkyID0gcG9seUI7XHJcbiAgICAgICAgICAgIGJvZHkxID0gYm9keUE7XHJcbiAgICAgICAgICAgIGJvZHkyID0gYm9keUI7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMSA9IHBvc2l0aW9uQTtcclxuICAgICAgICAgICAgYW5nbGUxID0gYW5nbGVBO1xyXG4gICAgICAgICAgICBwb3NpdGlvbjIgPSBwb3NpdGlvbkI7XHJcbiAgICAgICAgICAgIGFuZ2xlMiA9IGFuZ2xlQjtcclxuICAgICAgICAgICAgZWRnZTEgPSBlZGdlQTtcclxuICAgICAgICAgICAgdHlwZSA9IDA7IC8vIGZhY2VBXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmNpZGVudEVkZ2UgPSBjb2xsaWRlUG9seWdvbnNfaW5jaWRlbnRFZGdlO1xyXG4gICAgICAgIGZpbmRJbmNpZGVudEVkZ2UoaW5jaWRlbnRFZGdlLCBwb2x5MSwgcG9zaXRpb24xLCBhbmdsZTEsIGVkZ2UxLCBwb2x5MiwgcG9zaXRpb24yLCBhbmdsZTIpO1xyXG4gICAgICAgIHZhciBjb3VudDEgPSBwb2x5MS52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzMSA9IHBvbHkxLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBpdjEgPSBlZGdlMTtcclxuICAgICAgICB2YXIgaXYyID0gZWRnZTEgKyAxIDwgY291bnQxID8gZWRnZTEgKyAxIDogMDtcclxuICAgICAgICB2YXIgdjExID0gY29sbGlkZVBvbHlnb25zX3YxMTtcclxuICAgICAgICB2YXIgdjEyID0gY29sbGlkZVBvbHlnb25zX3YxMjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHYxMSwgdmVydGljZXMxW2l2MV0pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodjEyLCB2ZXJ0aWNlczFbaXYyXSk7XHJcbiAgICAgICAgdmFyIGxvY2FsVGFuZ2VudCA9IGNvbGxpZGVQb2x5Z29uc19sb2NhbFRhbmdlbnQ7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobG9jYWxUYW5nZW50LCB2MTIsIHYxMSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKGxvY2FsVGFuZ2VudCwgbG9jYWxUYW5nZW50KTtcclxuICAgICAgICB2YXIgbG9jYWxOb3JtYWwgPSBjb2xsaWRlUG9seWdvbnNfbG9jYWxOb3JtYWw7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3Jvc3NWWihsb2NhbE5vcm1hbCwgbG9jYWxUYW5nZW50LCAxLjApO1xyXG4gICAgICAgIHZhciBwbGFuZVBvaW50ID0gY29sbGlkZVBvbHlnb25zX3BsYW5lUG9pbnQ7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHBsYW5lUG9pbnQsIHYxMSwgdjEyKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShwbGFuZVBvaW50LCBwbGFuZVBvaW50LCAwLjUpO1xyXG4gICAgICAgIHZhciB0YW5nZW50ID0gY29sbGlkZVBvbHlnb25zX3RhbmdlbnQ7IC8vIHRhbmdlbnQgaW4gd29ybGQgc3BhY2VcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUodGFuZ2VudCwgbG9jYWxUYW5nZW50LCBhbmdsZTEpO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBjb2xsaWRlUG9seWdvbnNfbm9ybWFsOyAvLyBub3JtYWwgaW4gd29ybGQgc3BhY2VcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcm9zc1ZaKG5vcm1hbCwgdGFuZ2VudCwgMS4wKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHYxMSwgdjExLCBwb3NpdGlvbjEsIGFuZ2xlMSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh2MTIsIHYxMiwgcG9zaXRpb24xLCBhbmdsZTEpO1xyXG4gICAgICAgIC8vIEZhY2Ugb2Zmc2V0LlxyXG4gICAgICAgIHZhciBmcm9udE9mZnNldCA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHYxMSk7XHJcbiAgICAgICAgLy8gU2lkZSBvZmZzZXRzLCBleHRlbmRlZCBieSBwb2x5dG9wZSBza2luIHRoaWNrbmVzcy5cclxuICAgICAgICB2YXIgc2lkZU9mZnNldDEgPSAtdmVjMl8xLmRlZmF1bHQuZG90KHRhbmdlbnQsIHYxMSkgKyB0b3RhbFJhZGl1cztcclxuICAgICAgICB2YXIgc2lkZU9mZnNldDIgPSB2ZWMyXzEuZGVmYXVsdC5kb3QodGFuZ2VudCwgdjEyKSArIHRvdGFsUmFkaXVzO1xyXG4gICAgICAgIC8vIENsaXAgaW5jaWRlbnQgZWRnZSBhZ2FpbnN0IGV4dHJ1ZGVkIGVkZ2UxIHNpZGUgZWRnZXMuXHJcbiAgICAgICAgdmFyIGNsaXBQb2ludHMxID0gY29sbGlkZVBvbHlnb25zX2NsaXBQb2ludHMxO1xyXG4gICAgICAgIHZhciBjbGlwUG9pbnRzMiA9IGNvbGxpZGVQb2x5Z29uc19jbGlwUG9pbnRzMjtcclxuICAgICAgICB2YXIgbnAgPSAwO1xyXG4gICAgICAgIC8vIENsaXAgdG8gYm94IHNpZGUgMVxyXG4gICAgICAgIHZhciBuZWdhdGl2ZVRhbmdlbnQgPSBjb2xsaWRlUG9seWdvbnNfbmVnYXRpdmVUYW5nZW50O1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKG5lZ2F0aXZlVGFuZ2VudCwgdGFuZ2VudCwgLTEpO1xyXG4gICAgICAgIG5wID0gY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czEsIGluY2lkZW50RWRnZSwgbmVnYXRpdmVUYW5nZW50LCBzaWRlT2Zmc2V0MSAvKiwgaXYxKi8pO1xyXG4gICAgICAgIGlmIChucCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsaXAgdG8gbmVnYXRpdmUgYm94IHNpZGUgMVxyXG4gICAgICAgIG5wID0gY2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czIsIGNsaXBQb2ludHMxLCB0YW5nZW50LCBzaWRlT2Zmc2V0MiAvKiwgaXYyKi8pO1xyXG4gICAgICAgIGlmIChucCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludENvdW50ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE1hbmlmb2xkUG9pbnRzOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5kb3Qobm9ybWFsLCBjbGlwUG9pbnRzMltpXSkgLSBmcm9udE9mZnNldDtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gdG90YWxSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKytwb2ludENvdW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5MSwgYm9keTIsIHBvbHkxLCBwb2x5Mik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGMubm9ybWFsQSwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoYy5jb250YWN0UG9pbnRCLCBjbGlwUG9pbnRzMltpXSk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHkyLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGRpc3QsIG5vcm1hbCwgLXNlcGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKGMuY29udGFjdFBvaW50QSwgY2xpcFBvaW50czJbaV0sIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5MS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uICYmICF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvaW50Q291bnQgJiYgdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UocG9pbnRDb3VudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRDb3VudDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUhlaWdodGZpZWxkID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVQb3MsIGhmQm9keSwgaGZTaGFwZSwgaGZQb3MsIGp1c3RUZXN0LCByYWRpdXMpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGhmU2hhcGUuaGVpZ2h0cywgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLCBkaXN0ID0gY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCwgY2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlLCBtaW5DYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUsIG1pbkNhbmRpZGF0ZU5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCwgd29ybGROb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCwgdjAgPSBjaXJjbGVIZWlnaHRmaWVsZF92MCwgdjEgPSBjaXJjbGVIZWlnaHRmaWVsZF92MTtcclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XHJcbiAgICAgICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKChjaXJjbGVQb3NbMF0gLSByYWRpdXMgLSBoZlBvc1swXSkgLyB3KSwgaWR4QiA9IE1hdGguY2VpbCgoY2lyY2xlUG9zWzBdICsgcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyk7XHJcbiAgICAgICAgLyppZihpZHhCIDwgMCB8fCBpZHhBID49IGRhdGEubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7Ki9cclxuICAgICAgICBpZiAoaWR4QSA8IDApIHtcclxuICAgICAgICAgICAgaWR4QSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZHhCID49IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBtYXggYW5kIG1pblxyXG4gICAgICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLCBtaW4gPSBkYXRhW2lkeEJdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDwgaWR4QjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaXJjbGVQb3NbMV0gLSByYWRpdXMgPiBtYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgaWYoY2lyY2xlUG9zWzFdK3JhZGl1cyA8IG1pbil7XHJcbiAgICAgICAgICAgIC8vIEJlbG93IHRoZSBtaW5pbXVtIHBvaW50Li4uIFdlIGNhbiBqdXN0IGd1ZXNzLlxyXG4gICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBmaWVsZC4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXHJcbiAgICAgICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxyXG4gICAgICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxyXG4gICAgICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gaWR4QTsgaSA8IGlkeEI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRzXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2MCwgaSAqIHcsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjEsIChpICsgMSkgKiB3LCBkYXRhW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIGFkZCh2MCwgdjAsIGhmUG9zKTsgLy8gQHRvZG8gdHJhbnNmb3JtIGNpcmNsZSB0byBsb2NhbCBoZWlnaHRmaWVsZCBzcGFjZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIGFkZCh2MSwgdjEsIGhmUG9zKTtcclxuICAgICAgICAgICAgLy8gR2V0IG5vcm1hbFxyXG4gICAgICAgICAgICBzdWIod29ybGROb3JtYWwsIHYxLCB2MCk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgIC8vIEdldCBwb2ludCBvbiBjaXJjbGUsIGNsb3Nlc3QgdG8gdGhlIGVkZ2VcclxuICAgICAgICAgICAgc2NhbGUoY2FuZGlkYXRlLCB3b3JsZE5vcm1hbCwgLXJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFkZChjYW5kaWRhdGUsIGNhbmRpZGF0ZSwgY2lyY2xlUG9zKTtcclxuICAgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB2MCB0byB0aGUgY2FuZGlkYXRlIHBvaW50XHJcbiAgICAgICAgICAgIHN1YihkaXN0LCBjYW5kaWRhdGUsIHYwKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIGVsZW1lbnQgXCJzdGlja1wiXHJcbiAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVswXSA+PSB2MFswXSAmJiBjYW5kaWRhdGVbMF0gPCB2MVswXSAmJiBkIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNhbmRpZGF0ZSBwb2ludCwgcHJvamVjdGVkIHRvIHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBzY2FsZShkaXN0LCB3b3JsZE5vcm1hbCwgLWQpO1xyXG4gICAgICAgICAgICAgICAgYWRkKG1pbkNhbmRpZGF0ZSwgY2FuZGlkYXRlLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIGNvcHkobWluQ2FuZGlkYXRlTm9ybWFsLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSwgY2lyY2xlQm9keSwgaGZTaGFwZSwgY2lyY2xlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGlzIG91dCBvZiB0aGUgaGVpZ2h0ZmllbGRcclxuICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGVOb3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGhlaWdodGZpZWxkXHJcbiAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgY29weShjLmNvbnRhY3RQb2ludEEsIG1pbkNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgYWxsIHZlcnRpY2VzXHJcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBpZiAocmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaWR4QTsgaSA8PSBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBwb2ludFxyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHYwLCBpICogdywgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICBhZGQodjAsIHYwLCBoZlBvcyk7XHJcbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgY2lyY2xlUG9zLCB2MCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1cywgMikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSwgY2lyY2xlQm9keSwgaGZTaGFwZSwgY2lyY2xlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBub3JtYWwgLSBvdXQgb2YgaGVpZ2h0ZmllbGRcclxuICAgICAgICAgICAgICAgICAgICBjb3B5KGMubm9ybWFsQSwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdjAsIGhmUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YIHwgU2hhcGUuSEVJR0hURklFTERdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvcywgY29udmV4QW5nbGUsIGhmQm9keSwgaGZTaGFwZSwgaGZQb3MsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBoZlNoYXBlLmhlaWdodHMsIHcgPSBoZlNoYXBlLmVsZW1lbnRXaWR0aCwgdjAgPSBjb252ZXhIZWlnaHRmaWVsZF92MCwgdjEgPSBjb252ZXhIZWlnaHRmaWVsZF92MSwgdGlsZVBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MsIHRpbGVDb252ZXggPSBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGU7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxyXG4gICAgICAgIHZhciBpZHhBID0gTWF0aC5mbG9vcigoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3KSwgaWR4QiA9IE1hdGguY2VpbCgoY29udmV4Qm9keS5hYWJiLnVwcGVyQm91bmRbMF0gLSBoZlBvc1swXSkgLyB3KTtcclxuICAgICAgICBpZiAoaWR4QSA8IDApIHtcclxuICAgICAgICAgICAgaWR4QSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZHhCID49IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBtYXggYW5kIG1pblxyXG4gICAgICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLCBtaW4gPSBkYXRhW2lkeEJdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDwgaWR4QjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFsxXSA+IG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gMDtcclxuICAgICAgICAvLyBMb29wIG92ZXIgYWxsIGVkZ2VzXHJcbiAgICAgICAgLy8gQHRvZG8gSWYgcG9zc2libGUsIGNvbnN0cnVjdCBhIGNvbnZleCBmcm9tIHNldmVyYWwgZGF0YSBwb2ludHMgKG5lZWQgbyBjaGVjayBpZiB0aGUgcG9pbnRzIG1ha2UgYSBjb252ZXggc2hhcGUpXHJcbiAgICAgICAgLy8gQHRvZG8gdHJhbnNmb3JtIGNvbnZleCB0byBsb2NhbCBoZWlnaHRmaWVsZCBzcGFjZS5cclxuICAgICAgICAvLyBAdG9kbyBiYWlsIG91dCBpZiB0aGUgaGVpZ2h0ZmllbGQgdGlsZSBpcyBub3QgdGFsbCBlbm91Z2guXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkeEE7IGkgPCBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50c1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjAsIGkgKiB3LCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHYxLCAoaSArIDEpICogdywgZGF0YVtpICsgMV0pO1xyXG4gICAgICAgICAgICBhZGQodjAsIHYwLCBoZlBvcyk7XHJcbiAgICAgICAgICAgIGFkZCh2MSwgdjEsIGhmUG9zKTtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgY29udmV4XHJcbiAgICAgICAgICAgIHZhciB0aWxlSGVpZ2h0ID0gMTAwOyAvLyB0b2RvXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh0aWxlUG9zLCAodjFbMF0gKyB2MFswXSkgKiAwLjUsICh2MVsxXSArIHYwWzFdIC0gdGlsZUhlaWdodCkgKiAwLjUpO1xyXG4gICAgICAgICAgICBzdWIodGlsZUNvbnZleC52ZXJ0aWNlc1swXSwgdjEsIHRpbGVQb3MpO1xyXG4gICAgICAgICAgICBzdWIodGlsZUNvbnZleC52ZXJ0aWNlc1sxXSwgdjAsIHRpbGVQb3MpO1xyXG4gICAgICAgICAgICBjb3B5KHRpbGVDb252ZXgudmVydGljZXNbMl0sIHRpbGVDb252ZXgudmVydGljZXNbMV0pO1xyXG4gICAgICAgICAgICBjb3B5KHRpbGVDb252ZXgudmVydGljZXNbM10sIHRpbGVDb252ZXgudmVydGljZXNbMF0pO1xyXG4gICAgICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzJdWzFdIC09IHRpbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbM11bMV0gLT0gdGlsZUhlaWdodDtcclxuICAgICAgICAgICAgdGlsZUNvbnZleC51cGRhdGVOb3JtYWxzKCk7XHJcbiAgICAgICAgICAgIC8vIERvIGNvbnZleCBjb2xsaXNpb25cclxuICAgICAgICAgICAgbnVtQ29udGFjdHMgKz0gdGhpcy5jb252ZXhDb252ZXgoY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvcywgY29udmV4QW5nbGUsIGhmQm9keSwgdGlsZUNvbnZleCwgdGlsZVBvcywgMCwganVzdFRlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVtQ29udGFjdHM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5hcnJvd3BoYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBOYXJyb3dwaGFzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGludGVyc2VjdEJvZHlfd29ybGRQb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdjAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgaW50ZXJzZWN0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBSYXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy4gRm9yIGFuIGV4YW1wbGUsIHNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9yYXljYXN0Om1ldGhvZFwifX1Xb3JsZC5yYXljYXN0e3svY3Jvc3NMaW5rfX1cclxuICAgICAqIEBjbGFzcyBSYXlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZnJvbV1cclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnRvXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tb2RlPVJheS5BTlldXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmF5KG9wdGlvbnMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlbmd0aCBvZiB0aGUgcmF5XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5mcm9tKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMudG8gPSBvcHRpb25zLnRvID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy50bykgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XHJcbiAgICAgICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gb3B0aW9ucy5jb2xsaXNpb25Hcm91cCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25Hcm91cCA6IC0xO1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb2RlIDogUmF5LkFOWTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbiAoIC8qcmVzdWx0Ki8pIHsgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGlmIHlvdSBjaGFuZ2UgdGhlIGZyb20gb3IgdG8gcG9pbnQuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBVcGRhdGUgLmRpcmVjdGlvbiBhbmQgLmxlbmd0aFxyXG4gICAgICAgIHZhciBkID0gdGhpcy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZCwgdGhpcy50bywgdGhpcy5mcm9tKTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChkKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUoZCwgZCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb2RpZXMgPSBmdW5jdGlvbiAocmVzdWx0LCBib2RpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJvZGllcy5sZW5ndGg7ICFyZXN1bHQuc2hvdWxkU3RvcCh0aGlzKSAmJiBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYWFiYiA9IGJvZHkuZ2V0QUFCQigpO1xyXG4gICAgICAgICAgICBpZiAoYWFiYi5vdmVybGFwc1JheSh0aGlzKSA+PSAwIHx8IGFhYmIuY29udGFpbnNQb2ludCh0aGlzLmZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkocmVzdWx0LCBib2R5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cclxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAocmVzdWx0LCBib2R5KSB7XHJcbiAgICAgICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XHJcbiAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd29ybGRQb3NpdGlvbiA9IGludGVyc2VjdEJvZHlfd29ybGRQb3NpdGlvbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodGhpcy5jb2xsaXNpb25Hcm91cCAmIHNoYXBlLmNvbGxpc2lvbk1hc2spID09PSAwIHx8IChzaGFwZS5jb2xsaXNpb25Hcm91cCAmIHRoaXMuY29sbGlzaW9uTWFzaykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZFBvc2l0aW9uLCBzaGFwZS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh3b3JsZFBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uLCBib2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHdvcmxkQW5nbGUgPSBzaGFwZS5hbmdsZSArIGJvZHkuYW5nbGU7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUocmVzdWx0LCBzaGFwZSwgd29ybGRBbmdsZSwgd29ybGRQb3NpdGlvbiwgYm9keSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24gKHJlc3VsdCwgc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgICAgIC8vIENoZWNraW5nIHJhZGl1c1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvblNxdWFyZWQoZnJvbSwgdGhpcy5kaXJlY3Rpb24sIHBvc2l0aW9uKTtcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1JhZGl1cyAqIHNoYXBlLmJvdW5kaW5nUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvZHkgPSBib2R5O1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFwZSA9IHNoYXBlO1xyXG4gICAgICAgIHNoYXBlLnJheWNhc3QocmVzdWx0LCB0aGlzLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb2R5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFwZSA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgQUFCQiBvZiB0aGUgcmF5LlxyXG4gICAgICogQG1ldGhvZCBnZXRBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB2YXIgdG8gPSB0aGlzLnRvO1xyXG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQubG93ZXJCb3VuZCwgTWF0aC5taW4odG9bMF0sIGZyb21bMF0pLCBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSkpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQudXBwZXJCb3VuZCwgTWF0aC5tYXgodG9bMF0sIGZyb21bMF0pLCBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSkpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByZXBvcnRJbnRlcnNlY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gbm9ybWFsXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtmYWNlSW5kZXg9LTFdXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZSAvLyBUaGlzIG5ldmVyIHJldHVybmVkIGFueXRoaW5nLlxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLnJlcG9ydEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGZyYWN0aW9uLCBub3JtYWwsIGZhY2VJbmRleCkge1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMuX2N1cnJlbnRTaGFwZTtcclxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2N1cnJlbnRCb2R5O1xyXG4gICAgICAgIC8vIFNraXAgYmFjayBmYWNlcz9cclxuICAgICAgICBpZiAodGhpcy5za2lwQmFja2ZhY2VzICYmIHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHRoaXMuZGlyZWN0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIFJheS5BTEw6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG5vcm1hbCwgc2hhcGUsIGJvZHksIGZyYWN0aW9uLCBmYWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmF5LkNMT1NFU1Q6XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpZiBjbG9zZXIgdGhhbiBjdXJyZW50IGNsb3Nlc3RcclxuICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvbiA8IHJlc3VsdC5mcmFjdGlvbiB8fCAhcmVzdWx0Lmhhc0hpdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChub3JtYWwsIHNoYXBlLCBib2R5LCBmcmFjdGlvbiwgZmFjZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJheS5BTlk6XHJcbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgYW5kIHN0b3AuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG5vcm1hbCwgc2hhcGUsIGJvZHksIGZyYWN0aW9uLCBmYWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCBtYWtlIHRoZSBSYXkgdHJhdmVyc2UgdGhyb3VnaCBhbGwgaW50ZXJzZWN0aW9uIHBvaW50cyBhbmQgb25seSByZXR1cm4gdGhlIGNsb3Nlc3Qgb25lLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENMT1NFU1RcclxuICAgICAqL1xyXG4gICAgUmF5LkNMT1NFU1QgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSBzdG9wIHdoZW4gaXQgZmluZHMgdGhlIGZpcnN0IGludGVyc2VjdGlvbiBwb2ludC5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBBTllcclxuICAgICAqL1xyXG4gICAgUmF5LkFOWSA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgdHJhdmVyc2UgYWxsIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIGVhY2ggb25lLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEFMTFxyXG4gICAgICovXHJcbiAgICBSYXkuQUxMID0gNDtcclxuICAgIHJldHVybiBSYXk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJheTtcclxuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XHJcbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh2MCwgcG9zaXRpb24sIGZyb20pO1xyXG4gICAgdmFyIGRvdCA9IHZlYzJfMS5kZWZhdWx0LmRvdCh2MCwgZGlyZWN0aW9uKTtcclxuICAgIC8vIGludGVyc2VjdCA9IGRpcmVjdGlvbiAqIGRvdCArIGZyb21cclxuICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGludGVyc2VjdCwgZGlyZWN0aW9uLCBkb3QpO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQuYWRkKGludGVyc2VjdCwgaW50ZXJzZWN0LCBmcm9tKTtcclxuICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIHJheV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JheVwiKSk7XHJcbnZhciBSYXljYXN0UmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBoaXQgZGF0YS5cclxuICAgICAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbm9ybWFsIG9mIHRoZSBoaXQsIG9yaWVudGVkIGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IG5vcm1hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9ybWFsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBoaXQgdHJpYW5nbGUsIGlmIHRoZSBoaXQgc2hhcGUgd2FzIGluZGV4YWJsZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZmFjZUluZGV4XHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZhY2VJbmRleCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3RhbmNlIHRvIHRoZSBoaXQsIGFzIGEgZnJhY3Rpb24uIDAgaXMgYXQgdGhlIFwiZnJvbVwiIHBvaW50LCAxIGlzIGF0IHRoZSBcInRvXCIgcG9pbnQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQgeWV0LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmFjdGlvblxyXG4gICAgICAgICAqIEBkZWZhdWx0IC0xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mcmFjdGlvbiA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSByYXkgc2hvdWxkIHN0b3AgdHJhdmVyc2luZy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzU3RvcHBlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS4gTXVzdCBiZSBkb25lIGJlZm9yZSByZS11c2luZyB0aGUgcmVzdWx0IG9iamVjdC5cclxuICAgICAqIEBtZXRob2QgcmVzZXRcclxuICAgICAqL1xyXG4gICAgUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRoaXMubm9ybWFsLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnNoYXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZhY2VJbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMuZnJhY3Rpb24gPSAtMTtcclxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgaGl0IHBvaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRIaXREaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5nZXRIaXREaXN0YW5jZSA9IGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuZGlzdGFuY2UocmF5LmZyb20sIHJheS50bykgKiB0aGlzLmZyYWN0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByYXkgaGl0IHNvbWV0aGluZyBzaW5jZSB0aGUgbGFzdCByZXNldCgpLlxyXG4gICAgICogQG1ldGhvZCBoYXNIaXRcclxuICAgICAqIEDCrmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5oYXNIaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhY3Rpb24gIT09IC0xO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHdvcmxkIGhpdCBwb2ludC5cclxuICAgICAqIEBtZXRob2QgZ2V0SGl0UG9pbnRcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHtSYXl9IHJheVxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5nZXRIaXRQb2ludCA9IGZ1bmN0aW9uIChvdXQsIHJheSkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAob3V0LCByYXkuZnJvbSwgcmF5LnRvLCB0aGlzLmZyYWN0aW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBjYWxsZWQgd2hpbGUgaXRlcmF0aW5nIG92ZXIgaGl0cyB0byBzdG9wIHNlYXJjaGluZyBmb3IgaGl0IHBvaW50cy5cclxuICAgICAqIEBtZXRob2Qgc3RvcFxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2hvdWxkU3RvcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UmF5fSByYXlcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNob3VsZFN0b3AgPSBmdW5jdGlvbiAocmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdG9wcGVkIHx8ICh0aGlzLmZyYWN0aW9uICE9PSAtMSAmJiByYXkubW9kZSA9PT0gcmF5XzEuZGVmYXVsdC5BTlkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBub3JtYWxcclxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFjdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY2VJbmRleFxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobm9ybWFsLCBzaGFwZSwgYm9keSwgZnJhY3Rpb24sIGZhY2VJbmRleCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodGhpcy5ub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xyXG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcbiAgICAgICAgdGhpcy5mcmFjdGlvbiA9IGZyYWN0aW9uO1xyXG4gICAgICAgIHRoaXMuZmFjZUluZGV4ID0gZmFjZUluZGV4O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSYXljYXN0UmVzdWx0O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSYXljYXN0UmVzdWx0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb2FkcGhhc2VcIikpO1xyXG52YXIgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHNcIikpO1xyXG4vLyBUT0RPOiB0aGlzIGFwcGVhcnMgdG8gYmUgYSBidWJibGUgc29ydC4gV2UgY291bGQgcHJvYmFibHkgZG8gYmV0dGVyLlxyXG5mdW5jdGlvbiBzb3J0QXhpc0xpc3QoYSwgYXhpc0luZGV4KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IC8vIFdoeSBub3QgaT0wP1xyXG4gICAgICAgIHZhciB2ID0gYVtpXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IHYuYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFbaiArIDFdID0gYVtqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYVtqICsgMV0gPSB2O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxudmFyIFNBUEJyb2FkcGhhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU0FQQnJvYWRwaGFzZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogU3dlZXAgYW5kIHBydW5lIGJyb2FkcGhhc2UgYWxvbmcgb25lIGF4aXMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgQnJvYWRwaGFzZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTQVBCcm9hZHBoYXNlKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJyb2FkcGhhc2VfMS5kZWZhdWx0LlNBUCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5heGlzTGlzdCA9IFtdO1xyXG4gICAgICAgIF90aGlzLmF4aXNJbmRleCA9IDA7XHJcbiAgICAgICAgX3RoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMuYXhpc0xpc3QucHVzaChlLmJvZHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gbGlzdFxyXG4gICAgICAgICAgICB2YXIgaWR4ID0gX3RoaXMuYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xyXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXhpc0xpc3Quc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHRoZSB3b3JsZFxyXG4gICAgICogQG1ldGhvZCBzZXRXb3JsZFxyXG4gICAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgICAgICAvLyBDbGVhciB0aGUgb2xkIGF4aXMgYXJyYXlcclxuICAgICAgICB0aGlzLmF4aXNMaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkXHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KHRoaXMuYXhpc0xpc3QsIHdvcmxkLmJvZGllcyk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9sZCBoYW5kbGVycywgaWYgYW55XHJcbiAgICAgICAgd29ybGRcclxuICAgICAgICAgICAgLm9mZihcImFkZEJvZHlcIiwgdGhpcy5fYWRkQm9keUhhbmRsZXIpXHJcbiAgICAgICAgICAgIC5vZmYoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcclxuICAgICAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cclxuICAgICAgICAvLyBUT0RPOiBub3cgdGhhdCBJJ3ZlIGFkZGVkIGNvbnRleHQsIHdlIGNhbiB0ZXN0IG1vdmluZyB0aG9zZSBpbmxpbmUgZnVuY3Rpb25zIHRvIHByb3BlciBwcml2YXRlIG1ldGhvZHMuXHJcbiAgICAgICAgd29ybGQub24oXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyLCB0aGlzKVxyXG4gICAgICAgICAgICAub24oXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyLCB0aGlzKTtcclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc29ydExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xyXG4gICAgICAgIC8vIFNvcnQgdGhlIGxpc3RzXHJcbiAgICAgICAgc29ydEF4aXNMaXN0KGJvZGllcywgYXhpc0luZGV4KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uICggLyp3b3JsZCovKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsIHJlc3VsdCA9IHRoaXMucmVzdWx0LCBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcclxuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBVcGRhdGUgYWxsIEFBQkJzIGlmIG5lZWRlZFxyXG4gICAgICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2xdO1xyXG4gICAgICAgICAgICBpZiAoYi5hYWJiTmVlZHNVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNvcnQgdGhlIGxpc3RzXHJcbiAgICAgICAgdGhpcy5zb3J0TGlzdCgpO1xyXG4gICAgICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgWCBsaXN0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2RpZXMubGVuZ3RoIHwgMDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgTjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICAvLyBCb3VuZHMgb3ZlcmxhcD9cclxuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwcyA9IChiai5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSA8PSBiaS5hYWJiLnVwcGVyQm91bmRbYXhpc0luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJvYWRwaGFzZV8xLmRlZmF1bHQuY2FuQ29sbGlkZShiaSwgYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSwgYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cclxuICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKiBAdG9kbyBzaW5jZSB0aGUgbGlzdCBpcyBzb3J0ZWQsIG9wdGltaXphdGlvbiBjYW4gYmUgZG9uZVxyXG4gICAgICovXHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbiAod29ybGQsIGFhYmIsIHJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcclxuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XHJcbiAgICAgICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XHJcbiAgICAgICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIuYWFiYi5vdmVybGFwcyhhYWJiKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gU0FQQnJvYWRwaGFzZTtcclxufShicm9hZHBoYXNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTQVBCcm9hZHBoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjb25zdHJhaW50IGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb25zdHJhaW50KGJvZHlBLCBib2R5QiwgdHlwZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICAgICAgLy8gV2FrZSB1cCBib2RpZXMgd2hlbiBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoKChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWtlVXBCb2RpZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5QS53YWtlVXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb25zdHJhaW50IHBhcmFtZXRlcnMgYmVmb3JlIHNvbHZlLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc3RpZmZuZXNzIGZvciB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAbWV0aG9kIHNldFN0aWZmbmVzc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS5zZXRTdGlmZm5lc3MgPSBmdW5jdGlvbiAoc3RpZmZuZXNzKSB7XHJcbiAgICAgICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xyXG4gICAgICAgICAgICBlcS5zdGlmZm5lc3MgPSBzdGlmZm5lc3M7XHJcbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcmVsYXhhdGlvbiBmb3IgdGhpcyBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBzZXRSZWxheGF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS5zZXRSZWxheGF0aW9uID0gZnVuY3Rpb24gKHJlbGF4YXRpb24pIHtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbaV07XHJcbiAgICAgICAgICAgIGVxLnJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xyXG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhCaWFzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4Qmlhc1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhCaWFzID0gZnVuY3Rpb24gKG1heEJpYXMpIHtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbaV07XHJcbiAgICAgICAgICAgIGVxLm1heEJpYXMgPSBtYXhCaWFzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBESVNUQU5DRVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LkRJU1RBTkNFID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdFQVJcclxuICAgICAqL1xyXG4gICAgQ29uc3RyYWludC5HRUFSID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IExPQ0tcclxuICAgICAqL1xyXG4gICAgQ29uc3RyYWludC5MT0NLID0gMztcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFBSSVNNQVRJQ1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LlBSSVNNQVRJQyA9IDQ7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVZPTFVURVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LlJFVk9MVVRFID0gNTtcclxuICAgIHJldHVybiBDb25zdHJhaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCIpKTtcclxudmFyIG4gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxyXG52YXIgcmogPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXHJcbnZhciBEaXN0YW5jZUNvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGlzdGFuY2VDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLy8gdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgLy8gdGhpcy51cHBlckxpbWl0ID0gMTtcclxuICAgIC8vIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgIC8vIHRoaXMubG93ZXJMaW1pdCA9IDA7XHJcbiAgICAvLyB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RyYWludCB0aGF0IHRyaWVzIHRvIGtlZXAgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGJvZGllcyBjb25zdGFudC5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgRGlzdGFuY2VDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgYW5jaG9yIHBvaW50cy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JBXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QSwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQl0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUIsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QiBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubWF4Rm9yY2U9TnVtYmVyLk1BWF9WQUxVRV0gTWF4aW11bSBmb3JjZSB0byBhcHBseS5cclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIElmIGRpc3RhbmNlIGlzIG5vdCBnaXZlbiBhcyBhbiBvcHRpb24sIHRoZW4gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzIGlzIHVzZWQuXHJcbiAgICAgKiAgICAgLy8gSW4gdGhpcyBleGFtcGxlLCB0aGUgYm9kaWVzIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gaGF2ZSBhIGRpc3RhbmNlIG9mIDIgYmV0d2VlbiB0aGVpciBjZW50ZXJzLlxyXG4gICAgICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XHJcbiAgICAgKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBNYW51YWxseSBzZXQgdGhlIGRpc3RhbmNlIGFuZCBhbmNob3JzXHJcbiAgICAgKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICBkaXN0YW5jZTogMSwgICAgICAgICAgLy8gRGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBwb2ludHNcclxuICAgICAqICAgICAgICAgbG9jYWxBbmNob3JBOiBbMSwgMF0sIC8vIFBvaW50IG9uIGJvZHlBXHJcbiAgICAgKiAgICAgICAgIGxvY2FsQW5jaG9yQjogWy0xLCAwXSAvLyBQb2ludCBvbiBib2R5QlxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBjb25zdHJhaW50XzEuZGVmYXVsdC5ESVNUQU5DRSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGlzdGFuY2UgdG8ga2VlcC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZGlzdGFuY2VcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRpc3RhbmNlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZvcmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubWF4Rm9yY2UgPSBJbmZpbml0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgdXBwZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1cHBlckxpbWl0RW5hYmxlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVwcGVyIGNvbnN0cmFpbnQgbGltaXQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHVwcGVyTGltaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgbG93ZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBsb3dlckxpbWl0RW5hYmxlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvd2VyIGNvbnN0cmFpbnQgbGltaXQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvd2VyTGltaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGNvbnN0cmFpbnQgcG9zaXRpb24uIFRoaXMgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JBID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckEpID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5sb2NhbEFuY2hvckEpIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JCID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckIpID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5sb2NhbEFuY2hvckIpIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGxvY2FsQW5jaG9yQSA9IF90aGlzLmxvY2FsQW5jaG9yQTtcclxuICAgICAgICB2YXIgbG9jYWxBbmNob3JCID0gX3RoaXMubG9jYWxBbmNob3JCO1xyXG4gICAgICAgIF90aGlzLmRpc3RhbmNlID0gMDtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXN0YW5jZSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBfdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnQgd29ybGQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cclxuICAgICAgICAgICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB3b3JsZEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBbmNob3JBLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChyLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRBbmNob3JCKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qociwgciwgd29ybGRBbmNob3JBKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QociwgciwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBfdGhpcy5kaXN0YW5jZSA9IHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbm9ybWFsID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpOyAvLyBKdXN0IGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zID0gW25vcm1hbF07XHJcbiAgICAgICAgX3RoaXMubWF4Rm9yY2UgPSBtYXhGb3JjZTtcclxuICAgICAgICAvLyBnID0gKHhpIC0geGopLmRvdChuKVxyXG4gICAgICAgIC8vIGRnL2R0ID0gKHZpIC0gdmopLmRvdChuKSA9IEcqVyA9IFtuIDAgLW4gMF0gKiBbdmkgd2kgdmogd2pdJ1xyXG4gICAgICAgIC8vIC4uLmFuZCBpZiB3ZSB3ZXJlIHRvIGluY2x1ZGUgb2Zmc2V0IHBvaW50czpcclxuICAgICAgICAvLyBnID1cclxuICAgICAgICAvLyAgICAgICh4aiArIHJqIC0geGkgLSByaSkuZG90KG4pIC0gZGlzdGFuY2VcclxuICAgICAgICAvLyBkZy9kdCA9XHJcbiAgICAgICAgLy8gICAgICAodmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpKS5kb3QobikgPVxyXG4gICAgICAgIC8vICAgICAgeyB0ZXJtIDIgaXMgbmVhciB6ZXJvIH0gPVxyXG4gICAgICAgIC8vICAgICAgWy1uICAgLXJpIHggbiAgIG4gICByaiB4IG5dICogW3ZpIHdpIHZqIHdqXScgPVxyXG4gICAgICAgIC8vICAgICAgRyAqIFdcclxuICAgICAgICAvLyA9PiBHID0gWy1uIC1yaXhuIG4gcmp4bl1cclxuICAgICAgICB2YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByaSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcclxuICAgICAgICB2YXIgcmogPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXHJcbiAgICAgICAgdmFyIHRoYXQgPSBfdGhpcztcclxuICAgICAgICBub3JtYWwuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLCBib2R5QiA9IHRoaXMuYm9keUIsIHhpID0gYm9keUEucG9zaXRpb24sIHhqID0gYm9keUIucG9zaXRpb247XHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyaSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChyLCB4aiwgcmopO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCByLCByaSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHIsIHIsIHhpKTtcclxuICAgICAgICAgICAgLy92ZWMyLnN1YnRyYWN0KHIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgocikgLSB0aGF0LmRpc3RhbmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gTWFrZSB0aGUgY29udGFjdCBjb25zdHJhaW50IGJpbGF0ZXJhbFxyXG4gICAgICAgIF90aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgeGkgPSBib2R5QS5wb3NpdGlvbiwgeGogPSBib2R5Qi5wb3NpdGlvbiwgbm9ybWFsRXF1YXRpb24gPSB0aGlzLmVxdWF0aW9uc1swXSwgRyA9IG5vcm1hbC5HO1xyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJpLCB0aGlzLmxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyaiwgdGhpcy5sb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAvLyBHZXQgd29ybGQgYW5jaG9yIHBvaW50cyBhbmQgbm9ybWFsXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKG4sIHhqLCByaik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobiwgbiwgcmkpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG4sIG4sIHhpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKG4pO1xyXG4gICAgICAgIHZhciB2aW9sYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy51cHBlckxpbWl0RW5hYmxlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+IHRoaXMudXBwZXJMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAtdGhpcy5tYXhGb3JjZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnVwcGVyTGltaXQ7XHJcbiAgICAgICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvd2VyTGltaXRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uIDwgdGhpcy5sb3dlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5tYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2U7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5sb3dlckxpbWl0O1xyXG4gICAgICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgfHwgdGhpcy51cHBlckxpbWl0RW5hYmxlZCkgJiYgIXZpb2xhdGluZykge1xyXG4gICAgICAgICAgICAvLyBObyBjb25zdHJhaW50IG5lZWRlZC5cclxuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShuLCBuKTtcclxuICAgICAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgICAgICB2YXIgcml4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCBuKSwgcmp4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJqLCBuKTtcclxuICAgICAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cclxuICAgICAgICBHWzBdID0gLW5bMF07XHJcbiAgICAgICAgR1sxXSA9IC1uWzFdO1xyXG4gICAgICAgIEdbMl0gPSAtcml4bjtcclxuICAgICAgICBHWzNdID0gblswXTtcclxuICAgICAgICBHWzRdID0gblsxXTtcclxuICAgICAgICBHWzVdID0gcmp4bjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4IGZvcmNlIHRvIGJlIHVzZWRcclxuICAgICAqIEBtZXRob2Qgc2V0TWF4Rm9yY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxyXG4gICAgICovXHJcbiAgICBEaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24gKG1heEZvcmNlKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xyXG4gICAgICAgIG5vcm1hbC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcclxuICAgICAgICBub3JtYWwubWF4Rm9yY2UgPSBtYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWF4IGZvcmNlXHJcbiAgICAgKiBAbWV0aG9kIGdldE1heEZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIERpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xyXG4gICAgICAgIHJldHVybiBub3JtYWwubWF4Rm9yY2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpc3RhbmNlQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBhbmdsZV9sb2NrX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9hbmdsZS1sb2NrLWVxdWF0aW9uXCIpKTtcclxudmFyIGNvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50XCIpKTtcclxudmFyIEdlYXJDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEdlYXJDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJhaW5zIHRoZSBhbmdsZSBvZiB0d28gYm9kaWVzIHRvIGVhY2ggb3RoZXIgdG8gYmUgZXF1YWwuIElmIGEgZ2VhciByYXRpbyBpcyBub3Qgb25lLCB0aGUgYW5nbGUgb2YgYm9keUEgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBhbmdsZSBvZiBib2R5Qi5cclxuICAgICAqIEBjbGFzcyBHZWFyQ29uc3RyYWludFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLmFuZ2xlPTBdIFJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy4gV2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzICh0aGUgZ2VhciByYXRpbyBpcyBhY2NvdW50ZWQgZm9yKS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5yYXRpbz0xXSBHZWFyIHJhdGlvLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLm1heFRvcnF1ZV0gTWF4aW11bSB0b3JxdWUgdG8gYXBwbHkuXHJcbiAgICAgKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgcmF0aW86IDIsXHJcbiAgICAgKiAgICAgICAgIG1heFRvcnF1ZTogMTAwMFxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBjb25zdHJhaW50XzEuZGVmYXVsdC5HRUFSLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBnZWFyIHJhdGlvLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByYXRpb1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMucmF0aW8gPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmF0aW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlbGF0aXZlIGFuZ2xlXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFuZ2xlXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiBib2R5Qi5hbmdsZSAtIF90aGlzLnJhdGlvICogYm9keUEuYW5nbGU7XHJcbiAgICAgICAgLy8gU2VuZCBzYW1lIHBhcmFtZXRlcnMgdG8gdGhlIGVxdWF0aW9uXHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zID0gW1xyXG4gICAgICAgICAgICBuZXcgYW5nbGVfbG9ja19lcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgICAgICAgICAgICByYXRpbzogX3RoaXMucmF0aW8sXHJcbiAgICAgICAgICAgICAgICBhbmdsZTogX3RoaXMuYW5nbGVcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXTtcclxuICAgICAgICAvLyBTZXQgbWF4IHRvcnF1ZVxyXG4gICAgICAgIGlmIChvcHRpb25zLm1heFRvcnF1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNldE1heFRvcnF1ZShvcHRpb25zLm1heFRvcnF1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEdlYXJDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVxID0gdGhpcy5lcXVhdGlvbnNbMF07XHJcbiAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5yYXRpbztcclxuICAgICAgICBpZiAoZXEucmF0aW8gIT09IHJhdGlvKSB7XHJcbiAgICAgICAgICAgIGVxLnNldFJhdGlvKHJhdGlvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXEuYW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cclxuICAgICAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXHJcbiAgICAgKi9cclxuICAgIEdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XHJcbiAgICAgICAgdGhpcy5lcXVhdGlvbnNbMF0uc2V0TWF4VG9ycXVlKHRvcnF1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRNYXhUb3JxdWVcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdlYXJDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdlYXJDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCIpKTtcclxudmFyIGwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHhBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygxLCAwKTtcclxudmFyIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIExvY2tDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExvY2tDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGJldHdlZW4gdHdvIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgTG9ja0NvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsT2Zmc2V0Ql0gVGhlIG9mZnNldCBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4gdGhlIG9mZnNldCBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgcG9zaXRpb25zLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvY2FsQW5nbGVCXSBUaGUgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS4gSWYgbm90IGdpdmVuLCB0aGUgYW5nbGUgaXMgY29tcHV0ZWQgZnJvbSBjdXJyZW50IGFuZ2xlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV1cclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiBib2R5QSBhbmQgYm9keUJcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LkxPQ0ssIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgdmFyIG1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XHJcbiAgICAgICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxyXG4gICAgICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcclxuICAgICAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAuLi53aGVyZTpcclxuICAgICAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxyXG4gICAgICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcclxuICAgICAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xyXG4gICAgICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XHJcbiAgICAgICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxyXG4gICAgICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XHJcbiAgICAgICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcclxuICAgICAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcclxuICAgICAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXHJcbiAgICAgICAgdmFyIHggPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSksIHkgPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSksIHJvdCA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTtcclxuICAgICAgICB2YXIgbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBnID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHRoYXQgPSBfdGhpcztcclxuICAgICAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGwsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGcsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGcsIGcsIGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZ1swXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgZywgbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnWzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUociwgciwgLTEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnLCBib2R5QS5wb3NpdGlvbiwgYm9keUIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoZywgZywgcik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0LCByLCAtTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUodCwgdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5kb3QoZywgdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG9jYWxPZmZzZXRCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbE9mZnNldEIpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbE9mZnNldEIsIG9wdGlvbnMubG9jYWxPZmZzZXRCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBmcm9tIGN1cnJlbnQgcG9zaXRpb25zXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KF90aGlzLmxvY2FsT2Zmc2V0QiwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKF90aGlzLmxvY2FsT2Zmc2V0QiwgX3RoaXMubG9jYWxPZmZzZXRCLCAtYm9keUEuYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmdsZUIgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWxBbmdsZUIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zLnB1c2goeCk7XHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zLnB1c2goeSk7XHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zLnB1c2gocm90KTtcclxuICAgICAgICBfdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gZm9yY2UgdG8gYmUgYXBwbGllZC5cclxuICAgICAqIEBtZXRob2Qgc2V0TWF4Rm9yY2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb3JjZVxyXG4gICAgICovXHJcbiAgICBMb2NrQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBlcXNbaV0ubWF4Rm9yY2UgPSBmb3JjZTtcclxuICAgICAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWF4IGZvcmNlLlxyXG4gICAgICogQG1ldGhvZCBnZXRNYXhGb3JjZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb2NrQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xyXG4gICAgfTtcclxuICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uc1swXSwgeSA9IHRoaXMuZXF1YXRpb25zWzFdLCByb3QgPSB0aGlzLmVxdWF0aW9uc1syXSwgYm9keUEgPSB0aGlzLmJvZHlBLCBib2R5QiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGwsIHRoaXMubG9jYWxPZmZzZXRCLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHIsIHRoaXMubG9jYWxPZmZzZXRCLCBib2R5Qi5hbmdsZSAtIHRoaXMubG9jYWxBbmdsZUIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHIsIHIsIC0xKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUodCwgciwgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSh0LCB0KTtcclxuICAgICAgICB4LkdbMF0gPSAtMTtcclxuICAgICAgICB4LkdbMV0gPSAwO1xyXG4gICAgICAgIHguR1syXSA9IC12ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChsLCB4QXhpcyk7XHJcbiAgICAgICAgeC5HWzNdID0gMTtcclxuICAgICAgICB5LkdbMF0gPSAwO1xyXG4gICAgICAgIHkuR1sxXSA9IC0xO1xyXG4gICAgICAgIHkuR1syXSA9IC12ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChsLCB5QXhpcyk7XHJcbiAgICAgICAgeS5HWzRdID0gMTtcclxuICAgICAgICByb3QuR1swXSA9IC10WzBdO1xyXG4gICAgICAgIHJvdC5HWzFdID0gLXRbMV07XHJcbiAgICAgICAgcm90LkdbM10gPSB0WzBdO1xyXG4gICAgICAgIHJvdC5HWzRdID0gdFsxXTtcclxuICAgICAgICByb3QuR1s1XSA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHIsIHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMb2NrQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMb2NrQ29uc3RyYWludDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGNvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50XCIpKTtcclxudmFyIGNvbnRhY3RfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2NvbnRhY3QtZXF1YXRpb25cIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCIpKTtcclxudmFyIHJvdGF0aW9uYWxfbG9ja19lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvcm90YXRpb25hbC1sb2NrLWVxdWF0aW9uXCIpKTtcclxudmFyIHdvcmxkQXhpc0EgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBvcmllbnRlZEFuY2hvckEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgb3JpZW50ZWRBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHRtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgUHJpc21hdGljQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcmlzbWF0aWNDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJhaW50IHRoYXQgb25seSBhbGxvd3MgYm9kaWVzIHRvIG1vdmUgYWxvbmcgYSBsaW5lLCByZWxhdGl2ZSB0byBlYWNoIG90aGVyLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuaWZvcmNlMmQubmV0L2IyZHR1dC9qb2ludHMtcHJpc21hdGljXCI+dGhpcyB0dXRvcmlhbDwvYT4uIEFsc28gY2FsbGVkIFwic2xpZGVyIGNvbnN0cmFpbnRcIi5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgUHJpc21hdGljQ29uc3RyYWludFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2VdIE1heCBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIEJvZHkgQSdzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBCb2R5IEIncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQXhpc0FdIEFuIGF4aXMsIGRlZmluZWQgaW4gYm9keSBBIGZyYW1lLCB0aGF0IGJvZHkgQidzIGFuY2hvciBwb2ludCBtYXkgc2xpZGUgYWxvbmcuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9ja10gSWYgc2V0IHRvIHRydWUsIGJvZHlCIHdpbGwgYmUgZnJlZSB0byByb3RhdGUgYXJvdW5kIGl0cyBhbmNob3IgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudXBwZXJMaW1pdF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sb3dlckxpbWl0XVxyXG4gICAgICogQHRvZG8gQWJpbGl0eSB0byBjcmVhdGUgdXNpbmcgb25seSBhIHBvaW50IGFuZCBhIHdvcmxkQXhpc1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBQcmlzbWF0aWNDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICBsb2NhbEF4aXNBOiBbMCwgMV1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQcmlzbWF0aWNDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgY29uc3RyYWludF8xLmRlZmF1bHQuUFJJU01BVElDLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIEdldCBhbmNob3JzXHJcbiAgICAgICAgdmFyIGxvY2FsQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBsb2NhbEF4aXNBID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygxLCAwKSwgbG9jYWxBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckEpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEF4aXNBKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkobG9jYWxBeGlzQSwgb3B0aW9ucy5sb2NhbEF4aXNBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckIpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xyXG4gICAgICAgIF90aGlzLmxvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuICAgICAgICBfdGhpcy5sb2NhbEF4aXNBID0gbG9jYWxBeGlzQTtcclxuICAgICAgICAvKlxyXG5cclxuICAgICAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gZm9yIHRoZSBjb21tb24gYXhpcyBwb2ludCBpc1xyXG5cclxuICAgICAgICAgICAgZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHQgICA6PSAgZ2cqdFxyXG5cclxuICAgICAgICB3aGVyZSByIGFyZSBib2R5LWxvY2FsIGFuY2hvciBwb2ludHMsIGFuZCB0IGlzIGEgdGFuZ2VudCB0byB0aGUgY29uc3RyYWludCBheGlzIGRlZmluZWQgaW4gYm9keSBpIGZyYW1lLlxyXG5cclxuICAgICAgICAgICAgZ2RvdCA9ICAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogdCArICggeGogKyByaiAtIHhpIC0gcmkgKSAqICggd2kgeCB0IClcclxuXHJcbiAgICAgICAgTm90ZSB0aGUgdXNlIG9mIHRoZSBjaGFpbiBydWxlLiBOb3cgd2UgaWRlbnRpZnkgdGhlIGphY29iaWFuXHJcblxyXG4gICAgICAgICAgICBHKlcgPSBbIC10ICAgICAgLXJpIHggdCArIHQgeCBnZyAgICAgdCAgICByaiB4IHQgXSAqIFt2aSB3aSB2aiB3al1cclxuXHJcbiAgICAgICAgVGhlIHJvdGF0aW9uYWwgcGFydCBpcyBqdXN0IGEgcm90YXRpb24gbG9jay5cclxuXHJcbiAgICAgICAgKi9cclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSBfdGhpcy5tYXhGb3JjZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhGb3JjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XHJcbiAgICAgICAgLy8gVHJhbnNsYXRpb25hbCBwYXJ0XHJcbiAgICAgICAgdmFyIHRyYW5zID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xyXG4gICAgICAgIHZhciByaSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCByaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBnZyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIGJhZCBwcmFjdGljZS5cclxuICAgICAgICB0cmFucy5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGcgPSAoIHhqICsgcmogLSB4aSAtIHJpICkgKiB0XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5kb3QoZ2csIHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIGJhZCBwcmFjdGljZS5cclxuICAgICAgICB0cmFucy51cGRhdGVKYWNvYmlhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEcgPSB0aGlzLkcsIHhpID0gYm9keUEucG9zaXRpb24sIHhqID0gYm9keUIucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyaSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChnZywgeGosIHJqKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZ2csIGdnLCB4aSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGdnLCBnZywgcmkpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUodCwgbG9jYWxBeGlzQSwgYm9keUEuYW5nbGUgKyBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgIEdbMF0gPSAtdFswXTtcclxuICAgICAgICAgICAgR1sxXSA9IC10WzFdO1xyXG4gICAgICAgICAgICBHWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCB0KSArIHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHQsIGdnKTtcclxuICAgICAgICAgICAgR1szXSA9IHRbMF07XHJcbiAgICAgICAgICAgIEdbNF0gPSB0WzFdO1xyXG4gICAgICAgICAgICBHWzVdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmosIHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zLnB1c2godHJhbnMpO1xyXG4gICAgICAgIC8vIFJvdGF0aW9uYWwgcGFydFxyXG4gICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlUm90YXRpb25hbExvY2spKSB7XHJcbiAgICAgICAgICAgIHZhciByb3QgPSBuZXcgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgYW5jaG9yIEEgcmVsYXRpdmUgdG8gYW5jaG9yIEIsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHBvc2l0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgLy8gSXMgdGhpcyBvbmUgdXNlZCBhdCBhbGw/XHJcbiAgICAgICAgX3RoaXMudmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBsb3dlciBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdEVuYWJsZWRcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG93ZXJMaW1pdCkgIT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwcGVyTGltaXQpICE9PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG93ZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG93ZXJMaW1pdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcHBlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXQgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBwZXJMaW1pdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMTtcclxuICAgICAgICAvLyBFcXVhdGlvbnMgdXNlZCBmb3IgbGltaXRzXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IGNvbnRhY3RfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdEVxdWF0aW9uID0gbmV3IGNvbnRhY3RfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgLy8gU2V0IG1heC9taW4gZm9yY2VzXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gX3RoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcXVhdGlvbiB1c2VkIGZvciB0aGUgbW90b3IuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1vdG9yRXF1YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7RXF1YXRpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBtb3RvciBzdGF0ZS4gRW5hYmxlIG9yIGRpc2FibGUgdGhlIG1vdG9yIHVzaW5nIC5lbmFibGVNb3RvclxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtb3RvckVuYWJsZWRcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHRhcmdldCBzcGVlZCBmb3IgdGhlIG1vdG9yLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtb3RvclNwZWVkXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tb3RvclNwZWVkID0gMDtcclxuICAgICAgICB2YXIgdGhhdCA9IF90aGlzO1xyXG4gICAgICAgIHZhciBtb3RvckVxdWF0aW9uID0gX3RoaXMubW90b3JFcXVhdGlvbjtcclxuICAgICAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XHJcbiAgICAgICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR1cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBHID0gdGhpcy5HLCBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QiwgdmkgPSBiaS52ZWxvY2l0eSwgdmogPSBiai52ZWxvY2l0eSwgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCB2aSwgd2ksIHZqLCB3aikgKyB0aGF0Lm1vdG9yU3BlZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucywgdHJhbnMgPSBlcXNbMF0sIHVwcGVyTGltaXQgPSB0aGlzLnVwcGVyTGltaXQsIGxvd2VyTGltaXQgPSB0aGlzLmxvd2VyTGltaXQsIHVwcGVyTGltaXRFcXVhdGlvbiA9IHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLCBsb3dlckxpbWl0RXF1YXRpb24gPSB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiwgYm9keUEgPSB0aGlzLmJvZHlBLCBib2R5QiA9IHRoaXMuYm9keUIsIGxvY2FsQXhpc0EgPSB0aGlzLmxvY2FsQXhpc0EsIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBLCBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcclxuICAgICAgICB0cmFucy51cGRhdGVKYWNvYmlhbigpO1xyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCB0aGluZ3MgdG8gd29ybGRcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBeGlzQSwgbG9jYWxBeGlzQSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShvcmllbnRlZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh3b3JsZEFuY2hvckEsIG9yaWVudGVkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShvcmllbnRlZEFuY2hvckIsIGxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh3b3JsZEFuY2hvckIsIG9yaWVudGVkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciByZWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5kb3Qod29ybGRBbmNob3JCLCB3b3JsZEF4aXNBKSAtIHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZEFuY2hvckEsIHdvcmxkQXhpc0EpO1xyXG4gICAgICAgIC8vIE1vdG9yXHJcbiAgICAgICAgaWYgKHRoaXMubW90b3JFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIC8vIEcgPSBbIGEgICAgIGEgeCByaSAgIC1hICAgLWEgeCByaiBdXHJcbiAgICAgICAgICAgIHZhciBHID0gdGhpcy5tb3RvckVxdWF0aW9uLkc7XHJcbiAgICAgICAgICAgIEdbMF0gPSB3b3JsZEF4aXNBWzBdO1xyXG4gICAgICAgICAgICBHWzFdID0gd29ybGRBeGlzQVsxXTtcclxuICAgICAgICAgICAgR1syXSA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0EsIG9yaWVudGVkQW5jaG9yQik7XHJcbiAgICAgICAgICAgIEdbM10gPSAtd29ybGRBeGlzQVswXTtcclxuICAgICAgICAgICAgR1s0XSA9IC13b3JsZEF4aXNBWzFdO1xyXG4gICAgICAgICAgICBHWzVdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0EsIG9yaWVudGVkQW5jaG9yQSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIExpbWl0cyBzdHJhdGVneTpcclxuICAgICAgICAgICAgQWRkIGNvbnRhY3QgZXF1YXRpb24sIHdpdGggbm9ybWFsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXHJcbiAgICAgICAgICAgIG1pbi9tYXhGb3JjZSBpcyBzZXQgc28gdGhlIGNvbnN0cmFpbnQgaXMgcmVwdWxzaXZlIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgU29tZSBvZmZzZXQgaXMgYWRkZWQgdG8gZWl0aGVyIGVxdWF0aW9uLmNvbnRhY3RQb2ludEEgb3IgLmNvbnRhY3RQb2ludEIgdG8gZ2V0IHRoZSBjb3JyZWN0IHVwcGVyL2xvd2VyIGxpbWl0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBeXHJcbiAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgIHVwcGVyTGltaXQgeFxyXG4gICAgICAgICAgICAgICAgICAgIHwgICAgLS0tLS0tXHJcbiAgICAgICAgICAgIGFuY2hvckIgeDwtLS18ICBCIHxcclxuICAgICAgICAgICAgICAgICAgICB8ICAgIHwgICAgfFxyXG4gICAgICAgICAgICAtLS0tLS0gICB8ICAgIC0tLS0tLVxyXG4gICAgICAgICAgICB8ICAgIHwgICB8XHJcbiAgICAgICAgICAgIHwgIEEgfC0tPnggYW5jaG9yQVxyXG4gICAgICAgICAgICAtLS0tLS0gICB8XHJcbiAgICAgICAgICAgICAgICAgICAgeCBsb3dlckxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNcclxuICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uID4gdXBwZXJMaW1pdCkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHVwcGVyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAtMSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZSh0bXAsIHdvcmxkQXhpc0EsIHVwcGVyTGltaXQpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB0bXApO1xyXG4gICAgICAgICAgICBpZiAoZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uIDwgbG93ZXJMaW1pdCkge1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGxvd2VyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAxKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHRtcCwgd29ybGRBeGlzQSwgbG93ZXJMaW1pdCk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCBsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QiwgdG1wKTtcclxuICAgICAgICAgICAgaWYgKGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSB0aGUgbW90b3JcclxuICAgICAqIEBtZXRob2QgZW5hYmxlTW90b3JcclxuICAgICAqL1xyXG4gICAgUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubW90b3JFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0aGlzLm1vdG9yRXF1YXRpb24pO1xyXG4gICAgICAgIHRoaXMubW90b3JFbmFibGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcclxuICAgICAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXHJcbiAgICAgKi9cclxuICAgIFByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubW90b3JFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XHJcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvbnN0cmFpbnQgbGltaXRzLlxyXG4gICAgICogQG1ldGhvZCBzZXRMaW1pdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBsaW1pdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBsaW1pdC5cclxuICAgICAqL1xyXG4gICAgUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGxvd2VyKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XHJcbiAgICAgICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XHJcbiAgICAgICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodXBwZXIpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcclxuICAgICAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcclxuICAgICAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJpc21hdGljQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQcmlzbWF0aWNDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIHJvdGF0aW9uYWxfdmVsb2NpdHlfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL3JvdGF0aW9uYWwtdmVsb2NpdHktZXF1YXRpb25cIikpO1xyXG52YXIgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9yb3RhdGlvbmFsLWxvY2stZXF1YXRpb25cIikpO1xyXG52YXIgc3ViID0gdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Q7XHJcbnZhciBhZGQgPSB2ZWMyXzEuZGVmYXVsdC5hZGQ7XHJcbnZhciBkb3QgPSB2ZWMyXzEuZGVmYXVsdC5kb3Q7XHJcbnZhciByb3RhdGUgPSB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU7XHJcbnZhciBjb3B5ID0gdmVjMl8xLmRlZmF1bHQuY29weTtcclxudmFyIGNyb3NzTGVuZ3RoID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGg7XHJcbnZhciB3b3JsZFBpdm90QSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB3b3JsZFBpdm90QiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB4QXhpcyA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMSwgMCksIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKSwgZyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgUmV2b2x1dGVDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJldm9sdXRlQ29uc3RyYWludCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLCBsZXR0aW5nIHRoZW0gcm90YXRlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIgYXJvdW5kIHRoaXMgcG9pbnQuXHJcbiAgICAgKiBAY2xhc3MgUmV2b2x1dGVDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLndvcmxkUGl2b3RdIEEgcGl2b3QgcG9pbnQgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuIElmIHNwZWNpZmllZCwgbG9jYWxQaXZvdEEgYW5kIGxvY2FsUGl2b3RCIGFyZSBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGZyb20gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEFdIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RCXSBTZWUgbG9jYWxQaXZvdEEuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLm1heEZvcmNlXSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLlxyXG4gICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHJldm9sdXRlIGNvbnN0cmFpbnQgYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggcGl2b3QgcG9pbnQgaW4gYmV0d2VlbiB0aGVtLlxyXG4gICAgICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5QSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlCKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICB3b3JsZFBpdm90OiBbMCwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBVc2luZyBib2R5LWxvY2FsIHBpdm90IHBvaW50cywgdGhlIGNvbnN0cmFpbnQgY291bGQgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGxpa2UgdGhpczpcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsUGl2b3RBOiBbMSwgMF0sXHJcbiAgICAgKiAgICAgICAgIGxvY2FsUGl2b3RCOiBbLTEsIDBdXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBjb25zdHJhaW50XzEuZGVmYXVsdC5SRVZPTFVURSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSBfdGhpcy5tYXhGb3JjZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhGb3JjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIHBpdm90QSA9IF90aGlzLnBpdm90QSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBwaXZvdEIgPSBfdGhpcy5waXZvdEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmxkUGl2b3QpIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwaXZvdEEgYW5kIHBpdm90QlxyXG4gICAgICAgICAgICBzdWIocGl2b3RBLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgc3ViKHBpdm90Qiwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIC8vIFJvdGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgICAgICAgICByb3RhdGUocGl2b3RBLCBwaXZvdEEsIC1ib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZShwaXZvdEIsIHBpdm90QiwgLWJvZHlCLmFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBwaXZvdEEgYW5kIHBpdm90QlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsUGl2b3RBKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5KHBpdm90QSwgb3B0aW9ucy5sb2NhbFBpdm90QSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbFBpdm90Qikge1xyXG4gICAgICAgICAgICAgICAgY29weShwaXZvdEIsIG9wdGlvbnMubG9jYWxQaXZvdEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb3RvckVxdWF0aW9uID0gX3RoaXMubW90b3JFcXVhdGlvbiA9IG5ldyByb3RhdGlvbmFsX3ZlbG9jaXR5X2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIG1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB1cHBlckxpbWl0RXF1YXRpb24gPSBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIHZhciBsb3dlckxpbWl0RXF1YXRpb24gPSBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IGxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XHJcbiAgICAgICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXHJcbiAgICAgICAgdmFyIGVxcyA9IF90aGlzLmVxdWF0aW9ucyA9IFtcclxuICAgICAgICAgICAgbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpLFxyXG4gICAgICAgICAgICBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSksXHJcbiAgICAgICAgICAgIG1vdG9yRXF1YXRpb24sXHJcbiAgICAgICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbixcclxuICAgICAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgeCA9IGVxc1swXTtcclxuICAgICAgICB2YXIgeSA9IGVxc1sxXTtcclxuICAgICAgICAvLyBUT0RPOiBiYWQgcHJhY3RpY2UuXHJcbiAgICAgICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIGFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgd29ybGRQaXZvdEEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG90KGcsIHhBeGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb3RhdGUod29ybGRQaXZvdEEsIHBpdm90QSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgICAgICByb3RhdGUod29ybGRQaXZvdEIsIHBpdm90QiwgYm9keUIuYW5nbGUpO1xyXG4gICAgICAgICAgICBhZGQoZywgYm9keUIucG9zaXRpb24sIHdvcmxkUGl2b3RCKTtcclxuICAgICAgICAgICAgc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvdChnLCB5QXhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB5Lm1pbkZvcmNlID0geC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcclxuICAgICAgICB5Lm1heEZvcmNlID0geC5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgICAgIC8vIFRoZXNlIG5ldmVyIGNoYW5nZSBidXQgdGhlIGFuZ3VsYXIgcGFydHMgZG9cclxuICAgICAgICB4LkdbMF0gPSAtMTtcclxuICAgICAgICB4LkdbMV0gPSAwO1xyXG4gICAgICAgIHguR1szXSA9IDE7XHJcbiAgICAgICAgeC5HWzRdID0gMDtcclxuICAgICAgICB5LkdbMF0gPSAwO1xyXG4gICAgICAgIHkuR1sxXSA9IC0xO1xyXG4gICAgICAgIHkuR1szXSA9IDA7XHJcbiAgICAgICAgeS5HWzRdID0gMTtcclxuICAgICAgICBfdGhpcy5hbmdsZSA9IDA7XHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXQgPSAwO1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXQgPSAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb25zdHJhaW50IGFuZ2xlIGxpbWl0cywgYW5kIGVuYWJsZSB0aGVtLlxyXG4gICAgICogQG1ldGhvZCBzZXRMaW1pdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBMb3dlciBhbmdsZSBsaW1pdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBVcHBlciBhbmdsZSBsaW1pdC5cclxuICAgICAqL1xyXG4gICAgUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XHJcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XHJcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XHJcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgcGl2b3RBID0gdGhpcy5waXZvdEEsIHBpdm90QiA9IHRoaXMucGl2b3RCLCBlcXMgPSB0aGlzLmVxdWF0aW9ucywgeCA9IGVxc1swXSwgeSA9IGVxc1sxXSwgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCwgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCwgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uO1xyXG4gICAgICAgIHZhciByZWxBbmdsZSA9IHRoaXMuYW5nbGUgPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xyXG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5hbmdsZSA9IHVwcGVyTGltaXQ7XHJcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLmVuYWJsZWQgPSB0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlID4gdXBwZXJMaW1pdDtcclxuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24uYW5nbGUgPSBsb3dlckxpbWl0O1xyXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbi5lbmFibGVkID0gdGhpcy5sb3dlckxpbWl0RW5hYmxlZCAmJiByZWxBbmdsZSA8IGxvd2VyTGltaXQ7XHJcbiAgICAgICAgLypcclxuXHJcbiAgICAgICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGlzXHJcblxyXG4gICAgICAgICAgICBnID0geGogKyByaiAtIHhpIC0gcmlcclxuXHJcbiAgICAgICAgLi4ud2hlcmUgeGkgYW5kIHhqIGFyZSB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIHJpIGFuZCByaiB3b3JsZC1vcmllbnRlZCBvZmZzZXQgdmVjdG9ycy4gRGlmZmVyZW50aWF0ZTpcclxuXHJcbiAgICAgICAgICAgIGdkb3QgPSB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmlcclxuXHJcbiAgICAgICAgV2Ugc3BsaXQgdGhpcyBpbnRvIHggYW5kIHkgZGlyZWN0aW9ucy4gKGxldCB4IGFuZCB5IGJlIHVuaXQgdmVjdG9ycyBhbG9uZyB0aGUgcmVzcGVjdGl2ZSBheGVzKVxyXG5cclxuICAgICAgICAgICAgZ2RvdCAqIHggPSAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogeFxyXG4gICAgICAgICAgICAgICAgICAgID0gKCB2aip4ICsgKHdqIHggcmopKnggLXZpKnggLSh3aSB4IHJpKSp4XHJcbiAgICAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAocmogeCB4KSp3aiAtdmkqeCAtKHJpIHggeCkqd2lcclxuICAgICAgICAgICAgICAgICAgICA9IFsgLXggICAtKHJpIHggeCkgICB4ICAgKHJqIHggeCldICogW3ZpIHdpIHZqIHdqXVxyXG4gICAgICAgICAgICAgICAgICAgID0gRypXXHJcblxyXG4gICAgICAgIC4uLmFuZCBzaW1pbGFyIGZvciB5LiBXZSBoYXZlIHRoZW4gaWRlbnRpZmllZCB0aGUgamFjb2JpYW4gZW50cmllcyBmb3IgeCBhbmQgeSBkaXJlY3Rpb25zOlxyXG5cclxuICAgICAgICAgICAgR3ggPSBbIHggICAocmogeCB4KSAgIC14ICAgLShyaSB4IHgpXVxyXG4gICAgICAgICAgICBHeSA9IFsgeSAgIChyaiB4IHkpICAgLXkgICAtKHJpIHggeSldXHJcblxyXG4gICAgICAgIFNvIGZvciBleGFtcGxlLCBpbiB0aGUgWCBkaXJlY3Rpb24gd2Ugd291bGQgZ2V0IGluIDIgZGltZW5zaW9uc1xyXG5cclxuICAgICAgICAgICAgRyA9IFsgWzEgICAwICAgKHJqIHggWzEsMF0pICAgLTEgICAwICAgLShyaSB4IFsxLDBdKV1cclxuICAgICAgICAgICAgICAgIFswICAgMSAgIChyaiB4IFswLDFdKSAgICAwICAtMSAgIC0ocmkgeCBbMCwxXSldXHJcbiAgICAgICAgKi9cclxuICAgICAgICByb3RhdGUod29ybGRQaXZvdEEsIHBpdm90QSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgLy8gQHRvZG86IHRoZXNlIGFyZSBhIGJpdCBzcGFyc2UuIFdlIGNvdWxkIHNhdmUgc29tZSBjb21wdXRhdGlvbnMgb24gbWFraW5nIGN1c3RvbSBlcS5jb21wdXRlR1cgZnVuY3Rpb25zLCBldGNcclxuICAgICAgICB2YXIgeEcgPSB4Lkc7XHJcbiAgICAgICAgeEdbMl0gPSAtY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEsIHhBeGlzKTtcclxuICAgICAgICB4R1s1XSA9IGNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLCB4QXhpcyk7XHJcbiAgICAgICAgdmFyIHlHID0geS5HO1xyXG4gICAgICAgIHlHWzJdID0gLWNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RBLCB5QXhpcyk7XHJcbiAgICAgICAgeUdbNV0gPSBjcm9zc0xlbmd0aCh3b3JsZFBpdm90QiwgeUF4aXMpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLCBcIm1vdG9yRW5hYmxlZFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBtb3RvckVuYWJsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQgPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZSwgXCJtb3RvclNwZWVkXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW90b3JTcGVlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLnJlbGF0aXZlVmVsb2NpdHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24ucmVsYXRpdmVWZWxvY2l0eSA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLCBcIm1vdG9yTWF4Rm9yY2VcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3Rvck1heEZvcmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSB0aGlzLm1vdG9yRXF1YXRpb247XHJcbiAgICAgICAgICAgIGVxLm1heEZvcmNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLXZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBSZXZvbHV0ZUNvbnN0cmFpbnQ7XHJcbn0oY29uc3RyYWludF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmV2b2x1dGVDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG4vLyBTaG9ydGN1dHMuXHJcbnZhciBzY2FsZSA9IHZlYzJfMS5kZWZhdWx0LnNjYWxlLCBtdWx0aXBseSA9IHZlYzJfMS5kZWZhdWx0Lm11bHRpcGx5LCBjcmVhdGVWZWMyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlO1xyXG52YXIgRXF1YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgZXF1YXRpb25zLlxyXG4gICAgICogQGNsYXNzIEVxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUEgRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IC1JbmZpbml0eVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IEluZmluaXR5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWluRm9yY2UsIG1heEZvcmNlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwIHRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiAoRypxKSB0byB0aGlzIHZhbHVlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtYXhCaWFzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heEJpYXMgPSBJbmZpbml0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3RpZmZuZXNzIG9mIHRoaXMgZXF1YXRpb24uIFR5cGljYWxseSBjaG9zZW4gdG8gYSBsYXJnZSBudW1iZXIgKH4xZTcpLCBidXQgY2FuIGJlIGNob3NlbiBzb21ld2hhdCBmcmVlbHkgdG8gZ2V0IGEgc3RhYmxlIHNpbXVsYXRpb24uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWUgc3RlcHMgbmVlZGVkIHRvIHN0YWJpbGl6ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbi4gVHlwaWNhbGx5IGJldHdlZW4gMyBhbmQgNSB0aW1lIHN0ZXBzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuYSA9IDA7XHJcbiAgICAgICAgdGhpcy5iID0gMDtcclxuICAgICAgICB0aGlzLmVwc2lsb24gPSAwO1xyXG4gICAgICAgIHRoaXMudGltZVN0ZXAgPSAxIC8gNjA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHN0aWZmbmVzcyBvciByZWxheGF0aW9uIHdhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbmVlZHNVcGRhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzdWx0aW5nIGNvbnN0cmFpbnQgbXVsdGlwbGllciBmcm9tIHRoZSBsYXN0IHNvbHZlLiBUaGlzIGlzIG1vc3RseSBlcXVpdmFsZW50IHRvIHRoZSBmb3JjZSBwcm9kdWNlZCBieSB0aGUgY29uc3RyYWludC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbXVsdGlwbGllclxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxhdGl2ZSB2ZWxvY2l0eS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVsYXRpdmVWZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGlzIGVxdWF0aW9uIGlzIGVuYWJsZWQgb3Igbm90LiBJZiB0cnVlLCBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBUZW1wIHN0dWZmXHJcbiAgICAgICAgdGhpcy5tYXhGb3JjZUR0ID0gMDtcclxuICAgICAgICB0aGlzLm1pbkZvcmNlRHQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW52QyA9IDA7XHJcbiAgICAgICAgdGhpcy5CID0gMDtcclxuICAgICAgICB0aGlzLmxhbWJkYSA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMubWluRm9yY2UgPSBtaW5Gb3JjZSAhPT0gbnVsbCAmJiBtaW5Gb3JjZSAhPT0gdm9pZCAwID8gbWluRm9yY2UgOiAtSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlICE9PSBudWxsICYmIG1heEZvcmNlICE9PSB2b2lkIDAgPyBtYXhGb3JjZSA6IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubWF4QmlhcyA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBib2R5QSAhPT0gbnVsbCAmJiBib2R5QSAhPT0gdm9pZCAwID8gYm9keUEgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QiAhPT0gbnVsbCAmJiBib2R5QiAhPT0gdm9pZCAwID8gYm9keUIgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XHJcbiAgICAgICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xyXG4gICAgICAgIHRoaXMuRyA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5HW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgU1BPT0sgcGFyYW1ldGVycyAuYSwgLmIgYW5kIC5lcHNpbG9uIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYXJhbWV0ZXJzLiBTZWUgZXF1YXRpb25zIDksIDEwIGFuZCAxMSBpbiB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcIj5TUE9PSyBub3RlczwvYT4uXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsIGQgPSB0aGlzLnJlbGF4YXRpb24sIGggPSB0aGlzLnRpbWVTdGVwO1xyXG4gICAgICAgIHRoaXMuYSA9IDQgLyAoaCAqICgxICsgNCAqIGQpKTtcclxuICAgICAgICB0aGlzLmIgPSAoNCAqIGQpIC8gKDEgKyA0ICogZCk7XHJcbiAgICAgICAgdGhpcy5lcHNpbG9uID0gNCAvIChoICogaCAqIGsgKiAoMSArIDQgKiBkKSk7XHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgYSBqYWNvYmlhbiBlbnRyeSB3aXRoIGNvcnJlc3BvbmRpbmcgcG9zaXRpb25zIG9yIHZlbG9jaXRpZXNcclxuICAgICAqIEBtZXRob2QgZ211bHRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmdtdWx0ID0gZnVuY3Rpb24gKEcsIHZpLCB3aSwgdmosIHdqKSB7XHJcbiAgICAgICAgcmV0dXJuIEdbMF0gKiB2aVswXSArXHJcbiAgICAgICAgICAgIEdbMV0gKiB2aVsxXSArXHJcbiAgICAgICAgICAgIEdbMl0gKiB3aSArXHJcbiAgICAgICAgICAgIEdbM10gKiB2alswXSArXHJcbiAgICAgICAgICAgIEdbNF0gKiB2alsxXSArXHJcbiAgICAgICAgICAgIEdbNV0gKiB3ajtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBSSFMgb2YgdGhlIFNQT09LIGVxdWF0aW9uXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVCXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChhLCBiLCBoKSB7XHJcbiAgICAgICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcclxuICAgICAgICB2YXIgR3EgPSB0aGlzLmNvbXB1dGVHcSgpO1xyXG4gICAgICAgIHZhciBtYXhCaWFzID0gdGhpcy5tYXhCaWFzO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhHcSkgPiBtYXhCaWFzKSB7XHJcbiAgICAgICAgICAgIEdxID0gR3EgPiAwID8gbWF4QmlhcyA6IC1tYXhCaWFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuICAgICAgICB2YXIgQiA9IC1HcSAqIGEgLSBHVyAqIGIgLSBHaU1mICogaDtcclxuICAgICAgICByZXR1cm4gQjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIEdcXCpxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR3FcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgRyA9IHRoaXMuRywgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBhaSA9IGJpLmFuZ2xlLCBhaiA9IGJqLmFuZ2xlO1xyXG4gICAgICAgIHZhciBxaSA9IGNyZWF0ZVZlYzIoKSwgcWogPSBjcmVhdGVWZWMyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRywgcWksIGFpLCBxaiwgYWopICsgdGhpcy5vZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBHXFwqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR1dcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgRyA9IHRoaXMuRywgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciB2aSA9IGJpLnZlbG9jaXR5LCB2aiA9IGJqLnZlbG9jaXR5LCB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSwgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRywgdmksIHdpLCB2aiwgd2opICsgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIEcgPSB0aGlzLkcsIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCO1xyXG4gICAgICAgIGlmICghYmkgfHwgIWJqKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgdmkgPSBiaS52bGFtYmRhLCB2aiA9IGJqLnZsYW1iZGEsIHdpID0gYmkud2xhbWJkYSwgd2ogPSBiai53bGFtYmRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHZpLCB3aSwgdmosIHdqKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR2lNZlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCO1xyXG4gICAgICAgIGlmICghYmkgfHwgIWJqKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgZmkgPSBiaS5mb3JjZSwgdGkgPSBiaS5hbmd1bGFyRm9yY2UsIGZqID0gYmouZm9yY2UsIHRqID0gYmouYW5ndWxhckZvcmNlLCBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSwgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLCBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSwgRyA9IHRoaXMuRztcclxuICAgICAgICB2YXIgaU1maSA9IGNyZWF0ZVZlYzIoKSwgaU1maiA9IGNyZWF0ZVZlYzIoKTtcclxuICAgICAgICBzY2FsZShpTWZpLCBmaSwgaW52TWFzc2kpO1xyXG4gICAgICAgIG11bHRpcGx5KGlNZmksIGJpLm1hc3NNdWx0aXBsaWVyLCBpTWZpKTtcclxuICAgICAgICBzY2FsZShpTWZqLCBmaiwgaW52TWFzc2opO1xyXG4gICAgICAgIG11bHRpcGx5KGlNZmosIGJqLm1hc3NNdWx0aXBsaWVyLCBpTWZqKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCBpTWZpLCB0aSAqIGludklpLCBpTWZqLCB0aiAqIGludklqKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpHJ1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR2lNR3RcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSwgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLCBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSwgRyA9IHRoaXMuRztcclxuICAgICAgICByZXR1cm4gR1swXSAqIEdbMF0gKiBpbnZNYXNzaSAqIGJpLm1hc3NNdWx0aXBsaWVyWzBdICtcclxuICAgICAgICAgICAgR1sxXSAqIEdbMV0gKiBpbnZNYXNzaSAqIGJpLm1hc3NNdWx0aXBsaWVyWzFdICtcclxuICAgICAgICAgICAgR1syXSAqIEdbMl0gKiBpbnZJaSArXHJcbiAgICAgICAgICAgIEdbM10gKiBHWzNdICogaW52TWFzc2ogKiBiai5tYXNzTXVsdGlwbGllclswXSArXHJcbiAgICAgICAgICAgIEdbNF0gKiBHWzRdICogaW52TWFzc2ogKiBiai5tYXNzTXVsdGlwbGllclsxXSArXHJcbiAgICAgICAgICAgIEdbNV0gKiBHWzVdICogaW52SWo7XHJcbiAgICB9O1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLnVwZGF0ZUphY29iaWFuID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24gKGRlbHRhbGFtYmRhKSB7XHJcbiAgICAgICAgdmFyIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCO1xyXG4gICAgICAgIGlmICghYmkgfHwgIWJqKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSwgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLCBHID0gdGhpcy5HO1xyXG4gICAgICAgIC8vIHZfbGFtYmRhID0gRyAqIGludihNKSAqIGRlbHRhX2xhbWJkYVxyXG4gICAgICAgIGFkZFRvVkxhbWJkYShiaS52bGFtYmRhLCBHWzBdLCBHWzFdLCBpbnZNYXNzaSwgZGVsdGFsYW1iZGEsIGJpLm1hc3NNdWx0aXBsaWVyKTtcclxuICAgICAgICBiaS53bGFtYmRhICs9IGludklpICogR1syXSAqIGRlbHRhbGFtYmRhO1xyXG4gICAgICAgIGFkZFRvVkxhbWJkYShiai52bGFtYmRhLCBHWzNdLCBHWzRdLCBpbnZNYXNzaiwgZGVsdGFsYW1iZGEsIGJqLm1hc3NNdWx0aXBsaWVyKTtcclxuICAgICAgICBiai53bGFtYmRhICs9IGludklqICogR1s1XSAqIGRlbHRhbGFtYmRhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgZGVub21pbmF0b3IgcGFydCBvZiB0aGUgU1BPT0sgZXF1YXRpb246IEMgPSBHXFwqaW52KE0pXFwqRycgKyBlcHNcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUludkNcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZXBzXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlSW52QyA9IGZ1bmN0aW9uIChlcHMpIHtcclxuICAgICAgICB2YXIgaW52QyA9IDEgLyAodGhpcy5jb21wdXRlR2lNR3QoKSArIGVwcyk7XHJcbiAgICAgICAgcmV0dXJuIGludkM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBzdGlmZm5lc3Mgd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1NUSUZGTkVTU1xyXG4gICAgICogQGRlZmF1bHQgMWU2XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTID0gMWU2O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCByZWxheGF0aW9uIHdoZW4gY3JlYXRpbmcgYSBuZXcgRXF1YXRpb24uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gREVGQVVMVF9SRUxBWEFUSU9OXHJcbiAgICAgKiBAZGVmYXVsdCA0XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTiA9IDQ7XHJcbiAgICByZXR1cm4gRXF1YXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEVxdWF0aW9uO1xyXG5mdW5jdGlvbiBhZGRUb1ZMYW1iZGEodmxhbWJkYSwgR3gsIEd5LCBpbnZNYXNzLCBkZWx0YWxhbWJkYSwgbWFzc011bHRpcGxpZXIpIHtcclxuICAgIHZsYW1iZGFbMF0gKz0gR3ggKiBpbnZNYXNzICogZGVsdGFsYW1iZGEgKiBtYXNzTXVsdGlwbGllclswXTtcclxuICAgIHZsYW1iZGFbMV0gKz0gR3kgKiBpbnZNYXNzICogZGVsdGFsYW1iZGEgKiBtYXNzTXVsdGlwbGllclsxXTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FcXVhdGlvblwiKSk7XHJcbnZhciBBbmdsZUxvY2tFcXVhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBbmdsZUxvY2tFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBBbmdsZUxvY2tFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5IEEuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmF0aW9dIEdlYXIgcmF0aW9cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1JbmZpbml0eSwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgX3RoaXMucmF0aW8gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmF0aW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgX3RoaXMuc2V0UmF0aW8oX3RoaXMucmF0aW8pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF0aW8gKiB0aGlzLmJvZHlBLmFuZ2xlIC0gdGhpcy5ib2R5Qi5hbmdsZSArIHRoaXMuYW5nbGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGdlYXIgcmF0aW8gZm9yIHRoaXMgZXF1YXRpb25cclxuICAgICAqIEBtZXRob2Qgc2V0UmF0aW9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xyXG4gICAgICovXHJcbiAgICBBbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0UmF0aW8gPSBmdW5jdGlvbiAocmF0aW8pIHtcclxuICAgICAgICB2YXIgRyA9IHRoaXMuRztcclxuICAgICAgICBHWzJdID0gcmF0aW87XHJcbiAgICAgICAgR1s1XSA9IC0xO1xyXG4gICAgICAgIHRoaXMucmF0aW8gPSByYXRpbztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZXF1YXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIHNldE1heFRvcnF1ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcnF1ZVxyXG4gICAgICovXHJcbiAgICBBbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKHRvcnF1ZSkge1xyXG4gICAgICAgIHRoaXMubWF4Rm9yY2UgPSB0b3JxdWU7XHJcbiAgICAgICAgdGhpcy5taW5Gb3JjZSA9IC10b3JxdWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFuZ2xlTG9ja0VxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBbmdsZUxvY2tFcXVhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEVxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vRXF1YXRpb25cIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG5mdW5jdGlvbiBhZGRTdWJTdWIob3V0LCBhLCBiLCBjLCBkKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXSAtIGNbMF0gLSBkWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV0gLSBjWzFdIC0gZFsxXTtcclxufVxyXG52YXIgdmkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHZqID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciByZWxWZWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIENvbnRhY3RFcXVhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250YWN0RXF1YXRpb24sIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIE5vbi1wZW5ldHJhdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uLiBUcmllcyB0byBtYWtlIHRoZSBjb250YWN0UG9pbnRBIGFuZCBjb250YWN0UG9pbnRCIHZlY3RvcnMgY29pbmNpZGUsIHdoaWxlIGtlZXBpbmcgdGhlIGFwcGxpZWQgZm9yY2UgcmVwdWxzaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBDb250YWN0RXF1YXRpb25cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgMCwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVjdG9yIGZyb20gYm9keSBpIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RQb2ludEEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5wZW5ldHJhdGlvblZlYyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciBmcm9tIGJvZHkgQSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5vcm1hbCB2ZWN0b3IsIHBvaW50aW5nIG91dCBvZiBib2R5IGlcclxuICAgICAgICAgKiBAcHJvcGVydHkgbm9ybWFsQVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ub3JtYWxBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc3RpdHV0aW9uIHRvIHVzZSAoMD1ubyBib3VuY2luZXNzLCAxPW1heCBib3VuY2luZXNzKS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnJlc3RpdHV0aW9uID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGltcGFjdCBiZXR3ZWVuIHRoZSBib2RpZXMgKG5vdCBwZXJzaXN0YW50IGNvbnRhY3QpLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmaXJzdEltcGFjdFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmZpcnN0SW1wYWN0ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQVxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zaGFwZUEgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcclxuICAgICAgICAgKiBAdHlwZSB7U2hhcGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBDb250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGEsIGIsIGgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QiwgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLCB4aSA9IChfYSA9IGJpID09PSBudWxsIHx8IGJpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaS5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IEZsb2F0MzJBcnJheSgyKSwgeGogPSAoX2IgPSBiaiA9PT0gbnVsbCB8fCBiaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmoucG9zaXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5vcm1hbEEsIEcgPSB0aGlzLkc7XHJcbiAgICAgICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXHJcbiAgICAgICAgdmFyIHJpeG4gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaSwgbiksIHJqeG4gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgbik7XHJcbiAgICAgICAgLy8gRyA9IFstbiAtcml4biBuIHJqeG5dXHJcbiAgICAgICAgR1swXSA9IC1uWzBdO1xyXG4gICAgICAgIEdbMV0gPSAtblsxXTtcclxuICAgICAgICBHWzJdID0gLXJpeG47XHJcbiAgICAgICAgR1szXSA9IG5bMF07XHJcbiAgICAgICAgR1s0XSA9IG5bMV07XHJcbiAgICAgICAgR1s1XSA9IHJqeG47XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cclxuICAgICAgICB2YXIgR1csIEdxO1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0SW1wYWN0ICYmIHRoaXMucmVzdGl0dXRpb24gIT09IDApIHtcclxuICAgICAgICAgICAgR3EgPSAwO1xyXG4gICAgICAgICAgICBHVyA9ICgxIC8gYikgKiAoMSArIHRoaXMucmVzdGl0dXRpb24pICogdGhpcy5jb21wdXRlR1coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBxID0geGorcmogLSh4aStyaSkgaS5lLiB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXHJcbiAgICAgICAgICAgIHZhciBwZW5ldHJhdGlvblZlYyA9IHRoaXMucGVuZXRyYXRpb25WZWM7XHJcbiAgICAgICAgICAgIGFkZFN1YlN1YihwZW5ldHJhdGlvblZlYywgeGosIHJqLCB4aSwgcmkpO1xyXG4gICAgICAgICAgICBHcSA9IHZlYzJfMS5kZWZhdWx0LmRvdChuLCBwZW5ldHJhdGlvblZlYykgKyB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuICAgICAgICB2YXIgQiA9IC1HcSAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcclxuICAgICAgICByZXR1cm4gQjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgcmVsYXRpdmUgdmVsb2NpdHkgYWxvbmcgdGhlIG5vcm1hbCB2ZWN0b3IuXHJcbiAgICAgKiBAbWV0aG9kIGdldFZlbG9jaXR5QWxvbmdOb3JtYWxcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5nZXRWZWxvY2l0eUFsb25nTm9ybWFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm9keUEgJiYgdGhpcy5ib2R5QS5nZXRWZWxvY2l0eUF0UG9pbnQodmksIHRoaXMuY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgdGhpcy5ib2R5QiAmJiB0aGlzLmJvZHlCLmdldFZlbG9jaXR5QXRQb2ludCh2aiwgdGhpcy5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyZWxWZWwsIHZpLCB2aik7XHJcbiAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdCh0aGlzLm5vcm1hbEEsIHJlbFZlbCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIENvbnRhY3RFcXVhdGlvbjtcclxufShFcXVhdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFjdEVxdWF0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FcXVhdGlvblwiKSk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZyaWN0aW9uRXF1YXRpb24sIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnRcclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKSB7XHJcbiAgICAgICAgaWYgKHNsaXBGb3JjZSA9PT0gdm9pZCAwKSB7IHNsaXBGb3JjZSA9IEluZmluaXR5OyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQSB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29udGFjdFBvaW50QSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEIgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYW5nZW50IHZlY3RvciB0aGF0IHRoZSBmcmljdGlvbiBmb3JjZSB3aWxsIGFjdCBhbG9uZy4gV29ybGQgb3JpZW50ZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHRcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhY3RFcXVhdGlvbnMgY29ubmVjdGVkIHRvIHRoaXMgZnJpY3Rpb24gZXF1YXRpb24uIFRoZSBjb250YWN0IGVxdWF0aW9ucyBjYW4gYmUgdXNlZCB0byByZXNjYWxlIHRoZSBtYXggZm9yY2UgZm9yIHRoZSBmcmljdGlvbi4gSWYgbW9yZSB0aGFuIG9uZSBjb250YWN0IGVxdWF0aW9uIGlzIGdpdmVuLCB0aGVuIHRoZSBtYXggZm9yY2UgY2FuIGJlIHNldCB0byB0aGUgYXZlcmFnZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdEVxdWF0aW9uc1xyXG4gICAgICAgICAqIEB0eXBlIHtDb250YWN0RXF1YXRpb25bXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcclxuICAgICAgICAgKiBAdHlwZSB7U2hhcGV9XHJcbiAgICAgICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlQSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzaGFwZUJcclxuICAgICAgICAgKiBAdHlwZSB7U2hhcGV9XHJcbiAgICAgICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQi4uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlQiA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25Db2VmZmljaWVudFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxyXG4gICAgICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxyXG4gICAgICovXHJcbiAgICBGcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbiAoc2xpcEZvcmNlKSB7XHJcbiAgICAgICAgdGhpcy5tYXhGb3JjZSA9IHNsaXBGb3JjZTtcclxuICAgICAgICB0aGlzLm1pbkZvcmNlID0gLXNsaXBGb3JjZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cclxuICAgICAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBGcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChhLCBiLCBoKSB7XHJcbiAgICAgICAgdmFyIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLCByaiA9IHRoaXMuY29udGFjdFBvaW50QiwgdCA9IHRoaXMudCwgRyA9IHRoaXMuRztcclxuICAgICAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cclxuICAgICAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXHJcbiAgICAgICAgR1swXSA9IC10WzBdO1xyXG4gICAgICAgIEdbMV0gPSAtdFsxXTtcclxuICAgICAgICBHWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCB0KTtcclxuICAgICAgICBHWzNdID0gdFswXTtcclxuICAgICAgICBHWzRdID0gdFsxXTtcclxuICAgICAgICBHWzVdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmosIHQpO1xyXG4gICAgICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XHJcbiAgICAgICAgdmFyIEIgPSAvKiAtIGcgKiBhICAqLyAtR1cgKiBiIC0gaCAqIEdpTWY7XHJcbiAgICAgICAgcmV0dXJuIEI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEZyaWN0aW9uRXF1YXRpb247XHJcbn0oRXF1YXRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZyaWN0aW9uRXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIHdvcmxkVmVjdG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB3b3JsZFZlY3RvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgeEF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDEsIDApLCB5QXhpcyA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMCwgMSk7XHJcbnZhciBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJvdGF0aW9uYWxMb2NrRXF1YXRpb24sIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgUm90YXRpb25hbExvY2tFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5QS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtSW5maW5pdHksIEluZmluaXR5KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIHZhciBHID0gX3RoaXMuRztcclxuICAgICAgICBHWzJdID0gMTtcclxuICAgICAgICBHWzVdID0gLTE7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZFZlY3RvckEsIHhBeGlzLCB0aGlzLmJvZHlBLmFuZ2xlICsgdGhpcy5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkVmVjdG9yQiwgeUF4aXMsIHRoaXMuYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5kb3Qod29ybGRWZWN0b3JBLCB3b3JsZFZlY3RvckIpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FcXVhdGlvblwiKSk7XHJcbnZhciBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogU3luY3Mgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0d28gYm9kaWVzLCBvciBzZXRzIGEgcmVsYXRpdmUgdmVsb2NpdHkgKG1vdG9yKS5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb25cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24oYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtSW5maW5pdHksIEluZmluaXR5KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAxO1xyXG4gICAgICAgIF90aGlzLnJhdGlvID0gMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbiAoYSwgYiwgaCkge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HO1xyXG4gICAgICAgIEdbMl0gPSAtMTtcclxuICAgICAgICBHWzVdID0gdGhpcy5yYXRpbztcclxuICAgICAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuICAgICAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIHZhciBCID0gLUdXICogYiAtIGggKiBHaU1mO1xyXG4gICAgICAgIHJldHVybiBCO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcclxufShFcXVhdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXHJcbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcclxuICogQGV4YW1wbGVcclxuICogICAgIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gKiAgICAgZW1pdHRlci5vbignbXlFdmVudCcsIGZ1bmN0aW9uKGV2dCl7XHJcbiAqICAgICAgICAgY29uc29sZS5sb2coZXZ0Lm1lc3NhZ2UpO1xyXG4gKiAgICAgfSk7XHJcbiAqICAgICBlbWl0dGVyLmVtaXQoe1xyXG4gKiAgICAgICAgIHR5cGU6ICdteUV2ZW50JyxcclxuICogICAgICAgICBtZXNzYWdlOiAnSGVsbG8gd29ybGQhJ1xyXG4gKiAgICAgfSk7XHJcbiAqL1xyXG52YXIgRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAgICogQG1ldGhvZCBvblxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICBlbWl0dGVyLm9uKCdteUV2ZW50JywgZnVuY3Rpb24oZXZ0KXtcclxuICAgICAqICAgICAgICAgY29uc29sZS5sb2coJ215RXZ0IHdhcyB0cmlnZ2VyZWQhJyk7XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzW3R5cGVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dHNbdHlwZV0ucHVzaChjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcclxuICAgICAqIEBtZXRob2Qgb2ZmXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIGVtaXR0ZXIub24oJ215RXZlbnQnLCBoYW5kbGVyKTsgLy8gQWRkIGhhbmRsZXJcclxuICAgICAqICAgICBlbWl0dGVyLm9mZignbXlFdmVudCcsIGhhbmRsZXIpOyAvLyBSZW1vdmUgaGFuZGxlclxyXG4gICAgICovXHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzIHx8ICF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkXHJcbiAgICAgKiBAbWV0aG9kIGhhc1xyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVtaXQgYW4gZXZlbnQuXHJcbiAgICAgKiBAbWV0aG9kIGVtaXRcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQudHlwZVxyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIGVtaXR0ZXIuZW1pdCh7XHJcbiAgICAgKiAgICAgICAgIHR5cGU6ICdteUV2ZW50JyxcclxuICAgICAqICAgICAgICAgY3VzdG9tRGF0YTogMTIzXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IHRoZSB1bmtub3duIHR5cGUgaGVyZSBpcyBkaXN0dXJiaW5nLlxyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IHRoaXMuX2xpc3RlbmVyc1tldmVudC50eXBlXTtcclxuICAgICAgICB2YXIgY29udGV4dEFycmF5ID0gdGhpcy5fY29udGV4dHNbZXZlbnQudHlwZV07XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNvcHkgdGhlIGxpc3RlbmVyIGFycmF5LCBpbiBjYXNlIHNvbWUgbGlzdGVuZXIgd2FzIGFkZGVkL3JlbW92ZWQgaW5zaWRlIGEgbGlzdGVuZXJcclxuICAgICAgICAgICAgdmFyIHRtcExpc3RlbmVyQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHRtcENvbnRleHRBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0bXBMaXN0ZW5lckFycmF5LnB1c2gobGlzdGVuZXJBcnJheVtpXSk7XHJcbiAgICAgICAgICAgICAgICB0bXBDb250ZXh0QXJyYXkucHVzaChjb250ZXh0QXJyYXlbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbnRleHRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoY29udGV4dCwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy52ZWMyID0gZXhwb3J0cy5Xb3JsZCA9IGV4cG9ydHMuVXRpbHMgPSBleHBvcnRzLlJvdGF0aW9uYWxTcHJpbmcgPSBleHBvcnRzLkxpbmVhclNwcmluZyA9IGV4cG9ydHMuVG9wRG93blZlaGljbGUgPSBleHBvcnRzLlNwcmluZyA9IGV4cG9ydHMuU29sdmVyID0gZXhwb3J0cy5TaGFwZSA9IGV4cG9ydHMuU0FQQnJvYWRwaGFzZSA9IGV4cG9ydHMuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSBleHBvcnRzLkJveCA9IGV4cG9ydHMuUmF5Y2FzdFJlc3VsdCA9IGV4cG9ydHMuUmF5ID0gZXhwb3J0cy5QcmlzbWF0aWNDb25zdHJhaW50ID0gZXhwb3J0cy5SZXZvbHV0ZUNvbnN0cmFpbnQgPSBleHBvcnRzLlBvb2wgPSBleHBvcnRzLlBsYW5lID0gZXhwb3J0cy5QYXJ0aWNsZSA9IGV4cG9ydHMuTmFpdmVCcm9hZHBoYXNlID0gZXhwb3J0cy5OYXJyb3dwaGFzZSA9IGV4cG9ydHMuTWF0ZXJpYWwgPSBleHBvcnRzLkxvY2tDb25zdHJhaW50ID0gZXhwb3J0cy5MaW5lID0gZXhwb3J0cy5IZWlnaHRmaWVsZCA9IGV4cG9ydHMuR1NTb2x2ZXIgPSBleHBvcnRzLkdlYXJDb25zdHJhaW50ID0gZXhwb3J0cy5GcmljdGlvbkVxdWF0aW9uUG9vbCA9IGV4cG9ydHMuRnJpY3Rpb25FcXVhdGlvbiA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FcXVhdGlvbiA9IGV4cG9ydHMuRGlzdGFuY2VDb25zdHJhaW50ID0gZXhwb3J0cy5Db252ZXggPSBleHBvcnRzLkNvbnRhY3RNYXRlcmlhbCA9IGV4cG9ydHMuQ29udGFjdEVxdWF0aW9uUG9vbCA9IGV4cG9ydHMuQ29udGFjdEVxdWF0aW9uID0gZXhwb3J0cy5Db25zdHJhaW50ID0gZXhwb3J0cy5DaXJjbGUgPSBleHBvcnRzLkNhcHN1bGUgPSBleHBvcnRzLkJyb2FkcGhhc2UgPSBleHBvcnRzLkJvZHkgPSBleHBvcnRzLkFuZ2xlTG9ja0VxdWF0aW9uID0gZXhwb3J0cy5BQUJCID0gdm9pZCAwO1xyXG52YXIgdmVyc2lvbiA9IFwiMC4wLjFcIjtcclxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcclxudmFyIGFhYmJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vYWFiYlwiKSk7XHJcbmV4cG9ydHMuQUFCQiA9IGFhYmJfMS5kZWZhdWx0O1xyXG52YXIgYW5nbGVfbG9ja19lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VxdWF0aW9ucy9hbmdsZS1sb2NrLWVxdWF0aW9uXCIpKTtcclxuZXhwb3J0cy5BbmdsZUxvY2tFcXVhdGlvbiA9IGFuZ2xlX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgYm9keV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMvYm9keVwiKSk7XHJcbmV4cG9ydHMuQm9keSA9IGJvZHlfMS5kZWZhdWx0O1xyXG52YXIgYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9icm9hZHBoYXNlXCIpKTtcclxuZXhwb3J0cy5Ccm9hZHBoYXNlID0gYnJvYWRwaGFzZV8xLmRlZmF1bHQ7XHJcbnZhciBjYXBzdWxlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL2NhcHN1bGVcIikpO1xyXG5leHBvcnRzLkNhcHN1bGUgPSBjYXBzdWxlXzEuZGVmYXVsdDtcclxudmFyIGNpcmNsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9jaXJjbGVcIikpO1xyXG5leHBvcnRzLkNpcmNsZSA9IGNpcmNsZV8xLmRlZmF1bHQ7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuQ29uc3RyYWludCA9IGNvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uXCIpKTtcclxuZXhwb3J0cy5Db250YWN0RXF1YXRpb24gPSBjb250YWN0X2VxdWF0aW9uXzEuZGVmYXVsdDtcclxudmFyIGNvbnRhY3RfZXF1YXRpb25fcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2NvbnRhY3QtZXF1YXRpb24tcG9vbFwiKSk7XHJcbmV4cG9ydHMuQ29udGFjdEVxdWF0aW9uUG9vbCA9IGNvbnRhY3RfZXF1YXRpb25fcG9vbF8xLmRlZmF1bHQ7XHJcbnZhciBjb250YWN0X21hdGVyaWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWF0ZXJpYWwvY29udGFjdC1tYXRlcmlhbFwiKSk7XHJcbmV4cG9ydHMuQ29udGFjdE1hdGVyaWFsID0gY29udGFjdF9tYXRlcmlhbF8xLmRlZmF1bHQ7XHJcbnZhciBjb252ZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvY29udmV4XCIpKTtcclxuZXhwb3J0cy5Db252ZXggPSBjb252ZXhfMS5kZWZhdWx0O1xyXG52YXIgZGlzdGFuY2VfY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL2Rpc3RhbmNlLWNvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLkRpc3RhbmNlQ29uc3RyYWludCA9IGRpc3RhbmNlX2NvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lcXVhdGlvbnMvZXF1YXRpb25cIikpO1xyXG5leHBvcnRzLkVxdWF0aW9uID0gZXF1YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2V2ZW50cy9ldmVudC1lbWl0dGVyXCIpKTtcclxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBldmVudF9lbWl0dGVyXzEuZGVmYXVsdDtcclxudmFyIGZyaWN0aW9uX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxuZXhwb3J0cy5GcmljdGlvbkVxdWF0aW9uID0gZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2xcIikpO1xyXG5leHBvcnRzLkZyaWN0aW9uRXF1YXRpb25Qb29sID0gZnJpY3Rpb25fZXF1YXRpb25fcG9vbF8xLmRlZmF1bHQ7XHJcbnZhciBnZWFyX2NvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9nZWFyLWNvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLkdlYXJDb25zdHJhaW50ID0gZ2Vhcl9jb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIGdzX3NvbHZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NvbHZlci9ncy1zb2x2ZXJcIikpO1xyXG5leHBvcnRzLkdTU29sdmVyID0gZ3Nfc29sdmVyXzEuZGVmYXVsdDtcclxudmFyIGhlaWdodGZpZWxkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL2hlaWdodGZpZWxkXCIpKTtcclxuZXhwb3J0cy5IZWlnaHRmaWVsZCA9IGhlaWdodGZpZWxkXzEuZGVmYXVsdDtcclxudmFyIGxpbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvbGluZVwiKSk7XHJcbmV4cG9ydHMuTGluZSA9IGxpbmVfMS5kZWZhdWx0O1xyXG52YXIgbG9ja19jb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvbG9jay1jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5Mb2NrQ29uc3RyYWludCA9IGxvY2tfY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciBtYXRlcmlhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hdGVyaWFsL21hdGVyaWFsXCIpKTtcclxuZXhwb3J0cy5NYXRlcmlhbCA9IG1hdGVyaWFsXzEuZGVmYXVsdDtcclxudmFyIG5hcnJvd3BoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL25hcnJvd3BoYXNlXCIpKTtcclxuZXhwb3J0cy5OYXJyb3dwaGFzZSA9IG5hcnJvd3BoYXNlXzEuZGVmYXVsdDtcclxudmFyIG5haXZlX2Jyb2FkcGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vbmFpdmUtYnJvYWRwaGFzZVwiKSk7XHJcbmV4cG9ydHMuTmFpdmVCcm9hZHBoYXNlID0gbmFpdmVfYnJvYWRwaGFzZV8xLmRlZmF1bHQ7XHJcbnZhciBwYXJ0aWNsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9wYXJ0aWNsZVwiKSk7XHJcbmV4cG9ydHMuUGFydGljbGUgPSBwYXJ0aWNsZV8xLmRlZmF1bHQ7XHJcbnZhciBwbGFuZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9wbGFuZVwiKSk7XHJcbmV4cG9ydHMuUGxhbmUgPSBwbGFuZV8xLmRlZmF1bHQ7XHJcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcG9vbFwiKSk7XHJcbmV4cG9ydHMuUG9vbCA9IHBvb2xfMS5kZWZhdWx0O1xyXG52YXIgcmV2b2x1dGVfY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL3Jldm9sdXRlLWNvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLlJldm9sdXRlQ29uc3RyYWludCA9IHJldm9sdXRlX2NvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgcHJpc21hdGljX2NvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9wcmlzbWF0aWMtY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuUHJpc21hdGljQ29uc3RyYWludCA9IHByaXNtYXRpY19jb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIHJheV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9yYXlcIikpO1xyXG5leHBvcnRzLlJheSA9IHJheV8xLmRlZmF1bHQ7XHJcbnZhciByYXljYXN0X3Jlc3VsdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9yYXljYXN0LXJlc3VsdFwiKSk7XHJcbmV4cG9ydHMuUmF5Y2FzdFJlc3VsdCA9IHJheWNhc3RfcmVzdWx0XzEuZGVmYXVsdDtcclxudmFyIEJveF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9Cb3hcIikpO1xyXG5leHBvcnRzLkJveCA9IEJveF8xLmRlZmF1bHQ7XHJcbnZhciByb3RhdGlvbmFsX3ZlbG9jaXR5X2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXF1YXRpb25zL3JvdGF0aW9uYWwtdmVsb2NpdHktZXF1YXRpb25cIikpO1xyXG5leHBvcnRzLlJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uID0gcm90YXRpb25hbF92ZWxvY2l0eV9lcXVhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBzYXBfYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9zYXAtYnJvYWRwaGFzZVwiKSk7XHJcbmV4cG9ydHMuU0FQQnJvYWRwaGFzZSA9IHNhcF9icm9hZHBoYXNlXzEuZGVmYXVsdDtcclxudmFyIHNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL3NoYXBlXCIpKTtcclxuZXhwb3J0cy5TaGFwZSA9IHNoYXBlXzEuZGVmYXVsdDtcclxudmFyIHNvbHZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NvbHZlci9zb2x2ZXJcIikpO1xyXG5leHBvcnRzLlNvbHZlciA9IHNvbHZlcl8xLmRlZmF1bHQ7XHJcbnZhciBzcHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vYmplY3RzL3NwcmluZ1wiKSk7XHJcbmV4cG9ydHMuU3ByaW5nID0gc3ByaW5nXzEuZGVmYXVsdDtcclxudmFyIHRvcF9kb3duX3ZlaGljbGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vYmplY3RzL3RvcC1kb3duLXZlaGljbGVcIikpO1xyXG5leHBvcnRzLlRvcERvd25WZWhpY2xlID0gdG9wX2Rvd25fdmVoaWNsZV8xLmRlZmF1bHQ7XHJcbnZhciBsaW5lYXJfc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JqZWN0cy9saW5lYXItc3ByaW5nXCIpKTtcclxuZXhwb3J0cy5MaW5lYXJTcHJpbmcgPSBsaW5lYXJfc3ByaW5nXzEuZGVmYXVsdDtcclxudmFyIHJvdGF0aW9uYWxfc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JqZWN0cy9yb3RhdGlvbmFsLXNwcmluZ1wiKSk7XHJcbmV4cG9ydHMuUm90YXRpb25hbFNwcmluZyA9IHJvdGF0aW9uYWxfc3ByaW5nXzEuZGVmYXVsdDtcclxudmFyIHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvdXRpbHNcIikpO1xyXG5leHBvcnRzLlV0aWxzID0gdXRpbHNfMS5kZWZhdWx0O1xyXG52YXIgd29ybGRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93b3JsZC93b3JsZFwiKSk7XHJcbmV4cG9ydHMuV29ybGQgPSB3b3JsZF8xLmRlZmF1bHQ7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWF0aC92ZWMyXCIpKTtcclxuZXhwb3J0cy52ZWMyID0gdmVjMl8xLmRlZmF1bHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBNYXRlcmlhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuIFRvIGJlIHVzZWQgd2l0aCB7eyNjcm9zc0xpbmsgXCJDb250YWN0TWF0ZXJpYWxcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgKiBAY2xhc3MgTWF0ZXJpYWxcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSB3b29kZW4gYm94XHJcbiAgICAgKiAgICAgdmFyIHdvb2RNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgpO1xyXG4gICAgICogICAgIHZhciBib3hTaGFwZSA9IG5ldyBCb3goe1xyXG4gICAgICogICAgICAgICBtYXRlcmlhbDogd29vZE1hdGVyaWFsXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE1hdGVyaWFsKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXRlcmlhbCBpZGVudGlmaWVyLiBSZWFkIG9ubHkuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gKytNYXRlcmlhbC5pZENvdW50ZXI7XHJcbiAgICB9XHJcbiAgICBNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xyXG4gICAgcmV0dXJuIE1hdGVyaWFsO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRlcmlhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE1hdGVyaWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTWF0ZXJpYWxcIikpO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL0VxdWF0aW9uXCIpKTtcclxudmFyIENvbnRhY3RNYXRlcmlhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQsIHN1Y2ggYXMgd2hhdCBmcmljdGlvbiBjb2VmZmljaWVudCB0byB1c2UuIFlvdSBjYW4gYWxzbyBzZXQgb3RoZXIgdGhpbmdzIHN1Y2ggYXMgcmVzdGl0dXRpb24sIHN1cmZhY2UgdmVsb2NpdHkgYW5kIGNvbnN0cmFpbnQgcGFyYW1ldGVycy4gQWxzbyBzZWUge3sjY3Jvc3NMaW5rIFwiTWF0ZXJpYWxcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uPTAuM10gICAgICAgRnJpY3Rpb24gY29lZmZpY2llbnQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb25dIEZyaWN0aW9uRXF1YXRpb24gcmVsYXhhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzXSAgRnJpY3Rpb25FcXVhdGlvbiBzdGlmZm5lc3MuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZWxheGF0aW9uXSAgICAgICAgIENvbnRhY3RFcXVhdGlvbiByZWxheGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVzdGl0dXRpb249MF0gICAgICBSZXN0aXR1dGlvbiBjb2VmZmljaWVudCBha2EgXCJib3VuY2luZXNzXCIuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdGlmZm5lc3NdICAgICAgICAgIENvbnRhY3RFcXVhdGlvbiBzdGlmZm5lc3MuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHk9MF0gIFN1cmZhY2UgdmVsb2NpdHkuXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBpY2UgPSBuZXcgTWF0ZXJpYWwoKTtcclxuICAgICAqICAgICB2YXIgd29vZCA9IG5ldyBNYXRlcmlhbCgpO1xyXG4gICAgICogICAgIHZhciBpY2VXb29kQ29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbChpY2UsIHdvb2QsIHtcclxuICAgICAqICAgICAgICAgZnJpY3Rpb246IDAuMixcclxuICAgICAqICAgICAgICAgcmVzdGl0dXRpb246IDAuM1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnRhY3RNYXRlcmlhbChpY2VXb29kQ29udGFjdE1hdGVyaWFsKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29udGFjdE1hdGVyaWFsKG1hdGVyaWFsQSwgbWF0ZXJpYWxCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzLiBGcmljdGlvbiA9IDAgd2lsbCBtYWtlIHRoZSBpbnZvbHZlZCBvYmplY3RzIHN1cGVyIHNsaXBwZXJ5LCBhbmQgZnJpY3Rpb24gPSAxIHdpbGwgbWFrZSBpdCBtdWNoIGxlc3Mgc2xpcHBlcnkuIEEgZnJpY3Rpb24gY29lZmZpY2llbnQgbGFyZ2VyIHRoYW4gMSB3aWxsIGFsbG93IGZvciB2ZXJ5IGxhcmdlIGZyaWN0aW9uIGZvcmNlcywgd2hpY2ggY2FuIGJlIGNvbnZlbmllbnQgZm9yIHByZXZlbnRpbmcgY2FyIHRpcmVzIG5vdCBzbGlwIG9uIHRoZSBncm91bmQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZyaWN0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uID0gMC4zO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc3RpdHV0aW9uLCBvciBcImJvdW5jaW5lc3NcIiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFscy4gQSByZXN0aXR1dGlvbiBvZiAwIHdpbGwgbWFrZSBubyBib3VuY2UsIHdoaWxlIHJlc3RpdHV0aW9uPTEgd2lsbCBhcHByb3hpbWF0ZWx5IGJvdW5jZSBiYWNrIHdpdGggdGhlIHNhbWUgdmVsb2NpdHkgdGhlIG9iamVjdCBjYW1lIHdpdGguXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFyZG5lc3Mgb2YgdGhlIGNvbnRhY3QuIExlc3Mgc3RpZmZuZXNzIHdpbGwgbWFrZSB0aGUgb2JqZWN0cyBwZW5ldHJhdGUgbW9yZSwgYW5kIHdpbGwgbWFrZSB0aGUgY29udGFjdCBhY3QgbW9yZSBsaWtlIGEgc3ByaW5nIHRoYW4gYSBjb250YWN0IGZvcmNlLiBEZWZhdWx0IHZhbHVlIGlzIHt7I2Nyb3NzTGluayBcIkVxdWF0aW9uL0RFRkFVTFRfU1RJRkZORVNTOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTe3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9TVElGRk5FU1M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVsYXhhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIENvbnRhY3RFcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlLiBEZWZhdWx0IHZhbHVlIGlzIHt7I2Nyb3NzTGluayBcIkVxdWF0aW9uL0RFRkFVTFRfUkVMQVhBVElPTjpwcm9wZXJ0eVwifX1FcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT057ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gRm9yIG1vc3QgY2FzZXMsIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHNob3VsZCBiZSBhIGxhcmdlIG51bWJlci4gSSBjYW5ub3QgdGhpbmsgb2YgYW55IGNhc2Ugd2hlcmUgeW91IHdvdWxkIHdhbnQgbGVzcyBmcmljdGlvblN0aWZmbmVzcy4gRGVmYXVsdCB2YWx1ZSBpcyB7eyNjcm9zc0xpbmsgXCJFcXVhdGlvbi9ERUZBVUxUX1NUSUZGTkVTUzpwcm9wZXJ0eVwifX1FcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTU3t7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgZnJpY3Rpb24gZm9yY2UuIFRoZSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSBnb29kIGZvciBtb3N0IHNpbXVsYXRpb25zLiBEZWZhdWx0IHZhbHVlIGlzIHt7I2Nyb3NzTGluayBcIkVxdWF0aW9uL0RFRkFVTFRfUkVMQVhBVElPTjpwcm9wZXJ0eVwifX1FcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT057ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25SZWxheGF0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2lsbCBhZGQgc3VyZmFjZSB2ZWxvY2l0eSB0byB0aGlzIG1hdGVyaWFsLiBJZiBib2R5QSByZXN0cyBvbiB0b3AgaWYgYm9keUIsIGFuZCB0aGUgc3VyZmFjZSB2ZWxvY2l0eSBpcyBwb3NpdGl2ZSwgYm9keUEgd2lsbCBzbGlkZSB0byB0aGUgcmlnaHQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2Zmc2V0IHRvIGJlIHNldCBvbiBDb250YWN0RXF1YXRpb25zLiBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgbWFrZSB0aGUgYm9kaWVzIHBlbmV0cmF0ZSBtb3JlIGludG8gZWFjaCBvdGhlci4gQ2FuIGJlIHVzZWZ1bCBpbiBzY2VuZXMgd2hlcmUgY29udGFjdHMgbmVlZCB0byBiZSBtb3JlIHBlcnNpc3RlbnQsIGZvciBleGFtcGxlIHdoZW4gc3RhY2tpbmcuIEFrYSBcImN1cmUgZm9yIG5lcnZvdXMgY29udGFjdHNcIi5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdFNraW5TaXplXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDA1O1xyXG4gICAgICAgIGlmICghKG1hdGVyaWFsQSBpbnN0YW5jZW9mIE1hdGVyaWFsXzEuZGVmYXVsdCkgfHwgIShtYXRlcmlhbEIgaW5zdGFuY2VvZiBNYXRlcmlhbF8xLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IHR3byBhcmd1bWVudHMgbXVzdCBiZSBNYXRlcmlhbCBpbnN0YW5jZXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkID0gKytDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxBID0gbWF0ZXJpYWxBO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWxCID0gbWF0ZXJpYWxCO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZnJpY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAuMztcclxuICAgICAgICB0aGlzLnJlc3RpdHV0aW9uID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0aWZmbmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIHRoaXMucmVsYXhhdGlvbiA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWxheGF0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9SRUxBWEFUSU9OO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25TdGlmZm5lc3MgPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3MpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbiA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb24pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5zdXJmYWNlVmVsb2NpdHkgPSAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAwO1xyXG4gICAgICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMDU7XHJcbiAgICB9XHJcbiAgICBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcclxuICAgIHJldHVybiBDb250YWN0TWF0ZXJpYWw7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRhY3RNYXRlcmlhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lcy5cclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGxpbmVJbnRcclxuICogQHBhcmFtICB7QXJyYXl9ICBsMSAgICAgICAgICBMaW5lIHZlY3RvciAxXHJcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiAgIFByZWNpc2lvbiB0byB1c2Ugd2hlbiBjaGVja2luZyBpZiB0aGUgbGluZXMgYXJlIHBhcmFsbGVsXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGludGVyc2VjdGlvbiBwb2ludC5cclxuICovXHJcbmZ1bmN0aW9uIGxpbmVJbnQobDEsIGwyLCBwcmVjaXNpb24pIHtcclxuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAwOyB9XHJcbiAgICB2YXIgaSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7IC8vIHBvaW50XHJcbiAgICB2YXIgYTEsIGIxLCBjMSwgYTIsIGIyLCBjMiwgZGV0OyAvLyBzY2FsYXJzXHJcbiAgICBhMSA9IGwxWzFdWzFdIC0gbDFbMF1bMV07XHJcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XHJcbiAgICBjMSA9IGExICogbDFbMF1bMF0gKyBiMSAqIGwxWzBdWzFdO1xyXG4gICAgYTIgPSBsMlsxXVsxXSAtIGwyWzBdWzFdO1xyXG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xyXG4gICAgYzIgPSBhMiAqIGwyWzBdWzBdICsgYjIgKiBsMlswXVsxXTtcclxuICAgIGRldCA9IGExICogYjIgLSBhMiAqIGIxO1xyXG4gICAgaWYgKCFzY2FsYXJfZXEoZGV0LCAwLCBwcmVjaXNpb24pKSB7IC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcclxuICAgICAgICBpWzBdID0gKGIyICogYzEgLSBiMSAqIGMyKSAvIGRldDtcclxuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcclxuICAgIH1cclxuICAgIHJldHVybiBpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0cy5cclxuICogQG1ldGhvZCBzZWdtZW50c0ludGVyc2VjdFxyXG4gKiBAcGFyYW0ge0FycmF5fSBwMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHAyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHExIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHEyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RcclxuICovXHJcbmZ1bmN0aW9uIGxpbmVTZWdtZW50c0ludGVyc2VjdChwMSwgcDIsIHExLCBxMikge1xyXG4gICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcclxuICAgIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XHJcbiAgICB2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xyXG4gICAgdmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcclxuICAgIC8vIHNlZ21lbnRzIGFyZSBwYXJhbGxlbFxyXG4gICAgaWYgKChkYSAqIGR5IC0gZGIgKiBkeCkgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgcyA9IChkeCAqIChxMVsxXSAtIHAxWzFdKSArIGR5ICogKHAxWzBdIC0gcTFbMF0pKSAvIChkYSAqIGR5IC0gZGIgKiBkeCk7XHJcbiAgICB2YXIgdCA9IChkYSAqIChwMVsxXSAtIHExWzFdKSArIGRiICogKHExWzBdIC0gcDFbMF0pKSAvIChkYiAqIGR4IC0gZGEgKiBkeSk7XHJcbiAgICByZXR1cm4gKHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMSk7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYXJlYVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlhbmdsZUFyZWEoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkpIC0gKChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNMZWZ0KGEsIGIsIGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPiAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzTGVmdE9uKGEsIGIsIGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPj0gMDtcclxufVxyXG5mdW5jdGlvbiBpc1JpZ2h0KGEsIGIsIGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPCAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmlnaHRPbihhLCBiLCBjKSB7XHJcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDw9IDA7XHJcbn1cclxudmFyIHRtcFBvaW50MSA9IG5ldyBGbG9hdDMyQXJyYXkoMiksIHRtcFBvaW50MiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0wXSBUaHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB2ZWN0b3JzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgcmVzdWx0aW5nIHZlY3RvcnMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUuIFVzZSB6ZXJvIGZvciBtYXggcHJlY2lzaW9uLlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGluZWFyKGEsIGIsIGMsIHRocmVzaG9sZEFuZ2xlKSB7XHJcbiAgICBpZiAoIXRocmVzaG9sZEFuZ2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA9PT0gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBhYiA9IHRtcFBvaW50MSwgYmMgPSB0bXBQb2ludDI7XHJcbiAgICAgICAgYWJbMF0gPSBiWzBdIC0gYVswXTtcclxuICAgICAgICBhYlsxXSA9IGJbMV0gLSBhWzFdO1xyXG4gICAgICAgIGJjWzBdID0gY1swXSAtIGJbMF07XHJcbiAgICAgICAgYmNbMV0gPSBjWzFdIC0gYlsxXTtcclxuICAgICAgICB2YXIgZG90ID0gYWJbMF0gKiBiY1swXSArIGFiWzFdICogYmNbMV0sIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0gKiBhYlswXSArIGFiWzFdICogYWJbMV0pLCBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdICogYmNbMF0gKyBiY1sxXSAqIGJjWzFdKSwgYW5nbGUgPSBNYXRoLmFjb3MoZG90IC8gKG1hZ0EgKiBtYWdCKSk7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc3FkaXN0KGEsIGIpIHtcclxuICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xyXG4gICAgdmFyIGR5ID0gYlsxXSAtIGFbMV07XHJcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbn1cclxuLyoqXHJcbiAqIEdldCBhIHZlcnRleCBhdCBwb3NpdGlvbiBpLiBJdCBkb2VzIG5vdCBtYXR0ZXIgaWYgaSBpcyBvdXQgb2YgYm91bmRzLCB0aGlzIGZ1bmN0aW9uIHdpbGwganVzdCBjeWNsZS5cclxuICogQG1ldGhvZCBhdFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQXQocG9seWdvbiwgaSkge1xyXG4gICAgdmFyIHMgPSBwb2x5Z29uLmxlbmd0aDtcclxuICAgIHJldHVybiBwb2x5Z29uW2kgPCAwID8gaSAlIHMgKyBzIDogaSAlIHNdO1xyXG59XHJcbi8qKlxyXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXHJcbiAqIEBtZXRob2QgY2xlYXJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ2xlYXIocG9seWdvbikge1xyXG4gICAgcG9seWdvbi5sZW5ndGggPSAwO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBlbmQgcG9pbnRzIFwiZnJvbVwiIHRvIFwidG9cIi0xIGZyb20gYW4gb3RoZXIgcG9seWdvbiBcInBvbHlcIiBvbnRvIHRoaXMgb25lLlxyXG4gKiBAbWV0aG9kIGFwcGVuZFxyXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gIGZyb20gVGhlIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi5cclxuICogQHBhcmFtIHtOdW1iZXJ9ICB0byBUaGUgZW5kIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi4gTm90ZSB0aGF0IHRoaXMgdmVydGV4IGlzIE5PVCBpbmNsdWRlZCB3aGVuIGFwcGVuZGluZy5cclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQXBwZW5kKHBvbHlnb24sIHBvbHksIGZyb20sIHRvKSB7XHJcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcclxuICAgICAgICBwb2x5Z29uLnB1c2gocG9seVtpXSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxyXG4gKiBAbWV0aG9kIG1ha2VDQ1dcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25NYWtlQ0NXKHBvbHlnb24pIHtcclxuICAgIHZhciBiciA9IDAsIHYgPSBwb2x5Z29uO1xyXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmICh2W2ldWzFdIDwgdlticl1bMV0gfHwgKHZbaV1bMV0gPT09IHZbYnJdWzFdICYmIHZbaV1bMF0gPiB2W2JyXVswXSkpIHtcclxuICAgICAgICAgICAgYnIgPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldmVyc2UgcG9seSBpZiBjbG9ja3dpc2VcclxuICAgIGlmICghaXNMZWZ0KHBvbHlnb25BdChwb2x5Z29uLCBiciAtIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYnIpLCBwb2x5Z29uQXQocG9seWdvbiwgYnIgKyAxKSkpIHtcclxuICAgICAgICBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cclxuICogQG1ldGhvZCByZXZlcnNlXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKSB7XHJcbiAgICB2YXIgdG1wID0gW107XHJcbiAgICB2YXIgTiA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHZhciBwID0gcG9seWdvbi5wb3AoKTtcclxuICAgICAgICB0bXAucHVzaChwKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICBwb2x5Z29uW2ldID0gdG1wW2ldO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XHJcbiAqIEBtZXRob2QgaXNSZWZsZXhcclxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpIHtcclxuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XHJcbn1cclxudmFyIHRtcExpbmUxID0gW10sIHRtcExpbmUyID0gW107XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXHJcbiAqIEBtZXRob2QgY2FuU2VlXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYSBWZXJ0ZXggaW5kZXggMVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUocG9seWdvbiwgYSwgYikge1xyXG4gICAgdmFyIHAsIGRpc3QsIGwxID0gdG1wTGluZTEsIGwyID0gdG1wTGluZTI7XHJcbiAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEgKyAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSAtIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBkaXN0ID0gc3FkaXN0KHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcclxuICAgICAgICBpZiAoKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpIHsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxyXG4gICAgICAgICAgICBsMVswXSA9IHBvbHlnb25BdChwb2x5Z29uLCBhKTtcclxuICAgICAgICAgICAgbDFbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgYik7XHJcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xyXG4gICAgICAgICAgICBsMlsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSk7XHJcbiAgICAgICAgICAgIHAgPSBsaW5lSW50KGwxLCBsMik7XHJcbiAgICAgICAgICAgIGlmIChzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwKSA8IGRpc3QpIHsgLy8gaWYgZWRnZSBpcyBibG9ja2luZyB2aXNpYmlsaXR5IHRvIGJcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXHJcbiAqIEBtZXRob2QgY2FuU2VlMlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcclxuICogQHBhcmFtICB7TnVtYmVyfSBiIFZlcnRleCBpbmRleCAyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ2FuU2VlMihwb2x5Z29uLCBhLCBiKSB7XHJcbiAgICAvLyBmb3IgZWFjaCBlZGdlXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xyXG4gICAgICAgIGlmIChpID09PSBhIHx8IGkgPT09IGIgfHwgKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBhIHx8IChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVTZWdtZW50c0ludGVyc2VjdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cclxuICogQG1ldGhvZCBjb3B5XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cclxuICogQHJldHVybiB7UG9seWdvbn0gICAgICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBjb3B5LlxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdGFyZ2V0UG9seSkge1xyXG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5ICE9PSBudWxsICYmIHRhcmdldFBvbHkgIT09IHZvaWQgMCA/IHRhcmdldFBvbHkgOiBbXTtcclxuICAgIHBvbHlnb25DbGVhcihwKTtcclxuICAgIGlmIChpIDwgaikge1xyXG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcclxuICAgICAgICBmb3IgKHZhciBrID0gaTsgayA8PSBqOyBrKyspIHtcclxuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8PSBqOyBrKyspIHtcclxuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcclxuICAgICAgICBmb3IgKHZhciBrID0gaTsgayA8IHBvbHlnb24ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgcC5wdXNoKHBvbHlnb25ba10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cclxuICogTm90ZSB0aGF0IHRoaXMgYWxnb3JpdGhtIGhhcyBjb21wbGV4aXR5IE8oTl40KSBhbmQgd2lsbCBiZSB2ZXJ5IHNsb3cgZm9yIHBvbHlnb25zIHdpdGggbWFueSB2ZXJ0aWNlcy5cclxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKSB7XHJcbiAgICB2YXIgbWluID0gW10sIHRtcDEgPSBbXSwgdG1wMiA9IFtdLCB0bXBQb2x5ID0gW107XHJcbiAgICB2YXIgbkRpYWdzID0gSW5maW5pdHk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAocG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25DYW5TZWUocG9seWdvbiwgaSwgaikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXAxID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb25Db3B5KHBvbHlnb24sIGksIGosIHRtcFBvbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICB0bXAyID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb25Db3B5KHBvbHlnb24sIGosIGksIHRtcFBvbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRtcDIubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wMS5sZW5ndGggPCBuRGlhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gW3BvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGopXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbjtcclxufVxyXG4vKipcclxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXHJcbiAqIEBtZXRob2QgZGVjb21wXHJcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uRGVjb21wKHBvbHlnb24pIHtcclxuICAgIHZhciBlZGdlcyA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKTtcclxuICAgIGlmIChlZGdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb25TbGljZShwb2x5Z29uLCBlZGdlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTbGljZXMgdGhlIHBvbHlnb24gZ2l2ZW4gb25lIG9yIG1vcmUgY3V0IGVkZ2VzLiBJZiBnaXZlbiBvbmUsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHdvIHBvbHlnb25zIChmYWxzZSBvbiBmYWlsdXJlKS4gSWYgbWFueSwgYW4gYXJyYXkgb2YgcG9seWdvbnMuXHJcbiAqIEB3YXJuaW5nIFRoZSBpbm5lciB3b3JraW5ncyBvZiB0aGlzIGZ1bmN0aW9uIHdhcyBtYXNzaXZlbHkgbW9kaWZpZWQgd2hlbiBzd2l0Y2hpbmcgdG8gdHlwZXNjcmlwdC4gTmVlZHMgdGhvcm91Z2ggdGVzdGluZy5cclxuICogQG1ldGhvZCBzbGljZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBjdXRFZGdlcyBBIGxpc3Qgb2YgZWRnZXMsIGFzIHJldHVybmVkIGJ5IC5nZXRDdXRFZGdlcygpXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblNsaWNlKHBvbHlnb24sIGN1dEVkZ2VzKSB7XHJcbiAgICBpZiAoY3V0RWRnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtwb2x5Z29uXTtcclxuICAgIH1cclxuICAgIGlmIChjdXRFZGdlc1swXS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICB2YXIgcG9seXMgPSBbcG9seWdvbl07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXRFZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IFtjdXRFZGdlc1tpXV07XHJcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBwb2x5c1tqXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5Z29uU2xpY2UocG9seSwgY3V0RWRnZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seXMuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvbHlzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2FzIGdpdmVuIG9uZSBlZGdlXHJcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcclxuICAgICAgICB2YXIgaSA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzBdWzBdKTtcclxuICAgICAgICB2YXIgaiA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzBdWzFdKTtcclxuICAgICAgICBpZiAoaSAhPT0gLTEgJiYgaiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqKSxcclxuICAgICAgICAgICAgICAgIHBvbHlnb25Db3B5KHBvbHlnb24sIGosIGkpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXHJcbiAqIEBtZXRob2QgaXNTaW1wbGVcclxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAdG9kbyBTaG91bGQgaXQgY2hlY2sgYWxsIHNlZ21lbnRzIHdpdGggYWxsIG90aGVycz9cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25Jc1NpbXBsZShwb2x5Z29uKSB7XHJcbiAgICB2YXIgcGF0aCA9IHBvbHlnb24sIGk7XHJcbiAgICAvLyBDaGVja1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFtpXSwgcGF0aFtpICsgMV0sIHBhdGhbal0sIHBhdGhbaiArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgdGhlIHNlZ21lbnQgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHBvaW50IHRvIGFsbCBvdGhlcnNcclxuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgIGlmIChsaW5lU2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoW2ldLCBwYXRoW2kgKyAxXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSkge1xyXG4gICAgaWYgKGRlbHRhID09PSB2b2lkIDApIHsgZGVsdGEgPSAwOyB9XHJcbiAgICB2YXIgYTEgPSBwMlsxXSAtIHAxWzFdO1xyXG4gICAgdmFyIGIxID0gcDFbMF0gLSBwMlswXTtcclxuICAgIHZhciBjMSA9IChhMSAqIHAxWzBdKSArIChiMSAqIHAxWzFdKTtcclxuICAgIHZhciBhMiA9IHEyWzFdIC0gcTFbMV07XHJcbiAgICB2YXIgYjIgPSBxMVswXSAtIHEyWzBdO1xyXG4gICAgdmFyIGMyID0gKGEyICogcTFbMF0pICsgKGIyICogcTFbMV0pO1xyXG4gICAgdmFyIGRldCA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcclxuICAgIHZhciBwdCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICBpZiAoIXNjYWxhcl9lcShkZXQsIDAsIGRlbHRhKSkge1xyXG4gICAgICAgIHB0WzBdID0gKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQ7XHJcbiAgICAgICAgcHRbMV0gPSAoKGExICogYzIpIC0gKGEyICogYzEpKSAvIGRldDtcclxuICAgICAgICByZXR1cm4gcHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdFswXSA9IDA7XHJcbiAgICAgICAgcHRbMV0gPSAwO1xyXG4gICAgICAgIHJldHVybiBwdDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxyXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXHJcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcclxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cclxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWx0YV1cclxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25RdWlja0RlY29tcChwb2x5Z29uLCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKSB7XHJcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gbmV3IEFycmF5KCk7IH1cclxuICAgIGlmIChyZWZsZXhWZXJ0aWNlcyA9PT0gdm9pZCAwKSB7IHJlZmxleFZlcnRpY2VzID0gW107IH1cclxuICAgIGlmIChzdGVpbmVyUG9pbnRzID09PSB2b2lkIDApIHsgc3RlaW5lclBvaW50cyA9IFtdOyB9XHJcbiAgICBpZiAoZGVsdGEgPT09IHZvaWQgMCkgeyBkZWx0YSA9IDI1OyB9XHJcbiAgICBpZiAobWF4bGV2ZWwgPT09IHZvaWQgMCkgeyBtYXhsZXZlbCA9IDEwMDsgfVxyXG4gICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSAwOyB9XHJcbiAgICAvLyBUT0RPOiBzaG91bGQgdXBwZXJJbnQgcmVhbGx5IGJlIGluaXRpYWxpemVkIGhlcmU/IEl0IGxvb2tzIGxpa2UgaXQncyBvdmVyd3JpdHRlbi5cclxuICAgIHZhciB1cHBlckludCA9IG5ldyBGbG9hdDMyQXJyYXkoMiksIGxvd2VySW50ID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgcCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7IC8vIFBvaW50c1xyXG4gICAgdXBwZXJJbnRbMF0gPSAwO1xyXG4gICAgdXBwZXJJbnRbMV0gPSAwO1xyXG4gICAgbG93ZXJJbnRbMF0gPSAwO1xyXG4gICAgbG93ZXJJbnRbMV0gPSAwO1xyXG4gICAgcFswXSA9IDA7XHJcbiAgICBwWzFdID0gMDtcclxuICAgIHZhciB1cHBlckRpc3QgPSAwLCBsb3dlckRpc3QgPSAwLCBkID0gMCwgY2xvc2VzdERpc3QgPSAwOyAvLyBzY2FsYXJzXHJcbiAgICB2YXIgdXBwZXJJbmRleCA9IDAsIGxvd2VySW5kZXggPSAwLCBjbG9zZXN0SW5kZXggPSAwOyAvLyBJbnRlZ2Vyc1xyXG4gICAgdmFyIGxvd2VyUG9seSA9IG5ldyBBcnJheSgpLCB1cHBlclBvbHkgPSBuZXcgQXJyYXkoKTsgLy8gcG9seWdvbnNcclxuICAgIHZhciBwb2x5ID0gcG9seWdvbiwgdiA9IHBvbHlnb247XHJcbiAgICBpZiAodi5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGxldmVsKys7XHJcbiAgICBpZiAobGV2ZWwgPiBtYXhsZXZlbCkge1xyXG4gICAgICAgIC8vY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAocG9seWdvbklzUmVmbGV4KHBvbHksIGkpKSB7XHJcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seVtpXSk7XHJcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb24ubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqIC0gMSkpOyAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlbaV0sIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdCkgeyAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcclxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT09ICh1cHBlckluZGV4ICsgMSkgJSBwb2x5Z29uLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrcG9seWdvbi5sZW5ndGgrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgcFswXSA9IChsb3dlckludFswXSArIHVwcGVySW50WzBdKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBwWzFdID0gKGxvd2VySW50WzFdICsgdXBwZXJJbnRbMV0pIC8gMjtcclxuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwgbG93ZXJJbmRleCwgcG9seS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwgMCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCBwb2x5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCAwLCB1cHBlckluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCBsb3dlckluZGV4LCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbiB0aGUgdHJpYW5nbGVcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcXG5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIGlmICh1cHBlckluZGV4IDwgbG93ZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbG93ZXJJbmRleDsgaiA8PSB1cHBlckluZGV4OyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3QgJiYgcG9seWdvbkNhblNlZTIocG9seSwgaSwgaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSBwb2x5Z29uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIGNsb3Nlc3RJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0SW5kZXggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksIGNsb3Nlc3RJbmRleCwgdi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwgMCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHYubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIDAsIGNsb3Nlc3RJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCBjbG9zZXN0SW5kZXgsIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XHJcbiAgICAgICAgICAgIGlmIChsb3dlclBvbHkubGVuZ3RoIDwgdXBwZXJQb2x5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSwgcmVzdWx0LCByZWZsZXhWZXJ0aWNlcywgc3RlaW5lclBvaW50cywgZGVsdGEsIG1heGxldmVsLCBsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHksIHJlc3VsdCwgcmVmbGV4VmVydGljZXMsIHN0ZWluZXJQb2ludHMsIGRlbHRhLCBtYXhsZXZlbCwgbGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSwgcmVzdWx0LCByZWZsZXhWZXJ0aWNlcywgc3RlaW5lclBvaW50cywgZGVsdGEsIG1heGxldmVsLCBsZXZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUNvbGxpbmVhclBvaW50c1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZWRnZXMgYXJlIGNvbGxpbmVhci4gVXNlIHplcm8gZm9yIGZpbmVzdCBwcmVjaXNpb24uXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMocG9seWdvbiwgcHJlY2lzaW9uKSB7XHJcbiAgICB2YXIgbnVtID0gMDtcclxuICAgIGZvciAodmFyIGkgPSBwb2x5Z29uLmxlbmd0aCAtIDE7IHBvbHlnb24ubGVuZ3RoID4gMyAmJiBpID49IDA7IC0taSkge1xyXG4gICAgICAgIGlmIChjb2xsaW5lYXIocG9seWdvbkF0KHBvbHlnb24sIGkgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpLCBwcmVjaXNpb24pKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGkgJSBwb2x5Z29uLmxlbmd0aCwgMSk7XHJcbiAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudW07XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBkdXBsaWNhdGUgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxyXG4gKiBAbWV0aG9kIHJlbW92ZUR1cGxpY2F0ZVBvaW50c1xyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gcG9pbnRzIGFyZSB0aGUgc2FtZS4gVXNlIHplcm8gZm9yIGJlc3QgcHJlY2lzaW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblJlbW92ZUR1cGxpY2F0ZVBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pIHtcclxuICAgIGZvciAodmFyIGkgPSBwb2x5Z29uLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XHJcbiAgICAgICAgdmFyIHBpID0gcG9seWdvbltpXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgLS1qKSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNfZXEocGksIHBvbHlnb25bal0sIHByZWNpc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvbHlnb24uc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBzY2FsYXJzIGFyZSBlcXVhbFxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZXFcclxuICogQHBhcmFtICB7TnVtYmVyfSBhXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBzY2FsYXJfZXEoYSwgYiwgcHJlY2lzaW9uKSB7XHJcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcclxuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gcHJlY2lzaW9uO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgcG9pbnRzX2VxXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvaW50c19lcShhLCBiLCBwcmVjaXNpb24pIHtcclxuICAgIHJldHVybiBzY2FsYXJfZXEoYVswXSwgYlswXSwgcHJlY2lzaW9uKSAmJiBzY2FsYXJfZXEoYVsxXSwgYlsxXSwgcHJlY2lzaW9uKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBkZWNvbXA6IHBvbHlnb25EZWNvbXAsXHJcbiAgICBxdWlja0RlY29tcDogcG9seWdvblF1aWNrRGVjb21wLFxyXG4gICAgaXNTaW1wbGU6IHBvbHlnb25Jc1NpbXBsZSxcclxuICAgIHJlbW92ZUNvbGxpbmVhclBvaW50czogcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyxcclxuICAgIHJlbW92ZUR1cGxpY2F0ZVBvaW50czogcG9seWdvblJlbW92ZUR1cGxpY2F0ZVBvaW50cyxcclxuICAgIG1ha2VDQ1c6IHBvbHlnb25NYWtlQ0NXXHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qXHJcbiAgICBQb2x5SyBsaWJyYXJ5XHJcbiAgICB1cmw6IGh0dHA6Ly9wb2x5ay5pdmFuay5uZXRcclxuICAgIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbmNlLlxyXG5cclxuICAgIENvcHlyaWdodCAoYykgMjAxMiBJdmFuIEt1Y2tpclxyXG5cclxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxyXG4gICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XHJcbiAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXHJcbiAgICBjb25kaXRpb25zOlxyXG5cclxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXHJcbiAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcclxuICAgIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxyXG4gICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXHJcbiAgICBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiovXHJcbnZhciBQb2x5SyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvbHlLKCkge1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICBJcyBQb2x5Z29uIHNlbGYtaW50ZXJzZWN0aW5nP1xyXG5cclxuICAgICAgICBPKG5eMilcclxuICAgICovXHJcbiAgICAvKlxyXG4gICAgSXNTaW1wbGUocClcclxuICAgIHtcclxuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xyXG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIGExID0gbmV3IHRoaXMuX1AoKSwgYTIgPSBuZXcgdGhpcy5fUCgpO1xyXG4gICAgICAgIHZhciBiMSA9IG5ldyB0aGlzLl9QKCksIGIyID0gbmV3IHRoaXMuX1AoKTtcclxuICAgICAgICB2YXIgYyA9IG5ldyB0aGlzLl9QKCk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcclxuICAgICAgICAgICAgYTEueSA9IHBbMippKzFdO1xyXG4gICAgICAgICAgICBpZihpPT1uLTEpICB7IGEyLnggPSBwWzAgICAgXTsgIGEyLnkgPSBwWzEgICAgXTsgfVxyXG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8bjsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhpLWopIDwgMikgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEgJiYgaT09MCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEueCA9IHBbMipqICBdO1xyXG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xyXG4gICAgICAgICAgICAgICAgaWYoaj09bi0xKSAgeyBiMi54ID0gcFswICAgIF07ICBiMi55ID0gcFsxICAgIF07IH1cclxuICAgICAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYjIueCA9IHBbMipqKzJdOyAgYjIueSA9IHBbMipqKzNdOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fR2V0TGluZUludGVyc2VjdGlvbihhMSxhMixiMSxiMixjKSAhPSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgSXNDb252ZXgocClcclxuICAgIHtcclxuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gNDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxyXG4gICAgICAgICAgICBpZighdGhpcy5fY29udmV4KHBbaV0sIHBbaSsxXSwgcFtpKzJdLCBwW2krM10sIHBbaSs0XSwgcFtpKzVdKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmKCF0aGlzLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmKCF0aGlzLl9jb252ZXgocFtsKzJdLCBwW2wrM10sIHBbMCAgXSwgcFsxICBdLCBwWzJdLCBwWzNdKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIFBvbHlLLnByb3RvdHlwZS5HZXRBcmVhID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICBpZiAocC5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMilcclxuICAgICAgICAgICAgc3VtICs9IChwW2kgKyAyXSAtIHBbaV0pICogKHBbaSArIDFdICsgcFtpICsgM10pO1xyXG4gICAgICAgIHN1bSArPSAocFswXSAtIHBbbF0pICogKHBbbCArIDFdICsgcFsxXSk7XHJcbiAgICAgICAgcmV0dXJuIC1zdW0gKiAwLjU7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEdldEFBQkIocClcclxuICAgIHtcclxuICAgICAgICB2YXIgbWlueCA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtaW55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcclxuICAgICAgICB2YXIgbWF4eSA9IC1taW55O1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWlueCA9IE1hdGgubWluKG1pbngsIHBbaSAgXSk7XHJcbiAgICAgICAgICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2kgIF0pO1xyXG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcclxuICAgICAgICAgICAgbWF4eSA9IE1hdGgubWF4KG1heHksIHBbaSsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLlRyaWFuZ3VsYXRlID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoID4+IDE7XHJcbiAgICAgICAgaWYgKG4gPCAzKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgdmFyIHRncyA9IFtdO1xyXG4gICAgICAgIHZhciBhdmwgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgYXZsLnB1c2goaSk7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBhbCA9IG47XHJcbiAgICAgICAgd2hpbGUgKGFsID4gMykge1xyXG4gICAgICAgICAgICB2YXIgaTAgPSBhdmxbKGkgKyAwKSAlIGFsXTtcclxuICAgICAgICAgICAgdmFyIGkxID0gYXZsWyhpICsgMSkgJSBhbF07XHJcbiAgICAgICAgICAgIHZhciBpMiA9IGF2bFsoaSArIDIpICUgYWxdO1xyXG4gICAgICAgICAgICB2YXIgYXggPSBwWzIgKiBpMF0sIGF5ID0gcFsyICogaTAgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyICogaTFdLCBieSA9IHBbMiAqIGkxICsgMV07XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHBbMiAqIGkyXSwgY3kgPSBwWzIgKiBpMiArIDFdO1xyXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xyXG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aSA9PSBpMCB8fCB2aSA9PSBpMSB8fCB2aSA9PSBpMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX1BvaW50SW5UcmlhbmdsZShwWzIgKiB2aV0sIHBbMiAqIHZpICsgMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhckZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZWFyRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwKTtcclxuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkxKTtcclxuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkyKTtcclxuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkgKyAxKSAlIGFsLCAxKTtcclxuICAgICAgICAgICAgICAgIGFsLS07XHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpKysgPiAzICogYWwpXHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxyXG4gICAgICAgIH1cclxuICAgICAgICB0Z3MucHVzaChhdmxbMF0pO1xyXG4gICAgICAgIHRncy5wdXNoKGF2bFsxXSk7XHJcbiAgICAgICAgdGdzLnB1c2goYXZsWzJdKTtcclxuICAgICAgICByZXR1cm4gdGdzO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDb250YWluc1BvaW50KHAsIHB4LCBweSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xyXG4gICAgICAgIHZhciBheCwgYXksIGJ4ID0gcFsyKm4tMl0tcHgsIGJ5ID0gcFsyKm4tMV0tcHk7XHJcbiAgICAgICAgdmFyIGRlcHRoID0gMDtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBheCA9IGJ4OyAgYXkgPSBieTtcclxuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xyXG4gICAgICAgICAgICBieSA9IHBbMippKzFdIC0gcHk7XHJcbiAgICAgICAgICAgIGlmKGF5PCAwICYmIGJ5PCAwKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxyXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcclxuICAgICAgICAgICAgaWYoYXg8IDAgJiYgYng8IDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XHJcbiAgICAgICAgICAgIGlmKGx4PjApIGRlcHRoKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xyXG4gICAgfVxyXG5cclxuICAgIFNsaWNlKHAsIGF4LCBheSwgYngsIGJ5KVxyXG4gICAge1xyXG4gICAgICAgIGlmKHRoaXMuQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IHRoaXMuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xyXG5cclxuICAgICAgICB2YXIgYSA9IG5ldyB0aGlzLl9QKGF4LCBheSk7XHJcbiAgICAgICAgdmFyIGIgPSBuZXcgdGhpcy5fUChieCwgYnkpO1xyXG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgdmFyIHBzID0gW107ICAgIC8vIHBvaW50c1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHAubGVuZ3RoOyBpKz0yKSBwcy5wdXNoKG5ldyB0aGlzLl9QKHBbaV0sIHBbaSsxXSkpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxwcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpc2MgPSBuZXcgdGhpcy5fUCgwLDApO1xyXG4gICAgICAgICAgICBpc2MgPSB0aGlzLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGEsIGIsIHBzW2ldLCBwc1soaSsxKSVwcy5sZW5ndGhdLCBpc2MpO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNjKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpc2MuZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcclxuICAgICAgICAgICAgICAgIHBzLnNwbGljZShpKzEsMCxpc2MpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHJldHVybiBbcC5zbGljZSgwKV07XHJcbiAgICAgICAgdmFyIGNvbXAodSx2KSB7cmV0dXJuIHRoaXMuX1AuZGlzdChhLHUpIC0gdGhpcy5fUC5kaXN0KGEsdik7IH1cclxuICAgICAgICBpc2NzLnNvcnQoY29tcCk7XHJcblxyXG4gICAgICAgIHZhciBwZ3MgPSBbXTtcclxuICAgICAgICB2YXIgZGlyID0gMDtcclxuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcclxuICAgICAgICAgICAgdmFyIGkxID0gaXNjc1sxXTtcclxuICAgICAgICAgICAgdmFyIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcclxuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcclxuICAgICAgICAgICAgdmFyIHNvbHZlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5fZmlyc3RXaXRoRmxhZyhwcywgaW5kMCkgPT0gaW5kMSkgc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpMCA9IGlzY3NbMV07XHJcbiAgICAgICAgICAgICAgICBpMSA9IGlzY3NbMF07XHJcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XHJcbiAgICAgICAgICAgICAgICBpbmQxID0gcHMuaW5kZXhPZihpMSk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNvbHZlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlyLS07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGduID0gdGhpcy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcclxuICAgICAgICAgICAgICAgIHBncy5wdXNoKHBnbik7XHJcbiAgICAgICAgICAgICAgICBwcyA9IHRoaXMuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XHJcbiAgICAgICAgICAgICAgICBpMC5mbGFnID0gaTEuZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaXNjcy5zcGxpY2UoMCwyKTtcclxuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgZGlyKys7IGlzY3MucmV2ZXJzZSgpOyB9XHJcbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwZyA9IHBnc1tpXTtcclxuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxwZy5sZW5ndGg7IGorKykgbnBnLnB1c2gocGdbal0ueCwgcGdbal0ueSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5wZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgUmF5Y2FzdChwLCB4LCB5LCBkeCwgZHksIGlzYylcclxuICAgIHtcclxuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcclxuICAgICAgICB2YXIgdHAgPSB0aGlzLl90cDtcclxuICAgICAgICB2YXIgYTEgPSB0cFswXSwgYTIgPSB0cFsxXSxcclxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XHJcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xyXG4gICAgICAgIGEyLnggPSB4K2R4OyBhMi55ID0geStkeTtcclxuXHJcbiAgICAgICAgaWYoaXNjPT1udWxsKSBpc2MgPSB7ZGlzdDowLCBlZGdlOjAsIG5vcm06e3g6MCwgeTowfSwgcmVmbDp7eDowLCB5OjB9fTtcclxuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XHJcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xyXG4gICAgICAgICAgICB2YXIgbmlzYyA9IHRoaXMuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xyXG4gICAgICAgICAgICBpZihuaXNjKSB0aGlzLl91cGRhdGVJU0MoZHgsIGR5LCBhMSwgYjEsIGIyLCBjLCBpLzIsIGlzYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XHJcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcclxuICAgICAgICB2YXIgbmlzYyA9IHRoaXMuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xyXG4gICAgICAgIGlmKG5pc2MpIHRoaXMuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XHJcblxyXG4gICAgICAgIHJldHVybiAoaXNjLmRpc3QgIT0gSW5maW5pdHkpID8gaXNjIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBDbG9zZXN0RWRnZShwLCB4LCB5LCBpc2MpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XHJcbiAgICAgICAgdmFyIHRwID0gdGhpcy5fdHA7XHJcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXHJcbiAgICAgICAgYjEgPSB0cFsyXSwgYjIgPSB0cFszXSwgYyA9IHRwWzRdO1xyXG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcclxuXHJcbiAgICAgICAgaWYoaXNjPT1udWxsKSBpc2MgPSB7ZGlzdDowLCBlZGdlOjAsIHBvaW50Ont4OjAsIHk6MH0sIG5vcm06e3g6MCwgeTowfX07XHJcbiAgICAgICAgaXNjLmRpc3QgPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xyXG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xyXG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBsPj4xLCBpc2MpO1xyXG5cclxuICAgICAgICB2YXIgaWRzdCA9IDEvaXNjLmRpc3Q7XHJcbiAgICAgICAgaXNjLm5vcm0ueCA9ICh4LWlzYy5wb2ludC54KSppZHN0O1xyXG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcclxuICAgICAgICByZXR1cm4gaXNjO1xyXG4gICAgfVxyXG5cclxuICAgIF9wb2ludExpbmVEaXN0KHAsIGEsIGIsIGVkZ2UsIGlzYylcclxuICAgIHtcclxuICAgICAgICB2YXIgeCA9IHAueCwgeSA9IHAueSwgeDEgPSBhLngsIHkxID0gYS55LCB4MiA9IGIueCwgeTIgPSBiLnk7XHJcblxyXG4gICAgICAgIHZhciBBID0geCAtIHgxO1xyXG4gICAgICAgIHZhciBCID0geSAtIHkxO1xyXG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcclxuICAgICAgICB2YXIgRCA9IHkyIC0geTE7XHJcblxyXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xyXG4gICAgICAgIHZhciBsZW5fc3EgPSBDICogQyArIEQgKiBEO1xyXG4gICAgICAgIHZhciBwYXJhbSA9IGRvdCAvIGxlbl9zcTtcclxuXHJcbiAgICAgICAgdmFyIHh4LCB5eTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XHJcbiAgICAgICAgICAgIHh4ID0geDE7XHJcbiAgICAgICAgICAgIHl5ID0geTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmFtID4gMSkge1xyXG4gICAgICAgICAgICB4eCA9IHgyO1xyXG4gICAgICAgICAgICB5eSA9IHkyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcclxuICAgICAgICAgICAgeXkgPSB5MSArIHBhcmFtICogRDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkeCA9IHggLSB4eDtcclxuICAgICAgICB2YXIgZHkgPSB5IC0geXk7XHJcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgaWYoZHN0PGlzYy5kaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XHJcbiAgICAgICAgICAgIGlzYy5lZGdlID0gZWRnZTtcclxuICAgICAgICAgICAgaXNjLnBvaW50LnggPSB4eDtcclxuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcclxuICAgIHtcclxuICAgICAgICB2YXIgbnJsID0gdGhpcy5fUC5kaXN0KGExLCBjKTtcclxuICAgICAgICBpZihucmw8aXNjLmRpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgaWJsID0gMS90aGlzLl9QLmRpc3QoYjEsIGIyKTtcclxuICAgICAgICAgICAgdmFyIG54ID0gLShiMi55LWIxLnkpKmlibDtcclxuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcclxuICAgICAgICAgICAgdmFyIGRkb3QgPSAyKihkeCpueCtkeSpueSk7XHJcbiAgICAgICAgICAgIGlzYy5kaXN0ID0gbnJsO1xyXG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XHJcbiAgICAgICAgICAgIGlzYy5ub3JtLnkgPSBueTtcclxuICAgICAgICAgICAgaXNjLnJlZmwueCA9IC1kZG90Km54K2R4O1xyXG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XHJcbiAgICAgICAgICAgIGlzYy5lZGdlID0gZWRnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2dldFBvaW50cyhwcywgaW5kMCwgaW5kMSlcclxuICAgIHtcclxuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbnBzID0gW107XHJcbiAgICAgICAgaWYoaW5kMTxpbmQwKSBpbmQxICs9IG47XHJcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xyXG4gICAgICAgIHJldHVybiBucHM7XHJcbiAgICB9XHJcblxyXG4gICAgX2ZpcnN0V2l0aEZsYWcocHMsIGluZClcclxuICAgIHtcclxuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSh0cnVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5kID0gKGluZCsxKSVuO1xyXG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIFBvbHlLLnByb3RvdHlwZS5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24gKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xyXG4gICAgICAgIHZhciB2MHggPSBjeCAtIGF4O1xyXG4gICAgICAgIHZhciB2MHkgPSBjeSAtIGF5O1xyXG4gICAgICAgIHZhciB2MXggPSBieCAtIGF4O1xyXG4gICAgICAgIHZhciB2MXkgPSBieSAtIGF5O1xyXG4gICAgICAgIHZhciB2MnggPSBweCAtIGF4O1xyXG4gICAgICAgIHZhciB2MnkgPSBweSAtIGF5O1xyXG4gICAgICAgIHZhciBkb3QwMCA9IHYweCAqIHYweCArIHYweSAqIHYweTtcclxuICAgICAgICB2YXIgZG90MDEgPSB2MHggKiB2MXggKyB2MHkgKiB2MXk7XHJcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4ICogdjJ4ICsgdjB5ICogdjJ5O1xyXG4gICAgICAgIHZhciBkb3QxMSA9IHYxeCAqIHYxeCArIHYxeSAqIHYxeTtcclxuICAgICAgICB2YXIgZG90MTIgPSB2MXggKiB2MnggKyB2MXkgKiB2Mnk7XHJcbiAgICAgICAgdmFyIGludkRlbm9tID0gMSAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XHJcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XHJcbiAgICAgICAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgaW4gdHJpYW5nbGVcclxuICAgICAgICByZXR1cm4gKHUgPj0gMCkgJiYgKHYgPj0gMCkgJiYgKHUgKyB2IDwgMSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIF9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBkYXggPSAoYTEueC1hMi54KSwgZGJ4ID0gKGIxLngtYjIueCk7XHJcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcclxuXHJcbiAgICAgICAgdmFyIERlbiA9IGRheCpkYnkgLSBkYXkqZGJ4O1xyXG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxyXG5cclxuICAgICAgICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcclxuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcclxuXHJcbiAgICAgICAgdmFyIEkgPSBjO1xyXG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XHJcbiAgICAgICAgSS54ID0gKCBBKmRieCAtIGRheCpCICkgKiBpRGVuO1xyXG4gICAgICAgIEkueSA9ICggQSpkYnkgLSBkYXkqQiApICogaURlbjtcclxuXHJcbiAgICAgICAgaWYoIXRoaXMuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmKChkYXg+MCAmJiBJLng+YTEueCkgfHwgKGRheDwwICYmIEkueDxhMS54KSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIEk7XHJcbiAgICB9XHJcblxyXG4gICAgX0dldExpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcclxuICAgICAgICB2YXIgZGF5ID0gKGExLnktYTIueSksIGRieSA9IChiMS55LWIyLnkpO1xyXG5cclxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XHJcbiAgICAgICAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbDsgIC8vIHBhcmFsbGVsXHJcblxyXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xyXG4gICAgICAgIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xyXG5cclxuICAgICAgICB2YXIgSSA9IGM7XHJcbiAgICAgICAgSS54ID0gKCBBKmRieCAtIGRheCpCICkgLyBEZW47XHJcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgLyBEZW47XHJcblxyXG4gICAgICAgIGlmKHRoaXMuX0luUmVjdChJLCBhMSwgYTIpICYmIHRoaXMuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBfSW5SZWN0KGEsIGIsIGMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgIChiLnggPT0gYy54KSByZXR1cm4gKGEueT49TWF0aC5taW4oYi55LCBjLnkpICYmIGEueTw9TWF0aC5tYXgoYi55LCBjLnkpKTtcclxuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xyXG5cclxuICAgICAgICBpZihhLnggPj0gTWF0aC5taW4oYi54LCBjLngpICYmIGEueCA8PSBNYXRoLm1heChiLngsIGMueClcclxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIFBvbHlLLnByb3RvdHlwZS5fY29udmV4ID0gZnVuY3Rpb24gKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcclxuICAgICAgICByZXR1cm4gKGF5IC0gYnkpICogKGN4IC0gYngpICsgKGJ4IC0gYXgpICogKGN5IC0gYnkpID49IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvbHlLO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgUG9seUsoKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXHJcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcclxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcclxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXHJcbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xyXG4vKipcclxuICogVGhlIHZlYzIgb2JqZWN0IGZyb20gZ2xNYXRyaXgsIHdpdGggc29tZSBleHRlbnNpb25zIGFuZCBzb21lIHJlbW92ZWQgbWV0aG9kcy4gU2VlIGh0dHA6Ly9nbG1hdHJpeC5uZXQuXHJcbiAqIEBjbGFzcyB2ZWMyXHJcbiAqL1xyXG52YXIgVmVjMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZlYzIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSBjcm9zcyBwcm9kdWN0IGFuZCBvbmx5IHJldHVybiB0aGUgeiBjb21wb25lbnRcclxuICAgICAqIEBtZXRob2QgY3Jvc3NMZW5ndGhcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jcm9zc0xlbmd0aCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxyXG4gICAgICogQG1ldGhvZCBjcm9zc1ZaXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdmVjXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY3Jvc3NWWiA9IGZ1bmN0aW9uIChvdXQsIHZlYywgemNvbXApIHtcclxuICAgICAgICB0aGlzLnJvdGF0ZShvdXQsIHZlYywgLU1hdGguUEkgLyAyKTsgLy8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXHJcbiAgICAgICAgdGhpcy5zY2FsZShvdXQsIG91dCwgemNvbXApOyAvLyBTY2FsZSB3aXRoIHpcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcclxuICAgICAqIEBtZXRob2QgY3Jvc3NaVlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHZlY1xyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNyb3NzWlYgPSBmdW5jdGlvbiAob3V0LCB6Y29tcCwgdmVjKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGUob3V0LCB2ZWMsIE1hdGguUEkgLyAyKTsgLy8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXHJcbiAgICAgICAgdGhpcy5zY2FsZShvdXQsIG91dCwgemNvbXApOyAvLyBTY2FsZSB3aXRoIHpcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIGEgdmVjdG9yIGJ5IGFuIGFuZ2xlXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBhbmdsZSkge1xyXG4gICAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSwgcyA9IE1hdGguc2luKGFuZ2xlKSwgeCA9IGFbMF0sIHkgPSBhWzFdO1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBjICogeCAtIHMgKiB5O1xyXG4gICAgICAgICAgICBvdXRbMV0gPSBzICogeCArIGMgKiB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0WzBdID0gYVswXTtcclxuICAgICAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSBhIHZlY3RvciA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxyXG4gICAgICogQG1ldGhvZCByb3RhdGU5MGN3XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnJvdGF0ZTkwY3cgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdO1xyXG4gICAgICAgIHZhciB5ID0gYVsxXTtcclxuICAgICAgICBvdXRbMF0gPSB5O1xyXG4gICAgICAgIG91dFsxXSA9IC14O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBsb2NhbCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKC1mcmFtZUFuZ2xlKSwgcyA9IE1hdGguc2luKC1mcmFtZUFuZ2xlKSwgeCA9IHdvcmxkUG9pbnRbMF0gLSBmcmFtZVBvc2l0aW9uWzBdLCB5ID0gd29ybGRQb2ludFsxXSAtIGZyYW1lUG9zaXRpb25bMV07XHJcbiAgICAgICAgb3V0WzBdID0gYyAqIHggLSBzICogeTtcclxuICAgICAgICBvdXRbMV0gPSBzICogeCArIGMgKiB5O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBnbG9iYWwgZnJhbWUuXHJcbiAgICAgKiBAbWV0aG9kIHRvR2xvYmFsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnRvR2xvYmFsRnJhbWUgPSBmdW5jdGlvbiAob3V0LCBsb2NhbFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhmcmFtZUFuZ2xlKSwgcyA9IE1hdGguc2luKGZyYW1lQW5nbGUpLCB4ID0gbG9jYWxQb2ludFswXSwgeSA9IGxvY2FsUG9pbnRbMV0sIGFkZFggPSBmcmFtZVBvc2l0aW9uWzBdLCBhZGRZID0gZnJhbWVQb3NpdGlvblsxXTtcclxuICAgICAgICBvdXRbMF0gPSBjICogeCAtIHMgKiB5ICsgYWRkWDtcclxuICAgICAgICBvdXRbMV0gPSBzICogeCArIGMgKiB5ICsgYWRkWTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIHZlY3RvciB0byBsb2NhbCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gd29ybGRWZWN0b3JcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkVmVjdG9yLCBmcmFtZUFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcygtZnJhbWVBbmdsZSksIHMgPSBNYXRoLnNpbigtZnJhbWVBbmdsZSksIHggPSB3b3JsZFZlY3RvclswXSwgeSA9IHdvcmxkVmVjdG9yWzFdO1xyXG4gICAgICAgIG91dFswXSA9IGMgKiB4IC0gcyAqIHk7XHJcbiAgICAgICAgb3V0WzFdID0gcyAqIHggKyBjICogeTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB2ZWN0b3IgdG8gZ2xvYmFsIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB2ZWN0b3JUb0dsb2JhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3JcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxyXG4gICAgICovXHJcbiAgICAvL3ZlY3RvclRvR2xvYmFsRnJhbWUgPSB2ZWMyLnJvdGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBjZW50cm9pZCBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdmVjdG9ycyBhLGIsYy4gU2VlIGh0dHA6Ly9lYXN5Y2FsY3VsYXRpb24uY29tL2FuYWx5dGljYWwvbGVhcm4tY2VudHJvaWQucGhwXHJcbiAgICAgKiBAbWV0aG9kIGNlbnRyb2lkXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGJcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAgICAgKiBAcmV0dXJuICB7QXJyYXl9IFRoZSBcIm91dFwiIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy5hZGQob3V0LCBhLCBiKTtcclxuICAgICAgICB0aGlzLmFkZChvdXQsIG91dCwgYyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZShvdXQsIG91dCwgMSAvIDMpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgb3V0WzBdID0gMDtcclxuICAgICAgICBvdXRbMV0gPSAwO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgY2xvbmVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgZnJvbVZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIG91dFswXSA9IHg7XHJcbiAgICAgICAgb3V0WzFdID0geTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBjb3B5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvdXQsIHgsIHkpIHtcclxuICAgICAgICBvdXRbMF0gPSB4O1xyXG4gICAgICAgIG91dFsxXSA9IHk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBhZGRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzdWJ0cmFjdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbGllcyB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIG11bHRpcGx5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgZGl2aWRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgc2NhbGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdICogYjtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdICogYjtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBkaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLCB5ID0gYlsxXSAtIGFbMV07XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzcXVhcmVkRGlzdGFuY2VcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIHggPSBiWzBdIC0gYVswXSwgeSA9IGJbMV0gLSBhWzFdO1xyXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBsZW5ndGhcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgc3F1YXJlZExlbmd0aFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXTtcclxuICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIG5lZ2F0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xyXG4gICAgICAgIG91dFswXSA9IC1hWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IC1hWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemUgYSB2ZWMyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIG5vcm1hbGl6ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKG91dCwgYSkge1xyXG4gICAgICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV07XHJcbiAgICAgICAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XHJcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cclxuICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBkb3RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgc3RyXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHRocm93IFwidmVjMi5zdHIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgdHlwZXNjcmlwdCB2ZXJzaW9uIG9mIHAyLlwiO1xyXG4gICAgICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTGluZWFybHkgaW50ZXJwb2xhdGUvbWl4IHR3byB2ZWN0b3JzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBsZXJwXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgRmlyc3QgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIFNlY29uZCB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IExlcnAgZmFjdG9yXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcclxuICAgICAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XHJcbiAgICAgICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlZmxlY3QgYSB2ZWN0b3IgYWxvbmcgYSBub3JtYWwuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHJlZmxlY3RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub3JtYWxcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uIChvdXQsIHZlY3Rvciwgbm9ybWFsKSB7XHJcbiAgICAgICAgdmFyIGRvdCA9IHZlY3RvclswXSAqIG5vcm1hbFswXSArIHZlY3RvclsxXSAqIG5vcm1hbFsxXTtcclxuICAgICAgICBvdXRbMF0gPSB2ZWN0b3JbMF0gLSAyICogbm9ybWFsWzBdICogZG90O1xyXG4gICAgICAgIG91dFsxXSA9IHZlY3RvclsxXSAtIDIgKiBub3JtYWxbMV0gKiBkb3Q7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGludGVyc2VjdGlvbiBwb2ludCBiZXR3ZWVuIHR3byBsaW5lIHNlZ21lbnRzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBnZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDJcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwM1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJzZWN0aW9uLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHAwLCBwMSwgcDIsIHAzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKHAwLCBwMSwgcDIsIHAzKTtcclxuICAgICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0WzBdID0gcDBbMF0gKyAodCAqIChwMVswXSAtIHAwWzBdKSk7XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHAwWzFdICsgKHQgKiAocDFbMV0gLSBwMFsxXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGludGVyc2VjdGlvbiBmcmFjdGlvbiBiZXR3ZWVuIHR3byBsaW5lIHNlZ21lbnRzLiBJZiBzdWNjZXNzZnVsLCB0aGUgaW50ZXJzZWN0aW9uIGlzIGF0IHAwICsgdCAqIChwMSAtIHAwKVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBnZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJzZWN0aW9uLCBvdGhlcndpc2UgLTEuXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzKSB7XHJcbiAgICAgICAgdmFyIHMxX3ggPSBwMVswXSAtIHAwWzBdO1xyXG4gICAgICAgIHZhciBzMV95ID0gcDFbMV0gLSBwMFsxXTtcclxuICAgICAgICB2YXIgczJfeCA9IHAzWzBdIC0gcDJbMF07XHJcbiAgICAgICAgdmFyIHMyX3kgPSBwM1sxXSAtIHAyWzFdO1xyXG4gICAgICAgIHZhciBzLCB0O1xyXG4gICAgICAgIHMgPSAoLXMxX3kgKiAocDBbMF0gLSBwMlswXSkgKyBzMV94ICogKHAwWzFdIC0gcDJbMV0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XHJcbiAgICAgICAgdCA9IChzMl94ICogKHAwWzFdIC0gcDJbMV0pIC0gczJfeSAqIChwMFswXSAtIHAyWzBdKSkgLyAoLXMyX3ggKiBzMV95ICsgczFfeCAqIHMyX3kpO1xyXG4gICAgICAgIGlmIChzID49IDAgJiYgcyA8PSAxICYmIHQgPj0gMCAmJiB0IDw9IDEpIHsgLy8gQ29sbGlzaW9uIGRldGVjdGVkXHJcbiAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7IC8vIE5vIGNvbGxpc2lvblxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBWZWMyO1xyXG59KCkpO1xyXG52YXIgdmVjMiA9IG5ldyBWZWMyKCk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZlYzI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBhZGQgPSB2ZWMyXzEuZGVmYXVsdC5hZGQsIHN1YiA9IHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0LCB2ZWMyY3JlYXRlID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlO1xyXG52YXIgYWFiYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vYWFiYlwiKSk7XHJcbnZhciBwb2x5X2RlY29tcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3BvbHktZGVjb21wXCIpKTtcclxudmFyIENvbnZleF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29udmV4XCIpKTtcclxudmFyIHJheV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vcmF5XCIpKTtcclxudmFyIHJheWNhc3RfcmVzdWx0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9yYXljYXN0LXJlc3VsdFwiKSk7XHJcbnZhciBldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2V2ZW50cy9ldmVudC1lbWl0dGVyXCIpKTtcclxuLy9kZWNvbXAgPSByZXF1aXJlKCdwb2x5LWRlY29tcCcpXHJcbnZhciBpbnRlZ3JhdGVfZmhNaW52ID0gdmVjMmNyZWF0ZSgpO1xyXG52YXIgaW50ZWdyYXRlX3ZlbG9kdCA9IHZlYzJjcmVhdGUoKTtcclxudmFyIF90bXAgPSB2ZWMyY3JlYXRlKCk7XHJcbnZhciBfaWRDb3VudGVyID0gMDtcclxudmFyIEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQm9keSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQSByaWdpZCBib2R5LiBIYXMgZ290IGEgY2VudGVyIG9mIG1hc3MsIHBvc2l0aW9uLCB2ZWxvY2l0eSBhbmQgYSBudW1iZXIgb2ZcclxuICAgICAqIHNoYXBlcyB0aGF0IGFyZSB1c2VkIGZvciBjb2xsaXNpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBCb2R5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwPXRydWVdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGU9MF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjFdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhckZvcmNlPTBdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5PTBdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2NkSXRlcmF0aW9ucz0xMF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZD0tMV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29sbGlzaW9uUmVzcG9uc2VdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGFtcGluZz0wLjFdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpeGVkUm90YXRpb249ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpeGVkWD1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml4ZWRZPWZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZm9yY2VdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ3Jhdml0eVNjYWxlPTFdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWFzcz0wXSBBIG51bWJlciA+PSAwLiBJZiB6ZXJvLCB0aGUgLnR5cGUgd2lsbCBiZSBzZXQgdG8gQm9keS5TVEFUSUMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb3NpdGlvbl1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGVlcFNwZWVkTGltaXRdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXRdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudHlwZV0gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMudmVsb2NpdHldXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIGEgdHlwaWNhbCBkeW5hbWljIGJvZHlcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgbWFzczogMSwgLy8gbm9uLXplcm8gbWFzcyB3aWxsIHNldCB0eXBlIHRvIEJvZHkuRFlOQU1JQ1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzAsIDVdLFxyXG4gICAgICogICAgICAgICBhbmdsZTogMCxcclxuICAgICAqICAgICAgICAgdmVsb2NpdHk6IFswLCAwXSxcclxuICAgICAqICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCBhIGNpcmN1bGFyIHNoYXBlIHRvIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMC41IH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgdGhlIGJvZHkgdG8gdGhlIHdvcmxkXHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSBzdGF0aWMgcGxhbmUgYm9keVxyXG4gICAgICogICAgIHZhciBwbGFuZUJvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgKiAgICAgICAgIG1hc3M6IDAsIC8vIHplcm8gbWFzcyB3aWxsIHNldCB0eXBlIHRvIEJvZHkuU1RBVElDXHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgcGxhbmVTaGFwZSA9IG5ldyBQbGFuZSgpO1xyXG4gICAgICogICAgIHBsYW5lQm9keS5hZGRTaGFwZShwbGFuZVNoYXBlKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KHBsYW5lQm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIGEgbW92aW5nIGtpbmVtYXRpYyBib3ggYm9keVxyXG4gICAgICogICAgIHZhciBwbGF0Zm9ybUJvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgKiAgICAgICAgIHR5cGU6IEJvZHkuS0lORU1BVElDLFxyXG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzAsIDNdLFxyXG4gICAgICogICAgICAgICB2ZWxvY2l0eTogWzEsIDBdXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIGJveFNoYXBlID0gbmV3IEJveCh7IHdpZHRoOiAyLCBoZWlnaHQ6IDAuNSB9KTtcclxuICAgICAqICAgICBwbGF0Zm9ybUJvZHkuYWRkU2hhcGUoYm94U2hhcGUpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkocGxhdGZvcm1Cb2R5KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQm9keShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcztcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBib2R5IGlkZW50aWZpZXIuIFJlYWQgb25seSFcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaWQgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgYm9keSBpbiB0aGUgV29ybGQgLmJvZGllcyBhcnJheS4gSXMgc2V0IHRvIC0xIGlmIHRoZSBib2R5IGlzbid0IGFkZGVkIHRvIGEgV29ybGQuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGluZGV4XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdvcmxkIHRoYXQgdGhpcyBib2R5IGlzIGFkZGVkIHRvIChyZWFkIG9ubHkpLiBUaGlzIHByb3BlcnR5IGlzIHNldCB0byBOVUxMIGlmIHRoZSBib2R5IGlzIG5vdCBhZGRlZCB0byBhbnkgd29ybGQuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHdvcmxkXHJcbiAgICAgICAgICogQHR5cGUge1dvcmxkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLndvcmxkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGVzIG9mIHRoZSBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zaGFwZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFzcyBvZiB0aGUgYm9keS4gSWYgeW91IGNoYW5nZSB0aGlzIG51bWJlciwgeW91IHNob3VsZCBjYWxsIHt7I2Nyb3NzTGluayBcIkJvZHkvdXBkYXRlTWFzc1Byb3BlcnRpZXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1hc3NcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgYm9keS5tYXNzID0gMTtcclxuICAgICAgICAgKiAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1hc3MgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnZlcnNlIG1hc3Mgb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaW52TWFzcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluZXJ0aWEgb2YgdGhlIGJvZHkgYXJvdW5kIHRoZSBaIGF4aXMuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGluZXJ0aWFcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmluZXJ0aWEgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnZlcnNlIGluZXJ0aWEgb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGludkluZXJ0aWFcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmludkluZXJ0aWEgPSAwO1xyXG4gICAgICAgIF90aGlzLmludk1hc3NTb2x2ZSA9IDA7XHJcbiAgICAgICAgX3RoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZpeGVkUm90YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEZpeCByb3RhdGlvbiBkdXJpbmcgcnVudGltZVxyXG4gICAgICAgICAqICAgICBib2R5LmZpeGVkUm90YXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZml4ZWRSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSBib2R5IG1vdmVtZW50IGFsb25nIHRoZSBYIGF4aXMuIFRoZSBib2R5IHdpbGwgc3RpbGwgYmUgYWJsZSB0byBtb3ZlIGFsb25nIFkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEZpeCBYIG1vdmVtZW50IG9uIGJvZHkgY3JlYXRpb25cclxuICAgICAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEsIGZpeGVkWDogdHJ1ZSB9KTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEZpeCBYIG1vdmVtZW50IGR1cmluZyBydW50aW1lXHJcbiAgICAgICAgICogICAgIGJvZHkuZml4ZWRYID0gdHJ1ZTtcclxuICAgICAgICAgKiAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmZpeGVkWCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgYm9keSBtb3ZlbWVudCBhbG9uZyB0aGUgWSBheGlzLiBUaGUgYm9keSB3aWxsIHN0aWxsIGJlIGFibGUgdG8gbW92ZSBhbG9uZyBYLiBTZWUgLmZpeGVkWFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZml4ZWRZXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZml4ZWRZID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5ndWxhciBjb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyBsYXN0IHN0ZXAuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHdsYW1iZGFcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9IC8vIFRoaXMgd2FzIGFycmF5IGJlZm9yZSB0aGUgcG9ydCwgYnV0IGh0ZSBhc3NpZ25tZW50IHdhcyBhbHdheXMgMC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy53bGFtYmRhID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW5nbGUgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFuZ2xlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAvLyBUaGUgYW5nbGUgcHJvcGVydHkgaXMgbm90IG5vcm1hbGl6ZWQgdG8gdGhlIGludGVydmFsIDAgdG8gMipwaSwgaXQgY2FuIGJlIGFueSB2YWx1ZS5cclxuICAgICAgICAgKiAgICAgLy8gSWYgeW91IG5lZWQgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDIqcGksIHVzZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBpdC5cclxuICAgICAgICAgKiAgICAgZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUoYW5nbGUpe1xyXG4gICAgICAgICAqICAgICAgICAgYW5nbGUgPSBhbmdsZSAlICgyKk1hdGguUEkpO1xyXG4gICAgICAgICAqICAgICAgICAgaWYoYW5nbGUgPCAwKXtcclxuICAgICAgICAgKiAgICAgICAgICAgICBhbmdsZSArPSAoMipNYXRoLlBJKTtcclxuICAgICAgICAgKiAgICAgICAgIH1cclxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgYW5nbGUgb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHByZXZpb3VzQW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnByZXZpb3VzQW5nbGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgYW5nbGUgb2YgdGhlIGJvZHkuIFVzZSB0aGlzIGZvciByZW5kZXJpbmcuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZEFuZ2xlXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRBbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvZm9yY2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFuZ3VsYXJGb3JjZVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYW5ndWxhckZvcmNlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW5ndWxhciBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5ndWxhckRhbXBpbmdcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJEYW1waW5nID0gMC4xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIG1vdGlvbiB0aGlzIGJvZHkgaGFzLiBTaG91bGQgYmUgb25lIG9mOiB7eyNjcm9zc0xpbmsgXCJCb2R5L1NUQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LlNUQVRJQ3t7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L0RZTkFNSUM6cHJvcGVydHlcIn19Qm9keS5EWU5BTUlDe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvS0lORU1BVElDOnByb3BlcnR5XCJ9fUJvZHkuS0lORU1BVElDe3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqIFN0YXRpYyBib2RpZXMgZG8gbm90IG1vdmUsIGFuZCB0aGV5IGRvIG5vdCByZXNwb25kIHRvIGZvcmNlcyBvciBjb2xsaXNpb24uXHJcbiAgICAgICAgICogKiBEeW5hbWljIGJvZGllcyBib2R5IGNhbiBtb3ZlIGFuZCByZXNwb25kIHRvIGNvbGxpc2lvbnMgYW5kIGZvcmNlcy5cclxuICAgICAgICAgKiAqIEtpbmVtYXRpYyBib2RpZXMgb25seSBtb3ZlcyBhY2NvcmRpbmcgdG8gaXRzIC52ZWxvY2l0eSwgYW5kIGRvZXMgbm90IHJlc3BvbmQgdG8gY29sbGlzaW9ucyBvciBmb3JjZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEJvZGllcyBhcmUgc3RhdGljIGJ5IGRlZmF1bHQuIFN0YXRpYyBib2RpZXMgd2lsbCBuZXZlciBtb3ZlLlxyXG4gICAgICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudHlwZSA9PSBCb2R5LlNUQVRJQyk7IC8vIHRydWVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEJ5IHNldHRpbmcgdGhlIG1hc3Mgb2YgYSBib2R5IHRvIGEgbm9uemVybyBudW1iZXIsIHRoZSBib2R5XHJcbiAgICAgICAgICogICAgIC8vIHdpbGwgYmVjb21lIGR5bmFtaWMgYW5kIHdpbGwgbW92ZSBhbmQgaW50ZXJhY3Qgd2l0aCBvdGhlciBib2RpZXMuXHJcbiAgICAgICAgICogICAgIHZhciBkeW5hbWljQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAgICAgKiAgICAgICAgIG1hc3MgOiAxXHJcbiAgICAgICAgICogICAgIH0pO1xyXG4gICAgICAgICAqICAgICBjb25zb2xlLmxvZyhkeW5hbWljQm9keS50eXBlID09IEJvZHkuRFlOQU1JQyk7IC8vIHRydWVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgd2lsbCBvbmx5IG1vdmUgaWYgeW91IGNoYW5nZSB0aGVpciB2ZWxvY2l0eS5cclxuICAgICAgICAgKiAgICAgdmFyIGtpbmVtYXRpY0JvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgICAgICogICAgICAgICB0eXBlOiBCb2R5LktJTkVNQVRJQyAvLyBUeXBlIGNhbiBiZSBzZXQgdmlhIHRoZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMuIFVwZGF0ZSB3aXRoIHt7I2Nyb3NzTGluayBcIkJvZHkvdXBkYXRlQm91bmRpbmdSYWRpdXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyBpZiB0aGUgQUFCQiBuZWVkcyB1cGRhdGUuIFVwZGF0ZSBpdCB3aXRoIHt7I2Nyb3NzTGluayBcIkJvZHkvdXBkYXRlQUFCQjptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBzZWUgdXBkYXRlQUFCQlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRm9yY2UgdXBkYXRlIHRoZSBBQUJCXHJcbiAgICAgICAgICogICAgIGJvZHkuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgKiAgICAgYm9keS51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYWFiYk5lZWRzVXBkYXRlKTsgLy8gZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBib2R5IHdpbGwgYXV0b21hdGljYWxseSBmYWxsIHRvIHNsZWVwLiBOb3RlIHRoYXQgeW91IG5lZWQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJXb3JsZFwifX17ey9jcm9zc0xpbmt9fSBiZWZvcmUgYW55dGhpbmcgd2lsbCBoYXBwZW4uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYWxsb3dTbGVlcCA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25lIG9mIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQWTpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQWXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQSU5HOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBib2R5IGlzIGluaXRpYWxseSBCb2R5LkFXQUtFLiBJZiBpdHMgdmVsb2NpdHkgbm9ybSBpcyBiZWxvdyAuc2xlZXBTcGVlZExpbWl0LCB0aGUgc2xlZXBTdGF0ZSB3aWxsIGJlY29tZSBCb2R5LlNMRUVQWS4gSWYgdGhlIGJvZHkgY29udGludWVzIHRvIGJlIEJvZHkuU0xFRVBZIGZvciAuc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgd2lsbCBmYWxsIGFzbGVlcCAoQm9keS5TTEVFUFkpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IEJvZHkuQVdBS0VcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuMlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwU3BlZWRMaW1pdCA9IDAuMjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcHkgZm9yIHRoaXMgc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBzbGVlcGluZy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBUaW1lTGltaXRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zbGVlcFRpbWVMaW1pdCA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3Jhdml0eSBzY2FsaW5nIGZhY3Rvci4gSWYgeW91IHdhbnQgdGhlIGJvZHkgdG8gaWdub3JlIGdyYXZpdHksIHNldCB0aGlzIHRvIHplcm8uIElmIHlvdSB3YW50IHRvIHJldmVyc2UgZ3Jhdml0eSwgc2V0IGl0IHRvIC0xLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBncmF2aXR5U2NhbGVcclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZ3Jhdml0eVNjYWxlID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGJvZHkgd2lsbCBtb3ZlIHRocm91Z2ggb3RoZXIgYm9kaWVzLCBidXQgaXQgd2lsbCBzdGlsbCB0cmlnZ2VyIGNvbnRhY3QgZXZlbnRzLCBldGMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgbG9uZyB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcGluZy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRsZVRpbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pZGxlVGltZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgdGltZSB3aGVuIHRoZSBib2R5IHdlbnQgdG8gU0xFRVBZIHN0YXRlLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lTGFzdFNsZWVweVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBib2R5IHNwZWVkIGV4Y2VlZHMgdGhpcyB0aHJlc2hvbGQsIENDRCAoY29udGludW91cyBjb2xsaXNpb24gZGV0ZWN0aW9uKSB3aWxsIGJlIGVuYWJsZWQuIFNldCBpdCB0byBhIG5lZ2F0aXZlIG51bWJlciB0byBkaXNhYmxlIENDRCBjb21wbGV0ZWx5IGZvciB0aGlzIGJvZHkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNjZFNwZWVkVGhyZXNob2xkXHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciB0aGUgdGltZSBvZiBpbXBhY3QgZHVyaW5nIENDRC4gQSBsYXJnZXIgbnVtYmVyIHdpbGwgYXNzdXJlIHRoYXQgdGhlcmUncyBhIHNtYWxsIHBlbmV0cmF0aW9uIG9uIENDRCBjb2xsaXNpb24sIGJ1dCBhIHNtYWxsIG51bWJlciB3aWxsIGdpdmUgbW9yZSBwZXJmb3JtYW5jZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkSXRlcmF0aW9uc1xyXG4gICAgICAgICAqIEBkZWZhdWx0IDEwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY2NkSXRlcmF0aW9ucyA9IDEwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpc2xhbmRJZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmlzbGFuZElkID0gLTE7XHJcbiAgICAgICAgX3RoaXMuY29uY2F2ZVBhdGggPSBbXTtcclxuICAgICAgICAvLyBTaG91bGQgYmUgcHJpdmF0ZSwgYnV0IHVzZWQgYnkgd29ybGQuXHJcbiAgICAgICAgX3RoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fc2hhcGVBQUJCID0gbmV3IGFhYmJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgX3RoaXMuaWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICsrX2lkQ291bnRlcjtcclxuICAgICAgICBfdGhpcy5tYXNzID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgX3RoaXMuZml4ZWRSb3RhdGlvbiA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcclxuICAgICAgICBfdGhpcy5maXhlZFggPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZml4ZWRYKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcclxuICAgICAgICBfdGhpcy5maXhlZFkgPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZml4ZWRZKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZTtcclxuICAgICAgICBfdGhpcy5tYXNzTXVsdGlwbGllciA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24pID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5wb3NpdGlvbikgOiB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jbG9uZShfdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgX3RoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNsb25lKF90aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBfdGhpcy52ZWxvY2l0eSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmVsb2NpdHkpID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy52ZWxvY2l0eSkgOiB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMudmxhbWJkYSA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5hbmdsZSA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmdsZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMDtcclxuICAgICAgICBfdGhpcy5wcmV2aW91c0FuZ2xlID0gX3RoaXMuYW5nbGU7XHJcbiAgICAgICAgX3RoaXMuaW50ZXJwb2xhdGVkQW5nbGUgPSBfdGhpcy5hbmdsZTtcclxuICAgICAgICBfdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAwO1xyXG4gICAgICAgIF90aGlzLmZvcmNlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZSkgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmZvcmNlKSA6IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5hbmd1bGFyRm9yY2UgPSAoX2ggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5ndWxhckZvcmNlKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwO1xyXG4gICAgICAgIF90aGlzLmRhbXBpbmcgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGFtcGluZykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogMC4xO1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJEYW1waW5nID0gKF9rID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAwLjE7XHJcbiAgICAgICAgX3RoaXMuc2xlZXBUaW1lTGltaXQgPSAoX2wgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IDE7XHJcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXNzKSkge1xyXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gQm9keS5EWU5BTUlDO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5hYWJiID0gbmV3IGFhYmJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgX3RoaXMuYWxsb3dTbGVlcCA9IChfbSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd1NsZWVwKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiB0cnVlO1xyXG4gICAgICAgIF90aGlzLnNsZWVwU3BlZWRMaW1pdCA9IChfbyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zbGVlcFNwZWVkTGltaXQpICE9PSBudWxsICYmIF9vICE9PSB2b2lkIDAgPyBfbyA6IDAuMjtcclxuICAgICAgICBfdGhpcy5ncmF2aXR5U2NhbGUgPSAoX3AgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ3Jhdml0eVNjYWxlKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiAxO1xyXG4gICAgICAgIF90aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gKF9xID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfcSAhPT0gdm9pZCAwID8gX3EgOiB0cnVlO1xyXG4gICAgICAgIF90aGlzLmNjZFNwZWVkVGhyZXNob2xkID0gKF9yID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiAtMTtcclxuICAgICAgICBfdGhpcy5jY2RJdGVyYXRpb25zID0gKF9zID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNjZEl0ZXJhdGlvbnMpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IDEwO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSB0aGlzLmludk1hc3M7XHJcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gdGhpcy5pbnZJbmVydGlhO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdG90YWwgZGVuc2l0eSBvZiB0aGUgYm9keVxyXG4gICAgICogQG1ldGhvZCBzZXREZW5zaXR5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVuc2l0eVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5zZXREZW5zaXR5ID0gZnVuY3Rpb24gKGRlbnNpdHkpIHtcclxuICAgICAgICB2YXIgdG90YWxBcmVhID0gdGhpcy5nZXRBcmVhKCk7XHJcbiAgICAgICAgdGhpcy5tYXNzID0gdG90YWxBcmVhICogZGVuc2l0eTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRvdGFsIGFyZWEgb2YgYWxsIHNoYXBlcyBpbiB0aGUgYm9keVxyXG4gICAgICogQG1ldGhvZCBnZXRBcmVhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRvdGFsQXJlYSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0b3RhbEFyZWEgKz0gdGhpcy5zaGFwZXNbaV0uYXJlYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsQXJlYTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgQUFCQiBmcm9tIHRoZSBib2R5LiBUaGUgQUFCQiBpcyB1cGRhdGVkIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqIEBtZXRob2QgZ2V0QUFCQlxyXG4gICAgICogQHJldHVybiB7QUFCQn0gVGhlIEFBQkIgaW5zdGFuY2UgZnJvbSB0aGUgYm9keS5cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5hYWJiTmVlZHNVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFhYmI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBBQUJCIG9mIHRoZSBCb2R5LCBhbmQgc2V0IC5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZS5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlQUFCQlxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVBQUJCID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcywgTiA9IHNoYXBlcy5sZW5ndGgsIG9mZnNldCA9IF90bXAsIGJvZHlBbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sIGFuZ2xlID0gc2hhcGUuYW5nbGUgKyBib2R5QW5nbGU7XHJcbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBvZmZzZXRcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG9mZnNldCwgc2hhcGUucG9zaXRpb24sIGJvZHlBbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvZmZzZXQsIG9mZnNldCwgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXHJcbiAgICAgICAgICAgIHNoYXBlLmNvbXB1dGVBQUJCKHRoaXMuX3NoYXBlQUFCQiwgb2Zmc2V0LCBhbmdsZSk7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFhYmIuY29weSh0aGlzLl9zaGFwZUFBQkIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiLmV4dGVuZCh0aGlzLl9zaGFwZUFBQkIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keSAodGhpcy5ib3VuZGluZ1JhZGl1cykuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGUgZGltZW5zaW9ucyBvciBwb3NpdGlvbnMgYXJlIGNoYW5nZWQuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcywgTiA9IHNoYXBlcy5sZW5ndGgsIHJhZGl1cyA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sIG9mZnNldCA9IHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChzaGFwZS5wb3NpdGlvbiksIHIgPSBzaGFwZS5ib3VuZGluZ1JhZGl1cztcclxuICAgICAgICAgICAgaWYgKG9mZnNldCArIHIgPiByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5LiBZb3UgY2FuIHBhc3MgYSBsb2NhbCB0cmFuc2Zvcm0gd2hlbiBhZGRpbmcgYSBzaGFwZSxcclxuICAgICAqIHNvIHRoYXQgdGhlIHNoYXBlIGdldHMgYW4gb2Zmc2V0IGFuZCBhbmdsZSByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIFdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIG1hc3MgcHJvcGVydGllcyBhbmQgYm91bmRpbmcgcmFkaXVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgYWRkU2hhcGVcclxuICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgICAgICAgICAgc2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbb2Zmc2V0XSBMb2NhbCBib2R5IG9mZnNldCBvZiB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgIFthbmdsZV0gIExvY2FsIGJvZHkgYW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCksXHJcbiAgICAgKiAgICAgICAgIHNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIHRoZSBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeC1heGlzLlxyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzEsMF0pO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHktYXhpcywgYW5kIHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cuXHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMCwxXSxNYXRoLlBJLzIpO1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgb2Zmc2V0LCBhbmdsZSkge1xyXG4gICAgICAgIGlmIChhbmdsZSA9PT0gdm9pZCAwKSB7IGFuZ2xlID0gMDsgfVxyXG4gICAgICAgIGlmIChzaGFwZS5ib2R5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaGFwZSBjYW4gb25seSBiZSBhZGRlZCB0byBvbmUgYm9keS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuICAgICAgICBpZiAod29ybGQgJiYgd29ybGQuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNoYXBlIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhcGUuYm9keSA9IHRoaXM7XHJcbiAgICAgICAgLy8gQ29weSB0aGUgb2Zmc2V0IHZlY3RvclxyXG4gICAgICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShzaGFwZS5wb3NpdGlvbiwgb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChzaGFwZS5wb3NpdGlvbiwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYXBlLmFuZ2xlID0gYW5nbGUgfHwgMDtcclxuICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHNoYXBlLlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzaGFwZSB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGVsc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnJlbW92ZVNoYXBlID0gZnVuY3Rpb24gKHNoYXBlKSB7XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuICAgICAgICBpZiAod29ybGQgJiYgd29ybGQuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNoYXBlIGNhbm5vdCBiZSByZW1vdmVkIGR1cmluZyBzdGVwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2hhcGUuYm9keSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAuaW5lcnRpYSwgLmludk1hc3MsIC5pbnZJbmVydGlhIGZvciB0aGlzIEJvZHkuIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2luZyB0aGUgc3RydWN0dXJlIG9yIG1hc3Mgb2YgdGhlIEJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgYm9keS5tYXNzICs9IDE7XHJcbiAgICAgKiAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBCb2R5LlNUQVRJQyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1ha2luZyBpdCBpbmZpbml0eS5cclxuICAgICAgICAgICAgdGhpcy5tYXNzID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIHRoaXMuaW52TWFzcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLCBOID0gc2hhcGVzLmxlbmd0aCwgSSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXSwgcjIgPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHNoYXBlLnBvc2l0aW9uKSwgSWNtID0gc2hhcGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIEkgKz0gSWNtICsgcjI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSB0aGlzLm1hc3MgKiBJO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gSSA+IDAgPyAxIC8gSSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW52ZXJzZSBtYXNzIHByb3BlcnRpZXMgYXJlIGVhc3lcclxuICAgICAgICAgICAgdGhpcy5pbnZNYXNzID0gMSAvIHRoaXMubWFzcztcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRoaXMubWFzc011bHRpcGxpZXIsIHRoaXMuZml4ZWRYID8gMCA6IDEsIHRoaXMuZml4ZWRZID8gMCA6IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGZvcmNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuXHJcbiAgICAgKiBAbWV0aG9kIGFwcGx5Rm9yY2VcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBmb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gW3JlbGF0aXZlUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgZm9yY2Ugd2lsbCBiZSBleGVydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlbGF0aXZlUG9pbnQgPSBbMSwgMF07IC8vIFdpbGwgYXBwbHkgdGhlIGZvcmNlIGF0IFtib2R5LnBvc2l0aW9uWzBdICsgMSwgYm9keS5wb3NpdGlvblsxXV1cclxuICAgICAqICAgICB2YXIgZm9yY2UgPSBbMCwgMV07IC8vIHVwXHJcbiAgICAgKiAgICAgYm9keS5hcHBseUZvcmNlKGZvcmNlLCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LmZvcmNlKTsgLy8gWzAsIDFdXHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hbmd1bGFyRm9yY2UpOyAvLyAxXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UsIHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICAvLyBBZGQgbGluZWFyIGZvcmNlXHJcbiAgICAgICAgYWRkKHRoaXMuZm9yY2UsIHRoaXMuZm9yY2UsIGZvcmNlKTtcclxuICAgICAgICBpZiAocmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgZm9yY2VcclxuICAgICAgICAgICAgdmFyIHJvdEZvcmNlID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmVsYXRpdmVQb2ludCwgZm9yY2UpO1xyXG4gICAgICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJGb3JjZSArPSByb3RGb3JjZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBmb3JjZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkuYW5ndWxhckZvcmNlLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlTG9jYWxcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiBsb2NhbCBib2R5IHNwYWNlLlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IFtsb2NhbFBvaW50XSBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5IGluIGxvY2FsIGJvZHkgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgZm9yY2Ugd2lsbCBiZSBleGVydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsUG9pbnQgPSBbMSwgMF07IC8vIHg9MSBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsRm9yY2UgPSBbMCwgMV07IC8vIHVwLCBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgYm9keS5hcHBseUZvcmNlTG9jYWwobG9jYWxGb3JjZSwgbG9jYWxQb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5mb3JjZSk7IC8vIFswLCAxXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYW5ndWxhckZvcmNlKTsgLy8gMVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlTG9jYWwgPSBmdW5jdGlvbiAobG9jYWxGb3JjZSwgbG9jYWxQb2ludCkge1xyXG4gICAgICAgIC8vIFRoZXNlIDMgbGluZXMgd2VyZSBvcmlnaW5hbGx5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi4gTm90IHN1cmUgd2h5LlxyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5Rm9yY2VfZm9yY2VXb3JsZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQgPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIEJvZHlfYXBwbHlGb3JjZV9wb2ludExvY2FsID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGxvY2FsUG9pbnQgPSBsb2NhbFBvaW50IHx8IEJvZHlfYXBwbHlGb3JjZV9wb2ludExvY2FsO1xyXG4gICAgICAgIHZhciB3b3JsZEZvcmNlID0gQm9keV9hcHBseUZvcmNlX2ZvcmNlV29ybGQ7XHJcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRXb3JsZDtcclxuICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZEZvcmNlLCBsb2NhbEZvcmNlKTtcclxuICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZFBvaW50LCBsb2NhbFBvaW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5Rm9yY2Uod29ybGRGb3JjZSwgd29ybGRQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBpbXB1bHNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gaW1wdWxzZVZlY3RvciBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiB3b3JsZCBzcGFjZS4gSWYgbm90IGdpdmVuLCBpdCBpcyBzZXQgdG8gemVybyBhbmQgYWxsIG9mIHRoZSBpbXB1bHNlIHdpbGwgYmUgZXhlcnRlZCBvbiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciByZWxhdGl2ZVBvaW50ID0gWzAsIDBdOyAvLyBjZW50ZXIgb2YgdGhlIGJvZHlcclxuICAgICAqICAgICB2YXIgaW1wdWxzZVZlY3RvciA9IFswLCAxXTsgLy8gd29ybGQgdXBcclxuICAgICAqICAgICBib2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlVmVjdG9yLCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gKGltcHVsc2VWZWN0b3IsIHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IHZlYzJjcmVhdGUoKTsgLy8gV2FzIG9yaWdpbmFsbHkgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLiBcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxyXG4gICAgICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZSh2ZWxvLCBpbXB1bHNlVmVjdG9yLCB0aGlzLmludk1hc3MpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm11bHRpcGx5KHZlbG8sIHRoaXMubWFzc011bHRpcGxpZXIsIHZlbG8pO1xyXG4gICAgICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxyXG4gICAgICAgIGFkZCh0aGlzLnZlbG9jaXR5LCB2ZWxvLCB0aGlzLnZlbG9jaXR5KTtcclxuICAgICAgICBpZiAocmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICB2YXIgcm90VmVsbyA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJlbGF0aXZlUG9pbnQsIGltcHVsc2VWZWN0b3IpO1xyXG4gICAgICAgICAgICByb3RWZWxvICo9IHRoaXMuaW52SW5lcnRpYTtcclxuICAgICAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSByb3RWZWxvO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGltcHVsc2UgdG8gYSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCBhcHBseUltcHVsc2VMb2NhbFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsSW1wdWxzZSBUaGUgaW1wdWxzZSB2ZWN0b3IgdG8gYWRkLCBvcmllbnRlZCBpbiBsb2NhbCBib2R5IHNwYWNlLlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IFtsb2NhbFBvaW50XSBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5IGluIGxvY2FsIGJvZHkgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4ZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgbG9jYWxQb2ludCA9IFsxLCAwXTsgLy8geD0xLCBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsSW1wdWxzZSA9IFswLCAxXTsgLy8gdXAsIGxvY2FsbHkgaW4gdGhlIGJvZHlcclxuICAgICAqICAgICBib2R5LmFwcGx5SW1wdWxzZUxvY2FsKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS52ZWxvY2l0eSk7IC8vIFsxLCAwXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYW5ndWxhclZlbG9jaXR5KTsgLy8gMVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2VMb2NhbCA9IGZ1bmN0aW9uIChsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICAvLyBPcmlnaW5hbGx5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfaW1wdWxzZVdvcmxkID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGxvY2FsUG9pbnQgPSBsb2NhbFBvaW50IHx8IEJvZHlfYXBwbHlJbXB1bHNlX3BvaW50TG9jYWw7XHJcbiAgICAgICAgdmFyIHdvcmxkSW1wdWxzZSA9IEJvZHlfYXBwbHlJbXB1bHNlX2ltcHVsc2VXb3JsZDtcclxuICAgICAgICB2YXIgd29ybGRQb2ludCA9IEJvZHlfYXBwbHlJbXB1bHNlX3BvaW50V29ybGQ7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRJbXB1bHNlLCBsb2NhbEltcHVsc2UpO1xyXG4gICAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkUG9pbnQsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlJbXB1bHNlKHdvcmxkSW1wdWxzZSwgd29ybGRQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHBvaW50IHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50ICAgVGhlIGlucHV0IHdvcmxkIHBvaW50XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkUG9pbnQpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUob3V0LCB3b3JsZFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHBvaW50IHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50ICAgVGhlIGlucHV0IGxvY2FsIHBvaW50XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKG91dCwgbG9jYWxQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCB2ZWN0b3IgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHdvcmxkVmVjdG9yICBUaGUgaW5wdXQgd29ybGQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIHdvcmxkVmVjdG9yKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudmVjdG9yVG9Mb2NhbEZyYW1lKG91dCwgd29ybGRWZWN0b3IsIHRoaXMuYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgbG9jYWwgdmVjdG9yIHRvIHdvcmxkIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxWZWN0b3IgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24gKG91dCwgbG9jYWxWZWN0b3IpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUob3V0LCBsb2NhbFZlY3RvciwgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHBvbHlnb24gc2hhcGUgcGF0aCwgYW5kIGFzc2VtYmxlcyBjb252ZXggc2hhcGVzIGZyb20gdGhhdCBhbmQgcHV0cyB0aGVtIGF0IHByb3BlciBvZmZzZXQgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBmcm9tUG9seWdvblxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiAyZCB2ZWN0b3JzLCBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dIHRoYXQgcmVzZW1ibGVzIGEgY29uY2F2ZSBvciBjb252ZXggcG9seWdvbi4gVGhlIHNoYXBlIG11c3QgYmUgc2ltcGxlIGFuZCB3aXRob3V0IGhvbGVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcHRpbWFsRGVjb21wPWZhbHNlXSAgIFNldCB0byB0cnVlIGlmIHlvdSBuZWVkIG9wdGltYWwgZGVjb21wb3NpdGlvbi4gV2FybmluZzogdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiAxMCB2ZXJ0aWNlcy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFNpbXBsZUNoZWNrPWZhbHNlXSBTZXQgdG8gdHJ1ZSBpZiB5b3UgYWxyZWFkeSBrbm93IHRoYXQgdGhlIHBhdGggaXMgbm90IGludGVyc2VjdGluZyBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzPTBdIFNldCB0byBhIG51bWJlciAoYW5nbGUgdGhyZXNob2xkIHZhbHVlKSB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cywgb3IgMCB0byBrZWVwIGFsbCBwb2ludHMuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MsIGVsc2UgZmFsc2UuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAqICAgICB2YXIgcGF0aCA9IFtcclxuICAgICAqICAgICAgICAgWy0xLCAxXSxcclxuICAgICAqICAgICAgICAgWy0xLCAwXSxcclxuICAgICAqICAgICAgICAgWzEsIDBdLFxyXG4gICAgICogICAgICAgICBbMSwgMV0sXHJcbiAgICAgKiAgICAgICAgIFswLjUsIDAuNV1cclxuICAgICAqICAgICBdO1xyXG4gICAgICogICAgIGJvZHkuZnJvbVBvbHlnb24ocGF0aCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5zaGFwZXMpOyAvLyBbQ29udmV4LCBDb252ZXgsIC4uLl1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZnJvbVBvbHlnb24gPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgc2hhcGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaGFwZSh0aGlzLnNoYXBlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvcHkgdGhlIHBhdGhcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwW2ldID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUocGF0aFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2UgaXQgY291bnRlci1jbG9ja3dpc2VcclxuICAgICAgICBwb2x5X2RlY29tcF8xLmRlZmF1bHQubWFrZUNDVyhwKTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZW1vdmVDb2xsaW5lYXJQb2ludHMpICE9IDApIHtcclxuICAgICAgICAgICAgcG9seV9kZWNvbXBfMS5kZWZhdWx0LnJlbW92ZUNvbGxpbmVhclBvaW50cyhwLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBwYXRoIGl0c2VsZlxyXG4gICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwU2ltcGxlQ2hlY2spKSB7XHJcbiAgICAgICAgICAgIGlmICghcG9seV9kZWNvbXBfMS5kZWZhdWx0LmlzU2ltcGxlKHApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2F2ZSB0aGlzIHBhdGggZm9yIGxhdGVyXHJcbiAgICAgICAgdGhpcy5jb25jYXZlUGF0aCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmNhdmVQYXRoW2ldID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUocFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNsb3cgb3IgZmFzdCBkZWNvbXA/XHJcbiAgICAgICAgdmFyIGNvbnZleGVzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3B0aW1hbERlY29tcCkge1xyXG4gICAgICAgICAgICBjb252ZXhlcyA9IChfYiA9IHBvbHlfZGVjb21wXzEuZGVmYXVsdC5kZWNvbXAocCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udmV4ZXMgPSAoX2MgPSBwb2x5X2RlY29tcF8xLmRlZmF1bHQucXVpY2tEZWNvbXAocCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY20gPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgLy8gQWRkIGNvbnZleGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGNvbnZleGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBjb252ZXhcclxuICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ29udmV4XzEuZGVmYXVsdCh1bmRlZmluZWQsIGNvbnZleGVzW2ldKTtcclxuICAgICAgICAgICAgLy8gTW92ZSBhbGwgdmVydGljZXMgc28gaXRzIGNlbnRlciBvZiBtYXNzIGlzIGluIHRoZSBsb2NhbCBjZW50ZXIgb2YgdGhlIGNvbnZleFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gYy52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBjLnZlcnRpY2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgc3ViKHYsIHYsIGMuY2VudGVyT2ZNYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGNtLCBjLmNlbnRlck9mTWFzcyk7XHJcbiAgICAgICAgICAgIGMgPSBuZXcgQ29udmV4XzEuZGVmYXVsdCh1bmRlZmluZWQsIGMudmVydGljZXMpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHNoYXBlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkU2hhcGUoYywgY20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkanVzdENlbnRlck9mTWFzcygpO1xyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBzaGFwZSBvZmZzZXRzIHNvIHRoZWlyIGNlbnRlciBvZiBtYXNzIGJlY29tZXMgdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAbWV0aG9kIGFkanVzdENlbnRlck9mTWFzc1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgcG9zaXRpb246IFswLCAwXSB9KTtcclxuICAgICAqICAgICB2YXIgc2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsIFsxLCAwXSwgMCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGp1c3RDZW50ZXJPZk1hc3MoKTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LnBvc2l0aW9uKTsgLy8gWzEsIDBdXHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coc2hhcGUucG9zaXRpb24pOyAvLyBbMCwgMF1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYWRqdXN0Q2VudGVyT2ZNYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiA9IHZlYzJjcmVhdGUoKSwgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMgPSB2ZWMyY3JlYXRlKCksIGFkanVzdENlbnRlck9mTWFzc190bXA0ID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBvZmZzZXRfdGltZXNfYXJlYSA9IGFkanVzdENlbnRlck9mTWFzc190bXAyLCBzdW0gPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMywgY20gPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCwgdG90YWxBcmVhID0gMDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoc3VtLCAwLCAwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUob2Zmc2V0X3RpbWVzX2FyZWEsIHMucG9zaXRpb24sIHMuYXJlYSk7XHJcbiAgICAgICAgICAgIGFkZChzdW0sIHN1bSwgb2Zmc2V0X3RpbWVzX2FyZWEpO1xyXG4gICAgICAgICAgICB0b3RhbEFyZWEgKz0gcy5hcmVhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShjbSwgc3VtLCAxIC8gdG90YWxBcmVhKTtcclxuICAgICAgICAvLyBOb3cgbW92ZSBhbGwgc2hhcGVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHN1YihzLnBvc2l0aW9uLCBzLnBvc2l0aW9uLCBjbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1vdmUgdGhlIGJvZHkgcG9zaXRpb24gdG9vXHJcbiAgICAgICAgYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGNtKTtcclxuICAgICAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaSA8IHRoaXMuY29uY2F2ZVBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3ViKHRoaXMuY29uY2F2ZVBhdGhbaV0sIHRoaXMuY29uY2F2ZVBhdGhbaV0sIGNtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXHJcbiAgICAgKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmZvcmNlO1xyXG4gICAgICAgIGZbMF0gPSBmWzFdID0gdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgfTtcclxuICAgIEJvZHkucHJvdG90eXBlLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcywgdmxhbWJkYSA9IGIudmxhbWJkYTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmxhbWJkYSwgMCwgMCk7XHJcbiAgICAgICAgYi53bGFtYmRhID0gMDtcclxuICAgIH07XHJcbiAgICBCb2R5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGIgPSB0aGlzLCB2ID0gYi52ZWxvY2l0eTtcclxuICAgICAgICBhZGQodiwgdiwgYi52bGFtYmRhKTtcclxuICAgICAgICBiLmFuZ3VsYXJWZWxvY2l0eSArPSBiLndsYW1iZGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBkYW1waW5nLCBzZWUgPGEgaHJlZj1cImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NFwiPnRoaXM8L2E+IGZvciBkZXRhaWxzLlxyXG4gICAgICogQG1ldGhvZCBhcHBseURhbXBpbmdcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHQgQ3VycmVudCB0aW1lIHN0ZXBcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlEYW1waW5nID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQm9keS5EWU5BTUlDKSB7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodiwgdiwgTWF0aC5wb3coMSAtIHRoaXMuZGFtcGluZywgZHQpKTtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMSAtIHRoaXMuYW5ndWxhckRhbXBpbmcsIGR0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXHJcbiAgICAgKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXHJcbiAgICAgKiBAbWV0aG9kIHdha2VVcFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNsZWVwU3RhdGU7XHJcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcclxuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICBpZiAocyAhPT0gQm9keS5BV0FLRSkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCB3YWtlVXBFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRm9yY2UgYm9keSBzbGVlcFxyXG4gICAgICogQG1ldGhvZCBzbGVlcFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh0aGlzLnZlbG9jaXR5LCAwLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodGhpcy5mb3JjZSwgMCwgMCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgc2xlZXBFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxyXG4gICAgICogQG1ldGhvZCBzbGVlcFRpY2tcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHRcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24gKHRpbWUsIGRvbnRTbGVlcCwgZHQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpICsgTWF0aC5wb3codGhpcy5hbmd1bGFyVmVsb2NpdHksIDIpLCBzcGVlZExpbWl0U3F1YXJlZCA9IE1hdGgucG93KHRoaXMuc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAvLyBBZGQgdG8gaWRsZSB0aW1lXHJcbiAgICAgICAgaWYgKHNwZWVkU3F1YXJlZCA+PSBzcGVlZExpbWl0U3F1YXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWUgKz0gZHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBZKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIHNsZWVweUV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpIHtcclxuICAgICAgICAgICAgaWYgKCFkb250U2xlZXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBib2R5IGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgYm9keS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIGJvZHkgd2FzIGFkZGVkIHRvIGEgV29ybGQgYW5kIGlmIGF0IGxlYXN0IG9uZSBzdGVwIHdhcyB0YWtlbi5cclxuICAgICAqIEBtZXRob2Qgb3ZlcmxhcHNcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMud29ybGQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5vdmVybGFwS2VlcGVyLmJvZGllc0FyZU92ZXJsYXBwaW5nKHRoaXMsIGJvZHkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUgZ2l2ZW4gaXRzIGN1cnJlbnQgdmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIGludGVncmF0ZVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBkdFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB2YXIgbWludiA9IHRoaXMuaW52TWFzcywgZiA9IHRoaXMuZm9yY2UsIHBvcyA9IHRoaXMucG9zaXRpb24sIHZlbG8gPSB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgIC8vIFNhdmUgb2xkIHBvc2l0aW9uXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnByZXZpb3VzUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNBbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICAgICAgLy8gVmVsb2NpdHkgdXBkYXRlXHJcbiAgICAgICAgaWYgKCF0aGlzLmZpeGVkUm90YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5hbmd1bGFyRm9yY2UgKiB0aGlzLmludkluZXJ0aWEgKiBkdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZWdyYXRlX2ZoTWludiwgZiwgZHQgKiBtaW52KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5tdWx0aXBseShpbnRlZ3JhdGVfZmhNaW52LCB0aGlzLm1hc3NNdWx0aXBsaWVyLCBpbnRlZ3JhdGVfZmhNaW52KTtcclxuICAgICAgICBhZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XHJcbiAgICAgICAgLy8gQ0NEXHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVncmF0ZVRvVGltZU9mSW1wYWN0KGR0KSkge1xyXG4gICAgICAgICAgICAvLyBSZWd1bGFyIHBvc2l0aW9uIHVwZGF0ZVxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCB2ZWxvLCBkdCk7XHJcbiAgICAgICAgICAgIGFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlICs9IHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIEJvZHkucHJvdG90eXBlLmludGVncmF0ZVRvVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghdGhpcy53b3JsZClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgcmF5Y2FzdF9yZXN1bHRfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHJheSA9IG5ldyByYXlfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgbW9kZTogcmF5XzEuZGVmYXVsdC5DTE9TRVNULFxyXG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgZW5kID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBzdGFydFRvRW5kID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByZW1lbWJlclBvc2l0aW9uID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNjZFNwZWVkVGhyZXNob2xkIDwgMCB8fCB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpIDwgTWF0aC5wb3codGhpcy5jY2RTcGVlZFRocmVzaG9sZCwgMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZ25vcmUgYWxsIHRoZSBpZ25vcmVkIGJvZHkgcGFpcnNcclxuICAgICAgICAvLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBkb25lIHNvbWV3aGVyZSBlbHNlIGZvciBvcHRpbWl6YXRpb25cclxuICAgICAgICB2YXIgaWdub3JlQm9kaWVzID0gW107XHJcbiAgICAgICAgdmFyIGRpc2FibGVkUGFpcnMgPSB0aGlzLndvcmxkLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzYWJsZWRQYWlycy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgYm9keUEgPSBkaXNhYmxlZFBhaXJzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYm9keUIgPSBkaXNhYmxlZFBhaXJzW2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVCb2RpZXMucHVzaChib2R5Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm9keUIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGlnbm9yZUJvZGllcy5wdXNoKGJvZHlBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUoZGlyZWN0aW9uLCB0aGlzLnZlbG9jaXR5KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShlbmQsIHRoaXMudmVsb2NpdHksIGR0KTtcclxuICAgICAgICBhZGQoZW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBzdGFydFRvRW5kQW5nbGUgPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xyXG4gICAgICAgIHZhciBsZW4gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgoc3RhcnRUb0VuZCk7XHJcbiAgICAgICAgdmFyIHRpbWVPZkltcGFjdCA9IDE7XHJcbiAgICAgICAgdmFyIGhpdEJvZHkgPSBudWxsO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmF5LmZyb20sIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmF5LnRvLCBlbmQpO1xyXG4gICAgICAgIHJheS51cGRhdGUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICByZXN1bHQucmVzZXQoKTtcclxuICAgICAgICAgICAgcmF5LmNvbGxpc2lvbkdyb3VwID0gc2hhcGUuY29sbGlzaW9uR3JvdXA7XHJcbiAgICAgICAgICAgIHJheS5jb2xsaXNpb25NYXNrID0gc2hhcGUuY29sbGlzaW9uTWFzaztcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yYXljYXN0KHJlc3VsdCwgcmF5KTtcclxuICAgICAgICAgICAgaGl0Qm9keSA9IChfYSA9IHJlc3VsdC5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIWhpdEJvZHkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGhpdEJvZHkgPT09IHRoaXMgfHwgaWdub3JlQm9kaWVzLmluZGV4T2YoaGl0Qm9keSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBoaXRCb2R5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0Qm9keSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoaXRCb2R5IHx8ICF0aW1lT2ZJbXBhY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoZW5kLCByYXkpO1xyXG4gICAgICAgIHN1YihzdGFydFRvRW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzJfMS5kZWZhdWx0LmRpc3RhbmNlKGVuZCwgdGhpcy5wb3NpdGlvbikgLyBsZW47IC8vIGd1ZXNzXHJcbiAgICAgICAgdmFyIHJlbWVtYmVyQW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkocmVtZW1iZXJQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgLy8gR290IGEgc3RhcnQgYW5kIGVuZCBwb2ludC4gQXBwcm94aW1hdGUgdGltZSBvZiBpbXBhY3QgdXNpbmcgYmluYXJ5IHNlYXJjaFxyXG4gICAgICAgIHZhciBpdGVyID0gMDtcclxuICAgICAgICB2YXIgdG1pbiA9IDA7XHJcbiAgICAgICAgdmFyIHRtaWQgPSB0aW1lT2ZJbXBhY3Q7XHJcbiAgICAgICAgdmFyIHRtYXggPSAxO1xyXG4gICAgICAgIHdoaWxlICh0bWF4ID49IHRtaW4gJiYgaXRlciA8IHRoaXMuY2NkSXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICBpdGVyKys7XHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnRcclxuICAgICAgICAgICAgdG1pZCA9ICh0bWF4ICsgdG1pbikgLyAyO1xyXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBib2R5IHRvIHRoYXQgcG9pbnRcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgc3RhcnRUb0VuZCwgdG1pZCk7XHJcbiAgICAgICAgICAgIGFkZCh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uLCBpbnRlZ3JhdGVfdmVsb2R0KTtcclxuICAgICAgICAgICAgdGhpcy5hbmdsZSA9IHJlbWVtYmVyQW5nbGUgKyBzdGFydFRvRW5kQW5nbGUgKiB0bWlkO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgb3ZlcmxhcFxyXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmFhYmIub3ZlcmxhcHMoaGl0Qm9keS5hYWJiKSAmJiB0aGlzLndvcmxkLm5hcnJvd3BoYXNlLmJvZGllc092ZXJsYXAodGhpcywgaGl0Qm9keSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwcykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1heCB0byBzZWFyY2ggbG93ZXIgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIHRtYXggPSB0bWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1pbiB0byBzZWFyY2ggdXBwZXIgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIHRtaW4gPSB0bWlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHRtYXg7IC8vIE5lZWQgdG8gZ3VhcmFudGVlIG92ZXJsYXAgdG8gcmVzb2x2ZSBjb2xsaXNpb25zXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZTtcclxuICAgICAgICAvLyBtb3ZlIHRvIFRPSVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XHJcbiAgICAgICAgYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xyXG4gICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgKz0gc3RhcnRUb0VuZEFuZ2xlICogdGltZU9mSW1wYWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB2ZWxvY2l0eSBvZiBhIHBvaW50IGluIHRoZSBib2R5LlxyXG4gICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eUF0UG9pbnRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSByZXN1bHQgQSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHJlbGF0aXZlUG9pbnQgQSB3b3JsZCBvcmllbnRlZCB2ZWN0b3IsIGluZGljYXRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCB0byBnZXQgdGhlIHZlbG9jaXR5IGZyb21cclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcmVzdWx0IHZlY3RvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgbWFzczogMSxcclxuICAgICAqICAgICAgICAgdmVsb2NpdHk6IFsxLCAwXSxcclxuICAgICAqICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICogICAgIHZhciBwb2ludCA9IFsxLCAwXTtcclxuICAgICAqICAgICBib2R5LmdldFZlbG9jaXR5QXRQb2ludChyZXN1bHQsIHBvaW50KTtcclxuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyBbMSwgMV1cclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBdFBvaW50ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmVsYXRpdmVQb2ludCkge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzVloocmVzdWx0LCByZWxhdGl2ZVBvaW50LCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocmVzdWx0LCB0aGlzLnZlbG9jaXR5LCByZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEeW5hbWljIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgRFlOQU1JQ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5EWU5BTUlDID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGJvZHkuXHJcbiAgICAgKiBAcHJvcGVydHkgU1RBVElDXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCb2R5LlNUQVRJQyA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIEtpbmVtYXRpYyBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IEtJTkVNQVRJQ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5LSU5FTUFUSUMgPSA0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgQVdBS0VcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuQVdBS0UgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgU0xFRVBZXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCb2R5LlNMRUVQWSA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSBTTEVFUElOR1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5TTEVFUElORyA9IDI7XHJcbiAgICByZXR1cm4gQm9keTtcclxufShldmVudF9lbWl0dGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb2R5O1xyXG4vKipcclxuICogQGV2ZW50IHNsZWVweVxyXG4gKi9cclxudmFyIHNsZWVweUV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJzbGVlcHlcIlxyXG59O1xyXG4vKipcclxuICogQGV2ZW50IHNsZWVwXHJcbiAqL1xyXG52YXIgc2xlZXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2xlZXBcIlxyXG59O1xyXG4vKipcclxuICogQGV2ZW50IHdha2V1cFxyXG4gKi9cclxudmFyIHdha2VVcEV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJ3YWtldXBcIlxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc3ByaW5nXCIpKTtcclxudmFyIGFwcGx5Rm9yY2VfciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3JfdW5pdCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3UgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV9mID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2VfcmkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV9yaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3RtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgTGluZWFyU3ByaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpbmVhclNwcmluZywgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIExpbmVhclNwcmluZ1xyXG4gICAgICogQGV4dGVuZHMgU3ByaW5nXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgc3ByaW5nID0gbmV3IExpbmVhclNwcmluZyhib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgc3RpZmZuZXNzOiAxMDAsXHJcbiAgICAgKiAgICAgICAgIGRhbXBpbmc6IDEsXHJcbiAgICAgKiAgICAgICAgIGxvY2FsQW5jaG9yQTogWzAsMF0sIC8vIGNlbnRlciBvZiBib2R5QVxyXG4gICAgICogICAgICAgICBsb2NhbEFuY2hvckI6IFswLDBdIC8vIGNlbnRlciBvZiBib2R5QlxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZFNwcmluZyhzcHJpbmcpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmxkQW5jaG9yQSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRXb3JsZEFuY2hvckEob3B0aW9ucy53b3JsZEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmxkQW5jaG9yQikge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xyXG4gICAgICAgIF90aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMl8xLmRlZmF1bHQuZGlzdGFuY2Uod29ybGRBbmNob3JBLCB3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIF90aGlzLnJlc3RMZW5ndGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd29ybGREaXN0YW5jZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JBXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24gKHdvcmxkQW5jaG9yQSkge1xyXG4gICAgICAgIHRoaXMuYm9keUEudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLCB3b3JsZEFuY2hvckEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckJcclxuICAgICAqL1xyXG4gICAgTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbiAod29ybGRBbmNob3JCKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5Qi50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHdvcmxkQW5jaG9yQik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuYm9keUEudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBMaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmJvZHlCLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JCKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLCBkID0gdGhpcy5kYW1waW5nLCBsID0gdGhpcy5yZXN0TGVuZ3RoLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgciA9IGFwcGx5Rm9yY2Vfciwgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsIHUgPSBhcHBseUZvcmNlX3UsIGYgPSBhcHBseUZvcmNlX2YsIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xyXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSwgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckIsIHJpID0gYXBwbHlGb3JjZV9yaSwgcmogPSBhcHBseUZvcmNlX3JqO1xyXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXHJcbiAgICAgICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcclxuICAgICAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAvLyBDb21wdXRlIGRpc3RhbmNlIHZlY3RvciBiZXR3ZWVuIHdvcmxkIGFuY2hvciBwb2ludHNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCB3b3JsZEFuY2hvckIsIHdvcmxkQW5jaG9yQSk7XHJcbiAgICAgICAgdmFyIHJsZW4gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgocik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKHJfdW5pdCwgcik7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHUsIGJvZHlCLnZlbG9jaXR5LCBib2R5QS52ZWxvY2l0eSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1LCB1LCB0bXApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzWlYodG1wLCBib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJpKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh1LCB1LCB0bXApO1xyXG4gICAgICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShmLCByX3VuaXQsIC1rICogKHJsZW4gLSBsKSAtIGQgKiB2ZWMyXzEuZGVmYXVsdC5kb3QodSwgcl91bml0KSk7XHJcbiAgICAgICAgLy8gQWRkIGZvcmNlcyB0byBib2RpZXNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xyXG4gICAgICAgIC8vIEFuZ3VsYXIgZm9yY2VcclxuICAgICAgICB2YXIgcmlfeF9mID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIGYpO1xyXG4gICAgICAgIHZhciByal94X2YgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgZik7XHJcbiAgICAgICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcclxuICAgICAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaW5lYXJTcHJpbmc7XHJcbn0oc3ByaW5nXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5lYXJTcHJpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzcHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zcHJpbmdcIikpO1xyXG52YXIgUm90YXRpb25hbFNwcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb3RhdGlvbmFsU3ByaW5nLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJvdGF0aW9uYWwgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMgcm90YXRpb24uIFRoaXMgc3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBhbmd1bGFyRm9yY2UgKHRvcnF1ZSkgdG8gdGhlIGJvZGllcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgc3ByaW5nIGNhbiBiZSBjb21iaW5lZCB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiUmV2b2x1dGVDb25zdHJhaW50XCJ9fXt7L2Nyb3NzTGlua319IHRvIG1ha2UsIGZvciBleGFtcGxlLCBhIG1vdXNlIHRyYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIFJvdGF0aW9uYWxTcHJpbmdcclxuICAgICAqIEBleHRlbmRzIFNwcmluZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdEFuZ2xlXSBUaGUgcmVsYXRpdmUgYW5nbGUgb2YgYm9kaWVzIGF0IHdoaWNoIHRoZSBzcHJpbmcgaXMgYXQgcmVzdC4gSWYgbm90IGdpdmVuLCBpdCdzIHNldCB0byB0aGUgY3VycmVudCByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSBBIG51bWJlciA+PSAwLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHNwcmluZyA9IG5ldyBSb3RhdGlvbmFsU3ByaW5nKGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICBzdGlmZm5lc3M6IDEwMCxcclxuICAgICAqICAgICAgICAgZGFtcGluZzogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZFNwcmluZyhzcHJpbmcpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdCBhbmdsZSBvZiB0aGUgc3ByaW5nLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZXN0QW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnJlc3RBbmdsZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXN0QW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcywgZCA9IHRoaXMuZGFtcGluZywgbCA9IHRoaXMucmVzdEFuZ2xlLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgeCA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGUsIHUgPSBib2R5Qi5hbmd1bGFyVmVsb2NpdHkgLSBib2R5QS5hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgdmFyIHRvcnF1ZSA9IC1rICogKHggLSBsKSAtIGQgKiB1O1xyXG4gICAgICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSB0b3JxdWU7XHJcbiAgICAgICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHRvcnF1ZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gUm90YXRpb25hbFNwcmluZztcclxufShzcHJpbmdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdGF0aW9uYWxTcHJpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTcHJpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHt7I2Nyb3NzTGluayBcIkxpbmVhclNwcmluZ1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiUm90YXRpb25hbFNwcmluZ1wifX17ey9jcm9zc0xpbmt9fS4gTm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIFNwcmluZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RpZmZuZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxMDA7XHJcbiAgICAgICAgdGhpcy5kYW1waW5nID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhbXBpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgIH1cclxuICAgIHJldHVybiBTcHJpbmc7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNwcmluZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGJvZHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ib2R5XCIpKTtcclxudmFyIGNvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29uc3RyYWludHMvY29uc3RyYWludFwiKSk7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvZnJpY3Rpb24tZXF1YXRpb25cIikpO1xyXG52YXIgd29ybGRWZWxvY2l0eSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmVsYXRpdmVQb2ludCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdG1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBUb3BEb3duVmVoaWNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFRvcERvd25WZWhpY2xlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGNsYXNzIHdpbGwgYmUgbW92ZWQgb3V0IG9mIHRoZSBjb3JlIGxpYnJhcnkgaW4gZnV0dXJlIHZlcnNpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gY2hhc3Npc0JvZHkgQSBkeW5hbWljIGJvZHksIGFscmVhZHkgYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIGR5bmFtaWMgYm9keSBmb3IgdGhlIGNoYXNzaXNcclxuICAgICAqICAgICB2YXIgY2hhc3Npc0JvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgKiAgICAgICAgIG1hc3M6IDFcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDAuNSwgaGVpZ2h0OiAxIH0pO1xyXG4gICAgICogICAgIGNoYXNzaXNCb2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGNoYXNzaXNCb2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIHRoZSB2ZWhpY2xlXHJcbiAgICAgKiAgICAgdmFyIHZlaGljbGUgPSBuZXcgVG9wRG93blZlaGljbGUoY2hhc3Npc0JvZHkpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgb25lIGZyb250IHdoZWVsIGFuZCBvbmUgYmFjayB3aGVlbCAtIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgZm91ciA6KVxyXG4gICAgICogICAgIHZhciBmcm9udFdoZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAwLjVdIC8vIGZyb250XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgZnJvbnRXaGVlbC5zZXRTaWRlRnJpY3Rpb24oNCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEJhY2sgd2hlZWxcclxuICAgICAqICAgICB2YXIgYmFja1doZWVsID0gdmVoaWNsZS5hZGRXaGVlbCh7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsUG9zaXRpb246IFswLCAtMC41XSAvLyBiYWNrXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYmFja1doZWVsLnNldFNpZGVGcmljdGlvbigzKTsgLy8gTGVzcyBzaWRlIGZyaWN0aW9uIG9uIGJhY2sgd2hlZWwgbWFrZXMgaXQgZWFzaWVyIHRvIGRyaWZ0XHJcbiAgICAgKiAgICAgdmVoaWNsZS5hZGRUb1dvcmxkKHdvcmxkKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gU3RlZXIgdmFsdWUgemVybyBtZWFucyBzdHJhaWdodCBmb3J3YXJkLiBQb3NpdGl2ZSBpcyBsZWZ0IGFuZCBuZWdhdGl2ZSByaWdodC5cclxuICAgICAqICAgICBmcm9udFdoZWVsLnN0ZWVyVmFsdWUgPSBNYXRoLlBJIC8gMTY7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEVuZ2luZSBmb3JjZSBmb3J3YXJkXHJcbiAgICAgKiAgICAgYmFja1doZWVsLmVuZ2luZUZvcmNlID0gMTA7XHJcbiAgICAgKiAgICAgYmFja1doZWVsLnNldEJyYWtlRm9yY2UoMCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFRvcERvd25WZWhpY2xlKGNoYXNzaXNCb2R5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBBIGR1bW15IGJvZHkgdG8gY29uc3RyYWluIHRoZSBjaGFzc2lzIHRvXHJcbiAgICAgICAgdGhpcy5ncm91bmRCb2R5ID0gbmV3IGJvZHlfMS5kZWZhdWx0KHsgbWFzczogMCB9KTtcclxuICAgICAgICB0aGlzLndoZWVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBjaGFzc2lzQm9keTtcclxuICAgICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBhZGRUb1dvcmxkXHJcbiAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gICAgICovXHJcbiAgICBUb3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgICAgICB3b3JsZC5hZGRCb2R5KHRoaXMuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgd29ybGQub24oXCJwcmVTdGVwXCIsIHRoaXMucHJlU3RlcENhbGxiYWNrLCB0aGlzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2hlZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xyXG4gICAgICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KHdoZWVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxyXG4gICAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgVG9wRG93blZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLndvcmxkO1xyXG4gICAgICAgIGlmICh3b3JsZCkge1xyXG4gICAgICAgICAgICB3b3JsZC5yZW1vdmVCb2R5KHRoaXMuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgICAgIHdvcmxkLm9mZigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbHNbaV07XHJcbiAgICAgICAgICAgICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KHdoZWVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndvcmxkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYWRkV2hlZWxcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbd2hlZWxPcHRpb25zXVxyXG4gICAgICogQHJldHVybiB7V2hlZWxDb25zdHJhaW50fVxyXG4gICAgICovXHJcbiAgICBUb3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkV2hlZWwgPSBmdW5jdGlvbiAod2hlZWxPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHdoZWVsID0gbmV3IFdoZWVsQ29uc3RyYWludCh0aGlzLCB3aGVlbE9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMud2hlZWxzLnB1c2god2hlZWwpO1xyXG4gICAgICAgIHJldHVybiB3aGVlbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIFRvcERvd25WZWhpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLndoZWVsc1tpXS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFRvcERvd25WZWhpY2xlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUb3BEb3duVmVoaWNsZTtcclxudmFyIFdoZWVsQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXaGVlbENvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBXaGVlbENvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMge0NvbnN0cmFpbnR9XHJcbiAgICAgKiBAcGFyYW0ge1ZlaGljbGV9IHZlaGljbGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsRm9yd2FyZFZlY3Rvcl0gVGhlIGxvY2FsIHdoZWVsIGZvcndhcmQgdmVjdG9yIGluIGxvY2FsIGJvZHkgc3BhY2UuIERlZmF1bHQgaXMgemVyby5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsUG9zaXRpb25dIFRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgd2hlZW4gaW4gdGhlIGNoYXNzaXMgYm9keS4gRGVmYXVsdCBpcyB6ZXJvIC0gdGhlIGNlbnRlciBvZiB0aGUgYm9keS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnNpZGVGcmljdGlvbj01XSBUaGUgbWF4IGZyaWN0aW9uIGZvcmNlIGluIHRoZSBzaWRld2F5cyBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFdoZWVsQ29uc3RyYWludCh2ZWhpY2xlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IFxyXG4gICAgICAgIC8vIFRPRE86IEkgaGF2ZSBubyBpZGVhIHdoYXQga2luZCBvZiBjb25zdHJhaW50IHRoaXMgaXMgc3VwcG9zZWQgdG8gYmUuIEl0IHNlZW1zIHRoaXMgd2FzIHVuZGVmaW5lZCBpbiB0aGUgb3JpZ2luYWwgY29kZS5cclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2ZWhpY2xlLmNoYXNzaXNCb2R5LCB2ZWhpY2xlLmdyb3VuZEJvZHksIDApIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RlZXJWYWx1ZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZW5naW5lRm9yY2UgPSAwO1xyXG4gICAgICAgIF90aGlzLnZlaGljbGUgPSB2ZWhpY2xlO1xyXG4gICAgICAgIF90aGlzLmZvcndhcmRFcXVhdGlvbiA9IG5ldyBmcmljdGlvbl9lcXVhdGlvbl8xLmRlZmF1bHQodmVoaWNsZS5jaGFzc2lzQm9keSwgdmVoaWNsZS5ncm91bmRCb2R5KTtcclxuICAgICAgICBfdGhpcy5zaWRlRXF1YXRpb24gPSBuZXcgZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0KHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgX3RoaXMuc2V0U2lkZUZyaWN0aW9uKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWRlRnJpY3Rpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxvY2FsRm9yd2FyZFZlY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvY2FsRm9yd2FyZFZlY3RvciA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMCwgMSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3IpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIG9wdGlvbnMubG9jYWxGb3J3YXJkVmVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxQb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvY2FsUG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbFBvc2l0aW9uLCBvcHRpb25zLmxvY2FsUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChfdGhpcy5mb3J3YXJkRXF1YXRpb24pO1xyXG4gICAgICAgIF90aGlzLmVxdWF0aW9ucy5wdXNoKF90aGlzLnNpZGVFcXVhdGlvbik7XHJcbiAgICAgICAgX3RoaXMuc2V0QnJha2VGb3JjZSgwKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0QnJha2VGb3JjZVxyXG4gICAgICovXHJcbiAgICBXaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLnNldEJyYWtlRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICB0aGlzLmZvcndhcmRFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRTaWRlRnJpY3Rpb25cclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5zZXRTaWRlRnJpY3Rpb24gPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICB0aGlzLnNpZGVFcXVhdGlvbi5zZXRTbGlwRm9yY2UoZm9yY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBnZXRTcGVlZFxyXG4gICAgICovXHJcbiAgICBXaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLmdldFNwZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5O1xyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHJlbGF0aXZlUG9pbnQsIHRoaXMubG9jYWxGb3J3YXJkVmVjdG9yKTtcclxuICAgICAgICBib2R5LmdldFZlbG9jaXR5QXRQb2ludCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuZG90KHdvcmxkVmVsb2NpdHksIHJlbGF0aXZlUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHk7XHJcbiAgICAgICAgdmFyIGZvcndhcmRFcXVhdGlvbiA9IHRoaXMuZm9yd2FyZEVxdWF0aW9uO1xyXG4gICAgICAgIHZhciBzaWRlRXF1YXRpb24gPSB0aGlzLnNpZGVFcXVhdGlvbjtcclxuICAgICAgICB2YXIgc3RlZXJWYWx1ZSA9IHRoaXMuc3RlZXJWYWx1ZTtcclxuICAgICAgICAvLyBEaXJlY3Rpb25hbFxyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKGZvcndhcmRFcXVhdGlvbi50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNpZGVFcXVhdGlvbi50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3RvciwgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIGJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHNpZGVFcXVhdGlvbi50LCBzaWRlRXF1YXRpb24udCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGZvcndhcmRFcXVhdGlvbi50LCBmb3J3YXJkRXF1YXRpb24udCwgc3RlZXJWYWx1ZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNpZGVFcXVhdGlvbi50LCBzaWRlRXF1YXRpb24udCwgc3RlZXJWYWx1ZSk7XHJcbiAgICAgICAgLy8gQXR0YWNobWVudCBwb2ludFxyXG4gICAgICAgIGJvZHkudG9Xb3JsZEZyYW1lKGZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB0aGlzLmxvY2FsUG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoc2lkZUVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIGZvcndhcmRFcXVhdGlvbi5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICBib2R5LnZlY3RvclRvV29ybGRGcmFtZShmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSwgdGhpcy5sb2NhbFBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHNpZGVFcXVhdGlvbi5jb250YWN0UG9pbnRBLCBmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgLy8gQWRkIGVuZ2luZSBmb3JjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSh0bXBWZWMsIGZvcndhcmRFcXVhdGlvbi50KTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgdGhpcy5lbmdpbmVGb3JjZSk7XHJcbiAgICAgICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LmFwcGx5Rm9yY2UodG1wVmVjLCBmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdoZWVsQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXHJcbi8vICwgICBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxyXG4vLyAsICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmVcclxuLy8gLCAgIENvbnZleCA9IHJlcXVpcmUoJy4vQ29udmV4Jyk7XHJcbnZhciBDb252ZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Db252ZXhcIikpO1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQm94LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb3ggc2hhcGUgY2xhc3MuXHJcbiAgICAgKiBAY2xhc3MgQm94XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MV0gVG90YWwgd2lkdGggb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xXSBUb3RhbCBoZWlnaHQgb2YgdGhlIGJveFxyXG4gICAgICogQGV4dGVuZHMgQ29udmV4XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciBib3hTaGFwZSA9IG5ldyBCb3goe1xyXG4gICAgICogICAgICAgICB3aWR0aDogMixcclxuICAgICAqICAgICAgICAgaGVpZ2h0OiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJveChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlXzEuZGVmYXVsdC5CT1gsIFtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygtaHcsIC1oaCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaHcsIC1oaCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoaHcsIGhoKSxcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygtaHcsIGhoKVxyXG4gICAgICAgIF0sIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIF90aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQm94LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiAoaCAqIGggKyB3ICogdykgLyAxMjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIEJveC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydCh3ICogdyArIGggKiBoKSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQm94LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKSwgcyA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSksIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9ICh3ICogcyArIGggKiBjKSAqIDAuNTtcclxuICAgICAgICB2YXIgd2lkdGggPSAoaCAqIHMgKyB3ICogYykgKiAwLjU7XHJcbiAgICAgICAgdmFyIGwgPSBvdXQubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdSA9IG91dC51cHBlckJvdW5kO1xyXG4gICAgICAgIHZhciBweCA9IHBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBweSA9IHBvc2l0aW9uWzFdO1xyXG4gICAgICAgIGxbMF0gPSBweCAtIHdpZHRoO1xyXG4gICAgICAgIGxbMV0gPSBweSAtIGhlaWdodDtcclxuICAgICAgICB1WzBdID0gcHggKyB3aWR0aDtcclxuICAgICAgICB1WzFdID0gcHkgKyBoZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgQm94LnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEJveC5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobG9jYWxQb2ludFswXSkgPD0gdGhpcy53aWR0aCAqIDAuNSAmJiBNYXRoLmFicyhsb2NhbFBvaW50WzFdKSA8PSB0aGlzLmhlaWdodCAqIDAuNTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQm94O1xyXG59KENvbnZleF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm94O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcclxuLy8gLCAgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZTtcclxudmFyIFNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIENpcmNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDaXJjbGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZSBzaGFwZSBjbGFzcy5cclxuICAgICAqIEBjbGFzcyBDaXJjbGVcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXSBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY2xlXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHtcclxuICAgICAqICAgICAgICAgcmFkaXVzOiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENpcmNsZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNoYXBlXzEuZGVmYXVsdC5DSVJDTEUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnJhZGl1cyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYWRpdXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIHIgKiByIC8gMjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFyZWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uIC8qLCBhbmdsZTogZjMyKi8pIHtcclxuICAgICAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChvdXQudXBwZXJCb3VuZCwgciwgcik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBDaXJjbGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uIC8qLCBhbmdsZTogZjMyKi8pIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tLCB0byA9IHJheS50bywgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XHJcbiAgICAgICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBwb3NpdGlvblswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gcG9zaXRpb25bMV0pKTtcclxuICAgICAgICB2YXIgYyA9IE1hdGgucG93KGZyb21bMF0gLSBwb3NpdGlvblswXSwgMikgKyBNYXRoLnBvdyhmcm9tWzFdIC0gcG9zaXRpb25bMV0sIDIpIC0gTWF0aC5wb3cociwgMik7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XHJcbiAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDtcclxuICAgICAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XHJcbiAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkZWx0YSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xyXG4gICAgICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcclxuICAgICAgICAgICAgdmFyIGQxID0gKC1iIC0gc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICB2YXIgZDIgPSAoLWIgKyBzcXJ0RGVsdGEpICogaW52MmE7XHJcbiAgICAgICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkMiA+PSAwICYmIGQyIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQyLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDaXJjbGUucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoKGxvY2FsUG9pbnQpIDw9IHJhZGl1cyAqIHJhZGl1cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2lyY2xlO1xyXG59KFNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDaXJjbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHBvbHlrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvcG9seWtcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90O1xyXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19hID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHVwZGF0ZUNlbnRlck9mTWFzc19jID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB0bXBWZWMxID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENvbnZleF9yYXlFbmQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHBpY19yMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcGljX3IxID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB0bXBWZWMyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB3b3JsZEF4aXMgPSB0bXBWZWMyO1xyXG52YXIgQ29udmV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnZleCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmV4IHNoYXBlIGNsYXNzLlxyXG4gICAgICogQGNsYXNzIENvbnZleFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnZlcnRpY2VzXSBBbiBhcnJheSBvZiB2ZXJ0aWNlcyB0aGF0IHNwYW4gdGhpcyBzaGFwZS4gVmVydGljZXMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIChDQ1cpIGRpcmVjdGlvbi5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XHJcbiAgICAgKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh7XHJcbiAgICAgKiAgICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlc1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoY29udmV4U2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb252ZXgodHlwZSwgdmVydGljZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHZvaWQgMCA/IHR5cGUgOiBTaGFwZV8xLmRlZmF1bHQuQ09OVkVYLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIFRPRE86IHRoaXMgd291bGQgYmUgbW9yZSBlZmZpY2llbnQgaWYgSSBkaWRuJ3QgdXNlIGZsb2F0MzJhcnJheVtdcy4gSnVzdCBjb252ZXJ0IHRvIGEgYmlnIGZsb2F0MzJhcnJheSB3aXRoIGRvdWJsZSB0aGUgc2l6ZS5cclxuICAgICAgICAvLyBMZXQncyBnZXQgdGhpcyB3b3JraW5nIGZpcnN0IHRoZW4gc3dpdGNoIGl0LlxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVkZ2Ugbm9ybWFscyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZSwgcG9pbnRpbmcgb3V0IG9mIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbm9ybWFsc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ub3JtYWxzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpYW5ndWxhdGVkIHZlcnNpb24gb2YgdGhpcyBjb252ZXguIFRoZSBzdHJ1Y3R1cmUgaXMgQXJyYXkgb2YgMy1BcnJheXMsIGFuZCBlYWNoIHN1YmFycmF5IGNvbnRhaW5zIDMgaW50ZWdlcnMsIHJlZmVyZW5jaW5nIHRoZSB2ZXJ0aWNlcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdHJpYW5nbGVzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIC8vIENvcHkgdGhlIHZlcnRzXHJcbiAgICAgICAgdmFyIG5ld1ZlcnRpY2VzID0gdmVydGljZXMgIT09IG51bGwgJiYgdmVydGljZXMgIT09IHZvaWQgMCA/IHZlcnRpY2VzIDogW107XHJcbiAgICAgICAgX3RoaXMudmVydGljZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5ub3JtYWxzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBfdGhpcy52ZXJ0aWNlcy5wdXNoKHZlYzJfMS5kZWZhdWx0LmNsb25lKG5ld1ZlcnRpY2VzW2ldKSk7XHJcbiAgICAgICAgICAgIF90aGlzLm5vcm1hbHMucHVzaCh2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZXNlIGFyZSBjYWxsZWQgaW4gdGhlIHNoYXBlIGNvbnN0cnVjdG9yLCBidXQgbmVlZCB0byBjYWxsIGFnYWluIGhlcmUgYmVjYXVzZSB2ZXJ0cyB3ZXJlbid0IHNldCB1cCB5ZXQhXHJcbiAgICAgICAgX3RoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgICAgICBfdGhpcy51cGRhdGVBcmVhKCk7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlTm9ybWFscygpO1xyXG4gICAgICAgIF90aGlzLmNlbnRlck9mTWFzcyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIGlmIChfdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJpYW5nbGVzKCk7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBjb252ZXhcclxuICAgICAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcclxuICAgICAgICBfdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZUFyZWEoKTtcclxuICAgICAgICBpZiAoX3RoaXMuYXJlYSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugd2luZGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENvbnZleC5wcm90b3R5cGUudXBkYXRlTm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHZlcnRpY2VzWyhpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsc1tpXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xyXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3QgYSBDb252ZXggb250byBhIHdvcmxkLW9yaWVudGVkIGF4aXNcclxuICAgICAqIEBtZXRob2QgcHJvamVjdE9udG9BeGlzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxBeGlzXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUucHJvamVjdE9udG9Mb2NhbEF4aXMgPSBmdW5jdGlvbiAobG9jYWxBeGlzLCByZXN1bHQpIHtcclxuICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5LCBtaW4gPSBJbmZpbml0eSwgdiwgdmFsdWUsIGxvY2FsQXhpcyA9IHRtcFZlYzE7XHJcbiAgICAgICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdiA9IHRoaXMudmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhbHVlID0gZG90KHYsIGxvY2FsQXhpcyk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluID4gbWF4KSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gbWluO1xyXG4gICAgICAgICAgICBtaW4gPSBtYXg7XHJcbiAgICAgICAgICAgIG1heCA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQsIG1pbiwgbWF4KTtcclxuICAgIH07XHJcbiAgICBDb252ZXgucHJvdG90eXBlLkNvbnZleHByb2plY3RPbnRvV29ybGRBeGlzID0gZnVuY3Rpb24gKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMucHJvamVjdE9udG9Mb2NhbEF4aXMobG9jYWxBeGlzLCByZXN1bHQpO1xyXG4gICAgICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcclxuICAgICAgICBpZiAoc2hhcGVBbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd29ybGRBeGlzID0gbG9jYWxBeGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyZXN1bHQsIHJlc3VsdFswXSArIG9mZnNldCwgcmVzdWx0WzFdICsgb2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgLnRyaWFuZ2xlcyBwcm9wZXJ0eVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVUcmlhbmdsZXNcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS51cGRhdGVUcmlhbmdsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBSZXdyaXRlIG9uIHBvbHlrIG5vdGF0aW9uLCBhcnJheSBvZiBudW1iZXJzXHJcbiAgICAgICAgdmFyIHBvbHlrVmVydHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICBwb2x5a1ZlcnRzLnB1c2godlswXSk7XHJcbiAgICAgICAgICAgIHBvbHlrVmVydHMucHVzaCh2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJpYW5ndWxhdGVcclxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gcG9seWtfMS5kZWZhdWx0LlRyaWFuZ3VsYXRlKHBvbHlrVmVydHMpO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgdHJpYW5nbGVzLCBhZGQgdGhlaXIgaW5lcnRpYSBjb250cmlidXRpb25zIHRvIElcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICB2YXIgaWQxID0gdHJpYW5nbGVzW2ldLCBpZDIgPSB0cmlhbmdsZXNbaSArIDFdLCBpZDMgPSB0cmlhbmdsZXNbaSArIDJdO1xyXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIHZhciBUID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcclxuICAgICAgICAgICAgVFswXSA9IGlkMTtcclxuICAgICAgICAgICAgVFsxXSA9IGlkMjtcclxuICAgICAgICAgICAgVFsyXSA9IGlkMztcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChUKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIC5jZW50ZXJPZk1hc3MgcHJvcGVydHkuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUNlbnRlck9mTWFzc1xyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUNlbnRlck9mTWFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsIHZlcnRzID0gdGhpcy52ZXJ0aWNlcywgY20gPSB0aGlzLmNlbnRlck9mTWFzcywgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsIGEgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYSwgYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19iLCBjID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2MsIGNlbnRyb2lkX3RpbWVzX21hc3MgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcztcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoY20sIDAsIDApO1xyXG4gICAgICAgIHZhciB0b3RhbEFyZWEgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sIGEgPSB2ZXJ0c1t0WzBdXSwgYiA9IHZlcnRzW3RbMV1dLCBjID0gdmVydHNbdFsyXV07XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNlbnRyb2lkKGNlbnRyb2lkLCBhLCBiLCBjKTtcclxuICAgICAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcclxuICAgICAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsIGIsIGMpO1xyXG4gICAgICAgICAgICB0b3RhbEFyZWEgKz0gbTtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGNlbnRyb2lkX3RpbWVzX21hc3MsIGNlbnRyb2lkLCBtKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKGNtLCBjbSwgY2VudHJvaWRfdGltZXNfbWFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGNtLCBjbSwgMSAvIHRvdGFsQXJlYSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ29udmV4LlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvMzQyODIyLW1vbWVudC1vZi1pbmVydGlhLW9mLWEtcG9seWdvbi0yZC9cclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZW5vbSA9IDAuMCwgbnVtZXIgPSAwLjAsIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBqID0gTiAtIDEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xyXG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHAwLCBwMSkpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGRvdChwMSwgcDEpICsgZG90KHAxLCBwMCkgKyBkb3QocDAsIHAwKTtcclxuICAgICAgICAgICAgZGVub20gKz0gYSAqIGI7XHJcbiAgICAgICAgICAgIG51bWVyICs9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoMS4wIC8gNi4wKSAqIChkZW5vbSAvIG51bWVyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIC5ib3VuZGluZ1JhZGl1cyBwcm9wZXJ0eVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsIHIyID0gMDtcclxuICAgICAgICBpZiAoIXZlcnRzIHx8IHZlcnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGwyID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChsMiA+IHIyKSB7XHJcbiAgICAgICAgICAgICAgICByMiA9IGwyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhcmVhIG9mIHRoZSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBwb2ludHMgYSwgYiwgYy4gVGhlIGFyZWEgaXMgcG9zaXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIsIG90aGVyd2lzZSBuZWdhdGl2ZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgdHJpYW5nbGVBcmVhXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBDb252ZXgudHJpYW5nbGVBcmVhID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSkgLSAoKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkpKSAqIDAuNTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgLmFyZWFcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQXJlYVxyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRpY2VzKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRyaWFuZ2xlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSwgYSA9IHZlcnRzW3RbMF1dLCBiID0gdmVydHNbdFsxXV0sIGMgPSB2ZXJ0c1t0WzJdXTtcclxuICAgICAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsIGIsIGMpO1xyXG4gICAgICAgICAgICB0aGlzLmFyZWEgKz0gbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUFBQkJcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAdG9kbzogYXBwcm94aW1hdGUgd2l0aCBhIGxvY2FsIEFBQkI/XHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLCBwb3NpdGlvbiwgYW5nbGUsIDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgcmF5U3RhcnQgPSBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQ7XHJcbiAgICAgICAgdmFyIHJheUVuZCA9IGludGVyc2VjdENvbnZleF9yYXlFbmQ7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENvbnZleF9ub3JtYWw7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICAvLyBUcmFuc2Zvcm0gdG8gbG9jYWwgc2hhcGUgc3BhY2VcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHJheS5mcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShyYXlFbmQsIHJheS50bywgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2YXIgbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgIXJlc3VsdC5zaG91bGRTdG9wKHJheSk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcTEgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHEyID0gdmVydGljZXNbKGkgKyAxKSAlIG5dO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihyYXlTdGFydCwgcmF5RW5kLCBxMSwgcTIpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBxMiwgcTEpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG5vcm1hbCwgbm9ybWFsLCAtTWF0aC5QSSAvIDIgKyBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnZleC5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2YXIgcjAgPSBwaWNfcjAsIHIxID0gcGljX3IxLCB2ZXJ0cyA9IHRoaXMudmVydGljZXMsIGxhc3RDcm9zcyA9IG51bGwsIG51bVZlcnRzID0gdmVydHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydHNbaSAlIG51bVZlcnRzXSwgdjEgPSB2ZXJ0c1soaSArIDEpICUgbnVtVmVydHNdO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyMCwgdjAsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyMSwgdjEsIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyMCwgcjEpO1xyXG4gICAgICAgICAgICBpZiAobGFzdENyb3NzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgICAgIGlmIChjcm9zcyAqIGxhc3RDcm9zcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnZleDtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udmV4O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgU2hhcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlcy4gTm90IHRvIGJlIHVzZWQgZGlyZWN0bHkuXHJcbiAgICAgKiBAY2xhc3MgU2hhcGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaWRdIE9wdGlvbmFsIC0gc3BlY2lmeSBhbiBJRCBmb3IgdGhpcyBzaGFwZS4gUG9zc2libHkgdXNlZnVsIGZvciByZXBsYWNpbmcgc2hhcGVzLiBDYXJlZnVsIHRvIGF2b2lkIGR1cGxpY2F0ZXMhXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlPXRydWVdXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbD1udWxsXVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMucG9zaXRpb25dXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbnNvcj1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50eXBlPTBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNoYXBlKHR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5LWxvY2FsIHBvc2l0aW9uIG9mIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5LWxvY2FsIGFuZ2xlIG9mIHRoZSBzaGFwZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgc2hhcGUuIE9uZSBvZjpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDx1bD5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfQ0lSQ0xFXCI+U2hhcGUuQ0lSQ0xFPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X1BBUlRJQ0xFXCI+U2hhcGUuUEFSVElDTEU8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfUExBTkVcIj5TaGFwZS5QTEFORTwvYT48L2xpPlxyXG4gICAgICAgICAqIDxsaT48YSBocmVmPVwiU2hhcGUuaHRtbCNwcm9wZXJ0eV9DT05WRVhcIj5TaGFwZS5DT05WRVg8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfTElORVwiPlNoYXBlLkxJTkU8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfQk9YXCI+U2hhcGUuQk9YPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0NBUFNVTEVcIj5TaGFwZS5DQVBTVUxFPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0hFSUdIVEZJRUxEXCI+U2hhcGUuSEVJR0hURklFTEQ8L2E+PC9saT5cclxuICAgICAgICAgKiA8L3VsPlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNoYXBlIG9iamVjdCBpZGVudGlmaWVyLiBSZWFkIG9ubHkuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxpc2lvbiBncm91cCB0aGF0IHRoaXMgc2hhcGUgYmVsb25ncyB0byAoYml0IG1hc2spLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYXVyZWxpZW5yaWJvbi5jb20vYmxvZy8yMDExLzA3L2JveDJkLXR1dG9yaWFsLWNvbGxpc2lvbi1maWx0ZXJpbmcvXCI+dGhpcyB0dXRvcmlhbDwvYT4uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkdyb3VwXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAvLyBTZXR1cCBiaXRzIGZvciBlYWNoIGF2YWlsYWJsZSBncm91cFxyXG4gICAgICAgICAqICAgICB2YXIgUExBWUVSID0gTWF0aC5wb3coMiwwKSxcclxuICAgICAgICAgKiAgICAgICAgIEVORU1ZID0gIE1hdGgucG93KDIsMSksXHJcbiAgICAgICAgICogICAgICAgICBHUk9VTkQgPSBNYXRoLnBvdygyLDIpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gUHV0IHNoYXBlcyBpbnRvIHRoZWlyIGdyb3Vwc1xyXG4gICAgICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XHJcbiAgICAgICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcclxuICAgICAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbkdyb3VwID0gRU5FTVk7XHJcbiAgICAgICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25Hcm91cCA9IEdST1VORDtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBBc3NpZ24gZ3JvdXBzIHRoYXQgZWFjaCBzaGFwZSBjb2xsaWRlIHdpdGguXHJcbiAgICAgICAgICogICAgIC8vIE5vdGUgdGhhdCB0aGUgcGxheWVycyBjYW4gY29sbGlkZSB3aXRoIGdyb3VuZCBhbmQgZW5lbWllcywgYnV0IG5vdCB3aXRoIG90aGVyIHBsYXllcnMuXHJcbiAgICAgICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XHJcbiAgICAgICAgICogICAgIHBsYXllcjJTaGFwZS5jb2xsaXNpb25NYXNrID0gRU5FTVkgfCBHUk9VTkQ7XHJcbiAgICAgICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgR1JPVU5EO1xyXG4gICAgICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEVORU1ZO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gSG93IGNvbGxpc2lvbiBjaGVjayBpcyBkb25lXHJcbiAgICAgICAgICogICAgIGlmKHNoYXBlQS5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQi5jb2xsaXNpb25NYXNrKSE9MCAmJiAoc2hhcGVCLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVBLmNvbGxpc2lvbk1hc2spIT0wKXtcclxuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSBzaGFwZXMgd2lsbCBjb2xsaWRlXHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcmVhIG9mIHRoaXMgc2hhcGUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFyZWFcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IDA7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFuZ2xlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5pZCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKytTaGFwZS5pZENvdW50ZXI7XHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25Hcm91cCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMTtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbGxpc2lvblJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25NYXNrKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAxO1xyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF0ZXJpYWw7XHJcbiAgICAgICAgdGhpcy5zZW5zb3IgPSAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Vuc29yKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVBcmVhKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBzaGFwZS5cclxuICAgICAqIEBtZXRob2QgcG9pbnRUZXN0XHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBsb2NhbFBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBTaGFwZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHsgcmV0dXJuIGZhbHNlOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSB3b3JsZCBwb2ludCB0byBsb2NhbCBzaGFwZSBzcGFjZSAoYXNzdW1lZCB0aGUgc2hhcGUgaXMgdHJhbnNmb3JtZWQgYnkgYm90aCBpdHNlbGYgYW5kIHRoZSBib2R5KS5cclxuICAgICAqIEBtZXRob2Qgd29ybGRQb2ludFRvTG9jYWxcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gd29ybGRQb2ludFxyXG4gICAgICovXHJcbiAgICBTaGFwZS5wcm90b3R5cGUud29ybGRQb2ludFRvTG9jYWwgPSBmdW5jdGlvbiAob3V0LCB3b3JsZFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHNoYXBlV29ybGRQb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xyXG4gICAgICAgIGlmICghYm9keSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShzaGFwZVdvcmxkUG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGJvZHkuYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChzaGFwZVdvcmxkUG9zaXRpb24sIHNoYXBlV29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgc2hhcGVXb3JsZFBvc2l0aW9uLCBib2R5LmFuZ2xlICsgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgU2hhcGUuaWRDb3VudGVyID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxyXG4gICAgICovXHJcbiAgICBTaGFwZS5DSVJDTEUgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gUEFSVElDTEVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuUEFSVElDTEUgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuUExBTkUgPSA0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ09OVkVYXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkNPTlZFWCA9IDg7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkxJTkUgPSAxNjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPWFxyXG4gICAgICovXHJcbiAgICBTaGFwZS5CT1ggPSAzMjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENBUFNVTEVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuQ0FQU1VMRSA9IDY0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gSEVJR0hURklFTERcclxuICAgICAqL1xyXG4gICAgU2hhcGUuSEVJR0hURklFTEQgPSAxMjg7XHJcbiAgICByZXR1cm4gU2hhcGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgIHNoYWxsb3dDbG9uZSA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJykuc2hhbGxvd0Nsb25lXHJcbi8vICwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy91dGlsc1wiKSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlXCIpKTtcclxudmFyIHNoYWxsb3dDbG9uZSA9IHV0aWxzXzEuZGVmYXVsdC5zaGFsbG93Q2xvbmU7XHJcbmZ1bmN0aW9uIGJveEkodywgaCkge1xyXG4gICAgcmV0dXJuIHcgKiBoICogKE1hdGgucG93KHcsIDIpICsgTWF0aC5wb3coaCwgMikpIC8gMTI7XHJcbn1cclxuZnVuY3Rpb24gc2VtaUEocikge1xyXG4gICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyhyLCAyKSAvIDI7XHJcbn1cclxuLy8gaHR0cDovL3d3dy5lZnVuZGEuY29tL21hdGgvYXJlYXMvQ2lyY2xlSGFsZi5jZm1cclxuZnVuY3Rpb24gc2VtaUkocikge1xyXG4gICAgcmV0dXJuICgoTWF0aC5QSSAvIDQpIC0gKDggLyAoOSAqIE1hdGguUEkpKSkgKiBNYXRoLnBvdyhyLCA0KTtcclxufVxyXG5mdW5jdGlvbiBzZW1pQyhyKSB7XHJcbiAgICByZXR1cm4gKDQgKiByKSAvICgzICogTWF0aC5QSSk7XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2Vjb25kX21vbWVudF9vZl9hcmVhI1BhcmFsbGVsX2F4aXNfdGhlb3JlbVxyXG5mdW5jdGlvbiBjYXBzdWxlQShsLCByKSB7XHJcbiAgICByZXR1cm4gbCAqIDIgKiByICsgTWF0aC5QSSAqIE1hdGgucG93KHIsIDIpO1xyXG59XHJcbmZ1bmN0aW9uIGNhcHN1bGVJKGwsIHIpIHtcclxuICAgIHZhciBkID0gbCAvIDIgKyBzZW1pQyhyKTtcclxuICAgIHJldHVybiBib3hJKGwsIDIgKiByKSArIDIgKiAoc2VtaUkocikgKyBzZW1pQShyKSAqIE1hdGgucG93KGQsIDIpKTtcclxufVxyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9oaXRQb2ludFdvcmxkID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDYXBzdWxlX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3kgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgQ2Fwc3VsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDYXBzdWxlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXBzdWxlIHNoYXBlLlxyXG4gICAgICogQGNsYXNzIENhcHN1bGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVuZ3RoPTFdIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzLCBleHRlbmRzIGFsb25nIHRoZSBYIGF4aXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIFJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGNhcHN1bGVTaGFwZSA9IG5ldyBDYXBzdWxlKHtcclxuICAgICAqICAgICAgICAgbGVuZ3RoOiAxLFxyXG4gICAgICogICAgICAgICByYWRpdXM6IDJcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKGNhcHN1bGVTaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENhcHN1bGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGVfMS5kZWZhdWx0LkNBUFNVTEUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICBfdGhpcy5yYWRpdXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ2Fwc3VsZS5cclxuICAgICAqIEBtZXRob2QgY29ucHV0ZU1vbWVudE9mSW5lcnRpYVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICogQHRvZG9cclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBodHRwOi8vd3d3LmVmdW5kYS5jb20vbWF0aC9hcmVhcy9yZWN0YW5nbGUuY2ZtXHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cywgbCA9IHRoaXMubGVuZ3RoLCBhcmVhID0gY2Fwc3VsZUEobCwgcik7XHJcbiAgICAgICAgcmV0dXJuIChhcmVhID4gMCkgPyBjYXBzdWxlSShsLCByKSAvIGFyZWEgOiAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBDYXBzdWxlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXMgKyB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFyZWFcclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyArIHRoaXMucmFkaXVzICogMiAqIHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICAvLyBDb21wdXRlIGNlbnRlciBwb3NpdGlvbiBvZiBvbmUgb2YgdGhlIHRoZSBjaXJjbGVzLCB3b3JsZCBvcmllbnRlZCwgYnV0IHdpdGggbG9jYWwgb2Zmc2V0XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHIsIHRoaXMubGVuZ3RoIC8gMiwgMCk7XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShyLCByLCBhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBib3VuZHNcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQob3V0LnVwcGVyQm91bmQsIE1hdGgubWF4KHJbMF0gKyByYWRpdXMsIC1yWzBdICsgcmFkaXVzKSwgTWF0aC5tYXgoclsxXSArIHJhZGl1cywgLXJbMV0gKyByYWRpdXMpKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQob3V0Lmxvd2VyQm91bmQsIE1hdGgubWluKHJbMF0gLSByYWRpdXMsIC1yWzBdIC0gcmFkaXVzKSwgTWF0aC5taW4oclsxXSAtIHJhZGl1cywgLXJbMV0gLSByYWRpdXMpKTtcclxuICAgICAgICAvLyBBZGQgb2Zmc2V0XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIENhcHN1bGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIHRvID0gcmF5LnRvO1xyXG4gICAgICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0Q2Fwc3VsZV9oaXRQb2ludFdvcmxkO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDYXBzdWxlX25vcm1hbDtcclxuICAgICAgICB2YXIgbDAgPSBpbnRlcnNlY3RDYXBzdWxlX2wwO1xyXG4gICAgICAgIHZhciBsMSA9IGludGVyc2VjdENhcHN1bGVfbDE7XHJcbiAgICAgICAgLy8gVGhlIHNpZGVzXHJcbiAgICAgICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcclxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnJhZGl1cyAqIChpICogMiAtIDEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQobDAsIC1oYWxmTGVuLCB5KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwxLCBoYWxmTGVuLCB5KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShsMCwgbDAsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUobDEsIGwxLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihmcm9tLCB0bywgbDAsIGwxKTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIGludGVyc2VjdENhcHN1bGVfdW5pdF95LCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShub3JtYWwsIG5vcm1hbCwgKGkgKiAyIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENpcmNsZXNcclxuICAgICAgICB2YXIgZGlhZ29uYWxMZW5ndGhTcXVhcmVkID0gTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICsgTWF0aC5wb3coaGFsZkxlbiwgMik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwwLCBoYWxmTGVuICogKGkgKiAyIC0gMSksIDApO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnBvdyh0b1swXSAtIGZyb21bMF0sIDIpICsgTWF0aC5wb3codG9bMV0gLSBmcm9tWzFdLCAyKTtcclxuICAgICAgICAgICAgdmFyIGIgPSAyICogKCh0b1swXSAtIGZyb21bMF0pICogKGZyb21bMF0gLSBsMFswXSkgKyAodG9bMV0gLSBmcm9tWzFdKSAqIChmcm9tWzFdIC0gbDBbMV0pKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLnBvdyhmcm9tWzBdIC0gbDBbMF0sIDIpICsgTWF0aC5wb3coZnJvbVsxXSAtIGwwWzFdLCAyKSAtIE1hdGgucG93KHRoaXMucmFkaXVzLCAyKTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZGVsdGEsIG5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnYyYSA9IDEgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQxID0gKC1iIC0gc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQyID0gKC1iICsgc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQxID49IDAgJiYgZDEgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGQxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGhpdFBvaW50V29ybGQsIGwwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkMiA+PSAwICYmIGQyIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShoaXRQb2ludFdvcmxkLCBwb3NpdGlvbikgPiBkaWFnb25hbExlbmd0aFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMiwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSB0aGlzLmxlbmd0aCAqIDAuNTtcclxuICAgICAgICBpZiAoKE1hdGguYWJzKGxvY2FsUG9pbnRbMF0pIDw9IGhhbGZMZW5ndGggJiYgTWF0aC5hYnMobG9jYWxQb2ludFsxXSkgPD0gcmFkaXVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucG93KGxvY2FsUG9pbnRbMF0gLSBoYWxmTGVuZ3RoLCAyKSArIE1hdGgucG93KGxvY2FsUG9pbnRbMV0sIDIpIDw9IHJhZGl1cyAqIHJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucG93KGxvY2FsUG9pbnRbMF0gKyBoYWxmTGVuZ3RoLCAyKSArIE1hdGgucG93KGxvY2FsUG9pbnRbMV0sIDIpIDw9IHJhZGl1cyAqIHJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYXBzdWxlO1xyXG59KHNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDYXBzdWxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyB2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcclxuLy8gLCAgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZTtcclxudmFyIFNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2wwID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBIZWlnaHRmaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIZWlnaHRmaWVsZCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogSGVpZ2h0ZmllbGQgc2hhcGUgY2xhc3MuIEhlaWdodCBkYXRhIGlzIGdpdmVuIGFzIGFuIGFycmF5LiBUaGVzZSBkYXRhIHBvaW50cyBhcmUgc3ByZWFkIG91dCBldmVubHkgd2l0aCBhIGRpc3RhbmNlIFwiZWxlbWVudFdpZHRoXCIuXHJcbiAgICAgKiBAY2xhc3MgSGVpZ2h0ZmllbGRcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5oZWlnaHRzXSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluVmFsdWVdIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LiBXaWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IGdpdmVuLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRXaWR0aD0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXHJcbiAgICAgKiAgICAgdmFyIGhlaWdodHMgPSBbXTtcclxuICAgICAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcclxuICAgICAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcclxuICAgICAqICAgICAgICAgaGVpZ2h0cy5wdXNoKHkpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxyXG4gICAgICogICAgIHZhciBzaGFwZSA9IG5ldyBIZWlnaHRmaWVsZCh7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodHM6IGhlaWdodHMsXHJcbiAgICAgKiAgICAgICAgIGVsZW1lbnRXaWR0aDogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGRpcmVjdGlvblxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIEB0b2RvIFNob3VsZCB1c2UgYSBzY2FsZSBwcm9wZXJ0eSB3aXRoIFggYW5kIFkgZGlyZWN0aW9uIGluc3RlYWQgb2YganVzdCBlbGVtZW50V2lkdGhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSGVpZ2h0ZmllbGQob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTaGFwZV8xLmRlZmF1bHQuSEVJR0hURklFTEQsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhlaWdodHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5oZWlnaHRzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4IHZhbHVlIG9mIHRoZSBoZWlnaHRzXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubWF4VmFsdWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgaGVpZ2h0c1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1pblZhbHVlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVsZW1lbnRXaWR0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVsZW1lbnRXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuaGVpZ2h0cyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVpZ2h0cykgPyBvcHRpb25zLmhlaWdodHMuc2xpY2UoMCkgOiBbXTtcclxuICAgICAgICBfdGhpcy5lbGVtZW50V2lkdGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZWxlbWVudFdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLjE7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlQXJlYSgpO1xyXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heFZhbHVlKSAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pblZhbHVlKSkge1xyXG4gICAgICAgICAgICBfdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhWYWx1ZTtcclxuICAgICAgICAgICAgX3RoaXMubWluVmFsdWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlTWF4TWluVmFsdWVzKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIC5taW5WYWx1ZSBhbmQgdGhlIC5tYXhWYWx1ZVxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVNYXhNaW5WYWx1ZXNcclxuICAgICAqL1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heE1pblZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cztcclxuICAgICAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdO1xyXG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IGRhdGFbMF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAodiA+IG1heFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHYgPCBtaW5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWx1ZTtcclxuICAgICAgICB0aGlzLm1pblZhbHVlID0gbWluVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgfTtcclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gSW5maW5pdHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHMsIGFyZWEgPSAwO1xyXG4gICAgICAgIGlmICghZGF0YSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBhcmVhICs9IChkYXRhW2ldICsgZGF0YVtpICsgMV0pIC8gMiAqIHRoaXMuZWxlbWVudFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSxcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKClcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMF0sIDAsIHRoaXMubWF4VmFsdWUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMV0sIHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5oZWlnaHRzLmxlbmd0aCwgdGhpcy5tYXhWYWx1ZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHBvaW50c1syXSwgdGhpcy5lbGVtZW50V2lkdGggKiB0aGlzLmhlaWdodHMubGVuZ3RoLCB0aGlzLm1pblZhbHVlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocG9pbnRzWzNdLCAwLCB0aGlzLm1pblZhbHVlKTtcclxuICAgICAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBsaW5lIHNlZ21lbnQgaW4gdGhlIGhlaWdodGZpZWxkXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gc3RhcnQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzdGFydCBwb2ludFxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IGVuZCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIGVuZCBwb2ludFxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBpXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBpKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5lbGVtZW50V2lkdGg7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHN0YXJ0LCBpICogd2lkdGgsIGRhdGFbaV0pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlbmQsIChpICsgMSkgKiB3aWR0aCwgZGF0YVtpICsgMV0pO1xyXG4gICAgfTtcclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwb3NpdGlvblswXSAvIHRoaXMuZWxlbWVudFdpZHRoKTtcclxuICAgIH07XHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2xhbXBlZFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRTZWdtZW50SW5kZXgocG9zaXRpb24pO1xyXG4gICAgICAgIGkgPSBNYXRoLm1pbih0aGlzLmhlaWdodHMubGVuZ3RoLCBNYXRoLm1heChpLCAwKSk7IC8vIGNsYW1wXHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheVJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xyXG4gICAgICAgIHZhciB0byA9IHJheS50bztcclxuICAgICAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbDtcclxuICAgICAgICB2YXIgbDAgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMDtcclxuICAgICAgICB2YXIgbDEgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMTtcclxuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tO1xyXG4gICAgICAgIHZhciBsb2NhbFRvID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxUbztcclxuICAgICAgICAvLyBnZXQgbG9jYWwgcmF5IHN0YXJ0IGFuZCBlbmRcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxGcm9tLCBmcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFRvLCB0bywgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICAvLyBHZXQgdGhlIHNlZ21lbnQgcmFuZ2VcclxuICAgICAgICB2YXIgaTAgPSB0aGlzLmdldENsYW1wZWRTZWdtZW50SW5kZXgobG9jYWxGcm9tKTtcclxuICAgICAgICB2YXIgaTEgPSB0aGlzLmdldENsYW1wZWRTZWdtZW50SW5kZXgobG9jYWxUbyk7XHJcbiAgICAgICAgaWYgKGkwID4gaTEpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IGkwO1xyXG4gICAgICAgICAgICBpMCA9IGkxO1xyXG4gICAgICAgICAgICBpMSA9IHRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHNlZ21lbnRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZVNlZ21lbnQobDAsIGwxLCBpKTtcclxuICAgICAgICAgICAgdmFyIHQgPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsb2NhbEZyb20sIGxvY2FsVG8sIGwwLCBsMSk7XHJcbiAgICAgICAgICAgIGlmICh0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHdvcmxkTm9ybWFsLCBsMSwgbDApO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgYW5nbGUgKyBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCB3b3JsZE5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhlaWdodGZpZWxkO1xyXG59KFNoYXBlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBIZWlnaHRmaWVsZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZVxyXG4vLyAsICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xyXG52YXIgU2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciByYXljYXN0X25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF9sMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF9sMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmF5Y2FzdF91bml0X3kgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgTGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaW5lLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lIHNoYXBlIGNsYXNzLiBUaGUgbGluZSBzaGFwZSBpcyBhbG9uZyB0aGUgeCBkaXJlY3Rpb24sIGFuZCBzdHJldGNoZXMgZnJvbSBbLWxlbmd0aC8yLCAwXSB0byBbbGVuZ3RoLzIsMF0uXHJcbiAgICAgKiBAY2xhc3MgTGluZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MV0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIGxpbmVTaGFwZSA9IG5ldyBMaW5lKHtcclxuICAgICAqICAgICAgICAgbGVuZ3RoOiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShsaW5lU2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMaW5lKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgU2hhcGVfMS5kZWZhdWx0LkxJTkUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIG9mIHRoaXMgbGluZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICBfdGhpcy5sZW5ndGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMubGVuZ3RoLCAyKSAvIDEyO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIExpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdSYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbiAgICAgICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMF0sIC1sMiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHBvaW50c1sxXSwgbDIsIDApO1xyXG4gICAgICAgIG91dC5zZXRGcm9tUG9pbnRzKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBMaW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbTtcclxuICAgICAgICB2YXIgdG8gPSByYXkudG87XHJcbiAgICAgICAgdmFyIGwwID0gcmF5Y2FzdF9sMDtcclxuICAgICAgICB2YXIgbDEgPSByYXljYXN0X2wxO1xyXG4gICAgICAgIC8vIGdldCBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwwLCAtaGFsZkxlbiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwxLCBoYWxmTGVuLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwwLCBsMCwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwxLCBsMSwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2YXIgZnJhY3Rpb24gPSB2ZWMyXzEuZGVmYXVsdC5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihsMCwgbDEsIGZyb20sIHRvKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gcmF5Y2FzdF9ub3JtYWw7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIHJheWNhc3RfdW5pdF95LCBhbmdsZSk7IC8vIHRvZG86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiB3aGljaCBzaWRlIHRoZSByYXkgY29tZXMgZnJvbVxyXG4gICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gTGluZTtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGluZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZVxyXG4vLyAsICAgY29weSA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpLmNvcHk7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGNvcHkgPSB2ZWMyXzEuZGVmYXVsdC5jb3B5O1xyXG52YXIgUGFydGljbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGFydGljbGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxyXG4gICAgICogQGNsYXNzIFBhcnRpY2xlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIHNoYXBlID0gbmV3IFBhcnRpY2xlKCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBhcnRpY2xlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgU2hhcGVfMS5kZWZhdWx0LlBBUlRJQ0xFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24gLyosIGFuZ2xlKi8pIHtcclxuICAgICAgICBjb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICAgICAgY29weShvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHsgMTsgfTtcclxuICAgIHJldHVybiBQYXJ0aWNsZTtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFydGljbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb20gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdFBsYW5lX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0UGxhbmVfbGVuID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBQbGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQbGFuZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogUGxhbmUgc2hhcGUgY2xhc3MuIFRoZSBwbGFuZSBpcyBmYWNpbmcgaW4gdGhlIFkgZGlyZWN0aW9uLlxyXG4gICAgICogQGNsYXNzIFBsYW5lXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIHNoYXBlID0gbmV3IFBsYW5lKCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2hhcGVfMS5kZWZhdWx0LlBMQU5FLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7IC8vIFBsYW5lIGlzIGluZmluaXRlLiBUaGUgaW5lcnRpYSBzaG91bGQgdGhlcmVmb3JlIGJlIGluZmludHkgYnV0IGJ5IGNvbnZlbnRpb24gd2Ugc2V0IDAgaGVyZVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBJbmZpbml0eTtcclxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBQbGFuZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgYSA9IGFuZ2xlICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB2YXIgc2V0ID0gdmVjMl8xLmRlZmF1bHQuc2V0O1xyXG4gICAgICAgIHZhciBtYXggPSAxZTc7XHJcbiAgICAgICAgdmFyIGxvd2VyQm91bmQgPSBvdXQubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IG91dC51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vIFNldCBtYXggYm91bmRzXHJcbiAgICAgICAgc2V0KGxvd2VyQm91bmQsIC1tYXgsIC1tYXgpO1xyXG4gICAgICAgIHNldCh1cHBlckJvdW5kLCBtYXgsIG1heCk7XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8geSBnb2VzIGZyb20gLWluZiB0byAwXHJcbiAgICAgICAgICAgIHVwcGVyQm91bmRbMV0gPSBwb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gTWF0aC5QSSAvIDIpIHtcclxuICAgICAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcclxuICAgICAgICAgICAgbG93ZXJCb3VuZFswXSA9IHBvc2l0aW9uWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhID09PSBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIC8vIHkgZ29lcyBmcm9tIDAgdG8gaW5mXHJcbiAgICAgICAgICAgIGxvd2VyQm91bmRbMV0gPSBwb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gMyAqIE1hdGguUEkgLyAyKSB7XHJcbiAgICAgICAgICAgIC8vIHggZ29lcyBmcm9tIC1pbmYgdG8gMFxyXG4gICAgICAgICAgICB1cHBlckJvdW5kWzBdID0gcG9zaXRpb25bMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBsYW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYSA9IEluZmluaXR5O1xyXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIHRvID0gcmF5LnRvO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcclxuICAgICAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfbm9ybWFsO1xyXG4gICAgICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XHJcbiAgICAgICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChub3JtYWwsIDAsIDEpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxlbiwgZnJvbSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBwbGFuZVRvRnJvbSA9IHZlYzJfMS5kZWZhdWx0LmRvdChsZW4sIG5vcm1hbCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobGVuLCB0bywgcG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBwbGFuZVRvVG8gPSB2ZWMyXzEuZGVmYXVsdC5kb3QobGVuLCBub3JtYWwpO1xyXG4gICAgICAgIGlmIChwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApIHtcclxuICAgICAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGZyb20sIHRvKSA8IHBsYW5lVG9Gcm9tICogcGxhbmVUb0Zyb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbl9kb3RfZGlyID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChwbGFuZVBvaW50VG9Gcm9tLCBmcm9tLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHQgPSAtdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgcGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXIgLyByYXkubGVuZ3RoO1xyXG4gICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCBub3JtYWwsIC0xKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBQbGFuZS5wcm90b3R5cGUucG9pbnRUZXN0ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxQb2ludFsxXSA8PSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQbGFuZTtcclxufShzaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGxhbmU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zb2x2ZXJcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxuLy8gU2V0cyB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxyXG5mdW5jdGlvbiB1cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGludkR0KSB7XHJcbiAgICB2YXIgbCA9IGVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2xdO1xyXG4gICAgICAgIGVxLm11bHRpcGxpZXIgPSBlcS5sYW1iZGEgKiBpbnZEdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyYXRlRXF1YXRpb24oZXEpIHtcclxuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXHJcbiAgICB2YXIgQiA9IGVxLkIsIGVwcyA9IGVxLmVwc2lsb24sIGludkMgPSBlcS5pbnZDLCBsYW1iZGFqID0gZXEubGFtYmRhLCBHV2xhbWJkYSA9IGVxLmNvbXB1dGVHV2xhbWJkYSgpLCBtYXhGb3JjZV9kdCA9IGVxLm1heEZvcmNlRHQsIG1pbkZvcmNlX2R0ID0gZXEubWluRm9yY2VEdDtcclxuICAgIHZhciBkZWx0YWxhbWJkYSA9IGludkMgKiAoQiAtIEdXbGFtYmRhIC0gZXBzICogbGFtYmRhaik7XHJcbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxyXG4gICAgdmFyIGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA9IGxhbWJkYWogKyBkZWx0YWxhbWJkYTtcclxuICAgIGlmIChsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPCBtaW5Gb3JjZV9kdCkge1xyXG4gICAgICAgIGRlbHRhbGFtYmRhID0gbWluRm9yY2VfZHQgLSBsYW1iZGFqO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2VfZHQpIHtcclxuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlX2R0IC0gbGFtYmRhajtcclxuICAgIH1cclxuICAgIGVxLmxhbWJkYSArPSBkZWx0YWxhbWJkYTtcclxuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XHJcbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XHJcbn1cclxudmFyIEdTU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEdTU29sdmVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRpdmUgR2F1c3MtU2VpZGVsIGNvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBHU1NvbHZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBTb2x2ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTEwXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBHU1NvbHZlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgc29sdmVyXzEuZGVmYXVsdC5HUykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgICAgIF90aGlzLml0ZXJhdGlvbnMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXRlcmF0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XHJcbiAgICAgICAgX3RoaXMudG9sZXJhbmNlID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvbGVyYW5jZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWUtNztcclxuICAgICAgICBfdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZnJpY3Rpb25JdGVyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU29sdmUgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnNcclxuICAgICAqIEBtZXRob2Qgc29sdmVcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gIGggICAgICAgVGltZSBzdGVwXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gICB3b3JsZCAgICBXb3JsZCB0byBzb2x2ZVxyXG4gICAgICovXHJcbiAgICBHU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoaCwgd29ybGQpIHtcclxuICAgICAgICB0aGlzLnNvcnRFcXVhdGlvbnMoKTtcclxuICAgICAgICB2YXIgaXRlciA9IDAsIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLCBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucywgTmVxID0gZXF1YXRpb25zLmxlbmd0aCwgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlICogTmVxLCAyKSwgYm9kaWVzID0gd29ybGQuYm9kaWVzLCBOYm9kaWVzID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcclxuICAgICAgICBpZiAoTmVxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcclxuICAgICAgICAgICAgICAgIGIudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSAhPT0gTmVxOyBpXzErKykge1xyXG4gICAgICAgICAgICB2YXIgY18xID0gZXF1YXRpb25zW2lfMV07XHJcbiAgICAgICAgICAgIGNfMS5sYW1iZGEgPSAwO1xyXG4gICAgICAgICAgICBpZiAoY18xLnRpbWVTdGVwICE9PSBoIHx8IGNfMS5uZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgY18xLnRpbWVTdGVwID0gaDtcclxuICAgICAgICAgICAgICAgIGNfMS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjXzEuQiA9IGNfMS5jb21wdXRlQihjXzEuYSwgY18xLmIsIGgpO1xyXG4gICAgICAgICAgICBjXzEuaW52QyA9IGNfMS5jb21wdXRlSW52QyhjXzEuZXBzaWxvbik7XHJcbiAgICAgICAgICAgIGNfMS5tYXhGb3JjZUR0ID0gY18xLm1heEZvcmNlICogaDtcclxuICAgICAgICAgICAgY18xLm1pbkZvcmNlRHQgPSBjXzEubWluRm9yY2UgKiBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYywgZGVsdGFsYW1iZGFUb3QsIGo7XHJcbiAgICAgICAgaWYgKE5lcSAhPT0gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxyXG4gICAgICAgICAgICAgICAgYi5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhGcmljdGlvbkl0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb250YWN0IGVxdWF0aW9ucyB0byBnZXQgbm9ybWFsIGZvcmNlc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gaXRlcmF0ZUVxdWF0aW9uKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhbGFtYmRhVG90ICogZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIDEgLyBoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjb21wdXRlZCBmcmljdGlvbiBmb3JjZVxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXEgPSBlcXVhdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVxIGluc3RhbmNlb2YgZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayAhPT0gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXEubWF4Rm9yY2VEdCA9IGYgKiBoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcS5taW5Gb3JjZUR0ID0gLWYgKiBoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVxdWF0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGl0ZXIgPSAwOyBpdGVyICE9PSBtYXhJdGVyOyBpdGVyKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gTmVxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YWxhbWJkYSA9IGl0ZXJhdGVFcXVhdGlvbihjKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zKys7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLmFkZENvbnN0cmFpbnRWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgMSAvIGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gR1NTb2x2ZXI7XHJcbn0oc29sdmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBHU1NvbHZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG52YXIgU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNvbHZlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxyXG4gICAgICogQGNsYXNzIFNvbHZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsIHR5cGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gc29ydCBhbGwgZXF1YXRpb25zIGJlZm9yZSBlYWNoIHNvbHZlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvblNvcnRGdW5jdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbnxib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVxdWF0aW9uU29ydEZ1bmN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0IGFsbCBlcXVhdGlvbnMgdXNpbmcgdGhlIC5lcXVhdGlvblNvcnRGdW5jdGlvbi4gU2hvdWxkIGJlIGNhbGxlZCBieSBzdWJjbGFzc2VzIGJlZm9yZSBzb2x2aW5nLlxyXG4gICAgICogQG1ldGhvZCBzb3J0RXF1YXRpb25zXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUuc29ydEVxdWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBlcXVhdGlvbiB0byBiZSBzb2x2ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcclxuICAgICAqL1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uIChlcSkge1xyXG4gICAgICAgIGlmIChlcS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXFzXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24gKGVxcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gZXFzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgaWYgKGVxLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbiAoZXEpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YoZXEpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXVzcy1TZWlkZWwgc29sdmVyLlxyXG4gICAgICogQHByb3BlcnR5IEdTXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBTb2x2ZXIuR1MgPSAxO1xyXG4gICAgcmV0dXJuIFNvbHZlcjtcclxufShldmVudF9lbWl0dGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTb2x2ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbFwiKSk7XHJcbnZhciBjb250YWN0X2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uXCIpKTtcclxudmFyIENvbnRhY3RFcXVhdGlvblBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29udGFjdEVxdWF0aW9uUG9vbCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvblBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxyXG4gICAgICovXHJcbiAgICBDb250YWN0RXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb250YWN0X2VxdWF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25cclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvblBvb2x9XHJcbiAgICAgKi9cclxuICAgIENvbnRhY3RFcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcclxuICAgICAgICBlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29udGFjdEVxdWF0aW9uUG9vbDtcclxufShwb29sXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWN0RXF1YXRpb25Qb29sO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2xcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxudmFyIEZyaWN0aW9uRXF1YXRpb25Qb29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZyaWN0aW9uRXF1YXRpb25Qb29sLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRnJpY3Rpb25FcXVhdGlvblBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGZyaWN0aW9uX2VxdWF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge0ZyaWN0aW9uRXF1YXRpb259IGVxdWF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9uUG9vbH1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcclxuICAgICAgICBlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gRnJpY3Rpb25FcXVhdGlvblBvb2w7XHJcbn0ocG9vbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbFwiKSk7XHJcbnZhciBvdmVybGFwX2tlZXBlcl9yZWNvcmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vdmVybGFwLWtlZXBlci1yZWNvcmRcIikpO1xyXG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcmV0dXJuIHtPdmVybGFwS2VlcGVyUmVjb3JkfVxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgb3ZlcmxhcF9rZWVwZXJfcmVjb3JkXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge092ZXJsYXBLZWVwZXJSZWNvcmR9IHJlY29yZFxyXG4gICAgICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZFBvb2x9XHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIHJlY29yZC5zZXQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gT3ZlcmxhcEtlZXBlclJlY29yZFBvb2w7XHJcbn0ocG9vbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxhcEtlZXBlclJlY29yZFBvb2w7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVybGFwIGRhdGEgY29udGFpbmVyIGZvciB0aGUgT3ZlcmxhcEtlZXBlclxyXG4gICAgICogQGNsYXNzIE92ZXJsYXBLZWVwZXJSZWNvcmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XHJcbiAgICAgICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gT3ZlcmxhcEtlZXBlclJlY29yZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxhcEtlZXBlclJlY29yZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHR1cGxlX2RpY3Rpb25hcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90dXBsZS1kaWN0aW9uYXJ5XCIpKTtcclxudmFyIG92ZXJsYXBfa2VlcGVyX3JlY29yZF9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb3ZlcmxhcC1rZWVwZXItcmVjb3JkLXBvb2xcIikpO1xyXG52YXIgT3ZlcmxhcEtlZXBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2Ygb3ZlcmxhcHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBsYXN0IHN0ZXAgc3RhdGUuXHJcbiAgICAgKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XHJcbiAgICAgICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IG5ldyB0dXBsZV9kaWN0aW9uYXJ5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgdHVwbGVfZGljdGlvbmFyeV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLnJlY29yZFBvb2wgPSBuZXcgb3ZlcmxhcF9rZWVwZXJfcmVjb3JkX3Bvb2xfMS5kZWZhdWx0KHsgc2l6ZTogMTYgfSk7XHJcbiAgICAgICAgdGhpcy50bXBEaWN0ID0gbmV3IHR1cGxlX2RpY3Rpb25hcnlfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy50bXBBcnJheTEgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIC8vIFNhdmUgb2xkIG9iamVjdHMgaW50byBwb29sXHJcbiAgICAgICAgdmFyIGwgPSBsYXN0LmtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGxhc3Qua2V5c1tsXTtcclxuICAgICAgICAgICAgdmFyIGxhc3RPYmplY3QgPSBsYXN0LmdldEJ5S2V5KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChsYXN0T2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVjb3JkIGlzIG9ubHkgdXNlZCBpbiB0aGUgXCJsYXN0XCIgZGljdCwgYW5kIHdpbGwgYmUgcmVtb3ZlZC4gV2UgbWlnaHQgYXMgd2VsbCBwb29sIGl0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRQb29sLnJlbGVhc2UobGFzdE9iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcclxuICAgICAgICBsYXN0LnJlc2V0KCk7XHJcbiAgICAgICAgLy8gVHJhbnNmZXIgZnJvbSBuZXcgb2JqZWN0IHRvIG9sZFxyXG4gICAgICAgIGxhc3QuY29weShjdXJyZW50KTtcclxuICAgICAgICAvLyBDbGVhciBjdXJyZW50IG9iamVjdFxyXG4gICAgICAgIGN1cnJlbnQucmVzZXQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgY29udGFjdCBzdGF0ZVxyXG4gICAgICAgIGlmICghY3VycmVudC5nZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWNvcmRQb29sLmdldCgpO1xyXG4gICAgICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcclxuICAgICAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdPdmVybGFwcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kT3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHR3byBib2RpZXMgYXJlIGN1cnJlbnRseSBvdmVybGFwcGluZy5cclxuICAgICAqIEBtZXRob2QgYm9kaWVzQXJlT3ZlcmxhcHBpbmdcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuYm9kaWVzQXJlT3ZlcmxhcHBpbmcgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xyXG4gICAgICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICgoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RGlmZiA9IGZ1bmN0aW9uIChkaWN0QSwgZGljdEIsIHJlc3VsdCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGxhc3QgPSBkaWN0QTtcclxuICAgICAgICB2YXIgY3VycmVudCA9IGRpY3RCO1xyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBjdXJyZW50LmtleXNbbF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gY3VycmVudC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgJyArIGtleSArICcgaGFkIG5vIGRhdGEhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxhc3REYXRhID0gbGFzdC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgIGlmICghbGFzdERhdGEpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuaXNOZXdPdmVybGFwID0gZnVuY3Rpb24gKHNoYXBlQSwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcclxuICAgICAgICAvLyBOb3QgaW4gbGFzdCBidXQgaW4gbmV3XHJcbiAgICAgICAgcmV0dXJuICFsYXN0LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCkgJiYgISFjdXJyZW50LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3Qm9keU92ZXJsYXBzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kQm9keU92ZXJsYXBzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0Qm9keURpZmYgPSBmdW5jdGlvbiAob3ZlcmxhcHMsIHJlc3VsdCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcclxuICAgICAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XHJcbiAgICAgICAgdmFyIGwgPSBvdmVybGFwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG92ZXJsYXBzW2xdO1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSB1c2UgYm9keSBpZCdzIGZvciB0aGUgYWNjdW11bGF0b3IsIHRoZXNlIHdpbGwgYmUgYSBzdWJzZXQgb2YgdGhlIG9yaWdpbmFsIG9uZVxyXG4gICAgICAgICAgICBhY2N1bXVsYXRvci5zZXQoZGF0YS5ib2R5QS5pZCB8IDAsIGRhdGEuYm9keUIuaWQgfCAwLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCA9IGFjY3VtdWxhdG9yLmtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEuYm9keUEpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5ib2R5Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYWNjdW11bGF0b3IucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPdmVybGFwS2VlcGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPdmVybGFwS2VlcGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUG9vbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogT2JqZWN0IHBvb2xpbmcgdXRpbGl0eS5cclxuICAgICAqIEBjbGFzcyBQb29sXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG9vbChvcHRpb25zKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gb2JqZWN0c1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByZXNpemVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICAgKiBAcmV0dXJuIHtQb29sfSBTZWxmLCBmb3IgY2hhaW5pbmdcclxuICAgICAqL1xyXG4gICAgUG9vbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcclxuICAgICAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChvYmplY3RzLmxlbmd0aCA8IHNpemUpIHtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHRoaXMuY3JlYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbiBvYmplY3QgZnJvbSB0aGUgcG9vbCBvciBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBQb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdHMubGVuZ3RoID8gb2JqZWN0cy5wb3AoKSA6IHRoaXMuY3JlYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBhbmQgcHV0IHRoZSBvYmplY3QgYmFjayBpbnRvIHRoZSBwb29sIGZvciBsYXRlciB1c2UuXHJcbiAgICAgKiBAbWV0aG9kIHJlbGVhc2VcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcclxuICAgICAqIEByZXR1cm4ge1Bvb2x9IFNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgKi9cclxuICAgIFBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KG9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2gob2JqZWN0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9vbDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUG9vbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xyXG52YXIgVHVwbGVEaWN0aW9uYXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcclxuICAgICAgICAgKiBAcHJvcGVydHkgZGF0YVxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgdXNlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBrZXlzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEga2V5IGdpdmVuIHR3byBpbnRlZ2Vyc1xyXG4gICAgICogQG1ldGhvZCBnZXRLZXlcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGlkMSwgaWQyKSB7XHJcbiAgICAgICAgaWYgKChpZDEpID09PSAoaWQyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZhbGlkIGZvciB2YWx1ZXMgPCAyXjE2XHJcbiAgICAgICAgcmV0dXJuICgoaWQxKSA+IChpZDIpID9cclxuICAgICAgICAgICAgKGlkMSA8PCAxNikgfCAoaWQyICYgMHhGRkZGKSA6XHJcbiAgICAgICAgICAgIChpZDIgPDwgMTYpIHwgKGlkMSAmIDB4RkZGRikpIHwgMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZ2V0QnlLZXlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0ga2V5XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAga2V5ID0ga2V5O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZ2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0galxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmdldEtleShpLCBqKV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSB2YWx1ZS5cclxuICAgICAqIEBtZXRob2Qgc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0galxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIFR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGksIGosIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRhW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBkYXRhLlxyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLCBrZXlzID0gdGhpcy5rZXlzO1xyXG4gICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YVtrZXlzW2xdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5cy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29weSBhbm90aGVyIFR1cGxlRGljdGlvbmFyeS4gTm90ZSB0aGF0IGFsbCBkYXRhIGluIHRoaXMgZGljdGlvbmFyeSB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAbWV0aG9kIGNvcHlcclxuICAgICAqIEBwYXJhbSB7VHVwbGVEaWN0aW9uYXJ5fSBkaWN0IFRoZSBUdXBsZURpY3Rpb25hcnkgdG8gY29weSBpbnRvIHRoaXMgb25lLlxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZGljdCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkodGhpcy5rZXlzLCBkaWN0LmtleXMpO1xyXG4gICAgICAgIHZhciBsID0gZGljdC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBkaWN0LmtleXNbbF07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGljdC5kYXRhW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBUdXBsZURpY3Rpb25hcnk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFR1cGxlRGljdGlvbmFyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogZ2xvYmFsIFAyX0FSUkFZX1RZUEUgKi9cclxuLyoqXHJcbiAqIE1pc2MgdXRpbGl0eSBmdW5jdGlvbnNcclxuICovXHJcbnZhciBVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFV0aWxzKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmQgdGhlIHZhbHVlcyBpbiBhcnJheSBiIHRvIHRoZSBhcnJheSBhLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM3NDEyNi9ob3ctdG8tYXBwZW5kLWFuLWFycmF5LXRvLWFuLWV4aXN0aW5nLWphdmFzY3JpcHQtYXJyYXkvMTM3NDEzMSMxMzc0MTMxXCI+dGhpczwvYT4gZm9yIGFuIGV4cGxhbmF0aW9uLlxyXG4gICAgICogQG1ldGhvZCBhcHBlbmRBcnJheVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGIubGVuZ3RoOyBpICE9PSBsZW47ICsraSkge1xyXG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2FyYmFnZSBmcmVlIEFycmF5LnNwbGljZSgpLiBEb2VzIG5vdCBhbGxvY2F0ZSBhIG5ldyBhcnJheS5cclxuICAgICAqIEBtZXRob2Qgc3BsaWNlXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaG93bWFueVxyXG4gICAgICovXHJcbiAgICBVdGlscy5wcm90b3R5cGUuc3BsaWNlID0gZnVuY3Rpb24gKGFycmF5LCBpbmRleCwgaG93bWFueSkge1xyXG4gICAgICAgIGhvd21hbnkgPSBob3dtYW55IHx8IDE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4LCBsZW4gPSBhcnJheS5sZW5ndGggLSBob3dtYW55OyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgaG93bWFueV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFycmF5Lmxlbmd0aCA9IGxlbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXksIGlmIHRoZSBhcnJheSBjb250YWlucyB0aGUgZWxlbWVudC5cclxuICAgICAqIEBtZXRob2QgYXJyYXlSZW1vdmVcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5hcnJheVJlbW92ZSA9IGZ1bmN0aW9uIChhcnJheSwgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGFycmF5LCBpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBhbm90aGVyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGJcclxuICAgICAqL1xyXG4gICAgVXRpbHMucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGIpIHtcclxuICAgICAgICAgICAgYVtrZXldID0gYltrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0LiBSZXR1cm5zIGEgbmV3IG9iamVjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIGlucHV0IGluc3RhbmNlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzaGFsbG93Q2xvbmVcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb2JqXHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5zaGFsbG93Q2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXh0ZW5kKG5ld09iaiwgb2JqKTtcclxuICAgICAgICByZXR1cm4gbmV3T2JqO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVdGlscztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFV0aWxzKCk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbmlvbkZpbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFdlaWdodGVkIFF1aWNrIFVuaW9uLUZpbmQgd2l0aCBQYXRoIENvbXByZXNzaW9uLiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vanV6ZXJhbGkvdW5pb25maW5kLCBidXQgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cclxuICAgICAqIEBjbGFzcyBVbmlvbkZpbmRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVW5pb25GaW5kKHNpemUpIHtcclxuICAgICAgICB0aGlzLmlkID0gW107XHJcbiAgICAgICAgdGhpcy5zeiA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgZGlzdGluY3QgZ3JvdXBzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb3VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBzaXplO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBVbmlvbkZpbmQgZGF0YSBzdHJ1Y3R1cmUgd2l0aCBudW1iZXIgb2YgZGlzdGluY3QgZ3JvdXBzIHRvIGJlZ2luIHdpdGguIEVhY2ggZ3JvdXAgd2lsbCBiZSByZWZlcnJlZCB0byBhcyBpbmRleCBvZiB0aGUgYXJyYXkgb2Ygc2l6ZSBzaXplIHN0YXJ0aW5nIGF0IDAuXHJcbiAgICAgKiBAbWV0aG9kIHJlc2l6ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcclxuICAgICAqL1xyXG4gICAgVW5pb25GaW5kLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHZhciBzeiA9IHRoaXMuc3o7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZFtpXSA9IGk7XHJcbiAgICAgICAgICAgIHN6W2ldID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHJvb3QgKHZhbHVlKSBvZiB0aGUgZ3JvdXAgaW4gd2hpY2ggcCBpcy5cclxuICAgICAqIEBtZXRob2QgZmluZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBcclxuICAgICAqL1xyXG4gICAgVW5pb25GaW5kLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xyXG4gICAgICAgIHdoaWxlIChwICE9PSBpZFtwXSkge1xyXG4gICAgICAgICAgICBpZFtwXSA9IGlkW2lkW3BdXTtcclxuICAgICAgICAgICAgcCA9IGlkW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgZWxlbWVudHMgaW4gZ3JvdXBzIHAgYW5kIHEgaW50byBhIHNpbmdsZSBncm91cC4gSW4gb3RoZXIgd29yZHMgY29ubmVjdCB0aGUgdHdvIGdyb3Vwcy5cclxuICAgICAqIEBtZXRob2QgdW5pb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcVxyXG4gICAgICovXHJcbiAgICBVbmlvbkZpbmQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKHAsIHEpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZmluZChwKSwgaiA9IHRoaXMuZmluZChxKTtcclxuICAgICAgICBpZiAoaSA9PT0gaikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeiA9IHRoaXMuc3o7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcclxuICAgICAgICBpZiAoc3pbaV0gPCBzeltqXSkge1xyXG4gICAgICAgICAgICBpZFtpXSA9IGo7XHJcbiAgICAgICAgICAgIHN6W2pdICs9IHN6W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWRbal0gPSBpO1xyXG4gICAgICAgICAgICBzeltpXSArPSBzeltqXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW5pb25GaW5kO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVbmlvbkZpbmQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBnc19zb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc29sdmVyL2dzLXNvbHZlclwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBzaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFwZXMvc2hhcGVcIikpO1xyXG52YXIgZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9ldmVudHMvZXZlbnQtZW1pdHRlclwiKSk7XHJcbnZhciBib2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL29iamVjdHMvYm9keVwiKSk7XHJcbnZhciBtYXRlcmlhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRlcmlhbC9tYXRlcmlhbFwiKSk7XHJcbnZhciBjb250YWN0X21hdGVyaWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWxcIikpO1xyXG52YXIgYWFiYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vYWFiYlwiKSk7XHJcbnZhciBzYXBfYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb2xsaXNpb24vc2FwLWJyb2FkcGhhc2VcIikpO1xyXG52YXIgbmFycm93cGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL25hcnJvd3BoYXNlXCIpKTtcclxudmFyIHV0aWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3V0aWxzXCIpKTtcclxuLy9pbXBvcnQgYXJyYXlSZW1vdmUgZnJvbSAgXCJheVJlbW9cIjsgLy8gR2V0IHJpZCBvZiB0aGlzIGRlcGVuZGVuY3khXHJcbnZhciBvdmVybGFwX2tlZXBlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9vdmVybGFwLWtlZXBlclwiKSk7XHJcbnZhciB1bmlvbl9maW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdW5pb24tZmluZFwiKSk7XHJcbi8vaW1wb3J0IGYzMiBmcm9tIFwiZjMyXCI7XHJcbi8qKlxyXG4gKiBGaXJlZCBhZnRlciB0aGUgc3RlcCgpLlxyXG4gKiBAZXZlbnQgcG9zdFN0ZXBcclxuICovXHJcbnZhciBwb3N0U3RlcEV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJwb3N0U3RlcFwiXHJcbn07XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgYm9keSBpcyBhZGRlZCB0byB0aGUgd29ybGQuXHJcbiAqIEBldmVudCBhZGRCb2R5XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gKi9cclxudmFyIEFkZEJvZHlFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkZEJvZHlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImFkZEJvZHlcIjtcclxuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFkZEJvZHlFdmVudDtcclxufSgpKTtcclxudmFyIGFkZEJvZHlFdmVudCA9IG5ldyBBZGRCb2R5RXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXHJcbiAqIEBldmVudCByZW1vdmVCb2R5XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gKi9cclxudmFyIFJlbW92ZUJvZHlFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlbW92ZUJvZHlFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInJlbW92ZUJvZHlcIjtcclxuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlbW92ZUJvZHlFdmVudDtcclxufSgpKTtcclxudmFyIHJlbW92ZUJvZHlFdmVudCA9IG5ldyBSZW1vdmVCb2R5RXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBzcHJpbmcgaXMgYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gKiBAZXZlbnQgYWRkU3ByaW5nXHJcbiAqIEBwYXJhbSB7U3ByaW5nfSBzcHJpbmdcclxuICovXHJcbnZhciBBZGRTcHJpbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkZFNwcmluZ0V2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiYWRkU3ByaW5nXCI7XHJcbiAgICAgICAgdGhpcy5zcHJpbmcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFkZFNwcmluZ0V2ZW50O1xyXG59KCkpO1xyXG52YXIgYWRkU3ByaW5nRXZlbnQgPSBuZXcgQWRkU3ByaW5nRXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXHJcbiAqIEBldmVudCBpbXBhY3RcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAqIEBkZXByZWNhdGVkIEltcGFjdCBldmVudCB3aWxsIGJlIHJlbW92ZWQuIFVzZSBiZWdpbkNvbnRhY3QgaW5zdGVhZC5cclxuICovXHJcbnZhciBJbXBhY3RFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEltcGFjdEV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiaW1wYWN0XCI7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib2R5QiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFwZUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSW1wYWN0RXZlbnQ7XHJcbn0oKSk7XHJcbnZhciBpbXBhY3RFdmVudCA9IG5ldyBJbXBhY3RFdmVudCgpO1xyXG4vKipcclxuICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxyXG4gKiBJbnNpZGUgdGhlIGV2ZW50IGhhbmRsZXIsIHlvdSBjYW4gbW9kaWZ5IHRoZSBwYWlycyBhcnJheSBhcyB5b3UgbGlrZSwgdG9cclxuICogcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gb2JqZWN0cyB0aGF0IHlvdSBkb24ndCB3YW50LlxyXG4gKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcclxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQW4gYXJyYXkgb2YgY29sbGlzaW9uIHBhaXJzLiBJZiB0aGlzIGFycmF5IGlzIFtib2R5MSxib2R5Mixib2R5Myxib2R5NF0sIHRoZW4gdGhlIGJvZHkgcGFpcnMgMSwyIGFuZCAzLDQgd291bGQgYWR2YW5jZSB0byBuYXJyb3dwaGFzZS5cclxuICovXHJcbnZhciBQb3N0QnJvYWRwaGFzZUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9zdEJyb2FkcGhhc2VFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInBvc3RCcm9hZHBoYXNlXCI7XHJcbiAgICAgICAgdGhpcy5wYWlycyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUG9zdEJyb2FkcGhhc2VFdmVudDtcclxufSgpKTtcclxudmFyIHBvc3RCcm9hZHBoYXNlRXZlbnQgPSBuZXcgUG9zdEJyb2FkcGhhc2VFdmVudDtcclxudmFyIEJlZ2luQ29udGFjdEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmVnaW5Db250YWN0RXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJiZWdpbkNvbnRhY3RcIjtcclxuICAgICAgICB0aGlzLnNoYXBlQSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFwZUIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJlZ2luQ29udGFjdEV2ZW50O1xyXG59KCkpO1xyXG4vKipcclxuICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0YXJ0cyBzdGFydCB0byBvdmVybGFwLiBGaXJlZCBpbiB0aGUgbmFycm93cGhhc2UsIGR1cmluZyBzdGVwLlxyXG4gKiBAZXZlbnQgYmVnaW5Db250YWN0XHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUJcclxuICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xyXG4gKi9cclxudmFyIGJlZ2luQ29udGFjdEV2ZW50ID0gbmV3IEJlZ2luQ29udGFjdEV2ZW50KCk7XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RvcCBvdmVybGFwcGluZywgYWZ0ZXIgdGhlIG5hcnJvd3BoYXNlIChkdXJpbmcgc3RlcCkuXHJcbiAqIEBldmVudCBlbmRDb250YWN0XHJcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSAgYm9keUJcclxuICovXHJcbnZhciBlbmRDb250YWN0RXZlbnQgPSB7XHJcbiAgICB0eXBlOiBcImVuZENvbnRhY3RcIixcclxuICAgIHNoYXBlQTogbnVsbCxcclxuICAgIHNoYXBlQjogbnVsbCxcclxuICAgIGJvZHlBOiBudWxsLFxyXG4gICAgYm9keUI6IG51bGxcclxufTtcclxudmFyIGhpdFRlc3RfdG1wMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBoaXRUZXN0X3RtcDIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuLyoqXHJcbiAqIEZpcmVkIGp1c3QgYmVmb3JlIGVxdWF0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNvbHZlciB0byBiZSBzb2x2ZWQuIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hhdCBlcXVhdGlvbnMgZ29lcyBpbnRvIHRoZSBzb2x2ZXIuXHJcbiAqIEBldmVudCBwcmVTb2x2ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zICBBbiBhcnJheSBvZiBjb250YWN0cyB0byBiZSBzb2x2ZWQuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGZyaWN0aW9uRXF1YXRpb25zIEFuIGFycmF5IG9mIGZyaWN0aW9uIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQuXHJcbiAqL1xyXG52YXIgUHJlU29sdmVFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByZVNvbHZlRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcmVTb2x2ZVwiO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJlU29sdmVFdmVudDtcclxufSgpKTtcclxudmFyIHByZVNvbHZlRXZlbnQgPSBuZXcgUHJlU29sdmVFdmVudCgpO1xyXG5mdW5jdGlvbiBzb3J0Qm9kaWVzQnlJc2xhbmQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEuaXNsYW5kSWQgLSBiLmlzbGFuZElkO1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRFcXVhdGlvbnNCeUlzbGFuZChlcXVhdGlvbkEsIGVxdWF0aW9uQikge1xyXG4gICAgaWYgKCEoZXF1YXRpb25BID09PSBudWxsIHx8IGVxdWF0aW9uQSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXF1YXRpb25BLmJvZHlBKSB8fCAhKGVxdWF0aW9uQSA9PT0gbnVsbCB8fCBlcXVhdGlvbkEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVxdWF0aW9uQS5ib2R5QikgfHwgIShlcXVhdGlvbkIgPT09IG51bGwgfHwgZXF1YXRpb25CID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcXVhdGlvbkIuYm9keUEpIHx8ICEoZXF1YXRpb25CID09PSBudWxsIHx8IGVxdWF0aW9uQiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXF1YXRpb25CLmJvZHlCKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBpc2xhbmRBID0gZXF1YXRpb25BLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uQS5ib2R5QS5pc2xhbmRJZCA6IGVxdWF0aW9uQS5ib2R5Qi5pc2xhbmRJZDtcclxuICAgIHZhciBpc2xhbmRCID0gZXF1YXRpb25CLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uQi5ib2R5QS5pc2xhbmRJZCA6IGVxdWF0aW9uQi5ib2R5Qi5pc2xhbmRJZDtcclxuICAgIGlmIChpc2xhbmRBICE9PSBpc2xhbmRCKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzbGFuZEEgLSBpc2xhbmRCO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU29ydCBieSBlcXVhdGlvbiB0eXBlIGlmIHNhbWUgaXNsYW5kXHJcbiAgICAgICAgcmV0dXJuIGVxdWF0aW9uQS5pbmRleCAtIGVxdWF0aW9uQi5pbmRleDtcclxuICAgIH1cclxufVxyXG4vLyBXaHkgbm90IGp1c3QgbWFrZSB0aGlzIGEgcHJpdmF0ZSBtZXRob2QgaW4gd29ybGQ/XHJcbi8vIFdoYXQgYXJlIGFsbCB0aGVzZSBwcm9wcz8/P1xyXG5mdW5jdGlvbiBydW5OYXJyb3dwaGFzZSh3b3JsZCwgbnAsIGJpLCBzaSwgeGksIGFpLCBiaiwgc2osIHhqLCBhaiwgY20sIGdsZW4pIHtcclxuICAgIHZhciB4aXcgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgIHZhciB4ancgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXHJcbiAgICBpZiAoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgd29ybGQgcG9zaXRpb24gYW5kIGFuZ2xlIG9mIGVhY2ggc2hhcGVcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoeGl3LCB4aSwgYmkucG9zaXRpb24sIGJpLmFuZ2xlKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoeGp3LCB4aiwgYmoucG9zaXRpb24sIGJqLmFuZ2xlKTtcclxuICAgIGlmICh2ZWMyXzEuZGVmYXVsdC5kaXN0YW5jZSh4aXcsIHhqdykgPiBzaS5ib3VuZGluZ1JhZGl1cyArIHNqLmJvdW5kaW5nUmFkaXVzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XHJcbiAgICB2YXIgYWp3ID0gYWogKyBiai5hbmdsZTtcclxuICAgIG5wLmVuYWJsZUZyaWN0aW9uID0gY20uZnJpY3Rpb24gPiAwO1xyXG4gICAgdmFyIHJlZHVjZWRNYXNzO1xyXG4gICAgaWYgKGJpLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LlNUQVRJQyB8fCBiaS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5LSU5FTUFUSUMpIHtcclxuICAgICAgICByZWR1Y2VkTWFzcyA9IGJqLm1hc3M7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiai50eXBlID09PSBib2R5XzEuZGVmYXVsdC5TVEFUSUMgfHwgYmoudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuS0lORU1BVElDKSB7XHJcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiaS5tYXNzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAoYmkubWFzcyAqIGJqLm1hc3MpIC8gKGJpLm1hc3MgKyBiai5tYXNzKTtcclxuICAgIH1cclxuICAgIG5wLnNsaXBGb3JjZSA9IGNtLmZyaWN0aW9uICogZ2xlbiAqIHJlZHVjZWRNYXNzO1xyXG4gICAgbnAuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IGNtO1xyXG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xyXG4gICAgdmFyIHNlbnNvciA9IHNpLnNlbnNvciB8fCBzai5zZW5zb3I7XHJcbiAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XHJcbiAgICB2YXIgbnVtQ29udGFjdHMgPSBucC50ZXN0Q29udGFjdChiaSwgc2ksIHhpdywgYmosIHNqLCB4ancsIHNlbnNvcik7XHJcbiAgICB2YXIgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggLSBudW1GcmljdGlvbkJlZm9yZTtcclxuICAgIGlmIChudW1Db250YWN0cykge1xyXG4gICAgICAgIGlmIChiaS5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJpLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmoudHlwZSAhPT0gYm9keV8xLmRlZmF1bHQuU1RBVElDKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChiai52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiai5hbmd1bGFyVmVsb2NpdHksIDIpO1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRCID0gTWF0aC5wb3coYmouc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCICogMikge1xyXG4gICAgICAgICAgICAgICAgYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiai5hbGxvd1NsZWVwICYmXHJcbiAgICAgICAgICAgIGJqLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgJiZcclxuICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiZcclxuICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuQVdBS0UgJiZcclxuICAgICAgICAgICAgYmkudHlwZSAhPT0gYm9keV8xLmRlZmF1bHQuU1RBVElDKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChiaS52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiaS5hbmd1bGFyVmVsb2NpdHksIDIpO1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LCAyKTtcclxuICAgICAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBICogMikge1xyXG4gICAgICAgICAgICAgICAgYmouX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdvcmxkLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xyXG4gICAgICAgIGlmICh3b3JsZC5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHdvcmxkLm92ZXJsYXBLZWVwZXIuaXNOZXdPdmVybGFwKHNpLCBzaikpIHtcclxuICAgICAgICAgICAgLy8gUmVwb3J0IG5ldyBzaGFwZSBvdmVybGFwXHJcbiAgICAgICAgICAgIHZhciBlID0gYmVnaW5Db250YWN0RXZlbnQ7XHJcbiAgICAgICAgICAgIGUuc2hhcGVBID0gc2k7XHJcbiAgICAgICAgICAgIGUuc2hhcGVCID0gc2o7XHJcbiAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcclxuICAgICAgICAgICAgZS5ib2R5QiA9IGJqO1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xyXG4gICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgaWYgKCFzZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIG51bUNvbnRhY3RzOyBpIDwgbnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5wdXNoKG5wLmNvbnRhY3RFcXVhdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdvcmxkLmVtaXQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRpdmlkZSB0aGUgbWF4IGZyaWN0aW9uIGZvcmNlIGJ5IHRoZSBudW1iZXIgb2YgY29udGFjdHNcclxuICAgICAgICBpZiAoIXNlbnNvciAmJiBudW1GcmljdGlvbkVxdWF0aW9ucyA+IDEpIHsgLy8gV2h5IGRpdmlkZSBieSAxP1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIC0gbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGkgPCBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBucC5mcmljdGlvbkVxdWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGYuc2V0U2xpcEZvcmNlKGYuZ2V0U2xpcEZvcmNlKCkgLyBudW1GcmljdGlvbkVxdWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0R2xvYmFsRXF1YXRpb25QYXJhbXMod29ybGQsIHBhcmFtcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IHdvcmxkLmNvbnN0cmFpbnRzO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcclxuICAgICAgICB2YXIgZXFzID0gYy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGVxcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbal07XHJcbiAgICAgICAgICAgIGVxLnJlbGF4YXRpb24gPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucmVsYXhhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXEucmVsYXhhdGlvbjtcclxuICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gKF9iID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnN0aWZmbmVzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXEuc3RpZmZuZXNzO1xyXG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBXb3JsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXb3JsZCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGR5bmFtaWNzIHdvcmxkLCB3aGVyZSBhbGwgYm9kaWVzIGFuZCBjb25zdHJhaW50cyBsaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBXb3JsZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge1NvbHZlcn0gW29wdGlvbnMuc29sdmVyXSBEZWZhdWx0cyB0byBHU1NvbHZlci5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmdyYXZpdHldIERlZmF1bHRzIHRvIHk9LTkuNzguXHJcbiAgICAgKiBAcGFyYW0ge0Jyb2FkcGhhc2V9IFtvcHRpb25zLmJyb2FkcGhhc2VdIERlZmF1bHRzIHRvIFNBUEJyb2FkcGhhc2VcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNsYW5kU3BsaXQ9dHJ1ZV1cclxuICAgICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKHtcclxuICAgICAqICAgICAgICAgZ3Jhdml0eTogWzAsIC0xMF0sXHJcbiAgICAgKiAgICAgICAgIGJyb2FkcGhhc2U6IG5ldyBTQVBCcm9hZHBoYXNlKClcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KG5ldyBCb2R5KCkpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBXb3JsZChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIHNwcmluZ3MgaW4gdGhlIHdvcmxkLiBUbyBhZGQgYSBzcHJpbmcgdG8gdGhlIHdvcmxkLCB1c2Uge3sjY3Jvc3NMaW5rIFwiV29ybGQvYWRkU3ByaW5nOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzcHJpbmdzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNwcmluZ3MgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ib2RpZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlZCBib2R5IGNvbGxpc2lvbiBwYWlycy4gU2VlIHt7I2Nyb3NzTGluayBcIldvcmxkL2Rpc2FibGVCb2R5Q29sbGlzaW9uOm1ldGhvZFwifX0uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBkaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5hcnJvd3BoYXNlIHRvIHVzZSB0byBnZW5lcmF0ZSBjb250YWN0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxyXG4gICAgICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5uYXJyb3dwaGFzZSA9IG5ldyBuYXJyb3dwaGFzZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IGluIHRoZSB3b3JsZC4gVGhpcyBpcyBhcHBsaWVkIG9uIGFsbCBib2RpZXMgaW4gdGhlIGJlZ2lubmluZyBvZiBlYWNoIHN0ZXAoKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmdyYXZpdHkgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIC05Ljc4KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgdGhlIGZyaWN0aW9uIG1heCBmb3JjZSAobXUqbWFzcypncmF2aXR5KS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25HcmF2aXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZnJpY3Rpb25HcmF2aXR5ID0gMTA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgLmZyaWN0aW9uR3Jhdml0eSB0byBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHlcclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBsZW5ndGggb2YgLmdyYXZpdHkgaXMgemVybywgYW5kIC51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eT10cnVlLCB0aGVuIHN3aXRjaCB0byB1c2luZyAuZnJpY3Rpb25HcmF2aXR5IGZvciBmcmljdGlvbiBpbnN0ZWFkLiBUaGlzIGZhbGxiYWNrIGlzIHVzZWZ1bCBmb3IgZ3Jhdml0eWxlc3MgZ2FtZXMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29uc3RyYWludHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEdW1teSBkZWZhdWx0IG1hdGVyaWFsIGluIHRoZSB3b3JsZCwgdXNlZCBpbiAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TWF0ZXJpYWx9IGRlZmF1bHRNYXRlcmlhbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBtYXRlcmlhbF8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRpbWUgc3RlcCBzaXplIHdlIHVzZWQgbGFzdCBzdGVwXHJcbiAgICAgICAgICogQHByb3BlcnR5IGxhc3RUaW1lU3RlcFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubGFzdFRpbWVTdGVwID0gMSAvIDYwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IHNwcmluZyBmb3JjZXMgZWFjaCBzdGVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhcHBseVNwcmluZ0ZvcmNlc1xyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgYm9keSBkYW1waW5nIGVhY2ggc3RlcC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYXBwbHlEYW1waW5nXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFwcGx5RGFtcGluZyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hcHBseUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZS9kaXNhYmxlIGNvbnN0cmFpbnQgc29sdmluZyBpbiBlYWNoIHN0ZXAuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNvbHZlQ29uc3RyYWludHNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIENvbnRhY3RNYXRlcmlhbHMgYWRkZWQgdG8gdGhlIFdvcmxkLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0TWF0ZXJpYWxzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RNYXRlcmlhbHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXb3JsZCB0aW1lLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0aW1lXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50aW1lID0gMC4wO1xyXG4gICAgICAgIF90aGlzLmFjY3VtdWxhdG9yID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJcyB0cnVlIGR1cmluZyBzdGVwKCkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnN0ZXBwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBlbmFibGUgaXNsYW5kIHNwbGl0dGluZy4gSXNsYW5kIHNwbGl0dGluZyBjYW4gYmUgYW4gYWR2YW50YWdlIGZvciBib3RoIHByZWNpc2lvbiBhbmQgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaXNsYW5kU3BsaXQgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHRoZSB3b3JsZCB0byBlbWl0IHRoZSBcImltcGFjdFwiIGV2ZW50LiBUdXJuaW5nIHRoaXMgb2ZmIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVtaXRJbXBhY3RFdmVudFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbXBhY3QgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBVc2UgYmVnaW5Db250YWN0IGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZW1pdEltcGFjdEV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwTW9kZSA9IFdvcmxkLk5PX1NMRUVQSU5HO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VW5pb25GaW5kfSB1bmlvbkZpbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51bmlvbkZpbmQgPSBuZXcgdW5pb25fZmluZF8xLmRlZmF1bHQoMSk7XHJcbiAgICAgICAgLy8gSWQgY291bnRlcnNcclxuICAgICAgICBfdGhpcy5fY29uc3RyYWludElkQ291bnRlciA9IDA7XHJcbiAgICAgICAgX3RoaXMuX2JvZHlJZENvdW50ZXIgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T3ZlcmxhcEtlZXBlcn0gb3ZlcmxhcEtlZXBlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm92ZXJsYXBLZWVwZXIgPSBuZXcgb3ZlcmxhcF9rZWVwZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgX3RoaXMuc29sdmVyID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNvbHZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IGdzX3NvbHZlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdyYXZpdHkpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5ncmF2aXR5LCBvcHRpb25zLmdyYXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5mcmljdGlvbkdyYXZpdHkgPSAoX2IgPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgoX3RoaXMuZ3Jhdml0eSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEwO1xyXG4gICAgICAgIF90aGlzLmJyb2FkcGhhc2UgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYnJvYWRwaGFzZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IHNhcF9icm9hZHBoYXNlXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIF90aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgY29udGFjdF9tYXRlcmlhbF8xLmRlZmF1bHQoX3RoaXMuZGVmYXVsdE1hdGVyaWFsLCBfdGhpcy5kZWZhdWx0TWF0ZXJpYWwpO1xyXG4gICAgICAgIF90aGlzLmlzbGFuZFNwbGl0ID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlzbGFuZFNwbGl0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgc2ltdWxhdGlvbi4gTm90ZSB0aGF0IGJvdGggYm9kaWVzIGNvbm5lY3RlZCB0byB0aGUgY29uc3RyYWludCBtdXN0IGJlIGFkZGVkIHRvIHRoZSB3b3JsZCBmaXJzdC4gQWxzbyBub3RlIHRoYXQgeW91IGNhbid0IHJ1biB0aGlzIG1ldGhvZCBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRDb25zdHJhaW50ID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cmFpbnRzIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xyXG4gICAgICAgIGlmIChib2RpZXMuaW5kZXhPZihjb25zdHJhaW50LmJvZHlBKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIENvbnN0cmFpbnQ6IGJvZHlBIGlzIG5vdCBhZGRlZCB0byB0aGUgV29ybGQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib2RpZXMuaW5kZXhPZihjb25zdHJhaW50LmJvZHlCKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIENvbnN0cmFpbnQ6IGJvZHlCIGlzIG5vdCBhZGRlZCB0byB0aGUgV29ybGQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIENvbnRhY3RNYXRlcmlhbCB0byB0aGUgc2ltdWxhdGlvbi5cclxuICAgICAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXHJcbiAgICAgKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY29udGFjdE1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoY29udGFjdE1hdGVyaWFsKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb250YWN0IG1hdGVyaWFsXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbVxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuY29udGFjdE1hdGVyaWFscywgY20pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXHJcbiAgICAgKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cclxuICAgICAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKG1hdGVyaWFsQSwgbWF0ZXJpYWxCKSB7XHJcbiAgICAgICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gY21hdHMubGVuZ3RoOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNtID0gY21hdHNbaV07XHJcbiAgICAgICAgICAgIGlmICgoY20ubWF0ZXJpYWxBID09PSBtYXRlcmlhbEEgJiYgY20ubWF0ZXJpYWxCID09PSBtYXRlcmlhbEIpIHx8IChjbS5tYXRlcmlhbEEgPT09IG1hdGVyaWFsQiAmJiBjbS5tYXRlcmlhbEIgPT09IG1hdGVyaWFsQSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb25zdHJhaW50LiBOb3RlIHRoYXQgeW91IGNhbid0IHJ1biB0aGlzIG1ldGhvZCBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludFxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50cyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuY29uc3RyYWludHMsIGNvbnN0cmFpbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzdGVwXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIFNpbXBsZSBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXHJcbiAgICAgKiAgICAgdmFyIGZpeGVkVGltZVN0ZXAgPSAxIC8gNjA7XHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpe1xyXG4gICAgICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgKiAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCk7XHJcbiAgICAgKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxyXG4gICAgICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIEZpeGVkIHRpbWVzdGVwcGluZyB3aXRoIGludGVycG9sYXRpb25cclxuICAgICAqICAgICB2YXIgbWF4U3ViU3RlcHMgPSAxMDtcclxuICAgICAqICAgICB2YXIgbGFzdFRpbWVTZWNvbmRzO1xyXG4gICAgICpcclxuICAgICAqICAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWUpe1xyXG4gICAgICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgKiAgICAgICAgIHZhciB0aW1lU2Vjb25kcyA9IHRpbWUgLyAxMDAwO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgaWYobGFzdFRpbWVTZWNvbmRzKXtcclxuICAgICAqICAgICAgICAgICAgIHZhciBkZWx0YVRpbWUgPSB0aW1lU2Vjb25kcyAtIGxhc3RUaW1lU2Vjb25kcztcclxuICAgICAqICAgICAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCwgZGVsdGFUaW1lLCBtYXhTdWJTdGVwcyk7XHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGxhc3RUaW1lU2Vjb25kcyA9IHRpbWVTZWNvbmRzO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgcmVuZGVyQm9keShib2R5LmludGVycG9sYXRlZFBvc2l0aW9uLCBib2R5LmludGVycG9sYXRlZEFuZ2xlKTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBsb29wXHJcbiAgICAgKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICpcclxuICAgICAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGR0LCB0aW1lU2luY2VMYXN0Q2FsbGVkLCBtYXhTdWJTdGVwcykge1xyXG4gICAgICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XHJcbiAgICAgICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcclxuICAgICAgICBpZiAodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCkgeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcclxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcclxuICAgICAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRvciArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xyXG4gICAgICAgICAgICB2YXIgc3Vic3RlcHMgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5hY2N1bXVsYXRvciA+PSBkdCAmJiBzdWJzdGVwcyA8IG1heFN1YlN0ZXBzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRvciAtPSBkdDtcclxuICAgICAgICAgICAgICAgIHN1YnN0ZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHQgPSAodGhpcy5hY2N1bXVsYXRvciAlIGR0KSAvIGR0O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gdGhpcy5ib2RpZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbiwgYi5wb3NpdGlvbiwgdCk7XHJcbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5wcmV2aW91c0FuZ2xlICsgdCAqIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSBmaXhlZCBzdGVwLlxyXG4gICAgICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZHRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xyXG4gICAgICAgIHZhciBzdGVwX21nID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGVuZE92ZXJsYXBzID0gW107XHJcbiAgICAgICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCwgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncywgYm9kaWVzID0gdGhpcy5ib2RpZXMsIGcgPSB0aGlzLmdyYXZpdHksIHNvbHZlciA9IHRoaXMuc29sdmVyLCBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLCBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLCBucCA9IHRoaXMubmFycm93cGhhc2UsIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cywgbWcgPSBzdGVwX21nLCBhZGQgPSB2ZWMyXzEuZGVmYXVsdC5hZGQ7XHJcbiAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLnRpY2soKTtcclxuICAgICAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IGR0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxyXG4gICAgICAgIGlmICh0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5KSB7XHJcbiAgICAgICAgICAgIHZhciBncmF2aXR5TGVuID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XHJcbiAgICAgICAgICAgIGlmICghKGdyYXZpdHlMZW4gPT09IDAgJiYgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9uemVybyBncmF2aXR5LiBVc2UgaXQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uR3Jhdml0eSA9IGdyYXZpdHlMZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXHJcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlHcmF2aXR5KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldLCBmaSA9IGIuZm9yY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYi50eXBlICE9PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDIHx8IGIuc2xlZXBTdGF0ZSA9PT0gYm9keV8xLmRlZmF1bHQuU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKG1nLCBnLCBiLm1hc3MgKiBiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXHJcbiAgICAgICAgICAgICAgICBhZGQoZmksIGZpLCBtZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcclxuICAgICAgICBpZiAodGhpcy5hcHBseVNwcmluZ0ZvcmNlcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTnNwcmluZ3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzcHJpbmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgcy5hcHBseUZvcmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlEYW1waW5nKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuRFlOQU1JQykge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYXBwbHlEYW1waW5nKGR0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCcm9hZHBoYXNlXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGlnbm9yZWQgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdmFyIGlnbm9yZWRQYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlnbm9yZWRQYWlycy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGogPj0gMDsgaiAtPSAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlnbm9yZWRQYWlyc1tpXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpICsgMV0gPT09IHJlc3VsdFtqICsgMV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGlnbm9yZWRQYWlyc1tpICsgMV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaV0gPT09IHJlc3VsdFtqICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXHJcbiAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWMuY29sbGlkZUNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJlc3VsdC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYy5ib2R5QSA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUIgPT09IHJlc3VsdFtqICsgMV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2ogKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcG9zdEJyb2FkcGhhc2UgZXZlbnRcclxuICAgICAgICBwb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xyXG4gICAgICAgIHRoaXMuZW1pdChwb3N0QnJvYWRwaGFzZUV2ZW50KTtcclxuICAgICAgICBwb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gbnVsbDtcclxuICAgICAgICAvLyBOYXJyb3dwaGFzZVxyXG4gICAgICAgIG5wLnJlc2V0KCk7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgdmFyIGZyaWN0aW9uR3Jhdml0eSA9IHRoaXMuZnJpY3Rpb25HcmF2aXR5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOcmVzdWx0cyA9IHJlc3VsdC5sZW5ndGg7IGkgIT09IE5yZXN1bHRzOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGJpID0gcmVzdWx0W2ldLCBiaiA9IHJlc3VsdFtpICsgMV07XHJcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgTnNoYXBlc2kgPSBiaS5zaGFwZXMubGVuZ3RoOyBrICE9PSBOc2hhcGVzaTsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNba10sIHhpID0gc2kucG9zaXRpb24sIGFpID0gc2kuYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgc2hhcGVzIG9mIGJvZHkgalxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIE5zaGFwZXNqID0gYmouc2hhcGVzLmxlbmd0aDsgbCAhPT0gTnNoYXBlc2o7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaiA9IGJqLnNoYXBlc1tsXSwgeGogPSBzai5wb3NpdGlvbiwgYWogPSBzai5hbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE1hdGVyaWFsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2kubWF0ZXJpYWwgJiYgc2oubWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdE1hdGVyaWFsID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoc2kubWF0ZXJpYWwsIHNqLm1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcnVuTmFycm93cGhhc2UodGhpcywgbnAsIGJpLCBzaSwgeGksIGFpLCBiaiwgc2osIHhqLCBhaiwgY29udGFjdE1hdGVyaWFsICE9PSBudWxsICYmIGNvbnRhY3RNYXRlcmlhbCAhPT0gdm9pZCAwID8gY29udGFjdE1hdGVyaWFsIDogZGVmYXVsdENvbnRhY3RNYXRlcmlhbCwgZnJpY3Rpb25HcmF2aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWtlIHVwIGJvZGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5Lndha2VVcCgpO1xyXG4gICAgICAgICAgICAgICAgYm9keS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXHJcbiAgICAgICAgaWYgKF9zdXBlci5wcm90b3R5cGUuaGFzLmNhbGwodGhpcywgXCJlbmRDb250YWN0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XHJcbiAgICAgICAgICAgIHZhciBlID0gZW5kQ29udGFjdEV2ZW50O1xyXG4gICAgICAgICAgICB2YXIgbCA9IGVuZE92ZXJsYXBzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcclxuICAgICAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XHJcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XHJcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmRPdmVybGFwcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBucC5jb250YWN0RXF1YXRpb25zO1xyXG4gICAgICAgIHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucztcclxuICAgICAgICB0aGlzLmVtaXQocHJlU29sdmVFdmVudCk7XHJcbiAgICAgICAgcHJlU29sdmVFdmVudC5jb250YWN0RXF1YXRpb25zID0gcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgLy8gdXBkYXRlIGNvbnN0cmFpbnQgZXF1YXRpb25zXHJcbiAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50c1tpXS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIHx8IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCB8fCBOY29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGFsbCBlcXVhdGlvbnNcclxuICAgICAgICAgICAgdmFyIGVxdWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkoZXF1YXRpb25zLCBucC5jb250YWN0RXF1YXRpb25zKTtcclxuICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KGVxdWF0aW9ucywgbnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KGVxdWF0aW9ucywgY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc2xhbmRTcGxpdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgVW5pb25GaW5kXHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pb25GaW5kID0gdGhpcy51bmlvbkZpbmQ7XHJcbiAgICAgICAgICAgICAgICB1bmlvbkZpbmQucmVzaXplKHRoaXMuYm9kaWVzLmxlbmd0aCArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGVxdWF0aW9uIGluZGV4XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVxdWF0aW9uc1tpXS5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBVbml0ZSBib2RpZXMgaWYgdGhleSBhcmUgY29ubmVjdGVkIGJ5IGFuIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5QSA9IGVxdWF0aW9uc1tpXS5ib2R5QTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUIgPSBlcXVhdGlvbnNbaV0uYm9keUI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5QS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDICYmIGJvZHlCLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pb25GaW5kLnVuaW9uKGJvZHlBLmluZGV4LCBib2R5Qi5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYm9keSBpc2xhbmRzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuaXNsYW5kSWQgPSBib2R5LnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgPyB1bmlvbkZpbmQuZmluZChib2R5LmluZGV4KSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU29ydCBlcXVhdGlvbnMgYnkgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICBlcXVhdGlvbnMgPSBlcXVhdGlvbnMuc29ydChzb3J0RXF1YXRpb25zQnlJc2xhbmQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVxdWF0aW9uSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVxdWF0aW9uSW5kZXggPCBlcXVhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVxdWF0aW9uID0gZXF1YXRpb25zW2VxdWF0aW9uSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGVxdWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWF0aW9uLmJvZHlBIHx8ICFlcXVhdGlvbi5ib2R5QilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJc2xhbmRJZCA9IGVxdWF0aW9uLmJvZHlBLmlzbGFuZElkID4gMCA/IGVxdWF0aW9uLmJvZHlBLmlzbGFuZElkIDogZXF1YXRpb24uYm9keUIuaXNsYW5kSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJc2xhbmRJZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlaSA9IGVxdWF0aW9uc1tlcXVhdGlvbkluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVpLmJvZHlBICYmIGVpLmJvZHlCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJc2xhbmRJZCA9ICgoX2IgPSAoX2EgPSBlaS5ib2R5QSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzbGFuZElkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDAgPyAoX2QgPSAoX2MgPSBlaS5ib2R5QSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlzbGFuZElkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwIDogKF9mID0gKF9lID0gZWkuYm9keUIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5pc2xhbmRJZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJc2xhbmRJZCAhPT0gY3VycmVudElzbGFuZElkIHx8IGVxdWF0aW9uSW5kZXggPT09IGVxdWF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sdmUgdGhpcyBpc2xhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc29sdmVDb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sdmVyLnNvbHZlKGR0LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgYWxsIGFzIG9uZSBpc2xhbmRcclxuICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMoZXF1YXRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvbHZlQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmUoZHQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN0ZXAgZm9yd2FyZFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChib2R5LnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMgfHwgYm9keS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5LSU5FTUFUSUMpIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXNldCBmb3JjZVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgYm9kaWVzW2ldLnNldFplcm9Gb3JjZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbWl0IGltcGFjdCBldmVudFxyXG4gICAgICAgIGlmICh0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0JykpIHtcclxuICAgICAgICAgICAgdmFyIGV2ID0gaW1wYWN0RXZlbnQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXEgPSBucC5jb250YWN0RXF1YXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVxLmZpcnN0SW1wYWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuYm9keUEgPSAoX2cgPSBlcS5ib2R5QSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBldi5ib2R5QiA9IChfaCA9IGVxLmJvZHlCKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnNoYXBlQSA9IGVxLnNoYXBlQTtcclxuICAgICAgICAgICAgICAgICAgICBldi5zaGFwZUIgPSBlcS5zaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuY29udGFjdEVxdWF0aW9uID0gZXE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTbGVlcGluZyB1cGRhdGVcclxuICAgICAgICBpZiAodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSwgZmFsc2UsIGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNsZWVwTW9kZSA9PT0gV29ybGQuSVNMQU5EX1NMRUVQSU5HICYmIHRoaXMuaXNsYW5kU3BsaXQpIHtcclxuICAgICAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTbGVlcCBpc2xhbmRzXHJcbiAgICAgICAgICAgIHZhciBib2RpZXNTb3J0ZWRCeUlzbGFuZCA9IGJvZGllcy5zb3J0KHNvcnRCb2RpZXNCeUlzbGFuZCk7XHJcbiAgICAgICAgICAgIHZhciBpc2xhbmRFbmQgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpc2xhbmRTdGFydCA9IDA7IGlzbGFuZFN0YXJ0IDwgYm9kaWVzU29ydGVkQnlJc2xhbmQubGVuZ3RoOyBpc2xhbmRTdGFydCA9IGlzbGFuZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZElkID0gYm9kaWVzU29ydGVkQnlJc2xhbmRbaXNsYW5kU3RhcnRdLmlzbGFuZElkO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGlzbGFuZEVuZCBpbmRleFxyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgICAgICAgICAgICAgZm9yIChpc2xhbmRFbmQgPSBpc2xhbmRTdGFydCArIDE7IGlzbGFuZEVuZCA8IGJvZGllc1NvcnRlZEJ5SXNsYW5kLmxlbmd0aCAmJiBib2RpZXNTb3J0ZWRCeUlzbGFuZFtpc2xhbmRFbmRdLmlzbGFuZElkID09PSBpc2xhbmRJZDsgaXNsYW5kRW5kKyspIHsgfVxyXG4gICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIHN0YXRpYyBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNsYW5kSWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNsYW5kU2hvdWxkU2xlZXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlzbGFuZFN0YXJ0OyBpIDwgaXNsYW5kRW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvZGllc1NvcnRlZEJ5SXNsYW5kW2ldLndhbnRzVG9TbGVlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc2xhbmRTaG91bGRTbGVlcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNsYW5kU2hvdWxkU2xlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaXNsYW5kU3RhcnQ7IGkgPCBpc2xhbmRFbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2RpZXNTb3J0ZWRCeUlzbGFuZFtpXS5zbGVlcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgcG9zdFN0ZXBFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG9wZXJhdGlvbiBjYW4ndCBiZSBkb25lIGR1cmluZyBzdGVwLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgYWRkU3ByaW5nXHJcbiAgICAgKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRTcHJpbmcgPSBmdW5jdGlvbiAoc3ByaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcHJpbmdzIGNhbm5vdCBiZSBhZGRlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zcHJpbmdzLnB1c2goc3ByaW5nKTtcclxuICAgICAgICBhZGRTcHJpbmdFdmVudC5zcHJpbmcgPSBzcHJpbmc7XHJcbiAgICAgICAgdGhpcy5lbWl0KGFkZFNwcmluZ0V2ZW50KTtcclxuICAgICAgICBhZGRTcHJpbmdFdmVudC5zcHJpbmcgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc3ByaW5nLiBOb3RlIHRoYXQgdGhpcyBvcGVyYXRpb24gY2FuJ3QgYmUgZG9uZSBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVNwcmluZ1xyXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlU3ByaW5nID0gZnVuY3Rpb24gKHNwcmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ByaW5ncyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKHRoaXMuc3ByaW5ncywgc3ByaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCB5b3UgY2FuJ3QgYWRkIGEgYm9keSBkdXJpbmcgc3RlcDogeW91IGhhdmUgdG8gd2FpdCB1bnRpbCBhZnRlciB0aGUgc3RlcCAoc2VlIHRoZSBwb3N0U3RlcCBldmVudCkuXHJcbiAgICAgKiBBbHNvIG5vdGUgdGhhdCBib2RpZXMgY2FuIG9ubHkgYmUgYWRkZWQgdG8gb25lIFdvcmxkIGF0IGEgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZEJvZHlcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXHJcbiAgICAgKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZGllcyBjYW5ub3QgYmUgYWRkZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFscmVhZHkgYWRkZWQ/XHJcbiAgICAgICAgaWYgKGJvZHkud29ybGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2R5IGlzIGFscmVhZHkgYWRkZWQgdG8gYSBXb3JsZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYm9keS5pbmRleCA9IHRoaXMuYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xyXG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xyXG4gICAgICAgIGFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcclxuICAgICAgICB0aGlzLmVtaXQoYWRkQm9keUV2ZW50KTtcclxuICAgICAgICBhZGRCb2R5RXZlbnQuYm9keSA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCBib2RpZXMgY2Fubm90IGJlIHJlbW92ZWQgZHVyaW5nIHN0ZXAgKGZvciBleGFtcGxlLCBpbnNpZGUgdGhlIGJlZ2luQ29udGFjdCBldmVudCkuIEluIHRoYXQgY2FzZSB5b3UgbmVlZCB0byB3YWl0IHVudGlsIHRoZSBzdGVwIGlzIGRvbmUgKHNlZSB0aGUgcG9zdFN0ZXAgZXZlbnQpLlxyXG4gICAgICpcclxuICAgICAqIEFsc28gbm90ZSB0aGF0IGFueSBjb25zdHJhaW50cyBjb25uZWN0ZWQgdG8gdGhlIGJvZHkgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSB0aGUgYm9keS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHJlbW92ZUJvZHk7XHJcbiAgICAgKiAgICAgd29ybGQub24oXCJiZWdpbkNvbnRhY3RcIixmdW5jdGlvbihldmVudCl7XHJcbiAgICAgKiAgICAgICAgIC8vIFdlIGNhbm5vdCByZW1vdmUgdGhlIGJvZHkgaGVyZSBzaW5jZSB0aGUgd29ybGQgaXMgc3RpbGwgc3RlcHBpbmcuXHJcbiAgICAgKiAgICAgICAgIC8vIEluc3RlYWQsIHNjaGVkdWxlIHRoZSBib2R5IHRvIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIHN0ZXAgaXMgZG9uZS5cclxuICAgICAqICAgICAgICAgcmVtb3ZlQm9keSA9IGJvZHk7XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQub24oXCJwb3N0U3RlcFwiLGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAqICAgICAgICAgaWYocmVtb3ZlQm9keSl7XHJcbiAgICAgKiAgICAgICAgICAgICAvLyBTYWZlbHkgcmVtb3ZlIHRoZSBib2R5IGZyb20gdGhlIHdvcmxkLlxyXG4gICAgICogICAgICAgICAgICAgd29ybGQucmVtb3ZlQm9keShyZW1vdmVCb2R5KTtcclxuICAgICAqICAgICAgICAgICAgIHJlbW92ZUJvZHkgPSBudWxsO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZGllcyBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogd291bGQgaXQgYmUgc21hcnQgdG8gaGF2ZSBhIC5jb25zdHJhaW50cyBhcnJheSBvbiB0aGUgYm9keT9cclxuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xyXG4gICAgICAgIHZhciBsID0gY29uc3RyYWludHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzW2xdLmJvZHlBID09PSBib2R5IHx8IGNvbnN0cmFpbnRzW2xdLmJvZHlCID09PSBib2R5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgQm9keSBmcm9tIFdvcmxkOiBpdCBzdGlsbCBoYXMgY29uc3RyYWludHMgY29ubmVjdGVkIHRvIGl0LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvZHkud29ybGQgPSBudWxsO1xyXG4gICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXJyYXlSZW1vdmUoYm9kaWVzLCBib2R5KTtcclxuICAgICAgICBib2R5LmluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGwgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgYm9kaWVzW2xdLmluZGV4ID0gbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRW1pdCByZW1vdmVCb2R5IGV2ZW50XHJcbiAgICAgICAgcmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xyXG4gICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcclxuICAgICAgICB0aGlzLmVtaXQocmVtb3ZlQm9keUV2ZW50KTtcclxuICAgICAgICByZW1vdmVCb2R5RXZlbnQuYm9keSA9IG51bGw7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGRpc2FibGVkIGJvZHkgY29sbGlzaW9uIHBhaXJzIHRoYXQgaW52b2x2ZSBib2R5XHJcbiAgICAgICAgdmFyIHBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBwYWlycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHBhaXJzW2ldID09PSBib2R5IHx8IHBhaXJzW2kgKyAxXSA9PT0gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgYm9keSBieSBpdHMgaWQuXHJcbiAgICAgKiBAbWV0aG9kIGdldEJvZHlCeUlkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICAgICAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlIGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBib2RpZXNcclxuICAgICAqIEBtZXRob2QgZGlzYWJsZUJvZHlDb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLmRpc2FibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnMucHVzaChib2R5QSk7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlCKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBjb2xsaXNpb25zIGJldHdlZW4gdGhlIGdpdmVuIHR3byBib2RpZXMsIGlmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGRpc2FibGVkIHVzaW5nIC5kaXNhYmxlQm9keUNvbGxpc2lvbigpLlxyXG4gICAgICogQG1ldGhvZCBlbmFibGVCb2R5Q29sbGlzaW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBpZiAoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpICsgMV0gPT09IGJvZHlCKSB8fCAocGFpcnNbaSArIDFdID09PSBib2R5QSAmJiBwYWlyc1tpXSA9PT0gYm9keUIpKSB7XHJcbiAgICAgICAgICAgICAgICBwYWlycy5zcGxpY2UoaSwgMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzLCBzcHJpbmdzLCBhbmQgY29udGFjdCBtYXRlcmlhbHMgZnJvbSB0aGUgd29ybGQuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHNvbHZlciBlcXVhdGlvbnNcclxuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcclxuICAgICAgICB2YXIgaSA9IGNzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgYm9kaWVzXHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xyXG4gICAgICAgIGkgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgc3ByaW5nc1xyXG4gICAgICAgIHZhciBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xyXG4gICAgICAgIGkgPSBzcHJpbmdzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXHJcbiAgICAgICAgdmFyIGNtcyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcclxuICAgICAgICBpID0gY21zLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBhIHdvcmxkIHBvaW50IG92ZXJsYXBzIGJvZGllc1xyXG4gICAgICogQG1ldGhvZCBoaXRUZXN0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCBQb2ludCB0byB1c2UgZm9yIGludGVyc2VjdGlvbiB0ZXN0c1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGJvZGllcyBBIGxpc3Qgb2Ygb2JqZWN0cyB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHByZWNpc2lvbiBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGJvZGllcyB0aGF0IG92ZXJsYXAgdGhlIHBvaW50XHJcbiAgICAgKiBAdG9kbyBTaG91bGQgdXNlIGFuIGFwaSBzaW1pbGFyIHRvIHRoZSByYXljYXN0IGZ1bmN0aW9uXHJcbiAgICAgKiBAdG9kbyBTaG91bGQgcHJvYmFibHkgaW1wbGVtZW50IGEgLmNvbnRhaW5zUG9pbnQgbWV0aG9kIGZvciBhbGwgc2hhcGVzLiBXb3VsZCBiZSBtb3JlIGVmZmljaWVudFxyXG4gICAgICogQHRvZG8gU2hvdWxkIHVzZSB0aGUgYnJvYWRwaGFzZVxyXG4gICAgICogQHRvZG8gUmV0dXJuaW5nIHRoZSBoaXQgc2hhcGUgd291bGQgYmUgZmluZSAtIGl0IGNhcnJpZXMgYSByZWZlcmVuY2UgdG8gdGhlIGJvZHkgbm93XHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKHdvcmxkUG9pbnQsIGJvZGllcywgcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcclxuICAgICAgICB2YXIgc2hhcGVXb3JsZFBvc2l0aW9uID0gaGl0VGVzdF90bXAxLCBzaGFwZUxvY2FsUG9pbnQgPSBoaXRUZXN0X3RtcDI7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8vIENoZWNrIGJvZGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9kaWVzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgTlMgPSBib2R5LnNoYXBlcy5sZW5ndGg7IGogIT09IE5TOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGxvY2FsIHBvaW50IHBvc2l0aW9uIGluIHRoZSBzaGFwZVxyXG4gICAgICAgICAgICAgICAgc2hhcGUud29ybGRQb2ludFRvTG9jYWwoc2hhcGVMb2NhbFBvaW50LCB3b3JsZFBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5wb2ludFRlc3Qoc2hhcGVMb2NhbFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHNoYXBlV29ybGRQb3NpdGlvbiwgc2hhcGUucG9zaXRpb24sIGJvZHkuYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChzaGFwZVdvcmxkUG9zaXRpb24sIHNoYXBlV29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLnR5cGUgPT09IHNoYXBlXzEuZGVmYXVsdC5QQVJUSUNMRSAmJiB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2Uoc2hhcGVXb3JsZFBvc2l0aW9uLCB3b3JsZFBvaW50KSA8IHByZWNpc2lvbiAqIHByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc3RpZmZuZXNzIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cclxuICAgICAqIEBtZXRob2Qgc2V0R2xvYmFsU3RpZmZuZXNzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxTdGlmZm5lc3MgPSBmdW5jdGlvbiAoc3RpZmZuZXNzKSB7XHJcbiAgICAgICAgc2V0R2xvYmFsRXF1YXRpb25QYXJhbXModGhpcywgeyBzdGlmZm5lc3M6IHN0aWZmbmVzcyB9KTtcclxuICAgICAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xyXG4gICAgICAgIHZhciBjb250YWN0TWF0ZXJpYWxzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBjb250YWN0TWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gY29udGFjdE1hdGVyaWFsc1tpXTtcclxuICAgICAgICAgICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xyXG4gICAgICAgIGMuc3RpZmZuZXNzID0gYy5mcmljdGlvblN0aWZmbmVzcyA9IHN0aWZmbmVzcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcmVsYXhhdGlvbiBmb3IgYWxsIGVxdWF0aW9ucyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXHJcbiAgICAgKiBAbWV0aG9kIHNldEdsb2JhbFJlbGF4YXRpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxSZWxheGF0aW9uID0gZnVuY3Rpb24gKHJlbGF4YXRpb24pIHtcclxuICAgICAgICBzZXRHbG9iYWxFcXVhdGlvblBhcmFtcyh0aGlzLCB7IHJlbGF4YXRpb246IHJlbGF4YXRpb24gfSk7XHJcbiAgICAgICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy5jb250YWN0TWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzW2ldO1xyXG4gICAgICAgICAgICBjLnJlbGF4YXRpb24gPSBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSB3b3JsZC5cclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xyXG4gICAgICogICAgICAgICBtb2RlOiBSYXkuQ0xPU0VTVCwgLy8gb3IgQU5ZXHJcbiAgICAgKiAgICAgICAgIGZyb206IFswLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFsxMCwgMF0sXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XHJcbiAgICAgKiAgICAgd29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEdldCB0aGUgaGl0IHBvaW50XHJcbiAgICAgKiAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcclxuICAgICAqICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0hpdCBwb2ludDogJywgaGl0UG9pbnRbMF0sIGhpdFBvaW50WzFdLCAnIGF0IGRpc3RhbmNlICcgKyByZXN1bHQuZ2V0SGl0RGlzdGFuY2UocmF5KSk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XHJcbiAgICAgKiAgICAgICAgIG1vZGU6IFJheS5BTEwsXHJcbiAgICAgKiAgICAgICAgIGZyb206IFswLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFsxMCwgMF0sXHJcbiAgICAgKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihyZXN1bHQpe1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgIC8vIFByaW50IHNvbWUgaW5mbyBhYm91dCB0aGUgaGl0XHJcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IGJvZHkgYW5kIHNoYXBlOiAnLCByZXN1bHQuYm9keSwgcmVzdWx0LnNoYXBlKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxyXG4gICAgICogICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcclxuICAgICAqICAgICAgICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChoaXRQb2ludCwgcmF5KTtcclxuICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgaGFwcHkgd2l0aCB0aGUgaGl0cyB5b3UgZ290IHRoaXMgZmFyLCB5b3UgY2FuIHN0b3AgdGhlIHRyYXZlcnNhbCBoZXJlOlxyXG4gICAgICogICAgICAgICAgICAgcmVzdWx0LnN0b3AoKTtcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xyXG4gICAgICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSkge1xyXG4gICAgICAgIHZhciB0bXBBQUJCID0gbmV3IGFhYmJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHRtcEFycmF5ID0gW107XHJcbiAgICAgICAgLy8gR2V0IGFsbCBib2RpZXMgd2l0aGluIHRoZSByYXkgQUFCQlxyXG4gICAgICAgIHJheS5nZXRBQUJCKHRtcEFBQkIpO1xyXG4gICAgICAgIHRoaXMuYnJvYWRwaGFzZS5hYWJiUXVlcnkodGhpcywgdG1wQUFCQiwgdG1wQXJyYXkpO1xyXG4gICAgICAgIHJheS5pbnRlcnNlY3RCb2RpZXMocmVzdWx0LCB0bXBBcnJheSk7XHJcbiAgICAgICAgdG1wQXJyYXkubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc0hpdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTmV2ZXIgZGVhY3RpdmF0ZSBib2RpZXMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTk9fU0xFRVBJTkdcclxuICAgICAqL1xyXG4gICAgV29ybGQuTk9fU0xFRVBJTkcgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlIGluZGl2aWR1YWwgYm9kaWVzIGlmIHRoZXkgYXJlIHNsZWVweS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCT0RZX1NMRUVQSU5HXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLkJPRFlfU0xFRVBJTkcgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xyXG4gICAgcmV0dXJuIFdvcmxkO1xyXG59KGV2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmxkO1xyXG4iXX0=
(22)
});
