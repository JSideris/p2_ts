!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.p2=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var AABB = /** @class */ (function () {
    /**
     * Axis aligned bounding box class.
     * @class AABB
     * @constructor
     * @param {Object}  [options]
     * @param {Array}   [options.upperBound]
     * @param {Array}   [options.lowerBound]
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     */
    function AABB(options) {
        this.tmp = vec2_1.default.create();
        options = options !== null && options !== void 0 ? options : {};
        /**
         * The lower bound of the bounding box.
         * @property lowerBound
         * @type {Array}
         */
        this.lowerBound = options.lowerBound ? vec2_1.default.clone(options.lowerBound) : vec2_1.default.create();
        /**
         * The upper bound of the bounding box.
         * @property upperBound
         * @type {Array}
         */
        this.upperBound = options.upperBound ? vec2_1.default.clone(options.upperBound) : vec2_1.default.create();
    }
    /**
     * Set the AABB bounds from a set of points, transformed by the given position and angle.
     * @method setFromPoints
     * @param {Array} points An array of vec2's.
     * @param {Array} position
     * @param {number} [angle=0]
     * @param {number} [skinSize=0] Some margin to be added to the AABB.
     */
    AABB.prototype.setFromPoints = function (points, position, angle, skinSize) {
        if (skinSize === void 0) { skinSize = 0; }
        var l = this.lowerBound, u = this.upperBound;
        angle = angle || 0;
        // Set to the first point
        if (angle !== 0) {
            vec2_1.default.rotate(l, points[0], angle);
        }
        else {
            vec2_1.default.copy(l, points[0]);
        }
        vec2_1.default.copy(u, l);
        // Compute cosines and sines just once
        var cosAngle = Math.cos(angle), sinAngle = Math.sin(angle);
        for (var i = 1; i < points.length; i++) {
            var p = points[i];
            if (angle !== 0) {
                var x = p[0], y = p[1];
                this.tmp[0] = cosAngle * x - sinAngle * y;
                this.tmp[1] = sinAngle * x + cosAngle * y;
                p = this.tmp;
            }
            for (var j = 0; j < 2; j++) {
                if (p[j] > u[j]) {
                    u[j] = p[j];
                }
                if (p[j] < l[j]) {
                    l[j] = p[j];
                }
            }
        }
        // Add offset
        if (position) {
            vec2_1.default.add(l, l, position);
            vec2_1.default.add(u, u, position);
        }
        if (skinSize) {
            l[0] -= skinSize;
            l[1] -= skinSize;
            u[0] += skinSize;
            u[1] += skinSize;
        }
    };
    /**
     * Copy bounds from an AABB to this AABB
     * @method copy
     * @param  {AABB} aabb
     */
    AABB.prototype.copy = function (aabb) {
        vec2_1.default.copy(this.lowerBound, aabb.lowerBound);
        vec2_1.default.copy(this.upperBound, aabb.upperBound);
    };
    /**
     * Extend this AABB so that it covers the given AABB too.
     * @method extend
     * @param  {AABB} aabb
     */
    AABB.prototype.extend = function (aabb) {
        var lower = this.lowerBound, upper = this.upperBound;
        // Loop over x and y
        var i = 2;
        while (i--) {
            // Extend lower bound
            var l = aabb.lowerBound[i];
            if (lower[i] > l) {
                lower[i] = l;
            }
            // Upper
            var u = aabb.upperBound[i];
            if (upper[i] < u) {
                upper[i] = u;
            }
        }
    };
    /**
     * Returns true if the given AABB overlaps this AABB.
     * @method overlaps
     * @param  {AABB} aabb
     * @return {Boolean}
     */
    AABB.prototype.overlaps = function (aabb) {
        var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
        //      l2        u2
        //      |---------|
        // |--------|
        // l1       u1
        return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
            ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
    };
    ;
    /**
     * @method containsPoint
     * @param  {Array} point
     * @return {boolean}
     */
    AABB.prototype.containsPoint = function (point) {
        var l = this.lowerBound, u = this.upperBound;
        return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];
    };
    /**
     * Check if the AABB is hit by a ray.
     * @method overlapsRay
     * @param  {Ray} ray
     * @return {number} -1 if no hit, a number between 0 and 1 if hit, indicating the position between the "from" and "to" points.
     * @example
     *     var aabb = new AABB({
     *         upperBound: [1, 1],
     *         lowerBound: [-1, -1]
     *     });
     *     var ray = new Ray({
     *         from: [-2, 0],
     *         to: [0, 0]
     *     });
     *     var fraction = aabb.overlapsRay(ray); // fraction == 0.5
     */
    AABB.prototype.overlapsRay = function (ray) {
        // ray.direction is unit direction vector of ray
        var dirFracX = 1 / ray.direction[0];
        var dirFracY = 1 / ray.direction[1];
        // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
        var from = ray.from;
        var lowerBound = this.lowerBound;
        var upperBound = this.upperBound;
        var t1 = (lowerBound[0] - from[0]) * dirFracX;
        var t2 = (upperBound[0] - from[0]) * dirFracX;
        var t3 = (lowerBound[1] - from[1]) * dirFracY;
        var t4 = (upperBound[1] - from[1]) * dirFracY;
        var tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        var tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));
        // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
        if (tmax < 0) {
            //t = tmax;
            return -1;
        }
        // if tmin > tmax, ray doesn't intersect AABB
        if (tmin > tmax) {
            //t = tmax;
            return -1;
        }
        return tmin / ray.length;
    };
    return AABB;
}());
exports.default = AABB;

},{"../math/vec2":28}],2:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Body_1 = __importDefault(_dereq_("../objects/Body"));
// TODO: I think this is supposed to be abstract.
var Broadphase = /** @class */ (function () {
    /**
     * Base class for broadphase implementations. Don't use this class directly.
     * @class Broadphase
     * @constructor
     */
    function Broadphase(type) {
        /**
         * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
         * @property result
         * @type {Array}
         */
        this.result = [];
        /**
         * The world to search for collision pairs in. To change it, use .setWorld()
         * @property world
         * @type {World}
         * @readOnly
         */
        this.world = null;
        /**
         * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.
         * @property {Number} boundingVolumeType
         */
        this.boundingVolumeType = Broadphase.AABB;
        this.type = type || 1;
    }
    /**
     * Set the world that we are searching for collision pairs in.
     * @method setWorld
     * @param  {World} world
     */
    // TODO: move to constructor!
    Broadphase.prototype.setWorld = function (world) {
        this.world = world;
    };
    ;
    /*
     * Get all potential intersecting body pairs.
     * @method getCollisionPairs
     * @param  {World} world The world to search in.
     * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
     */
    Broadphase.prototype.getCollisionPairs = function (world) {
        // I guess this should be overridden?
        // TODO: possible abstract method.
        return [];
    };
    ;
    /**
     * Check whether the bounding radius of two bodies overlap.
     * @method  boundingRadiusCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.boundingRadiusCheck = function (bodyA, bodyB) {
        var d2 = vec2_1.default.squaredDistance(bodyA.position, bodyB.position), r = bodyA.boundingRadius + bodyB.boundingRadius;
        return d2 <= r * r;
    };
    ;
    /**
     * Check whether the AABB of two bodies overlap.
     * @method  aabbCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.aabbCheck = function (bodyA, bodyB) {
        return bodyA.getAABB().overlaps(bodyB.getAABB());
    };
    ;
    /**
     * Check whether the bounding volumes of two bodies overlap.
     * @method  boundingVolumeCheck
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.prototype.boundingVolumeCheck = function (bodyA, bodyB) {
        var result;
        switch (this.boundingVolumeType) {
            case Broadphase.BOUNDING_CIRCLE:
                result = Broadphase.boundingRadiusCheck(bodyA, bodyB);
                break;
            case Broadphase.AABB:
                result = Broadphase.aabbCheck(bodyA, bodyB);
                break;
            default:
                throw new Error('Bounding volume type not recognized: ' + this.boundingVolumeType);
        }
        return result;
    };
    ;
    /**
     * Check whether two bodies are allowed to collide at all.
     * @method  canCollide
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Broadphase.canCollide = function (bodyA, bodyB) {
        var KINEMATIC = Body_1.default.KINEMATIC;
        var STATIC = Body_1.default.STATIC;
        var typeA = bodyA.type;
        var typeB = bodyB.type;
        // Cannot collide static bodies
        if (typeA === STATIC && typeB === STATIC) {
            return false;
        }
        // Cannot collide static vs kinematic bodies
        if ((typeA === KINEMATIC && typeB === STATIC) ||
            (typeA === STATIC && typeB === KINEMATIC)) {
            return false;
        }
        // Cannot collide kinematic vs kinematic
        if (typeA === KINEMATIC && typeB === KINEMATIC) {
            return false;
        }
        // Cannot collide both sleeping bodies
        if (bodyA.sleepState === Body_1.default.SLEEPING && bodyB.sleepState === Body_1.default.SLEEPING) {
            return false;
        }
        // Cannot collide if one is static and the other is sleeping
        if ((bodyA.sleepState === Body_1.default.SLEEPING && typeB === STATIC) ||
            (bodyB.sleepState === Body_1.default.SLEEPING && typeA === STATIC)) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    Broadphase.prototype.aabbQuery = function (world, aabb, result) {
        // To be implemented in subclasses
    };
    ;
    // Mode:
    Broadphase.NAIVE = 1;
    Broadphase.SAP = 2;
    // Bounding box:
    /**
     * Axis aligned bounding box type.
     * @static
     * @property {Number} AABB
     */
    Broadphase.AABB = 1;
    /**
     * Bounding circle type.
     * @static
     * @property {Number} BOUNDING_CIRCLE
     */
    Broadphase.BOUNDING_CIRCLE = 2;
    return Broadphase;
}());
exports.default = Broadphase;

},{"../math/vec2":28,"../objects/Body":29}],3:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var NaiveBroadphase = /** @class */ (function (_super) {
    __extends(NaiveBroadphase, _super);
    /**
     * Naive broadphase implementation. Does N^2 tests.
     *
     * @class NaiveBroadphase
     * @constructor
     * @extends Broadphase
     */
    function NaiveBroadphase() {
        return _super.call(this, broadphase_1.default.NAIVE) || this;
    }
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    NaiveBroadphase.prototype.getCollisionPairs = function (world) {
        var bodies = world.bodies, result = this.result;
        result.length = 0;
        for (var i = 0, Ncolliding = bodies.length; i !== Ncolliding; i++) {
            var bi = bodies[i];
            for (var j = 0; j < i; j++) {
                var bj = bodies[j];
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     */
    NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        var bodies = world.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return NaiveBroadphase;
}(broadphase_1.default));
exports.default = NaiveBroadphase;

},{"./broadphase":2}],4:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var sub = vec2_1.default.subtract, add = vec2_1.default.add, dot = vec2_1.default.dot, rotate = vec2_1.default.rotate, normalize = vec2_1.default.normalize, copy = vec2_1.default.copy, scale = vec2_1.default.scale, squaredLength = vec2_1.default.squaredLength, createVec2 = vec2_1.default.create;
var Circle_1 = __importDefault(_dereq_("../shapes/Circle"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var Box_1 = __importDefault(_dereq_("../shapes/Box"));
var contact_equation_pool_1 = __importDefault(_dereq_("../utils/contact-equation-pool"));
var friction_equation_pool_1 = __importDefault(_dereq_("../utils/friction-equation-pool"));
var tuple_dictionary_1 = __importDefault(_dereq_("../utils/tuple-dictionary"));
var yAxis = vec2_1.default.fromValues(0, 1);
var tmp1 = createVec2(), tmp2 = createVec2(), tmp3 = createVec2(), tmp4 = createVec2(), tmp5 = createVec2(), tmp6 = createVec2(), tmp7 = createVec2(), tmp8 = createVec2(), tmp9 = createVec2(), tmp10 = createVec2(), tmp11 = createVec2(), tmp12 = createVec2(), tmp13 = createVec2(), tmp14 = createVec2(), tmp15 = createVec2(), tmpArray = [];
var findMaxSeparation_n = vec2_1.default.create();
var findMaxSeparation_v1 = vec2_1.default.create();
var findMaxSeparation_tmp = vec2_1.default.create();
var findMaxSeparation_tmp2 = vec2_1.default.create();
var findIncidentEdge_normal1 = vec2_1.default.create();
var collidePolygons_tempVec = vec2_1.default.create();
var collidePolygons_tmpVec = vec2_1.default.create();
var collidePolygons_localTangent = vec2_1.default.create();
var collidePolygons_localNormal = vec2_1.default.create();
var collidePolygons_planePoint = vec2_1.default.create();
var collidePolygons_tangent = vec2_1.default.create();
var collidePolygons_normal = vec2_1.default.create();
var collidePolygons_negativeTangent = vec2_1.default.create();
var collidePolygons_v11 = vec2_1.default.create();
var collidePolygons_v12 = vec2_1.default.create();
var collidePolygons_dist = vec2_1.default.create();
var collidePolygons_clipPoints1 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_clipPoints2 = [vec2_1.default.create(), vec2_1.default.create()];
var collidePolygons_incidentEdge = [vec2_1.default.create(), vec2_1.default.create()];
var pic_localPoint = createVec2(), pic_r0 = createVec2(), pic_r1 = createVec2();
var bodiesOverlap_shapePositionA = createVec2(), bodiesOverlap_shapePositionB = createVec2();
var capsuleCapsule_tempVec1 = createVec2(), capsuleCapsule_tempVec2 = createVec2();
var convexCapsule_tempVec = createVec2();
var planeCapsule_tmp1 = createVec2(), planeCapsule_tmp2 = createVec2();
var circleHeightfield_candidate = createVec2(), circleHeightfield_dist = createVec2(), circleHeightfield_v0 = createVec2(), circleHeightfield_v1 = createVec2(), circleHeightfield_minCandidate = createVec2(), circleHeightfield_worldNormal = createVec2(), circleHeightfield_minCandidateNormal = createVec2();
var convexHeightfield_v0 = createVec2(), convexHeightfield_v1 = createVec2(), convexHeightfield_tilePos = createVec2(), convexHeightfield_tempConvexShape = new Convex_1.default(undefined, [createVec2(), createVec2(), createVec2(), createVec2()]);
function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape) {
    var capsuleRadius = capsuleShape.radius;
    var halfCapsuleLength = capsuleShape.length * 0.5;
    var verts = convexShape.vertices;
    vec2_1.default.set(verts[0], -halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[1], halfCapsuleLength, -capsuleRadius);
    vec2_1.default.set(verts[2], halfCapsuleLength, capsuleRadius);
    vec2_1.default.set(verts[3], -halfCapsuleLength, capsuleRadius);
}
/*
* Check if a point is in a polygon
*/
function pointInConvex(worldPoint, convexShape, convexOffset, convexAngle) {
    var localPoint = pic_localPoint, r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null;
    vec2_1.default.toLocalFrame(localPoint, worldPoint, convexOffset, convexAngle);
    for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
/*
* Check if a point is in a polygon
*/
function pointInConvexLocal(localPoint, convexShape) {
    var r0 = pic_r0, r1 = pic_r1, verts = convexShape.vertices, lastCross = null, numVerts = verts.length;
    for (var i = 0; i < numVerts + 1; i++) {
        var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
        sub(r0, v0, localPoint);
        sub(r1, v1, localPoint);
        var cross = vec2_1.default.crossLength(r0, r1);
        if (lastCross === null) {
            lastCross = cross;
        }
        // If we got a different sign of the distance vector, the point is out of the polygon
        if (cross * lastCross < 0) {
            return false;
        }
        lastCross = cross;
    }
    return true;
}
function addSub(out, a, b, c) {
    out[0] = a[0] + b[0] - c[0];
    out[1] = a[1] + b[1] - c[1];
}
function findMaxSeparation(maxSeparationOut, poly1, position1, angle1, poly2, position2, angle2) {
    // Find the max separation between poly1 and poly2 using edge normals from poly1.
    var count1 = poly1.vertices.length;
    var count2 = poly2.vertices.length;
    var n1s = poly1.normals;
    var v1s = poly1.vertices;
    var v2s = poly2.vertices;
    var n = findMaxSeparation_n;
    var v1 = findMaxSeparation_v1;
    var tmp = findMaxSeparation_tmp;
    var tmp2 = findMaxSeparation_tmp2;
    var angle = angle1 - angle2;
    var bestIndex = 0;
    var maxSeparation = -Infinity;
    for (var i = 0; i < count1; ++i) {
        // Get poly1 normal in frame2.
        vec2_1.default.rotate(n, n1s[i], angle);
        // Get poly1 vertex in frame2
        vec2_1.default.toGlobalFrame(tmp2, v1s[i], position1, angle1);
        vec2_1.default.toLocalFrame(v1, tmp2, position2, angle2);
        // Find deepest point for normal i.
        var si = Infinity;
        for (var j = 0; j < count2; ++j) {
            vec2_1.default.subtract(tmp, v2s[j], v1);
            var sij = vec2_1.default.dot(n, tmp);
            if (sij < si) {
                si = sij;
            }
        }
        if (si > maxSeparation) {
            maxSeparation = si;
            bestIndex = i;
        }
    }
    // Use a vec2 for storing the float value and always return int, for perf
    maxSeparationOut[0] = maxSeparation;
    return bestIndex;
}
function findIncidentEdge(clipVerticesOut, poly1, position1, angle1, edge1, poly2, position2, angle2) {
    var normals1 = poly1.normals;
    var count2 = poly2.vertices.length;
    var vertices2 = poly2.vertices;
    var normals2 = poly2.normals;
    // Get the normal of the reference edge in poly2's frame.
    var normal1 = findIncidentEdge_normal1;
    vec2_1.default.rotate(normal1, normals1[edge1], angle1 - angle2);
    // Find the incident edge on poly2.
    var index = 0;
    var minDot = Infinity;
    for (var i = 0; i < count2; ++i) {
        var dot_1 = vec2_1.default.dot(normal1, normals2[i]);
        if (dot_1 < minDot) {
            minDot = dot_1;
            index = i;
        }
    }
    // Build the clip vertices for the incident edge.
    var i1 = index;
    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
    vec2_1.default.toGlobalFrame(clipVerticesOut[0], vertices2[i1], position2, angle2);
    vec2_1.default.toGlobalFrame(clipVerticesOut[1], vertices2[i2], position2, angle2);
}
function clipSegmentToLine(vOut, vIn, normal, offset) {
    // Start with no output points
    var numOut = 0;
    // Calculate the distance of end points to the line
    var distance0 = vec2_1.default.dot(normal, vIn[0]) - offset;
    var distance1 = vec2_1.default.dot(normal, vIn[1]) - offset;
    // If the points are behind the plane
    if (distance0 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[0]);
    }
    if (distance1 <= 0.0) {
        vec2_1.default.copy(vOut[numOut++], vIn[1]);
    }
    // If the points are on different sides of the plane
    if (distance0 * distance1 < 0.0) {
        // Find intersection point of edge and plane
        var interp = distance0 / (distance0 - distance1);
        var v = vOut[numOut];
        vec2_1.default.subtract(v, vIn[1], vIn[0]);
        vec2_1.default.scale(v, v, interp);
        vec2_1.default.add(v, v, vIn[0]);
        ++numOut;
    }
    return numOut;
}
var Narrowphase = /** @class */ (function () {
    /**
     * Narrowphase. Creates contacts and friction given shapes and transforms.
     * @class Narrowphase
     * @constructor
     */
    function Narrowphase() {
        /**
         * @property contactEquations
         * @type {Array}
         */
        this.contactEquations = [];
        /**
         * @property frictionEquations
         * @type {Array}
         */
        this.frictionEquations = [];
        /**
         * Whether to make friction equations in the upcoming contacts.
         * @property enableFriction
         * @type {Boolean}
         */
        this.enableFriction = true;
        /**
         * Whether to make equations enabled in upcoming contacts.
         * @property enabledEquations
         * @type {Boolean}
         */
        this.enabledEquations = true;
        /**
         * The friction slip force to use when creating friction equations.
         * @property slipForce
         * @type {Number}
         */
        this.slipForce = 10.0;
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {ContactEquationPool} contactEquationPool
         *
         * @example
         *
         *     // Allocate a few equations before starting the simulation.
         *     // This way, no contact objects need to be created on the fly in the game loop.
         *     world.narrowphase.contactEquationPool.resize(1024);
         *     world.narrowphase.frictionEquationPool.resize(1024);
         */
        this.contactEquationPool = new contact_equation_pool_1.default({ size: 32 });
        /**
         * Keeps track of the allocated ContactEquations.
         * @property {FrictionEquationPool} frictionEquationPool
         */
        this.frictionEquationPool = new friction_equation_pool_1.default({ size: 64 });
        /**
         * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
         * @property enableFrictionReduction
         * @type {Boolean}
         * @deprecated This flag will be removed when the feature is stable enough.
         * @default true
         */
        this.enableFrictionReduction = true;
        /**
         * Keeps track of the colliding bodies last step.
         * @private
         * @property collidingBodiesLastStep
         * @type {TupleDictionary}
         */
        this.collidingBodiesLastStep = new tuple_dictionary_1.default();
        /**
         * @property currentContactMaterial
         * @type {ContactMaterial}
         */
        this.currentContactMaterial = null;
    }
    /**
     * @method bodiesOverlap
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @param  {boolean} [checkCollisionMasks=false]
     * @return {Boolean}
     */
    Narrowphase.prototype.bodiesOverlap = function (bodyA, bodyB, checkCollisionMasks) {
        if (checkCollisionMasks === void 0) { checkCollisionMasks = false; }
        var shapePositionA = bodiesOverlap_shapePositionA;
        var shapePositionB = bodiesOverlap_shapePositionB;
        // Loop over all shapes of bodyA
        for (var k = 0, Nshapesi = bodyA.shapes.length; k !== Nshapesi; k++) {
            var shapeA = bodyA.shapes[k];
            // All shapes of body j
            for (var l = 0, Nshapesj = bodyB.shapes.length; l !== Nshapesj; l++) {
                var shapeB = bodyB.shapes[l];
                // Check collision groups and masks
                if (checkCollisionMasks && !((shapeA.collisionGroup & shapeB.collisionMask) !== 0 && (shapeB.collisionGroup & shapeA.collisionMask) !== 0)) {
                    return false;
                }
                bodyA.toWorldFrame(shapePositionA, shapeA.position);
                bodyB.toWorldFrame(shapePositionB, shapeB.position);
                var result = this.testContact(bodyA, shapeA, shapePositionA, bodyB, shapeB, shapePositionB, true);
                if (result)
                    return true;
            }
        }
        return false;
    };
    ;
    /**
     * Check if the bodies were in contact since the last reset().
     * @method collidedLastStep
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {Boolean}
     */
    Narrowphase.prototype.collidedLastStep = function (bodyA, bodyB) {
        var id1 = bodyA.id | 0, id2 = bodyB.id | 0;
        return !!this.collidingBodiesLastStep.get(id1, id2);
    };
    ;
    /**
     * Throws away the old equations and gets ready to create new
     * @method reset
     */
    Narrowphase.prototype.reset = function () {
        this.collidingBodiesLastStep.reset();
        var eqs = this.contactEquations;
        var l = eqs.length;
        while (l--) {
            var eq = eqs[l], id1 = eq.bodyA.id, id2 = eq.bodyB.id;
            this.collidingBodiesLastStep.set(id1, id2, 1);
        }
        var ce = this.contactEquations, fe = this.frictionEquations;
        for (var i = 0; i < ce.length; i++) {
            this.contactEquationPool.release(ce[i]);
        }
        for (var i = 0; i < fe.length; i++) {
            this.frictionEquationPool.release(fe[i]);
        }
        // Reset
        this.contactEquations.length = this.frictionEquations.length = 0;
    };
    ;
    /**
     * Creates a ContactEquation, either by reusing an existing object or creating a new one.
     * @method createContactEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {ContactEquation}
     */
    Narrowphase.prototype.createContactEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.contactEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.enabled = this.enabledEquations;
        c.firstImpact = !this.collidedLastStep(bodyA, bodyB);
        c.restitution = currentContactMaterial.restitution;
        c.stiffness = currentContactMaterial.stiffness;
        c.relaxation = currentContactMaterial.relaxation;
        c.offset = currentContactMaterial.contactSkinSize;
        c.needsUpdate = true;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
     * @method createFrictionEquation
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionEquation = function (bodyA, bodyB, shapeA, shapeB) {
        var c = this.frictionEquationPool.get();
        var currentContactMaterial = this.currentContactMaterial;
        c.bodyA = bodyA;
        c.bodyB = bodyB;
        c.shapeA = shapeA;
        c.shapeB = shapeB;
        c.setSlipForce(this.slipForce);
        c.enabled = this.enabledEquations;
        c.frictionCoefficient = currentContactMaterial.friction;
        c.relativeVelocity = currentContactMaterial.surfaceVelocity;
        c.stiffness = currentContactMaterial.frictionStiffness;
        c.relaxation = currentContactMaterial.frictionRelaxation;
        c.needsUpdate = true;
        c.contactEquations.length = 0;
        return c;
    };
    ;
    /**
     * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
     * @method createFrictionFromContact
     * @param  {ContactEquation} contactEquation
     * @return {FrictionEquation}
     */
    Narrowphase.prototype.createFrictionFromContact = function (c) {
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        copy(eq.contactPointA, c.contactPointA);
        copy(eq.contactPointB, c.contactPointB);
        vec2_1.default.rotate90cw(eq.t, c.normalA);
        eq.contactEquations.push(c);
        return eq;
    };
    ;
    // Take the average N latest contact point on the plane.
    Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
        var c = this.contactEquations[this.contactEquations.length - 1];
        var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
        var bodyA = c.bodyA;
        vec2_1.default.set(eq.contactPointA, 0, 0);
        vec2_1.default.set(eq.contactPointB, 0, 0);
        vec2_1.default.set(eq.t, 0, 0);
        for (var i = 0; i < numContacts; i++) {
            c = this.contactEquations[this.contactEquations.length - 1 - i];
            if (c.bodyA === bodyA) {
                add(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                add(eq.contactPointB, eq.contactPointB, c.contactPointB);
            }
            else {
                sub(eq.t, eq.t, c.normalA);
                add(eq.contactPointA, eq.contactPointA, c.contactPointB);
                add(eq.contactPointB, eq.contactPointB, c.contactPointA);
            }
            eq.contactEquations.push(c);
        }
        var invNumContacts = 1 / numContacts;
        scale(eq.contactPointA, eq.contactPointA, invNumContacts);
        scale(eq.contactPointB, eq.contactPointB, invNumContacts);
        normalize(eq.t, eq.t);
        vec2_1.default.rotate90cw(eq.t, eq.t);
        return eq;
    };
    ;
    Narrowphase.prototype.testContact = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest
    // meta?: {
    // 	radiusA?: f32,
    // 	radiusB?: f32
    // }
    ) {
        var result = 0;
        if (shapeA.type > shapeB.type) {
            var bTmp = bodyB;
            bodyB = bodyA;
            bodyA = bTmp;
            var sTmp = shapeB;
            shapeB = shapeA;
            shapeA = sTmp;
            var pTmp = offsetB;
            offsetB = offsetA;
            offsetA = pTmp;
        }
        switch (shapeA.type | shapeB.type) {
            case 1: { // Circle/circle
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCircle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius, sb.radius);
                break;
            }
            case 3: { // Particle/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleParticle(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest);
                break;
            }
            case 5: { // Plane/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 33: // Box/circle.
            case 9: { // Convex/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, sa.radius);
                break;
            }
            case 17: { // Line/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleLine(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest, 0, sa.radius);
                break;
            }
            case 65: { // Capsule/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 129: { // Heightfield/circle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.circleHeightfield(bodyA, sa, offsetA, bodyB, sb, offsetB, justTest, sa.radius);
                break;
            }
            case 6: { // Plane/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particlePlane(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 34: // Box/particle.
            case 10: { // Convex/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleConvex(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 10: { // Capsule/particle.
                var sa = shapeA;
                var sb = shapeB;
                result = this.particleCapsule(bodyA, sa, offsetA, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 36: // Box/plane.
            case 12: { // Convex/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 20: { // Line/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeLine(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 68: { // Capsule/plane.
                var sa = shapeA;
                var sb = shapeB;
                result = this.planeCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 32: // Box/box.
            case 40: // Box/convex.
            case 8: { // Convex/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexConvex(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 24: { // Line/convex.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.convexLine(bodyA, sa, offsetA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle, 
                // 	justTest);
                break;
            }
            case 72: { // Capsule/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
            case 136: { // Heightfield/convex.
                var sa = shapeA;
                var sb = shapeB;
                result = this.convexHeightfield(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, justTest);
                break;
            }
            case 16: { // Line/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineLine(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 48: { // Box/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineBox(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 80: { // Capsule/line.
                var sa = shapeA;
                var sb = shapeB;
                // NOT SUPPORTED!
                // result = this.lineCapsule(bodyA, sa, shapePositionA, bodyA.angle + sa.angle,
                // 	bodyB, sb, offsetB, bodyB.angle + sb.angle,
                // 	justTest);
                break;
            }
            case 64: { // Capsule/capsule.
                var sa = shapeA;
                var sb = shapeB;
                result = this.capsuleCapsule(bodyA, sa, offsetA, bodyA.angle + sa.angle, bodyB, sb, offsetB, bodyB.angle + sb.angle, justTest);
                break;
            }
        }
        return result;
    };
    /**
     * Convex/line narrowphase
     * @method convexLine
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexOffset
     * @param  {Number}     convexAngle
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param {boolean}     justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.LINE] =
    Narrowphase.prototype.convexLine = function (
    /*
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Line/box narrowphase
     * @method lineBox
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      lineOffset
     * @param  {Number}     lineAngle
     * @param  {Body}       boxBody
     * @param  {Box}  boxShape
     * @param  {Array}      boxOffset
     * @param  {Number}     boxAngle
     * @param  {Boolean}    justTest
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.BOX] =
    Narrowphase.prototype.lineBox = function (
    /*
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    boxBody,
    boxShape,
    boxOffset,
    boxAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Convex/capsule narrowphase
     * @method convexCapsule
     * @param  {Body}       convexBody
     * @param  {Convex}     convexShape
     * @param  {Array}      convexPosition
     * @param  {Number}     convexAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX | Shape.CAPSULE] =
    //Narrowphase.prototype[Shape.BOX | Shape.CAPSULE] =
    Narrowphase.prototype.convexCapsule = function (convexBody, convexShape, convexPosition, convexAngle, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        var convexCapsule_tempRect = new Box_1.default({ width: 1, height: 1 });
        // Check the circles
        // Add offsets!
        var circlePos = convexCapsule_tempVec;
        var halfLength = capsuleShape.length / 2;
        vec2_1.default.set(circlePos, halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result1 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        vec2_1.default.set(circlePos, -halfLength, 0);
        vec2_1.default.toGlobalFrame(circlePos, circlePos, capsulePosition, capsuleAngle);
        var result2 = this.circleConvex(capsuleBody, capsuleShape, circlePos, convexBody, convexShape, convexPosition, convexAngle, justTest, capsuleShape.radius);
        if (justTest && (result1 + result2) !== 0) {
            return 1;
        }
        // Check center rect
        var r = convexCapsule_tempRect;
        setConvexToCapsuleShapeMiddle(r, capsuleShape);
        var result = this.convexConvex(convexBody, convexShape, convexPosition, convexAngle, capsuleBody, r, capsulePosition, capsuleAngle, justTest);
        return result + result1 + result2;
    };
    ;
    /**
     * Capsule/line narrowphase
     * @method lineCapsule
     * @param  {Body}       lineBody
     * @param  {Line}       lineShape
     * @param  {Array}      linePosition
     * @param  {Number}     lineAngle
     * @param  {Body}       capsuleBody
     * @param  {Capsule}    capsuleShape
     * @param  {Array}      capsulePosition
     * @param  {Number}     capsuleAngle
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE | Shape.CAPSULE] =
    Narrowphase.prototype.lineCapsule = function (
    /*
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
    */
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Capsule/capsule narrowphase
     * @method capsuleCapsule
     * @param  {Body}       bi
     * @param  {Capsule}    si
     * @param  {Array}      xi
     * @param  {Number}     ai
     * @param  {Body}       bj
     * @param  {Capsule}    sj
     * @param  {Array}      xj
     * @param  {Number}     aj
     */
    //Narrowphase.prototype[Shape.CAPSULE] =
    Narrowphase.prototype.capsuleCapsule = function (bi, si, xi, ai, bj, sj, xj, aj, justTest) {
        throw "Capsule-capsule collisions are not currently supported.";
        return 0;
        // let capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });
        // let enableFrictionBefore: boolean = false;
        // // Check the circles
        // // Add offsets!
        // let circlePosi = capsuleCapsule_tempVec1,
        // 	circlePosj = capsuleCapsule_tempVec2;
        // let numContacts = 0;
        // // Need 4 circle checks, between all
        // for(let i=0; i<2; i++){
        // 	vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        // 	vec2.toGlobalFrame(circlePosi, circlePosi, xi, ai);
        // 	for(let j=0; j<2; j++){
        // 		vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
        // 		vec2.toGlobalFrame(circlePosj, circlePosj, xj, aj);
        // 		// Temporarily turn off friction
        // 		if(this.enableFrictionReduction){
        // 			enableFrictionBefore = this.enableFriction;
        // 			this.enableFriction = false;
        // 		}
        // 		let result = this.circleCircle(bi,si,circlePosi, bj,sj,circlePosj, justTest, si.radius, sj.radius);
        // 		if(this.enableFrictionReduction){
        // 			this.enableFriction = enableFrictionBefore;
        // 		}
        // 		if(justTest && result !== 0){
        // 			return 1;
        // 		}
        // 		numContacts += result;
        // 	}
        // }
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // // Check circles against the center boxs
        // let rect = capsuleCapsule_tempRect1;
        // setConvexToCapsuleShapeMiddle(rect,si);
        // let result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result1 !== 0){
        // 	return 1;
        // }
        // numContacts += result1;
        // if(this.enableFrictionReduction){
        // 	// Temporarily turn off friction
        // 	let enableFrictionBefore = this.enableFriction;
        // 	this.enableFriction = false;
        // }
        // setConvexToCapsuleShapeMiddle(rect,sj);
        // let result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);
        // if(this.enableFrictionReduction){
        // 	this.enableFriction = enableFrictionBefore;
        // }
        // if(justTest && result2 !== 0){
        // 	return 1;
        // }
        // numContacts += result2;
        // if(this.enableFrictionReduction){
        // 	if(numContacts && this.enableFriction){
        // 		this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        // 	}
        // }
        // return numContacts;
    };
    ;
    /**
     * Line/line narrowphase
     * @method lineLine
     * @param  {Body}       bodyA
     * @param  {Line}       shapeA
     * @param  {Array}      positionA
     * @param  {Number}     angleA
     * @param  {Body}       bodyB
     * @param  {Line}       shapeB
     * @param  {Array}      positionB
     * @param  {Number}     angleB
     * @return {number}
     * @todo Implement me!
     */
    //Narrowphase.prototype[Shape.LINE] =
    Narrowphase.prototype.lineLine = function (
    /* bodyA,
        shapeA,
        positionA,
        angleA,
        bodyB,
        shapeB,
        positionB,
        angleB,
        justTest*/
    ) {
        // TODO
        return 0;
    };
    ;
    /**
     * Plane/line Narrowphase
     * @method planeLine
     * @param  {Body}   planeBody
     * @param  {Plane}  planeShape
     * @param  {Array}  planeOffset
     * @param  {Number} planeAngle
     * @param  {Body}   lineBody
     * @param  {Line}   lineShape
     * @param  {Array}  lineOffset
     * @param  {Number} lineAngle
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
    Narrowphase.prototype.planeLine = function (planeBody, planeShape, planeOffset, planeAngle, lineBody, lineShape, lineOffset, lineAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldVertex01 = tmp3, worldVertex11 = tmp4, worldEdge = tmp5, worldEdgeUnit = tmp6, dist = tmp7, worldNormal = tmp8, worldTangent = tmp9, verts = tmpArray, numContacts = 0;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -lineShape.length / 2, 0);
        vec2_1.default.set(worldVertex1, lineShape.length / 2, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        rotate(worldNormal, yAxis, planeAngle);
        // Check line ends
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, planeOffset);
            var d = dot(dist, worldNormal);
            if (d < 0) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(planeBody, lineBody, planeShape, lineShape);
                numContacts++;
                copy(c.normalA, worldNormal);
                normalize(c.normalA, c.normalA);
                // distance vector along plane normal
                scale(dist, worldNormal, d);
                // Vector from plane center to contact
                sub(c.contactPointA, v, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                // From line center to contact
                sub(c.contactPointB, v, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (justTest) {
            return 0;
        }
        if (!this.enableFrictionReduction) {
            if (numContacts && this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
            }
        }
        return numContacts;
    };
    ;
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
    Narrowphase.prototype.particleCapsule = function (particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest) {
        return this.circleLine(particleBody, particleShape, particlePosition, capsuleBody, capsuleShape, capsulePosition, capsuleAngle, justTest, capsuleShape.radius, 0);
    };
    ;
    /**
     * Circle/line Narrowphase
     * @method circleLine
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} lineBody
     * @param  {Line} lineShape
     * @param  {Array} lineOffset
     * @param  {Number} lineAngle
     * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
     * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
     * @param {Number} circleRadius If set, this value overrides the circle shape radius.
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
    Narrowphase.prototype.circleLine = function (circleBody, circleShape, circleOffset, 
    //circleAngle: f32,
    lineBody, lineShape, lineOffset, lineAngle, justTest, lineRadius, circleRadius) {
        lineRadius = lineRadius !== null && lineRadius !== void 0 ? lineRadius : 0;
        var orthoDist = tmp1;
        var lineToCircleOrthoUnit = tmp2;
        var projectedPoint = tmp3;
        var centerDist = tmp4;
        var worldTangent = tmp5;
        var worldEdge = tmp6;
        var worldEdgeUnit = tmp7;
        var worldVertex0 = tmp8;
        var worldVertex1 = tmp9;
        var worldVertex01 = tmp10;
        var worldVertex11 = tmp11;
        var dist = tmp12;
        var lineToCircle = tmp13;
        var lineEndToLineRadius = tmp14;
        var verts = tmpArray;
        var halfLineLength = lineShape.length / 2;
        // Get start and end points
        vec2_1.default.set(worldVertex0, -halfLineLength, 0);
        vec2_1.default.set(worldVertex1, halfLineLength, 0);
        // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
        vec2_1.default.toGlobalFrame(worldVertex01, worldVertex0, lineOffset, lineAngle);
        vec2_1.default.toGlobalFrame(worldVertex11, worldVertex1, lineOffset, lineAngle);
        copy(worldVertex0, worldVertex01);
        copy(worldVertex1, worldVertex11);
        // Get vector along the line
        sub(worldEdge, worldVertex1, worldVertex0);
        normalize(worldEdgeUnit, worldEdge);
        // Get tangent to the edge.
        vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
        // Check distance from the plane spanned by the edge vs the circle
        sub(dist, circleOffset, worldVertex0);
        var d = dot(dist, worldTangent); // Distance from center of line to circle center
        sub(centerDist, worldVertex0, lineOffset);
        sub(lineToCircle, circleOffset, lineOffset);
        var radiusSum = circleRadius + lineRadius;
        if (Math.abs(d) < radiusSum) {
            // Now project the circle onto the edge
            scale(orthoDist, worldTangent, d);
            sub(projectedPoint, circleOffset, orthoDist);
            // Add the missing line radius
            scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
            normalize(lineToCircleOrthoUnit, lineToCircleOrthoUnit);
            scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
            add(projectedPoint, projectedPoint, lineToCircleOrthoUnit);
            // Check if the point is within the edge span
            var pos = dot(worldEdgeUnit, projectedPoint);
            var pos0 = dot(worldEdgeUnit, worldVertex0);
            var pos1 = dot(worldEdgeUnit, worldVertex1);
            if (pos > pos0 && pos < pos1) {
                // We got contact!
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                scale(c.normalA, orthoDist, -1);
                normalize(c.normalA, c.normalA);
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, projectedPoint, lineOffset);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        // Add corner
        verts[0] = worldVertex0;
        verts[1] = worldVertex1;
        for (var i = 0; i < verts.length; i++) {
            var v = verts[i];
            sub(dist, v, circleOffset);
            if (squaredLength(dist) < Math.pow(radiusSum, 2)) {
                if (justTest) {
                    return 1;
                }
                var c = this.createContactEquation(circleBody, lineBody, circleShape, lineShape);
                copy(c.normalA, dist);
                normalize(c.normalA, c.normalA);
                // Vector from circle to contact point is the normal times the circle radius
                scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);
                sub(c.contactPointB, v, lineOffset);
                scale(lineEndToLineRadius, c.normalA, -lineRadius);
                add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
                add(c.contactPointB, c.contactPointB, lineOffset);
                sub(c.contactPointB, c.contactPointB, lineBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
                return 1;
            }
        }
        return 0;
    };
    ;
    /**
     * Circle/capsule Narrowphase
     * @method circleCapsule
     * @param  {Body}   bi
     * @param  {Circle} si
     * @param  {Array}  xi
     * @param  {Body}   bj
     * @param  {Line}   sj
     * @param  {Array}  xj
     * @param  {Number} aj
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
    Narrowphase.prototype.circleCapsule = function (bi, si, xi, bj, sj, xj, aj, justTest) {
        return this.circleLine(bi, si, xi, bj, sj, xj, aj, justTest, 0, si.radius);
    };
    ;
    /**
     * Circle/convex Narrowphase.
     * @method circleConvex
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param  {Boolean} justTest
     * @param  {Number} circleRadius
     * @return {number}
     * @todo Should probably do a separating axis test like https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2CollideCircle.cpp#L62
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CIRCLE | Shape.BOX] =
    Narrowphase.prototype.circleConvex = function (circleBody, circleShape, circleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest, circleRadius) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, edge = tmp3, edgeUnit = tmp4, normal = tmp5, zero = tmp6, localCirclePosition = tmp7, r = tmp8, dist = tmp10, worldVertex = tmp11, closestEdgeProjectedPoint = tmp13, candidate = tmp14, candidateDist = tmp15, found = -1, minCandidateDistance = Infinity;
        vec2_1.default.set(zero, 0, 0);
        // New algorithm:
        // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        vec2_1.default.toLocalFrame(localCirclePosition, circleOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        var normals = convexShape.normals;
        var numVertices = vertices.length;
        var normalIndex = -1;
        // Find the min separating edge.
        var separation = -Infinity;
        var radius = convexShape.boundingRadius + circleRadius;
        for (var i = 0; i < numVertices; i++) {
            sub(r, localCirclePosition, vertices[i]);
            var s = dot(normals[i], r);
            if (s > radius) {
                // Early out.
                return 0;
            }
            if (s > separation) {
                separation = s;
                normalIndex = i;
            }
        }
        // Check edges first
        for (var i = normalIndex + numVertices - 1; i < normalIndex + numVertices + 2; i++) {
            var v0 = vertices[i % numVertices], n = normals[i % numVertices];
            // Get point on circle, closest to the convex
            scale(candidate, n, -circleRadius);
            add(candidate, candidate, localCirclePosition);
            if (pointInConvexLocal(candidate, convexShape)) {
                sub(candidateDist, v0, candidate);
                var candidateDistance = Math.abs(dot(candidateDist, n));
                if (candidateDistance < minCandidateDistance) {
                    minCandidateDistance = candidateDistance;
                    found = i;
                }
            }
        }
        if (found !== -1) {
            if (justTest) {
                return 1;
            }
            var v0 = vertices[found % numVertices], v1 = vertices[(found + 1) % numVertices];
            vec2_1.default.toGlobalFrame(worldVertex0, v0, convexOffset, convexAngle);
            vec2_1.default.toGlobalFrame(worldVertex1, v1, convexOffset, convexAngle);
            sub(edge, worldVertex1, worldVertex0);
            normalize(edgeUnit, edge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(normal, edgeUnit);
            // Get point on circle, closest to the convex
            scale(candidate, normal, -circleRadius);
            add(candidate, candidate, circleOffset);
            scale(closestEdgeProjectedPoint, normal, minCandidateDistance);
            add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, candidate);
            var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
            sub(c.normalA, candidate, circleOffset);
            normalize(c.normalA, c.normalA);
            scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        // Check closest vertices
        if (circleRadius > 0 && normalIndex !== -1) {
            for (var i = normalIndex + numVertices; i < normalIndex + numVertices + 2; i++) {
                var localVertex = vertices[i % numVertices];
                sub(dist, localVertex, localCirclePosition);
                if (squaredLength(dist) < circleRadius * circleRadius) {
                    if (justTest) {
                        return 1;
                    }
                    vec2_1.default.toGlobalFrame(worldVertex, localVertex, convexOffset, convexAngle);
                    sub(dist, worldVertex, circleOffset);
                    var c = this.createContactEquation(circleBody, convexBody, circleShape, convexShape);
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    // Vector from circle to contact point is the normal times the circle radius
                    scale(c.contactPointA, c.normalA, circleRadius);
                    add(c.contactPointA, c.contactPointA, circleOffset);
                    sub(c.contactPointA, c.contactPointA, circleBody.position);
                    sub(c.contactPointB, worldVertex, convexOffset);
                    add(c.contactPointB, c.contactPointB, convexOffset);
                    sub(c.contactPointB, c.contactPointB, convexBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                    return 1;
                }
            }
        }
        return 0;
    };
    ;
    /**
     * Particle/convex Narrowphase
     * @method particleConvex
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Number} particleAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo use pointInConvex and code more similar to circleConvex
     * @todo don't transform each vertex, but transform the particle position to convex-local instead
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PARTICLE | Shape.BOX] =
    Narrowphase.prototype.particleConvex = function (particleBody, particleShape, particleOffset, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex0 = tmp1, worldVertex1 = tmp2, worldEdge = tmp3, worldEdgeUnit = tmp4, worldTangent = tmp5, centerDist = tmp6, convexToparticle = tmp7, closestEdgeProjectedPoint = tmp13, candidateDist = tmp14, minEdgeNormal = tmp15, minCandidateDistance = Infinity, found = false, verts = convexShape.vertices;
        // Check if the particle is in the polygon at all
        if (!pointInConvex(particleOffset, convexShape, convexOffset, convexAngle)) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        // Check edges first
        for (var i = 0, numVerts = verts.length; i !== numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            // Transform vertices to world
            // @todo transform point to local space instead
            rotate(worldVertex0, v0, convexAngle);
            rotate(worldVertex1, v1, convexAngle);
            add(worldVertex0, worldVertex0, convexOffset);
            add(worldVertex1, worldVertex1, convexOffset);
            // Get world edge
            sub(worldEdge, worldVertex1, worldVertex0);
            normalize(worldEdgeUnit, worldEdge);
            // Get tangent to the edge. Points out of the Convex
            vec2_1.default.rotate90cw(worldTangent, worldEdgeUnit);
            // Check distance from the infinite line (spanned by the edge) to the particle
            //sub(dist, particleOffset, worldVertex0);
            //let d = dot(dist, worldTangent);
            sub(centerDist, worldVertex0, convexOffset);
            sub(convexToparticle, particleOffset, convexOffset);
            sub(candidateDist, worldVertex0, particleOffset);
            var candidateDistance = Math.abs(dot(candidateDist, worldTangent));
            if (candidateDistance < minCandidateDistance) {
                minCandidateDistance = candidateDistance;
                scale(closestEdgeProjectedPoint, worldTangent, candidateDistance);
                add(closestEdgeProjectedPoint, closestEdgeProjectedPoint, particleOffset);
                copy(minEdgeNormal, worldTangent);
                found = true;
            }
        }
        if (found) {
            var c = this.createContactEquation(particleBody, convexBody, particleShape, convexShape);
            scale(c.normalA, minEdgeNormal, -1);
            normalize(c.normalA, c.normalA);
            // Particle has no extent to the contact point
            vec2_1.default.set(c.contactPointA, 0, 0);
            add(c.contactPointA, c.contactPointA, particleOffset);
            sub(c.contactPointA, c.contactPointA, particleBody.position);
            // From convex center to point
            sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
            add(c.contactPointB, c.contactPointB, convexOffset);
            sub(c.contactPointB, c.contactPointB, convexBody.position);
            this.contactEquations.push(c);
            if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }
            return 1;
        }
        return 0;
    };
    ;
    /**
     * Circle/circle Narrowphase
     * @method circleCircle
     * @param  {Body} bodyA
     * @param  {Circle} shapeA
     * @param  {Array} offsetA
     * @param  {Body} bodyB
     * @param  {Circle} shapeB
     * @param  {Array} offsetB
     * @param {Boolean} justTest
     * @param {Number} [radiusA] Optional radius to use for shapeA
     * @param {Number} [radiusB] Optional radius to use for shapeB
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE] =
    Narrowphase.prototype.circleCircle = function (bodyA, shapeA, offsetA, bodyB, shapeB, offsetB, justTest, radiusA, radiusB) {
        var dist = tmp1;
        sub(dist, offsetA, offsetB);
        var r = radiusA + radiusB;
        if (squaredLength(dist) > r * r) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(bodyA, bodyB, shapeA, shapeB);
        var cpA = c.contactPointA;
        var cpB = c.contactPointB;
        var normalA = c.normalA;
        sub(normalA, offsetB, offsetA);
        normalize(normalA, normalA);
        scale(cpA, normalA, radiusA);
        scale(cpB, normalA, -radiusB);
        addSub(cpA, cpA, offsetA, bodyA.position);
        addSub(cpB, cpB, offsetB, bodyB.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Plane/Convex Narrowphase
     * @method planeConvex
     * @param  {Body} planeBody
     * @param  {Plane} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} convexBody
     * @param  {Convex} convexShape
     * @param  {Array} convexOffset
     * @param  {Number} convexAngle
     * @param {Boolean} justTest
     * @return {number}
     * @todo only use the deepest contact point + the contact point furthest away from it
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
    //Narrowphase.prototype[Shape.PLANE | Shape.BOX] =
    Narrowphase.prototype.planeConvex = function (planeBody, planeShape, planeOffset, planeAngle, convexBody, convexShape, convexOffset, convexAngle, justTest) {
        var worldVertex = tmp1, worldNormal = tmp2, dist = tmp3, localPlaneOffset = tmp4, localPlaneNormal = tmp5, localDist = tmp6;
        var numReported = 0;
        rotate(worldNormal, yAxis, planeAngle);
        // Get convex-local plane offset and normal
        vec2_1.default.vectorToLocalFrame(localPlaneNormal, worldNormal, convexAngle);
        vec2_1.default.toLocalFrame(localPlaneOffset, planeOffset, convexOffset, convexAngle);
        var vertices = convexShape.vertices;
        for (var i = 0, numVerts = vertices.length; i !== numVerts; i++) {
            var v = vertices[i];
            sub(localDist, v, localPlaneOffset);
            if (dot(localDist, localPlaneNormal) <= 0) {
                if (justTest) {
                    return 1;
                }
                vec2_1.default.toGlobalFrame(worldVertex, v, convexOffset, convexAngle);
                sub(dist, worldVertex, planeOffset);
                // Found vertex
                numReported++;
                var c = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);
                sub(dist, worldVertex, planeOffset);
                copy(c.normalA, worldNormal);
                var d = dot(dist, c.normalA);
                scale(dist, c.normalA, d);
                // rj is from convex center to contact
                sub(c.contactPointB, worldVertex, convexBody.position);
                // ri is from plane center to contact
                sub(c.contactPointA, worldVertex, dist);
                sub(c.contactPointA, c.contactPointA, planeBody.position);
                this.contactEquations.push(c);
                if (!this.enableFrictionReduction) {
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (this.enableFrictionReduction) {
            if (this.enableFriction && numReported) {
                this.frictionEquations.push(this.createFrictionFromAverage(numReported));
            }
        }
        return numReported;
    };
    ;
    /**
     * Narrowphase for particle vs plane
     * @method particlePlane
     * @param  {Body}       particleBody
     * @param  {Particle}   particleShape
     * @param  {Array}      particleOffset
     * @param  {Body}       planeBody
     * @param  {Plane}      planeShape
     * @param  {Array}      planeOffset
     * @param  {Number}     planeAngle
     * @param {Boolean}     justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
    Narrowphase.prototype.particlePlane = function (particleBody, particleShape, particleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var dist = tmp1, worldNormal = tmp2;
        planeAngle = planeAngle || 0;
        sub(dist, particleOffset, planeOffset);
        rotate(worldNormal, yAxis, planeAngle);
        var d = dot(dist, worldNormal);
        if (d > 0) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(planeBody, particleBody, planeShape, particleShape);
        copy(c.normalA, worldNormal);
        scale(dist, c.normalA, d);
        // dist is now the distance vector in the normal direction
        // ri is the particle position projected down onto the plane, from the plane center
        sub(c.contactPointA, particleOffset, dist);
        sub(c.contactPointA, c.contactPointA, planeBody.position);
        // rj is from the body center to the particle center
        sub(c.contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * Circle/Particle Narrowphase
     * @method circleParticle
     * @param  {Body} circleBody
     * @param  {Circle} circleShape
     * @param  {Array} circleOffset
     * @param  {Body} particleBody
     * @param  {Particle} particleShape
     * @param  {Array} particleOffset
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
    Narrowphase.prototype.circleParticle = function (circleBody, circleShape, circleOffset, particleBody, particleShape, particleOffset, justTest) {
        var dist = tmp1;
        var circleRadius = circleShape.radius;
        sub(dist, particleOffset, circleOffset);
        if (squaredLength(dist) > circleRadius * circleRadius) {
            return 0;
        }
        if (justTest) {
            return 1;
        }
        var c = this.createContactEquation(circleBody, particleBody, circleShape, particleShape);
        var normalA = c.normalA;
        var contactPointA = c.contactPointA;
        var contactPointB = c.contactPointB;
        copy(normalA, dist);
        normalize(normalA, normalA);
        // Vector from circle to contact point is the normal times the circle radius
        scale(contactPointA, normalA, circleRadius);
        add(contactPointA, contactPointA, circleOffset);
        sub(contactPointA, contactPointA, circleBody.position);
        // Vector from particle center to contact point is zero
        sub(contactPointB, particleOffset, particleBody.position);
        this.contactEquations.push(c);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(c));
        }
        return 1;
    };
    ;
    /**
     * @method planeCapsule
     * @param  {Body} planeBody
     * @param  {Circle} planeShape
     * @param  {Array} planeOffset
     * @param  {Number} planeAngle
     * @param  {Body} capsuleBody
     * @param  {Particle} capsuleShape
     * @param  {Array} capsuleOffset
     * @param  {Number} capsuleAngle
     * @param {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
    Narrowphase.prototype.planeCapsule = function (planeBody, planeShape, planeOffset, planeAngle, capsuleBody, capsuleShape, capsuleOffset, capsuleAngle, justTest) {
        var planeCapsule_tmpCircle = new Circle_1.default({ radius: 1 });
        var end1 = planeCapsule_tmp1, end2 = planeCapsule_tmp2, circle = planeCapsule_tmpCircle, halfLength = capsuleShape.length / 2;
        // Compute world end positions
        vec2_1.default.set(end1, -halfLength, 0);
        vec2_1.default.set(end2, halfLength, 0);
        vec2_1.default.toGlobalFrame(end1, end1, capsuleOffset, capsuleAngle);
        vec2_1.default.toGlobalFrame(end2, end2, capsuleOffset, capsuleAngle);
        circle.radius = capsuleShape.radius;
        var enableFrictionBefore = this.enableFriction;
        // Temporarily turn off friction
        if (this.enableFrictionReduction) {
            this.enableFriction = false;
        }
        // Do Narrowphase as two circles
        var numContacts1 = this.circlePlane(capsuleBody, circle, end1, planeBody, planeShape, planeOffset, planeAngle, justTest), numContacts2 = this.circlePlane(capsuleBody, circle, end2, planeBody, planeShape, planeOffset, planeAngle, justTest);
        // Restore friction
        if (this.enableFrictionReduction) {
            this.enableFriction = enableFrictionBefore;
        }
        if (justTest) {
            return numContacts1 + numContacts2;
        }
        else {
            var numTotal = numContacts1 + numContacts2;
            if (this.enableFrictionReduction) {
                if (numTotal) {
                    this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
                }
            }
            return numTotal;
        }
    };
    ;
    /**
     * @method circlePlane
     * @param  {Body}    circleBody
     * @param  {Circle}  circleShape
     * @param  {Array}   circleOffset
     * @param  {Body}    planeBody
     * @param  {Plane}   planeShape
     * @param  {Array}   planeOffset
     * @param  {Number}  planeAngle
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
    Narrowphase.prototype.circlePlane = function (circleBody, circleShape, circleOffset, planeBody, planeShape, planeOffset, planeAngle, justTest) {
        var circleRadius = circleShape.radius;
        // Vector from plane to circle
        var planeToCircle = tmp1, worldNormal = tmp2, temp = tmp3;
        sub(planeToCircle, circleOffset, planeOffset);
        // World plane normal
        rotate(worldNormal, yAxis, planeAngle);
        // Normal direction distance
        var d = dot(worldNormal, planeToCircle);
        if (d > circleRadius) {
            return 0; // No overlap. Abort.
        }
        if (justTest) {
            return 1;
        }
        // Create contact
        var contact = this.createContactEquation(planeBody, circleBody, planeShape, circleShape);
        // ni is the plane world normal
        copy(contact.normalA, worldNormal);
        // rj is the vector from circle center to the contact point
        var cpB = contact.contactPointB;
        scale(cpB, contact.normalA, -circleRadius);
        add(cpB, cpB, circleOffset);
        sub(cpB, cpB, circleBody.position);
        // ri is the distance from plane center to contact.
        var cpA = contact.contactPointA;
        scale(temp, contact.normalA, d);
        sub(cpA, planeToCircle, temp); // Subtract normal distance vector from the distance vector
        add(cpA, cpA, planeOffset);
        sub(cpA, cpA, planeBody.position);
        this.contactEquations.push(contact);
        if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(contact));
        }
        return 1;
    };
    ;
    // Find edge normal of max separation on A - return if separating axis is found
    // Find edge normal of max separation on B - return if separation axis is found
    // Choose reference edge as min(minA, minB)
    // Find incident edge
    // Clip
    // The normal points from 1 to 2
    /*function collidePolygons(
        manifold,
        polyA, positionA, angleA,
        polyB, positionB, angleB,
        incidentEdge
    ) {*/
    /**
     * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
     * @method convexConvex
     * @param  {Body} bi
     * @param  {Convex} si
     * @param  {Array} xi
     * @param  {Number} ai
     * @param  {Body} bj
     * @param  {Convex} sj
     * @param  {Array} xj
     * @param  {Number} aj
     * @param  {Boolean} justTest
     * @return {number}
     */
    //Narrowphase.prototype[Shape.CONVEX] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.BOX] =
    //Narrowphase.prototype[Shape.BOX] =
    Narrowphase.prototype.convexConvex = function (bodyA, polyA, positionA, angleA, bodyB, polyB, positionB, angleB, justTest) {
        var maxManifoldPoints = 2;
        var totalRadius = 0;
        var dist = collidePolygons_dist;
        var tempVec = collidePolygons_tempVec;
        var tmpVec = collidePolygons_tmpVec;
        var edgeA = findMaxSeparation(tempVec, polyA, positionA, angleA, polyB, positionB, angleB);
        var separationA = tempVec[0];
        if (separationA > totalRadius) {
            return 0;
        }
        var edgeB = findMaxSeparation(tmpVec, polyB, positionB, angleB, polyA, positionA, angleA);
        var separationB = tmpVec[0];
        if (separationB > totalRadius) {
            return 0;
        }
        var poly1; // reference polygon
        var poly2; // incident polygon
        var position1;
        var position2;
        var angle1;
        var angle2;
        var body1;
        var body2;
        var edge1; // reference edge
        var type;
        if (separationB > separationA) {
            poly1 = polyB;
            poly2 = polyA;
            body1 = bodyB;
            body2 = bodyA;
            position1 = positionB;
            angle1 = angleB;
            position2 = positionA;
            angle2 = angleA;
            edge1 = edgeB;
            type = 1; // faceB
        }
        else {
            poly1 = polyA;
            poly2 = polyB;
            body1 = bodyA;
            body2 = bodyB;
            position1 = positionA;
            angle1 = angleA;
            position2 = positionB;
            angle2 = angleB;
            edge1 = edgeA;
            type = 0; // faceA
        }
        var incidentEdge = collidePolygons_incidentEdge;
        findIncidentEdge(incidentEdge, poly1, position1, angle1, edge1, poly2, position2, angle2);
        var count1 = poly1.vertices.length;
        var vertices1 = poly1.vertices;
        var iv1 = edge1;
        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
        var v11 = collidePolygons_v11;
        var v12 = collidePolygons_v12;
        vec2_1.default.copy(v11, vertices1[iv1]);
        vec2_1.default.copy(v12, vertices1[iv2]);
        var localTangent = collidePolygons_localTangent;
        vec2_1.default.subtract(localTangent, v12, v11);
        vec2_1.default.normalize(localTangent, localTangent);
        var localNormal = collidePolygons_localNormal;
        vec2_1.default.crossVZ(localNormal, localTangent, 1.0);
        var planePoint = collidePolygons_planePoint;
        vec2_1.default.add(planePoint, v11, v12);
        vec2_1.default.scale(planePoint, planePoint, 0.5);
        var tangent = collidePolygons_tangent; // tangent in world space
        vec2_1.default.rotate(tangent, localTangent, angle1);
        var normal = collidePolygons_normal; // normal in world space
        vec2_1.default.crossVZ(normal, tangent, 1.0);
        vec2_1.default.toGlobalFrame(v11, v11, position1, angle1);
        vec2_1.default.toGlobalFrame(v12, v12, position1, angle1);
        // Face offset.
        var frontOffset = vec2_1.default.dot(normal, v11);
        // Side offsets, extended by polytope skin thickness.
        var sideOffset1 = -vec2_1.default.dot(tangent, v11) + totalRadius;
        var sideOffset2 = vec2_1.default.dot(tangent, v12) + totalRadius;
        // Clip incident edge against extruded edge1 side edges.
        var clipPoints1 = collidePolygons_clipPoints1;
        var clipPoints2 = collidePolygons_clipPoints2;
        var np = 0;
        // Clip to box side 1
        var negativeTangent = collidePolygons_negativeTangent;
        vec2_1.default.scale(negativeTangent, tangent, -1);
        np = clipSegmentToLine(clipPoints1, incidentEdge, negativeTangent, sideOffset1 /*, iv1*/);
        if (np < 2) {
            return 0;
        }
        // Clip to negative box side 1
        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2 /*, iv2*/);
        if (np < 2) {
            return 0;
        }
        var pointCount = 0;
        for (var i = 0; i < maxManifoldPoints; ++i) {
            var separation = vec2_1.default.dot(normal, clipPoints2[i]) - frontOffset;
            if (separation <= totalRadius) {
                if (justTest) {
                    return 1;
                }
                ++pointCount;
                var c = this.createContactEquation(body1, body2, poly1, poly2);
                vec2_1.default.copy(c.normalA, normal);
                vec2_1.default.copy(c.contactPointB, clipPoints2[i]);
                sub(c.contactPointB, c.contactPointB, body2.position);
                vec2_1.default.scale(dist, normal, -separation);
                vec2_1.default.add(c.contactPointA, clipPoints2[i], dist);
                sub(c.contactPointA, c.contactPointA, body1.position);
                this.contactEquations.push(c);
                if (this.enableFriction && !this.enableFrictionReduction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        if (pointCount && this.enableFrictionReduction && this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromAverage(pointCount));
        }
        return pointCount;
    };
    ;
    //Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.circleHeightfield = function (circleBody, circleShape, circlePos, hfBody, hfShape, hfPos, justTest, radius) {
        var data = hfShape.heights, w = hfShape.elementWidth, dist = circleHeightfield_dist, candidate = circleHeightfield_candidate, minCandidate = circleHeightfield_minCandidate, minCandidateNormal = circleHeightfield_minCandidateNormal, worldNormal = circleHeightfield_worldNormal, v0 = circleHeightfield_v0, v1 = circleHeightfield_v1;
        // Get the index of the points to test against
        var idxA = Math.floor((circlePos[0] - radius - hfPos[0]) / w), idxB = Math.ceil((circlePos[0] + radius - hfPos[0]) / w);
        /*if(idxB < 0 || idxA >= data.length)
            return justTest ? false : 0;*/
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (circlePos[1] - radius > max) {
            return 0;
        }
        /*
        if(circlePos[1]+radius < min){
            // Below the minimum point... We can just guess.
            // TODO
        }
        */
        // 1. Check so center of circle is not inside the field. If it is, this wont work...
        // 2. For each edge
        // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
        // 2. 2. Check if point is inside.
        var found = false;
        // Check all edges first
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos); // @todo transform circle to local heightfield space instead
            add(v1, v1, hfPos);
            // Get normal
            sub(worldNormal, v1, v0);
            rotate(worldNormal, worldNormal, Math.PI / 2);
            normalize(worldNormal, worldNormal);
            // Get point on circle, closest to the edge
            scale(candidate, worldNormal, -radius);
            add(candidate, candidate, circlePos);
            // Distance from v0 to the candidate point
            sub(dist, candidate, v0);
            // Check if it is in the element "stick"
            var d = dot(dist, worldNormal);
            if (candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0) {
                if (justTest) {
                    return 1;
                }
                found = true;
                // Store the candidate point, projected to the edge
                scale(dist, worldNormal, -d);
                add(minCandidate, candidate, dist);
                copy(minCandidateNormal, worldNormal);
                var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                // Normal is out of the heightfield
                copy(c.normalA, minCandidateNormal);
                // Vector from circle to heightfield
                scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);
                copy(c.contactPointA, minCandidate);
                sub(c.contactPointA, c.contactPointA, hfBody.position);
                this.contactEquations.push(c);
                if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
        // Check all vertices
        found = false;
        if (radius > 0) {
            for (var i = idxA; i <= idxB; i++) {
                // Get point
                vec2_1.default.set(v0, i * w, data[i]);
                add(v0, v0, hfPos);
                sub(dist, circlePos, v0);
                if (squaredLength(dist) < Math.pow(radius, 2)) {
                    if (justTest) {
                        return 1;
                    }
                    found = true;
                    var c = this.createContactEquation(hfBody, circleBody, hfShape, circleShape);
                    // Construct normal - out of heightfield
                    copy(c.normalA, dist);
                    normalize(c.normalA, c.normalA);
                    scale(c.contactPointB, c.normalA, -radius);
                    add(c.contactPointB, c.contactPointB, circlePos);
                    sub(c.contactPointB, c.contactPointB, circleBody.position);
                    sub(c.contactPointA, v0, hfPos);
                    add(c.contactPointA, c.contactPointA, hfPos);
                    sub(c.contactPointA, c.contactPointA, hfBody.position);
                    this.contactEquations.push(c);
                    if (this.enableFriction) {
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
        if (found) {
            return 1;
        }
        return 0;
    };
    //Narrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =
    //Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
    Narrowphase.prototype.convexHeightfield = function (convexBody, convexShape, convexPos, convexAngle, hfBody, hfShape, hfPos, justTest) {
        var data = hfShape.heights, w = hfShape.elementWidth, v0 = convexHeightfield_v0, v1 = convexHeightfield_v1, tilePos = convexHeightfield_tilePos, tileConvex = convexHeightfield_tempConvexShape;
        // Get the index of the points to test against
        var idxA = Math.floor((convexBody.aabb.lowerBound[0] - hfPos[0]) / w), idxB = Math.ceil((convexBody.aabb.upperBound[0] - hfPos[0]) / w);
        if (idxA < 0) {
            idxA = 0;
        }
        if (idxB >= data.length) {
            idxB = data.length - 1;
        }
        // Get max and min
        var max = data[idxA], min = data[idxB];
        for (var i = idxA; i < idxB; i++) {
            if (data[i] < min) {
                min = data[i];
            }
            if (data[i] > max) {
                max = data[i];
            }
        }
        if (convexBody.aabb.lowerBound[1] > max) {
            return 0;
        }
        var numContacts = 0;
        // Loop over all edges
        // @todo If possible, construct a convex from several data points (need o check if the points make a convex shape)
        // @todo transform convex to local heightfield space.
        // @todo bail out if the heightfield tile is not tall enough.
        for (var i = idxA; i < idxB; i++) {
            // Get points
            vec2_1.default.set(v0, i * w, data[i]);
            vec2_1.default.set(v1, (i + 1) * w, data[i + 1]);
            add(v0, v0, hfPos);
            add(v1, v1, hfPos);
            // Construct a convex
            var tileHeight = 100; // todo
            vec2_1.default.set(tilePos, (v1[0] + v0[0]) * 0.5, (v1[1] + v0[1] - tileHeight) * 0.5);
            sub(tileConvex.vertices[0], v1, tilePos);
            sub(tileConvex.vertices[1], v0, tilePos);
            copy(tileConvex.vertices[2], tileConvex.vertices[1]);
            copy(tileConvex.vertices[3], tileConvex.vertices[0]);
            tileConvex.vertices[2][1] -= tileHeight;
            tileConvex.vertices[3][1] -= tileHeight;
            tileConvex.updateNormals();
            // Do convex collision
            numContacts += this.convexConvex(convexBody, convexShape, convexPos, convexAngle, hfBody, tileConvex, tilePos, 0, justTest);
        }
        return numContacts;
    };
    return Narrowphase;
}());
exports.default = Narrowphase;

},{"../math/vec2":28,"../shapes/Box":35,"../shapes/Circle":36,"../shapes/Convex":37,"../utils/contact-equation-pool":49,"../utils/friction-equation-pool":50,"../utils/tuple-dictionary":55}],5:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectBody_worldPosition = vec2_1.default.create();
var v0 = vec2_1.default.create(), intersect = vec2_1.default.create();
var Ray = /** @class */ (function () {
    /**
     * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink "World/raycast:method"}}World.raycast{{/crossLink}}
     * @class Ray
     * @constructor
     * @param {object} [options]
     * @param {array} [options.from]
     * @param {array} [options.to]
     * @param {boolean} [options.checkCollisionResponse=true]
     * @param {boolean} [options.skipBackfaces=false]
     * @param {number} [options.collisionMask=-1]
     * @param {number} [options.collisionGroup=-1]
     * @param {number} [options.mode=Ray.ANY]
     * @param {Function} [options.callback]
     */
    function Ray(options) {
        /**
         * @readOnly
         * @property {array} direction
         */
        this.direction = vec2_1.default.create();
        /**
         * Length of the ray
         * @readOnly
         * @property {number} length
         */
        this.length = 1;
        options = options !== null && options !== void 0 ? options : {};
        this.from = options.from ? vec2_1.default.clone(options.from) : vec2_1.default.create();
        this.to = options.to ? vec2_1.default.clone(options.to) : vec2_1.default.create();
        this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;
        this.skipBackfaces = !!options.skipBackfaces;
        this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;
        this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;
        this.mode = options.mode !== undefined ? options.mode : Ray.ANY;
        this.callback = options.callback || function ( /*result*/) { };
        this.update();
    }
    /**
     * Should be called if you change the from or to point.
     * @method update
     */
    Ray.prototype.update = function () {
        // Update .direction and .length
        var d = this.direction;
        vec2_1.default.subtract(d, this.to, this.from);
        this.length = vec2_1.default.length(d);
        vec2_1.default.normalize(d, d);
    };
    ;
    /**
     * @method intersectBodies
     * @param {Array} bodies An array of Body objects.
     */
    Ray.prototype.intersectBodies = function (result, bodies) {
        for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {
            var body = bodies[i];
            var aabb = body.getAABB();
            if (aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)) {
                this.intersectBody(result, body);
            }
        }
    };
    ;
    /**
     * Shoot a ray at a body, get back information about the hit.
     * @method intersectBody
     * @private
     * @param {Body} body
     */
    Ray.prototype.intersectBody = function (result, body) {
        var checkCollisionResponse = this.checkCollisionResponse;
        if (checkCollisionResponse && !body.collisionResponse) {
            return;
        }
        var worldPosition = intersectBody_worldPosition;
        for (var i = 0, N = body.shapes.length; i < N; i++) {
            var shape = body.shapes[i];
            if (checkCollisionResponse && !shape.collisionResponse) {
                continue; // Skip
            }
            if ((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0) {
                continue;
            }
            // Get world angle and position of the shape
            vec2_1.default.rotate(worldPosition, shape.position, body.angle);
            vec2_1.default.add(worldPosition, worldPosition, body.position);
            var worldAngle = shape.angle + body.angle;
            this.intersectShape(result, shape, worldAngle, worldPosition, body);
            if (result.shouldStop(this)) {
                break;
            }
        }
    };
    ;
    /**
     * @method intersectShape
     * @private
     * @param {Shape} shape
     * @param {number} angle
     * @param {array} position
     * @param {Body} body
     */
    Ray.prototype.intersectShape = function (result, shape, angle, position, body) {
        var from = this.from;
        // Checking radius
        var distance = distanceFromIntersectionSquared(from, this.direction, position);
        if (distance > shape.boundingRadius * shape.boundingRadius) {
            return;
        }
        this._currentBody = body;
        this._currentShape = shape;
        shape.raycast(result, this, position, angle);
        this._currentBody = undefined;
        this._currentShape = undefined;
    };
    ;
    /**
     * Get the AABB of the ray.
     * @method getAABB
     * @param  {AABB} aabb
     */
    Ray.prototype.getAABB = function (result) {
        var to = this.to;
        var from = this.from;
        vec2_1.default.set(result.lowerBound, Math.min(to[0], from[0]), Math.min(to[1], from[1]));
        vec2_1.default.set(result.upperBound, Math.max(to[0], from[0]), Math.max(to[1], from[1]));
    };
    ;
    /**
     * @method reportIntersection
     * @private
     * @param  {number} fraction
     * @param  {array} normal
     * @param  {number} [faceIndex=-1]
     * @return {boolean} True if the intersections should continue // This never returned anything.
     */
    Ray.prototype.reportIntersection = function (result, fraction, normal, faceIndex) {
        var shape = this._currentShape;
        var body = this._currentBody;
        // Skip back faces?
        if (this.skipBackfaces && vec2_1.default.dot(normal, this.direction) > 0) {
            return;
        }
        switch (this.mode) {
            case Ray.ALL:
                result.set(normal, shape, body, fraction, faceIndex);
                this.callback(result);
                break;
            case Ray.CLOSEST:
                // Store if closer than current closest
                if (fraction < result.fraction || !result.hasHit()) {
                    result.set(normal, shape, body, fraction, faceIndex);
                }
                break;
            case Ray.ANY:
                // Report and stop.
                result.set(normal, shape, body, fraction, faceIndex);
                break;
        }
    };
    ;
    /**
     * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.
     * @static
     * @property {Number} CLOSEST
     */
    Ray.CLOSEST = 1;
    /**
     * This raycasting mode will make the Ray stop when it finds the first intersection point.
     * @static
     * @property {Number} ANY
     */
    Ray.ANY = 2;
    /**
     * This raycasting mode will traverse all intersection points and executes a callback for each one.
     * @static
     * @property {Number} ALL
     */
    Ray.ALL = 4;
    return Ray;
}());
exports.default = Ray;
function distanceFromIntersectionSquared(from, direction, position) {
    // v0 is vector from from to position
    vec2_1.default.subtract(v0, position, from);
    var dot = vec2_1.default.dot(v0, direction);
    // intersect = direction * dot + from
    vec2_1.default.scale(intersect, direction, dot);
    vec2_1.default.add(intersect, intersect, from);
    return vec2_1.default.squaredDistance(position, intersect);
}

},{"../math/vec2":28}],6:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var ray_1 = __importDefault(_dereq_("./ray"));
var RaycastResult = /** @class */ (function () {
    /**
     * Storage for Ray casting hit data.
     * @class RaycastResult
     * @constructor
     */
    function RaycastResult() {
        /**
         * The normal of the hit, oriented in world space.
         * @property {array} normal
         */
        this.normal = vec2_1.default.create();
        /**
         * The index of the hit triangle, if the hit shape was indexable.
         * @property {number} faceIndex
         * @default -1
         */
        this.faceIndex = -1;
        /**
         * Distance to the hit, as a fraction. 0 is at the "from" point, 1 is at the "to" point. Will be set to -1 if there was no hit yet.
         * @property {number} fraction
         * @default -1
         */
        this.fraction = -1;
        /**
         * If the ray should stop traversing.
         * @readonly
         * @property {Boolean} isStopped
         */
        this.isStopped = false;
    }
    /**
     * Reset all result data. Must be done before re-using the result object.
     * @method reset
     */
    RaycastResult.prototype.reset = function () {
        vec2_1.default.set(this.normal, 0, 0);
        this.shape = undefined;
        this.body = undefined;
        this.faceIndex = -1;
        this.fraction = -1;
        this.isStopped = false;
    };
    /**
     * Get the distance to the hit point.
     * @method getHitDistance
     * @param {Ray} ray
     * @return {number}
     */
    RaycastResult.prototype.getHitDistance = function (ray) {
        return vec2_1.default.distance(ray.from, ray.to) * this.fraction;
    };
    /**
     * Returns true if the ray hit something since the last reset().
     * @method hasHit
     * @eturn {boolean}
     */
    RaycastResult.prototype.hasHit = function () {
        return this.fraction !== -1;
    };
    /**
     * Get world hit point.
     * @method getHitPoint
     * @param {array} out
     * @param {Ray} ray
     */
    RaycastResult.prototype.getHitPoint = function (out, ray) {
        vec2_1.default.lerp(out, ray.from, ray.to, this.fraction);
    };
    /**
     * Can be called while iterating over hits to stop searching for hit points.
     * @method stop
     */
    RaycastResult.prototype.stop = function () {
        this.isStopped = true;
    };
    /**
     * @method shouldStop
     * @private
     * @param {Ray} ray
     * @return {boolean}
     */
    RaycastResult.prototype.shouldStop = function (ray) {
        return this.isStopped || (this.fraction !== -1 && ray.mode === ray_1.default.ANY);
    };
    /**
     * @method set
     * @private
     * @param {array} normal
     * @param {Shape} shape
     * @param {Body} body
     * @param {number} fraction
     * @param {number} faceIndex
     */
    RaycastResult.prototype.set = function (normal, shape, body, fraction, faceIndex) {
        vec2_1.default.copy(this.normal, normal);
        this.shape = shape;
        this.body = body;
        this.fraction = fraction;
        this.faceIndex = faceIndex;
    };
    return RaycastResult;
}());
exports.default = RaycastResult;

},{"../math/vec2":28,"./ray":5}],7:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var broadphase_1 = __importDefault(_dereq_("./broadphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
// TODO: this appears to be a bubble sort. We could probably do better.
function sortAxisList(a, axisIndex) {
    for (var i = 1, l = a.length; i < l; i++) { // Why not i=0?
        var v = a[i];
        for (var j = i - 1; j >= 0; j--) {
            if (a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]) {
                break;
            }
            a[j + 1] = a[j];
        }
        a[j + 1] = v;
    }
    return a;
}
var SAPBroadphase = /** @class */ (function (_super) {
    __extends(SAPBroadphase, _super);
    /**
     * Sweep and prune broadphase along one axis.
     *
     * @class SAPBroadphase
     * @constructor
     * @extends Broadphase
     */
    function SAPBroadphase() {
        var _this = _super.call(this, broadphase_1.default.SAP) || this;
        _this.axisList = [];
        _this.axisIndex = 0;
        _this._addBodyHandler = function (e) {
            _this.axisList.push(e.body);
        };
        _this._removeBodyHandler = function (e) {
            // Remove from list
            var idx = _this.axisList.indexOf(e.body);
            if (idx !== -1) {
                _this.axisList.splice(idx, 1);
            }
        };
        return _this;
    }
    /**
     * Change the world
     * @method setWorld
     * @param {World} world
     */
    SAPBroadphase.prototype.setWorld = function (world) {
        // Clear the old axis array
        this.axisList.length = 0;
        // Add all bodies from the new world
        utils_1.default.appendArray(this.axisList, world.bodies);
        // Remove old handlers, if any
        world
            .off("addBody", this._addBodyHandler)
            .off("removeBody", this._removeBodyHandler);
        // Add handlers to update the list of bodies.
        // TODO: now that I've added context, we can test moving those inline functions to proper private methods.
        world.on("addBody", this._addBodyHandler, this)
            .on("removeBody", this._removeBodyHandler, this);
        this.world = world;
    };
    ;
    SAPBroadphase.prototype.sortList = function () {
        var bodies = this.axisList, axisIndex = this.axisIndex;
        // Sort the lists
        sortAxisList(bodies, axisIndex);
    };
    ;
    /**
     * Get the colliding pairs
     * @method getCollisionPairs
     * @param  {World} world
     * @return {Array}
     */
    SAPBroadphase.prototype.getCollisionPairs = function ( /*world*/) {
        var bodies = this.axisList, result = this.result, axisIndex = this.axisIndex;
        result.length = 0;
        // Update all AABBs if needed
        var l = bodies.length;
        while (l--) {
            var b = bodies[l];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
        }
        // Sort the lists
        this.sortList();
        // Look through the X list
        for (var i = 0, N = bodies.length | 0; i !== N; i++) {
            var bi = bodies[i];
            for (var j = i + 1; j < N; j++) {
                var bj = bodies[j];
                // Bounds overlap?
                var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
                if (!overlaps) {
                    break;
                }
                if (broadphase_1.default.canCollide(bi, bj) && this.boundingVolumeCheck(bi, bj)) {
                    result.push(bi);
                    result.push(bj);
                }
            }
        }
        return result;
    };
    ;
    /**
     * Returns all the bodies within an AABB.
     * @method aabbQuery
     * @param  {World} world
     * @param  {AABB} aabb
     * @param {array} result An array to store resulting bodies in.
     * @return {array}
     * @todo since the list is sorted, optimization can be done
     */
    SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
        result = result || [];
        this.sortList();
        var axisList = this.axisList;
        for (var i = 0; i < axisList.length; i++) {
            var b = axisList[i];
            if (b.aabbNeedsUpdate) {
                b.updateAABB();
            }
            if (b.aabb.overlaps(aabb)) {
                result.push(b);
            }
        }
        return result;
    };
    ;
    return SAPBroadphase;
}(broadphase_1.default));
exports.default = SAPBroadphase;

},{"../utils/utils":56,"./broadphase":2}],8:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Constraint = /** @class */ (function () {
    /**
     * Base constraint class.
     *
     * @class Constraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} type
     * @param {Object} [options]
     * @param {Object} [options.collideConnected=true]
     */
    function Constraint(bodyA, bodyB, type, options) {
        var _a, _b;
        this.type = type;
        this.equations = [];
        this.bodyA = bodyA;
        this.bodyB = bodyB;
        this.collideConnected = (_a = options === null || options === void 0 ? void 0 : options.collideConnected) !== null && _a !== void 0 ? _a : true;
        // Wake up bodies when connected
        if (((_b = options === null || options === void 0 ? void 0 : options.wakeUpBodies) !== null && _b !== void 0 ? _b : false) !== false) {
            if (bodyA) {
                bodyA.wakeUp();
            }
            if (bodyB) {
                bodyB.wakeUp();
            }
        }
    }
    /**
     * Updates the internal constraint parameters before solve.
     * @method update
     */
    Constraint.prototype.update = function () {
        throw new Error("method update() not implmemented in this Constraint subclass!");
    };
    ;
    /**
     * Set stiffness for this constraint.
     * @method setStiffness
     * @param {Number} stiffness
     */
    Constraint.prototype.setStiffness = function (stiffness) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.stiffness = stiffness;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * Set relaxation for this constraint.
     * @method setRelaxation
     * @param {Number} relaxation
     */
    Constraint.prototype.setRelaxation = function (relaxation) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.relaxation = relaxation;
            eq.needsUpdate = true;
        }
    };
    ;
    /**
     * @method setMaxBias
     * @param {Number} maxBias
     */
    Constraint.prototype.setMaxBias = function (maxBias) {
        var eqs = this.equations;
        for (var i = 0; i !== eqs.length; i++) {
            var eq = eqs[i];
            eq.maxBias = maxBias;
        }
    };
    ;
    /**
     * @static
     * @property {number} DISTANCE
     */
    Constraint.DISTANCE = 1;
    /**
     * @static
     * @property {number} GEAR
     */
    Constraint.GEAR = 2;
    /**
     * @static
     * @property {number} LOCK
     */
    Constraint.LOCK = 3;
    /**
     * @static
     * @property {number} PRISMATIC
     */
    Constraint.PRISMATIC = 4;
    /**
     * @static
     * @property {number} REVOLUTE
     */
    Constraint.REVOLUTE = 5;
    return Constraint;
}());
exports.default = Constraint;

},{}],9:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var n = vec2_1.default.create();
var ri = vec2_1.default.create(); // worldAnchorA
var rj = vec2_1.default.create(); // worldAnchorB
var DistanceConstraint = /** @class */ (function (_super) {
    __extends(DistanceConstraint, _super);
    // this.upperLimitEnabled = false;
    // this.upperLimit = 1;
    // this.lowerLimitEnabled = false;
    // this.lowerLimit = 0;
    // this.position = 0;
    /**
     * Constraint that tries to keep the distance between two bodies constant.
     *
     * @class DistanceConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {object} [options]
     * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
     * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
     * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
     * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
     * @extends Constraint
     *
     * @example
     *     // If distance is not given as an option, then the current distance between the bodies is used.
     *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     var constraint = new DistanceConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     // Manually set the distance and anchors
     *     var constraint = new DistanceConstraint(bodyA, bodyB, {
     *         distance: 1,          // Distance to keep between the points
     *         localAnchorA: [1, 0], // Point on bodyA
     *         localAnchorB: [-1, 0] // Point on bodyB
     *     });
     *     world.addConstraint(constraint);
     */
    function DistanceConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.DISTANCE, options) || this;
        /**
         * The distance to keep.
         * @property distance
         * @type {Number}
         */
        _this.distance = 0;
        /**
         * Max force to apply.
         * @property {number} maxForce
         */
        _this.maxForce = Infinity;
        /**
         * If the upper limit is enabled or not.
         * @property {Boolean} upperLimitEnabled
         */
        _this.upperLimitEnabled = false;
        /**
         * The upper constraint limit.
         * @property {number} upperLimit
         */
        _this.upperLimit = 1;
        /**
         * If the lower limit is enabled or not.
         * @property {Boolean} lowerLimitEnabled
         */
        _this.lowerLimitEnabled = false;
        /**
         * The lower constraint limit.
         * @property {number} lowerLimit
         */
        _this.lowerLimit = 0;
        /**
         * Current constraint position. This is equal to the current distance between the world anchor points.
         * @property {number} position
         */
        _this.position = 0;
        _this.localAnchorA = (options === null || options === void 0 ? void 0 : options.localAnchorA) ? vec2_1.default.clone(options.localAnchorA) : vec2_1.default.create();
        _this.localAnchorB = (options === null || options === void 0 ? void 0 : options.localAnchorB) ? vec2_1.default.clone(options.localAnchorB) : vec2_1.default.create();
        var localAnchorA = _this.localAnchorA;
        var localAnchorB = _this.localAnchorB;
        _this.distance = 0;
        if ((options === null || options === void 0 ? void 0 : options.distance) !== undefined) {
            _this.distance = options.distance;
        }
        else {
            // Use the current world distance between the world anchor points.
            var worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), r = vec2_1.default.create();
            // Transform local anchors to world
            vec2_1.default.rotate(worldAnchorA, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(worldAnchorB, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, bodyB.position, worldAnchorB);
            vec2_1.default.subtract(r, r, worldAnchorA);
            vec2_1.default.subtract(r, r, bodyA.position);
            _this.distance = vec2_1.default.length(r);
        }
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var normal = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce); // Just in the normal direction
        _this.equations = [normal];
        _this.maxForce = maxForce;
        // g = (xi - xj).dot(n)
        // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'
        // ...and if we were to include offset points:
        // g =
        //      (xj + rj - xi - ri).dot(n) - distance
        // dg/dt =
        //      (vj + wj x rj - vi - wi x ri).dot(n) =
        //      { term 2 is near zero } =
        //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
        //      G * W
        // => G = [-n -rixn n rjxn]
        var r = vec2_1.default.create();
        var ri = vec2_1.default.create(); // worldAnchorA
        var rj = vec2_1.default.create(); // worldAnchorB
        var that = _this;
        normal.computeGq = function () {
            var bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position;
            // Transform local anchors to world
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(r, xj, rj);
            vec2_1.default.subtract(r, r, ri);
            vec2_1.default.subtract(r, r, xi);
            //vec2.subtract(r, bodyB.position, bodyA.position);
            return vec2_1.default.length(r) - that.distance;
        };
        // Make the contact constraint bilateral
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    DistanceConstraint.prototype.update = function () {
        var normal = this.equations[0], bodyA = this.bodyA, bodyB = this.bodyB, xi = bodyA.position, xj = bodyB.position, normalEquation = this.equations[0], G = normal.G;
        // Transform local anchors to world
        vec2_1.default.rotate(ri, this.localAnchorA, bodyA.angle);
        vec2_1.default.rotate(rj, this.localAnchorB, bodyB.angle);
        // Get world anchor points and normal
        vec2_1.default.add(n, xj, rj);
        vec2_1.default.subtract(n, n, ri);
        vec2_1.default.subtract(n, n, xi);
        this.position = vec2_1.default.length(n);
        var violating = false;
        if (this.upperLimitEnabled) {
            if (this.position > this.upperLimit) {
                normalEquation.maxForce = 0;
                normalEquation.minForce = -this.maxForce;
                this.distance = this.upperLimit;
                violating = true;
            }
        }
        if (this.lowerLimitEnabled) {
            if (this.position < this.lowerLimit) {
                normalEquation.maxForce = this.maxForce;
                normalEquation.minForce = 0;
                this.distance = this.lowerLimit;
                violating = true;
            }
        }
        if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating) {
            // No constraint needed.
            normalEquation.enabled = false;
            return;
        }
        normalEquation.enabled = true;
        vec2_1.default.normalize(n, n);
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
    };
    /**
     * Set the max force to be used
     * @method setMaxForce
     * @param {Number} maxForce
     */
    DistanceConstraint.prototype.setMaxForce = function (maxForce) {
        var normal = this.equations[0];
        normal.minForce = -maxForce;
        normal.maxForce = maxForce;
    };
    /**
     * Get the max force
     * @method getMaxForce
     * @return {Number}
     */
    DistanceConstraint.prototype.getMaxForce = function () {
        var normal = this.equations[0];
        return normal.maxForce;
    };
    return DistanceConstraint;
}(constraint_1.default));
exports.default = DistanceConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],10:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var angle_lock_equation_1 = __importDefault(_dereq_("../equations/angle-lock-equation"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var GearConstraint = /** @class */ (function (_super) {
    __extends(GearConstraint, _super);
    /**
     * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.
     * @class GearConstraint
     * @constructor
     * @author schteppe
     * @param {Body}            bodyA
     * @param {Body}            bodyB
     * @param {Object}          [options]
     * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
     * @param {Number}          [options.ratio=1] Gear ratio.
     * @param {Number}          [options.maxTorque] Maximum torque to apply.
     * @extends Constraint
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     *
     * @example
     *     var constraint = new GearConstraint(bodyA, bodyB, {
     *         ratio: 2,
     *         maxTorque: 1000
     *     });
     *     world.addConstraint(constraint);
     */
    function GearConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = this;
        options = options || {};
        _this = _super.call(this, bodyA, bodyB, constraint_1.default.GEAR, options) || this;
        /**
         * The gear ratio.
         * @property ratio
         * @type {Number}
         */
        _this.ratio = (_a = options === null || options === void 0 ? void 0 : options.ratio) !== null && _a !== void 0 ? _a : 1;
        /**
         * The relative angle
         * @property angle
         * @type {Number}
         */
        _this.angle = options.angle !== undefined ? options.angle : bodyB.angle - _this.ratio * bodyA.angle;
        // Send same parameters to the equation
        _this.equations = [
            new angle_lock_equation_1.default(bodyA, bodyB, {
                ratio: _this.ratio,
                angle: _this.angle
            }),
        ];
        // Set max torque
        if (options.maxTorque !== undefined) {
            _this.setMaxTorque(options.maxTorque);
        }
        return _this;
    }
    GearConstraint.prototype.update = function () {
        var eq = this.equations[0];
        var ratio = this.ratio;
        if (eq.ratio !== ratio) {
            eq.setRatio(ratio);
        }
        eq.angle = this.angle;
    };
    /**
     * Set the max torque for the constraint.
     * @method setMaxTorque
     * @param {Number} torque
     */
    GearConstraint.prototype.setMaxTorque = function (torque) {
        this.equations[0].setMaxTorque(torque);
    };
    /**
     * Get the max torque for the constraint.
     * @method getMaxTorque
     * @return {Number}
     */
    GearConstraint.prototype.getMaxTorque = function () {
        return this.equations[0].maxForce;
    };
    return GearConstraint;
}(constraint_1.default));
exports.default = GearConstraint;

},{"../equations/angle-lock-equation":15,"./constraint":8}],11:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var l = vec2_1.default.create();
var r = vec2_1.default.create();
var t = vec2_1.default.create();
var xAxis = vec2_1.default.fromValues(1, 0);
var yAxis = vec2_1.default.fromValues(0, 1);
var LockConstraint = /** @class */ (function (_super) {
    __extends(LockConstraint, _super);
    /**
     * Locks the relative position and rotation between two bodies.
     *
     * @class LockConstraint
     * @constructor
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
     * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
     * @param {number} [options.maxForce]
     * @extends Constraint
     *
     * @example
     *     // Locks the relative position and rotation between bodyA and bodyB
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    function LockConstraint(bodyA, bodyB, options) {
        //options = options || {};
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.LOCK, options) || this;
        var maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Use 3 equations:
        // gx =   (xj - xi - l) * xhat = 0
        // gy =   (xj - xi - l) * yhat = 0
        // gr =   (xi - xj + r) * that = 0
        //
        // ...where:
        //   l is the localOffsetB vector rotated to world in bodyA frame
        //   r is the same vector but reversed and rotated from bodyB frame
        //   xhat, yhat are world axis vectors
        //   that is the tangent of r
        //
        // For the first two constraints, we get
        // G*W = (vj - vi - ldot  ) * xhat
        //     = (vj - vi - wi x l) * xhat
        //
        // Since (wi x l) * xhat = (l x xhat) * wi, we get
        // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
        //
        // The last constraint gives
        // GW = (vi - vj + wj x r) * that
        //    = [  that   0  -that  (r x t) ]
        var x = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), y = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce), rot = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var l = vec2_1.default.create(), g = vec2_1.default.create(), that = _this;
        x.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[0];
        };
        y.computeGq = function () {
            vec2_1.default.rotate(l, that.localOffsetB, bodyA.angle);
            vec2_1.default.subtract(g, bodyB.position, bodyA.position);
            vec2_1.default.subtract(g, g, l);
            return g[1];
        };
        var r = vec2_1.default.create(), t = vec2_1.default.create();
        rot.computeGq = function () {
            vec2_1.default.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
            vec2_1.default.scale(r, r, -1);
            vec2_1.default.subtract(g, bodyA.position, bodyB.position);
            vec2_1.default.add(g, g, r);
            vec2_1.default.rotate(t, r, -Math.PI / 2);
            vec2_1.default.normalize(t, t);
            return vec2_1.default.dot(g, t);
        };
        /**
         * The offset of bodyB in bodyA's frame.
         * @property {Array} localOffsetB
         */
        _this.localOffsetB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localOffsetB) {
            vec2_1.default.copy(_this.localOffsetB, options.localOffsetB);
        }
        else {
            // Construct from current positions
            vec2_1.default.subtract(_this.localOffsetB, bodyB.position, bodyA.position);
            vec2_1.default.rotate(_this.localOffsetB, _this.localOffsetB, -bodyA.angle);
        }
        /**
         * The offset angle of bodyB in bodyA's frame.
         * @property {Number} localAngleB
         */
        _this.localAngleB = (_b = options === null || options === void 0 ? void 0 : options.localAngleB) !== null && _b !== void 0 ? _b : bodyB.angle - bodyA.angle;
        _this.equations.push(x);
        _this.equations.push(y);
        _this.equations.push(rot);
        _this.setMaxForce(maxForce);
        return _this;
    }
    /**
     * Set the maximum force to be applied.
     * @method setMaxForce
     * @param {Number} force
     */
    LockConstraint.prototype.setMaxForce = function (force) {
        var eqs = this.equations;
        for (var i = 0; i < this.equations.length; i++) {
            eqs[i].maxForce = force;
            eqs[i].minForce = -force;
        }
    };
    /**
     * Get the max force.
     * @method getMaxForce
     * @return {Number}
     */
    LockConstraint.prototype.getMaxForce = function () {
        return this.equations[0].maxForce;
    };
    LockConstraint.prototype.update = function () {
        var x = this.equations[0], y = this.equations[1], rot = this.equations[2], bodyA = this.bodyA, bodyB = this.bodyB;
        vec2_1.default.rotate(l, this.localOffsetB, bodyA.angle);
        vec2_1.default.rotate(r, this.localOffsetB, bodyB.angle - this.localAngleB);
        vec2_1.default.scale(r, r, -1);
        vec2_1.default.rotate(t, r, Math.PI / 2);
        vec2_1.default.normalize(t, t);
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[2] = -vec2_1.default.crossLength(l, xAxis);
        x.G[3] = 1;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[2] = -vec2_1.default.crossLength(l, yAxis);
        y.G[4] = 1;
        rot.G[0] = -t[0];
        rot.G[1] = -t[1];
        rot.G[3] = t[0];
        rot.G[4] = t[1];
        rot.G[5] = vec2_1.default.crossLength(r, t);
    };
    return LockConstraint;
}(constraint_1.default));
exports.default = LockConstraint;

},{"../equations/Equation":14,"../math/vec2":28,"./constraint":8}],12:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var constraint_1 = __importDefault(_dereq_("./constraint"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var worldAxisA = vec2_1.default.create(), worldAnchorA = vec2_1.default.create(), worldAnchorB = vec2_1.default.create(), orientedAnchorA = vec2_1.default.create(), orientedAnchorB = vec2_1.default.create(), tmp = vec2_1.default.create();
var PrismaticConstraint = /** @class */ (function (_super) {
    __extends(PrismaticConstraint, _super);
    /**
     * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>. Also called "slider constraint".
     *
     * @class PrismaticConstraint
     * @constructor
     * @extends Constraint
     * @author schteppe
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.maxForce] Max force to be applied by the constraint
     * @param {Array} [options.localAnchorA] Body A's anchor point, defined in its own local frame.
     * @param {Array} [options.localAnchorB] Body B's anchor point, defined in its own local frame.
     * @param {Array} [options.localAxisA] An axis, defined in body A frame, that body B's anchor point may slide along.
     * @param {Boolean} [options.disableRotationalLock] If set to true, bodyB will be free to rotate around its anchor point.
     * @param {Number} [options.upperLimit]
     * @param {Number} [options.lowerLimit]
     * @todo Ability to create using only a point and a worldAxis
     * @example
     *     var constraint = new PrismaticConstraint(bodyA, bodyB, {
     *         localAxisA: [0, 1]
     *     });
     *     world.addConstraint(constraint);
     */
    function PrismaticConstraint(bodyA, bodyB, options) {
        var _a, _b, _c;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.PRISMATIC, options) || this;
        // Get anchors
        var localAnchorA = vec2_1.default.create(), localAxisA = vec2_1.default.fromValues(1, 0), localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAxisA) {
            vec2_1.default.copy(localAxisA, options.localAxisA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(localAnchorB, options.localAnchorB);
        }
        _this.localAnchorA = localAnchorA;
        _this.localAnchorB = localAnchorB;
        _this.localAxisA = localAxisA;
        /*

        The constraint violation for the common axis point is

            g = ( xj + rj - xi - ri ) * t   :=  gg*t

        where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

            gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

        Note the use of the chain rule. Now we identify the jacobian

            G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

        The rotational part is just a rotation lock.

        */
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        // Translational part
        var trans = new Equation_1.default(bodyA, bodyB, -maxForce, maxForce);
        var ri = vec2_1.default.create(), rj = vec2_1.default.create(), gg = vec2_1.default.create(), t = vec2_1.default.create();
        // TODO: This is a bad practice.
        trans.computeGq = function () {
            // g = ( xj + rj - xi - ri ) * t
            return vec2_1.default.dot(gg, t);
        };
        // TODO: This is a bad practice.
        trans.updateJacobian = function () {
            var G = this.G, xi = bodyA.position, xj = bodyB.position;
            vec2_1.default.rotate(ri, localAnchorA, bodyA.angle);
            vec2_1.default.rotate(rj, localAnchorB, bodyB.angle);
            vec2_1.default.add(gg, xj, rj);
            vec2_1.default.subtract(gg, gg, xi);
            vec2_1.default.subtract(gg, gg, ri);
            vec2_1.default.rotate(t, localAxisA, bodyA.angle + Math.PI / 2);
            G[0] = -t[0];
            G[1] = -t[1];
            G[2] = -vec2_1.default.crossLength(ri, t) + vec2_1.default.crossLength(t, gg);
            G[3] = t[0];
            G[4] = t[1];
            G[5] = vec2_1.default.crossLength(rj, t);
        };
        _this.equations.push(trans);
        // Rotational part
        if (!(options === null || options === void 0 ? void 0 : options.disableRotationalLock)) {
            var rot = new rotational_lock_equation_1.default(bodyA, bodyB);
            _this.equations.push(rot);
        }
        /**
         * The position of anchor A relative to anchor B, along the constraint axis.
         * @property position
         * @type {Number}
         */
        _this.position = 0;
        // Is this one used at all?
        _this.velocity = 0;
        /**
         * Set to true to enable lower limit.
         * @property lowerLimitEnabled
         * @type {Boolean}
         */
        _this.lowerLimitEnabled = (options === null || options === void 0 ? void 0 : options.lowerLimit) !== undefined ? true : false;
        /**
         * Set to true to enable upper limit.
         * @property upperLimitEnabled
         * @type {Boolean}
         */
        _this.upperLimitEnabled = (options === null || options === void 0 ? void 0 : options.upperLimit) !== undefined ? true : false;
        /**
         * Lower constraint limit. The constraint position is forced to be larger than this value.
         * @property lowerLimit
         * @type {Number}
         */
        _this.lowerLimit = (_b = options === null || options === void 0 ? void 0 : options.lowerLimit) !== null && _b !== void 0 ? _b : 0;
        /**
         * Upper constraint limit. The constraint position is forced to be smaller than this value.
         * @property upperLimit
         * @type {Number}
         */
        _this.upperLimit = (_c = options === null || options === void 0 ? void 0 : options.upperLimit) !== null && _c !== void 0 ? _c : 1;
        // Equations used for limits
        _this.upperLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        _this.lowerLimitEquation = new contact_equation_1.default(bodyA, bodyB);
        // Set max/min forces
        _this.upperLimitEquation.minForce = _this.lowerLimitEquation.minForce = 0;
        _this.upperLimitEquation.maxForce = _this.lowerLimitEquation.maxForce = maxForce;
        /**
         * Equation used for the motor.
         * @property motorEquation
         * @type {Equation}
         */
        _this.motorEquation = new Equation_1.default(bodyA, bodyB);
        /**
         * The current motor state. Enable or disable the motor using .enableMotor
         * @property motorEnabled
         * @type {Boolean}
         */
        _this.motorEnabled = false;
        /**
         * Set the target speed for the motor.
         * @property motorSpeed
         * @type {Number}
         */
        _this.motorSpeed = 0;
        var that = _this;
        var motorEquation = _this.motorEquation;
        motorEquation.computeGq = function () { return 0; };
        motorEquation.computeGW = function () {
            var G = this.G, bi = this.bodyA, bj = this.bodyB, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
            return this.gmult(G, vi, wi, vj, wj) + that.motorSpeed;
        };
        return _this;
    }
    /**
     * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
     * @method update
     */
    PrismaticConstraint.prototype.update = function () {
        var eqs = this.equations, trans = eqs[0], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation, bodyA = this.bodyA, bodyB = this.bodyB, localAxisA = this.localAxisA, localAnchorA = this.localAnchorA, localAnchorB = this.localAnchorB;
        trans.updateJacobian();
        // Transform local things to world
        vec2_1.default.rotate(worldAxisA, localAxisA, bodyA.angle);
        vec2_1.default.rotate(orientedAnchorA, localAnchorA, bodyA.angle);
        vec2_1.default.add(worldAnchorA, orientedAnchorA, bodyA.position);
        vec2_1.default.rotate(orientedAnchorB, localAnchorB, bodyB.angle);
        vec2_1.default.add(worldAnchorB, orientedAnchorB, bodyB.position);
        var relPosition = this.position = vec2_1.default.dot(worldAnchorB, worldAxisA) - vec2_1.default.dot(worldAnchorA, worldAxisA);
        // Motor
        if (this.motorEnabled) {
            // G = [ a     a x ri   -a   -a x rj ]
            var G = this.motorEquation.G;
            G[0] = worldAxisA[0];
            G[1] = worldAxisA[1];
            G[2] = vec2_1.default.crossLength(worldAxisA, orientedAnchorB);
            G[3] = -worldAxisA[0];
            G[4] = -worldAxisA[1];
            G[5] = -vec2_1.default.crossLength(worldAxisA, orientedAnchorA);
        }
        /*
            Limits strategy:
            Add contact equation, with normal along the constraint axis.
            min/maxForce is set so the constraint is repulsive in the correct direction.
            Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                    ^
                    |
        upperLimit x
                    |    ------
            anchorB x<---|  B |
                    |    |    |
            ------   |    ------
            |    |   |
            |  A |-->x anchorA
            ------   |
                    x lowerLimit
                    |
                    axis
        */
        if (this.upperLimitEnabled && relPosition > upperLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(upperLimitEquation.normalA, worldAxisA, -1);
            vec2_1.default.subtract(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, upperLimit);
            vec2_1.default.add(upperLimitEquation.contactPointA, upperLimitEquation.contactPointA, tmp);
            if (eqs.indexOf(upperLimitEquation) === -1) {
                eqs.push(upperLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(upperLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
        if (this.lowerLimitEnabled && relPosition < lowerLimit) {
            // Update contact constraint normal, etc
            vec2_1.default.scale(lowerLimitEquation.normalA, worldAxisA, 1);
            vec2_1.default.subtract(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
            vec2_1.default.scale(tmp, worldAxisA, lowerLimit);
            vec2_1.default.subtract(lowerLimitEquation.contactPointB, lowerLimitEquation.contactPointB, tmp);
            if (eqs.indexOf(lowerLimitEquation) === -1) {
                eqs.push(lowerLimitEquation);
            }
        }
        else {
            var idx = eqs.indexOf(lowerLimitEquation);
            if (idx !== -1) {
                eqs.splice(idx, 1);
            }
        }
    };
    /**
     * Enable the motor
     * @method enableMotor
     */
    PrismaticConstraint.prototype.enableMotor = function () {
        if (this.motorEnabled) {
            return;
        }
        this.equations.push(this.motorEquation);
        this.motorEnabled = true;
    };
    /**
     * Disable the rotational motor
     * @method disableMotor
     */
    PrismaticConstraint.prototype.disableMotor = function () {
        if (!this.motorEnabled) {
            return;
        }
        var i = this.equations.indexOf(this.motorEquation);
        this.equations.splice(i, 1);
        this.motorEnabled = false;
    };
    /**
     * Set the constraint limits.
     * @method setLimits
     * @param {number} lower Lower limit.
     * @param {number} upper Upper limit.
     */
    PrismaticConstraint.prototype.setLimits = function (lower, upper) {
        if (typeof (lower) === 'number') {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = true;
        }
        else {
            this.lowerLimit = lower;
            this.lowerLimitEnabled = false;
        }
        if (typeof (upper) === 'number') {
            this.upperLimit = upper;
            this.upperLimitEnabled = true;
        }
        else {
            this.upperLimit = upper;
            this.upperLimitEnabled = false;
        }
    };
    return PrismaticConstraint;
}(constraint_1.default));
exports.default = PrismaticConstraint;

},{"../equations/Equation":14,"../equations/contact-equation":16,"../equations/rotational-lock-equation":19,"../math/vec2":28,"./constraint":8}],13:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constraint_1 = __importDefault(_dereq_("./constraint"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var rotational_velocity_equation_1 = __importDefault(_dereq_("../equations/rotational-velocity-equation"));
var rotational_lock_equation_1 = __importDefault(_dereq_("../equations/rotational-lock-equation"));
var sub = vec2_1.default.subtract;
var add = vec2_1.default.add;
var dot = vec2_1.default.dot;
var rotate = vec2_1.default.rotate;
var copy = vec2_1.default.copy;
var crossLength = vec2_1.default.crossLength;
var worldPivotA = vec2_1.default.create(), worldPivotB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1), g = vec2_1.default.create();
var RevoluteConstraint = /** @class */ (function (_super) {
    __extends(RevoluteConstraint, _super);
    /**
     * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
     * @class RevoluteConstraint
     * @constructor
     * @author schteppe
     * @param {Body}    bodyA
     * @param {Body}    bodyB
     * @param {Object}  [options]
     * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
     * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
     * @param {Array}   [options.localPivotB] See localPivotA.
     * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
     * @extends Constraint
     *
     * @example
     *     // This will create a revolute constraint between two bodies with pivot point in between them.
     *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
     *     world.addBody(bodyA);
     *
     *     var bodyB = new Body({ mass: 1, position: [1, 0] });
     *     world.addBody(bodyB);
     *
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         worldPivot: [0, 0]
     *     });
     *     world.addConstraint(constraint);
     *
     *     // Using body-local pivot points, the constraint could have been constructed like this:
     *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
     *         localPivotA: [1, 0],
     *         localPivotB: [-1, 0]
     *     });
     */
    function RevoluteConstraint(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, constraint_1.default.REVOLUTE, options) || this;
        var maxForce = _this.maxForce = (_a = options === null || options === void 0 ? void 0 : options.maxForce) !== null && _a !== void 0 ? _a : Infinity;
        var pivotA = _this.pivotA = vec2_1.default.create();
        var pivotB = _this.pivotB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.worldPivot) {
            // Compute pivotA and pivotB
            sub(pivotA, options.worldPivot, bodyA.position);
            sub(pivotB, options.worldPivot, bodyB.position);
            // Rotate to local coordinate system
            rotate(pivotA, pivotA, -bodyA.angle);
            rotate(pivotB, pivotB, -bodyB.angle);
        }
        else {
            // Get pivotA and pivotB
            if (options === null || options === void 0 ? void 0 : options.localPivotA) {
                copy(pivotA, options.localPivotA);
            }
            if (options === null || options === void 0 ? void 0 : options.localPivotB) {
                copy(pivotB, options.localPivotB);
            }
        }
        var motorEquation = _this.motorEquation = new rotational_velocity_equation_1.default(bodyA, bodyB);
        motorEquation.enabled = false;
        var upperLimitEquation = _this.upperLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        var lowerLimitEquation = _this.lowerLimitEquation = new rotational_lock_equation_1.default(bodyA, bodyB);
        upperLimitEquation.minForce = lowerLimitEquation.maxForce = 0;
        // Equations to be fed to the solver
        var eqs = _this.equations = [
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            new Equation_1.default(bodyA, bodyB, -maxForce, maxForce),
            motorEquation,
            upperLimitEquation,
            lowerLimitEquation
        ];
        var x = eqs[0];
        var y = eqs[1];
        // TODO: bad practice.
        x.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, xAxis);
        };
        y.computeGq = function () {
            rotate(worldPivotA, pivotA, bodyA.angle);
            rotate(worldPivotB, pivotB, bodyB.angle);
            add(g, bodyB.position, worldPivotB);
            sub(g, g, bodyA.position);
            sub(g, g, worldPivotA);
            return dot(g, yAxis);
        };
        y.minForce = x.minForce = -maxForce;
        y.maxForce = x.maxForce = maxForce;
        // These never change but the angular parts do
        x.G[0] = -1;
        x.G[1] = 0;
        x.G[3] = 1;
        x.G[4] = 0;
        y.G[0] = 0;
        y.G[1] = -1;
        y.G[3] = 0;
        y.G[4] = 1;
        _this.angle = 0;
        _this.lowerLimitEnabled = false;
        _this.upperLimitEnabled = false;
        _this.lowerLimit = 0;
        _this.upperLimit = 0;
        return _this;
    }
    /**
     * Set the constraint angle limits, and enable them.
     * @method setLimits
     * @param {number} lower Lower angle limit.
     * @param {number} upper Upper angle limit.
     */
    RevoluteConstraint.prototype.setLimits = function (lower, upper) {
        this.lowerLimit = lower;
        this.upperLimit = upper;
        this.lowerLimitEnabled = this.upperLimitEnabled = true;
    };
    RevoluteConstraint.prototype.update = function () {
        var bodyA = this.bodyA, bodyB = this.bodyB, pivotA = this.pivotA, pivotB = this.pivotB, eqs = this.equations, x = eqs[0], y = eqs[1], upperLimit = this.upperLimit, lowerLimit = this.lowerLimit, upperLimitEquation = this.upperLimitEquation, lowerLimitEquation = this.lowerLimitEquation;
        var relAngle = this.angle = bodyB.angle - bodyA.angle;
        upperLimitEquation.angle = upperLimit;
        upperLimitEquation.enabled = this.upperLimitEnabled && relAngle > upperLimit;
        lowerLimitEquation.angle = lowerLimit;
        lowerLimitEquation.enabled = this.lowerLimitEnabled && relAngle < lowerLimit;
        /*

        The constraint violation is

            g = xj + rj - xi - ri

        ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

            gdot = vj + wj x rj - vi - wi x ri

        We split this into x and y directions. (let x and y be unit vectors along the respective axes)

            gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                    = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                    = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                    = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                    = G*W

        ...and similar for y. We have then identified the jacobian entries for x and y directions:

            Gx = [ x   (rj x x)   -x   -(ri x x)]
            Gy = [ y   (rj x y)   -y   -(ri x y)]

        So for example, in the X direction we would get in 2 dimensions

            G = [ [1   0   (rj x [1,0])   -1   0   -(ri x [1,0])]
                [0   1   (rj x [0,1])    0  -1   -(ri x [0,1])]
        */
        rotate(worldPivotA, pivotA, bodyA.angle);
        rotate(worldPivotB, pivotB, bodyB.angle);
        // @todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc
        var xG = x.G;
        xG[2] = -crossLength(worldPivotA, xAxis);
        xG[5] = crossLength(worldPivotB, xAxis);
        var yG = y.G;
        yG[2] = -crossLength(worldPivotA, yAxis);
        yG[5] = crossLength(worldPivotB, yAxis);
    };
    Object.defineProperty(RevoluteConstraint.prototype, "motorEnabled", {
        /**
         * @property {boolean} motorEnabled
         */
        get: function () {
            return this.motorEquation.enabled;
        },
        set: function (value) {
            this.motorEquation.enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorSpeed", {
        /**
         * @property {number} motorSpeed
         */
        get: function () {
            return this.motorEquation.relativeVelocity;
        },
        set: function (value) {
            this.motorEquation.relativeVelocity = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RevoluteConstraint.prototype, "motorMaxForce", {
        /**
         * @property {number} motorMaxForce
         */
        get: function () {
            return this.motorEquation.maxForce;
        },
        set: function (value) {
            var eq = this.motorEquation;
            eq.maxForce = value;
            eq.minForce = -value;
        },
        enumerable: false,
        configurable: true
    });
    return RevoluteConstraint;
}(constraint_1.default));
exports.default = RevoluteConstraint;

},{"../equations/Equation":14,"../equations/rotational-lock-equation":19,"../equations/rotational-velocity-equation":20,"../math/vec2":28,"./constraint":8}],14:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
// Shortcuts.
var scale = vec2_1.default.scale, multiply = vec2_1.default.multiply, createVec2 = vec2_1.default.create;
var Equation = /** @class */ (function () {
    /**
     * Base class for constraint equations.
     * @class Equation
     * @constructor
     * @param {Body} bodyA First body participating in the equation
     * @param {Body} bodyB Second body participating in the equation
     * @param {number} minForce Minimum force to apply. Default: -Infinity
     * @param {number} maxForce Maximum force to apply. Default: Infinity
     */
    function Equation(bodyA, bodyB, minForce, maxForce) {
        /**
         * Cap the constraint violation (G*q) to this value.
         * @property maxBias
         * @type {Number}
         */
        this.maxBias = Infinity;
        /**
         * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        /**
         * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.offset = 0;
        this.a = 0;
        this.b = 0;
        this.epsilon = 0;
        this.timeStep = 1 / 60;
        /**
         * Indicates if stiffness or relaxation was changed.
         * @property {Boolean} needsUpdate
         */
        this.needsUpdate = true;
        /**
         * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
         * @property multiplier
         * @type {Number}
         */
        this.multiplier = 0;
        /**
         * Relative velocity.
         * @property {Number} relativeVelocity
         */
        this.relativeVelocity = 0;
        /**
         * Whether this equation is enabled or not. If true, it will be added to the solver.
         * @property {Boolean} enabled
         */
        this.enabled = true;
        // Temp stuff
        this.maxForceDt = 0;
        this.minForceDt = 0;
        this.invC = 0;
        this.B = 0;
        this.lambda = 0;
        this.index = -1;
        this.minForce = minForce !== null && minForce !== void 0 ? minForce : -Infinity;
        this.maxForce = maxForce !== null && maxForce !== void 0 ? maxForce : Infinity;
        this.maxBias = Infinity;
        this.bodyA = bodyA !== null && bodyA !== void 0 ? bodyA : null;
        this.bodyB = bodyB !== null && bodyB !== void 0 ? bodyB : null;
        this.stiffness = Equation.DEFAULT_STIFFNESS;
        this.relaxation = Equation.DEFAULT_RELAXATION;
        this.G = new Float32Array(6);
        for (var i = 0; i < 6; i++) {
            this.G[i] = 0;
        }
    }
    /**
     * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
     * @method update
     */
    Equation.prototype.update = function () {
        var k = this.stiffness, d = this.relaxation, h = this.timeStep;
        this.a = 4 / (h * (1 + 4 * d));
        this.b = (4 * d) / (1 + 4 * d);
        this.epsilon = 4 / (h * h * k * (1 + 4 * d));
        this.needsUpdate = false;
    };
    /**
     * Multiply a jacobian entry with corresponding positions or velocities
     * @method gmult
     * @return {Number}
     */
    Equation.prototype.gmult = function (G, vi, wi, vj, wj) {
        return G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
    };
    /**
     * Computes the RHS of the SPOOK equation
     * @method computeB
     * @return {Number}
     */
    Equation.prototype.computeB = function (a, b, h) {
        var GW = this.computeGW();
        var Gq = this.computeGq();
        var maxBias = this.maxBias;
        if (Math.abs(Gq) > maxBias) {
            Gq = Gq > 0 ? maxBias : -maxBias;
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - GiMf * h;
        return B;
    };
    /**
     * Computes G\*q, where q are the generalized body coordinates
     * @method computeGq
     * @return {Number}
     */
    Equation.prototype.computeGq = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var ai = bi.angle, aj = bj.angle;
        var qi = createVec2(), qj = createVec2();
        return this.gmult(G, qi, ai, qj, aj) + this.offset;
    };
    /**
     * Computes G\*W, where W are the body velocities
     * @method computeGW
     * @return {Number}
     */
    Equation.prototype.computeGW = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
        return this.gmult(G, vi, wi, vj, wj) + this.relativeVelocity;
    };
    /**
     * Computes G\*Wlambda, where W are the body velocities
     * @method computeGWlambda
     * @return {Number}
     */
    Equation.prototype.computeGWlambda = function () {
        var G = this.G, bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
        return this.gmult(G, vi, wi, vj, wj);
    };
    /**
     * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
     * @method computeGiMf
     * @return {Number}
     */
    Equation.prototype.computeGiMf = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var fi = bi.force, ti = bi.angularForce, fj = bj.force, tj = bj.angularForce, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        var iMfi = createVec2(), iMfj = createVec2();
        scale(iMfi, fi, invMassi);
        multiply(iMfi, bi.massMultiplier, iMfi);
        scale(iMfj, fj, invMassj);
        multiply(iMfj, bj.massMultiplier, iMfj);
        return this.gmult(G, iMfi, ti * invIi, iMfj, tj * invIj);
    };
    /**
     * Computes G\*inv(M)\*G'
     * @method computeGiMGt
     * @return {Number}
     */
    Equation.prototype.computeGiMGt = function () {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return 0;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        return G[0] * G[0] * invMassi * bi.massMultiplier[0] +
            G[1] * G[1] * invMassi * bi.massMultiplier[1] +
            G[2] * G[2] * invIi +
            G[3] * G[3] * invMassj * bj.massMultiplier[0] +
            G[4] * G[4] * invMassj * bj.massMultiplier[1] +
            G[5] * G[5] * invIj;
    };
    Equation.prototype.updateJacobian = function () { };
    ;
    /**
     * Add constraint velocity to the bodies.
     * @method addToWlambda
     * @param {Number} deltalambda
     */
    Equation.prototype.addToWlambda = function (deltalambda) {
        var bi = this.bodyA, bj = this.bodyB;
        if (!bi || !bj)
            return;
        var invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaSolve, invIj = bj.invInertiaSolve, G = this.G;
        // v_lambda = G * inv(M) * delta_lambda
        addToVLambda(bi.vlambda, G[0], G[1], invMassi, deltalambda, bi.massMultiplier);
        bi.wlambda += invIi * G[2] * deltalambda;
        addToVLambda(bj.vlambda, G[3], G[4], invMassj, deltalambda, bj.massMultiplier);
        bj.wlambda += invIj * G[5] * deltalambda;
    };
    /**
     * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
     * @method computeInvC
     * @param  {Number} eps
     * @return {Number}
     */
    Equation.prototype.computeInvC = function (eps) {
        var invC = 1 / (this.computeGiMGt() + eps);
        return invC;
    };
    /**
     * The default stiffness when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_STIFFNESS
     * @default 1e6
     */
    Equation.DEFAULT_STIFFNESS = 1e6;
    /**
     * The default relaxation when creating a new Equation.
     * @static
     * @property {Number} DEFAULT_RELAXATION
     * @default 4
     */
    Equation.DEFAULT_RELAXATION = 4;
    return Equation;
}());
exports.default = Equation;
function addToVLambda(vlambda, Gx, Gy, invMass, deltalambda, massMultiplier) {
    vlambda[0] += Gx * invMass * deltalambda * massMultiplier[0];
    vlambda[1] += Gy * invMass * deltalambda * massMultiplier[1];
}

},{"../math/vec2":28}],15:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var AngleLockEquation = /** @class */ (function (_super) {
    __extends(AngleLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class AngleLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in body A.
     * @param {Number} [options.ratio] Gear ratio
     */
    function AngleLockEquation(bodyA, bodyB, options) {
        var _a, _b;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        _this.ratio = (_b = options === null || options === void 0 ? void 0 : options.ratio) !== null && _b !== void 0 ? _b : 1;
        _this.setRatio(_this.ratio);
        return _this;
    }
    AngleLockEquation.prototype.computeGq = function () {
        return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
    };
    /**
     * Set the gear ratio for this equation
     * @method setRatio
     * @param {Number} ratio
     */
    AngleLockEquation.prototype.setRatio = function (ratio) {
        var G = this.G;
        G[2] = ratio;
        G[5] = -1;
        this.ratio = ratio;
    };
    /**
     * Set the max force for the equation.
     * @method setMaxTorque
     * @param {Number} torque
     */
    AngleLockEquation.prototype.setMaxTorque = function (torque) {
        this.maxForce = torque;
        this.minForce = -torque;
    };
    return AngleLockEquation;
}(Equation_1.default));
exports.default = AngleLockEquation;

},{"./Equation":14}],16:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
function addSubSub(out, a, b, c, d) {
    out[0] = a[0] + b[0] - c[0] - d[0];
    out[1] = a[1] + b[1] - c[1] - d[1];
}
var vi = vec2_1.default.create();
var vj = vec2_1.default.create();
var relVel = vec2_1.default.create();
var ContactEquation = /** @class */ (function (_super) {
    __extends(ContactEquation, _super);
    /**
     * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
     *
     * @class ContactEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function ContactEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, 0, Infinity) || this;
        /**
         * Vector from body i center of mass to the contact point.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        _this.penetrationVec = vec2_1.default.create();
        /**
         * World-oriented vector from body A center of mass to the contact point.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * The normal vector, pointing out of body i
         * @property normalA
         * @type {Array}
         */
        _this.normalA = vec2_1.default.create();
        /**
         * The restitution to use (0=no bounciness, 1=max bounciness).
         * @property restitution
         * @type {Number}
         */
        _this.restitution = 0;
        /**
         * This property is set to true if this is the first impact between the bodies (not persistant contact).
         * @property firstImpact
         * @type {Boolean}
         * @readOnly
         */
        _this.firstImpact = false;
        /**
         * The shape in body i that triggered this contact.
         * @property shapeA
         * @type {Shape}
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this contact.
         * @property shapeB
         * @type {Shape}
         */
        _this.shapeB = null;
        return _this;
    }
    ContactEquation.prototype.computeB = function (a, b, h) {
        var _a, _b;
        var bi = this.bodyA, bj = this.bodyB, ri = this.contactPointA, rj = this.contactPointB, xi = (_a = bi === null || bi === void 0 ? void 0 : bi.position) !== null && _a !== void 0 ? _a : new Float32Array(2), xj = (_b = bj === null || bj === void 0 ? void 0 : bj.position) !== null && _b !== void 0 ? _b : new Float32Array(2);
        var n = this.normalA, G = this.G;
        // Caluclate cross products
        var rixn = vec2_1.default.crossLength(ri, n), rjxn = vec2_1.default.crossLength(rj, n);
        // G = [-n -rixn n rjxn]
        G[0] = -n[0];
        G[1] = -n[1];
        G[2] = -rixn;
        G[3] = n[0];
        G[4] = n[1];
        G[5] = rjxn;
        // Compute iteration
        var GW, Gq;
        if (this.firstImpact && this.restitution !== 0) {
            Gq = 0;
            GW = (1 / b) * (1 + this.restitution) * this.computeGW();
        }
        else {
            // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
            var penetrationVec = this.penetrationVec;
            addSubSub(penetrationVec, xj, rj, xi, ri);
            Gq = vec2_1.default.dot(n, penetrationVec) + this.offset;
            GW = this.computeGW();
        }
        var GiMf = this.computeGiMf();
        var B = -Gq * a - GW * b - h * GiMf;
        return B;
    };
    ;
    /**
     * Get the relative velocity along the normal vector.
     * @method getVelocityAlongNormal
     * @return {number}
     */
    ContactEquation.prototype.getVelocityAlongNormal = function () {
        this.bodyA && this.bodyA.getVelocityAtPoint(vi, this.contactPointA);
        this.bodyB && this.bodyB.getVelocityAtPoint(vj, this.contactPointB);
        vec2_1.default.subtract(relVel, vi, vj);
        return vec2_1.default.dot(this.normalA, relVel);
    };
    ;
    return ContactEquation;
}(Equation_1.default));
exports.default = ContactEquation;

},{"../math/vec2":28,"./Equation":14}],17:[function(_dereq_,module,exports){
module.exports=_dereq_(14)
},{"../math/vec2":28}],18:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Equation_1 = __importDefault(_dereq_("./Equation"));
var FrictionEquation = /** @class */ (function (_super) {
    __extends(FrictionEquation, _super);
    /**
     * Constrains the slipping in a contact along a tangent
     *
     * @class FrictionEquation
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Number} slipForce
     * @extends Equation
     */
    function FrictionEquation(bodyA, bodyB, slipForce) {
        if (slipForce === void 0) { slipForce = Infinity; }
        var _this = _super.call(this, bodyA, bodyB, -slipForce, slipForce) || this;
        /**
         * Relative vector from center of body A to the contact point, world oriented.
         * @property contactPointA
         * @type {Array}
         */
        _this.contactPointA = vec2_1.default.create();
        /**
         * Relative vector from center of body B to the contact point, world oriented.
         * @property contactPointB
         * @type {Array}
         */
        _this.contactPointB = vec2_1.default.create();
        /**
         * Tangent vector that the friction force will act along. World oriented.
         * @property t
         * @type {Array}
         */
        _this.t = vec2_1.default.create();
        /**
         * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
         * @property contactEquations
         * @type {ContactEquation[]}
         */
        _this.contactEquations = [];
        /**
         * The shape in body i that triggered this friction.
         * @property shapeA
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeA...
         */
        _this.shapeA = null;
        /**
         * The shape in body j that triggered this friction.
         * @property shapeB
         * @type {Shape}
         * @todo Needed? The shape can be looked up via contactEquation.shapeB...
         */
        _this.shapeB = null;
        /**
         * The friction coefficient to use.
         * @property frictionCoefficient
         * @type {Number}
         */
        _this.frictionCoefficient = 0.3;
        return _this;
    }
    /**
     * Set the slipping condition for the constraint. The friction force cannot be
     * larger than this value.
     * @method setSlipForce
     * @param  {Number} slipForce
     */
    FrictionEquation.prototype.setSlipForce = function (slipForce) {
        this.maxForce = slipForce;
        this.minForce = -slipForce;
    };
    ;
    /**
     * Get the max force for the constraint.
     * @method getSlipForce
     * @return {Number}
     */
    FrictionEquation.prototype.getSlipForce = function () {
        return this.maxForce;
    };
    ;
    FrictionEquation.prototype.computeB = function (a, b, h) {
        var ri = this.contactPointA, rj = this.contactPointB, t = this.t, G = this.G;
        // G = [-t -rixt t rjxt]
        // And remember, this is a pure velocity constraint, g is always zero!
        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2_1.default.crossLength(ri, t);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2_1.default.crossLength(rj, t);
        var GW = this.computeGW(), GiMf = this.computeGiMf();
        var B = /* - g * a  */ -GW * b - h * GiMf;
        return B;
    };
    ;
    return FrictionEquation;
}(Equation_1.default));
exports.default = FrictionEquation;

},{"../math/vec2":28,"./Equation":14}],19:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var worldVectorA = vec2_1.default.create(), worldVectorB = vec2_1.default.create(), xAxis = vec2_1.default.fromValues(1, 0), yAxis = vec2_1.default.fromValues(0, 1);
var RotationalLockEquation = /** @class */ (function (_super) {
    __extends(RotationalLockEquation, _super);
    /**
     * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
     *
     * @class RotationalLockEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
     */
    function RotationalLockEquation(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        var G = _this.G;
        G[2] = 1;
        G[5] = -1;
        return _this;
    }
    RotationalLockEquation.prototype.computeGq = function () {
        vec2_1.default.rotate(worldVectorA, xAxis, this.bodyA.angle + this.angle);
        vec2_1.default.rotate(worldVectorB, yAxis, this.bodyB.angle);
        return vec2_1.default.dot(worldVectorA, worldVectorB);
    };
    ;
    return RotationalLockEquation;
}(Equation_1.default));
exports.default = RotationalLockEquation;

},{"../math/vec2":28,"./Equation":14}],20:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Equation_1 = __importDefault(_dereq_("./Equation"));
var RotationalVelocityEquation = /** @class */ (function (_super) {
    __extends(RotationalVelocityEquation, _super);
    /**
     * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
     *
     * @class RotationalVelocityEquation
     * @constructor
     * @extends Equation
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    function RotationalVelocityEquation(bodyA, bodyB) {
        var _this = _super.call(this, bodyA, bodyB, -Infinity, Infinity) || this;
        _this.relativeVelocity = 1;
        _this.ratio = 1;
        return _this;
    }
    RotationalVelocityEquation.prototype.computeB = function (a, b, h) {
        var G = this.G;
        G[2] = -1;
        G[5] = this.ratio;
        var GiMf = this.computeGiMf();
        var GW = this.computeGW();
        var B = -GW * b - h * GiMf;
        return B;
    };
    return RotationalVelocityEquation;
}(Equation_1.default));
exports.default = RotationalVelocityEquation;

},{"./Equation":14}],21:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @example
 *     var emitter = new EventEmitter();
 *     emitter.on('myEvent', function(evt){
 *         console.log(evt.message);
 *     });
 *     emitter.emit({
 *         type: 'myEvent',
 *         message: 'Hello world!'
 *     });
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._listeners = {};
        this._contexts = {};
    }
    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', function(evt){
     *         console.log('myEvt was triggered!');
     *     });
     */
    EventEmitter.prototype.on = function (type, listener, context) {
        if (this._listeners[type] === undefined) {
            this._listeners[type] = [];
            this._contexts[type] = [];
        }
        if (this._listeners[type].indexOf(listener) === -1) {
            this._listeners[type].push(listener);
            this._contexts[type].push(context);
        }
        return this;
    };
    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.on('myEvent', handler); // Add handler
     *     emitter.off('myEvent', handler); // Remove handler
     */
    EventEmitter.prototype.off = function (type, listener) {
        if (!this._listeners || !this._listeners[type]) {
            return this;
        }
        var index = this._listeners[type].indexOf(listener);
        if (index !== -1) {
            this._listeners[type].splice(index, 1);
            this._contexts[type].splice(index, 1);
        }
        return this;
    };
    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    EventEmitter.prototype.has = function (type, listener) {
        if (this._listeners === undefined) {
            return false;
        }
        var listeners = this._listeners;
        if (listener) {
            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
                return true;
            }
        }
        else {
            if (listeners[type] !== undefined) {
                return true;
            }
        }
        return false;
    };
    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     * @example
     *     emitter.emit({
     *         type: 'myEvent',
     *         customData: 123
     *     });
     */
    // TODO: the unknown type here is disturbing.
    EventEmitter.prototype.emit = function (event) {
        if (this._listeners === undefined) {
            return this;
        }
        var listenerArray = this._listeners[event.type];
        var contextArray = this._contexts[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Need to copy the listener array, in case some listener was added/removed inside a listener
            var tmpListenerArray = [];
            var tmpContextArray = [];
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                tmpListenerArray.push(listenerArray[i]);
                tmpContextArray.push(contextArray[i]);
            }
            for (var i = 0, l = listenerArray.length; i < l; i++) {
                var listener = listenerArray[i];
                var context = contextArray[i];
                listener.call(context, event);
            }
        }
        return this;
    };
    return EventEmitter;
}());
exports.default = EventEmitter;

},{}],22:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.vec2 = exports.World = exports.Utils = exports.RotationalSpring = exports.LinearSpring = exports.TopDownVehicle = exports.Spring = exports.Solver = exports.Shape = exports.SAPBroadphase = exports.RotationalVelocityEquation = exports.Box = exports.RaycastResult = exports.Ray = exports.PrismaticConstraint = exports.RevoluteConstraint = exports.Pool = exports.Plane = exports.Particle = exports.NaiveBroadphase = exports.Narrowphase = exports.Material = exports.LockConstraint = exports.Line = exports.Heightfield = exports.GSSolver = exports.GearConstraint = exports.FrictionEquationPool = exports.FrictionEquation = exports.EventEmitter = exports.Equation = exports.DistanceConstraint = exports.Convex = exports.ContactMaterial = exports.ContactEquationPool = exports.ContactEquation = exports.Constraint = exports.Circle = exports.Capsule = exports.Broadphase = exports.Body = exports.AngleLockEquation = exports.AABB = void 0;
var version = "0.0.1";
exports.version = version;
var aabb_1 = __importDefault(_dereq_("./collision/aabb"));
exports.AABB = aabb_1.default;
var angle_lock_equation_1 = __importDefault(_dereq_("./equations/angle-lock-equation"));
exports.AngleLockEquation = angle_lock_equation_1.default;
var body_1 = __importDefault(_dereq_("./objects/body"));
exports.Body = body_1.default;
var broadphase_1 = __importDefault(_dereq_("./collision/broadphase"));
exports.Broadphase = broadphase_1.default;
var capsule_1 = __importDefault(_dereq_("./shapes/capsule"));
exports.Capsule = capsule_1.default;
var circle_1 = __importDefault(_dereq_("./shapes/circle"));
exports.Circle = circle_1.default;
var constraint_1 = __importDefault(_dereq_("./constraints/constraint"));
exports.Constraint = constraint_1.default;
var contact_equation_1 = __importDefault(_dereq_("./equations/contact-equation"));
exports.ContactEquation = contact_equation_1.default;
var contact_equation_pool_1 = __importDefault(_dereq_("./utils/contact-equation-pool"));
exports.ContactEquationPool = contact_equation_pool_1.default;
var contact_material_1 = __importDefault(_dereq_("./material/contact-material"));
exports.ContactMaterial = contact_material_1.default;
var convex_1 = __importDefault(_dereq_("./shapes/convex"));
exports.Convex = convex_1.default;
var distance_constraint_1 = __importDefault(_dereq_("./constraints/distance-constraint"));
exports.DistanceConstraint = distance_constraint_1.default;
var equation_1 = __importDefault(_dereq_("./equations/equation"));
exports.Equation = equation_1.default;
var event_emitter_1 = __importDefault(_dereq_("./events/event-emitter"));
exports.EventEmitter = event_emitter_1.default;
var friction_equation_1 = __importDefault(_dereq_("./equations/friction-equation"));
exports.FrictionEquation = friction_equation_1.default;
var friction_equation_pool_1 = __importDefault(_dereq_("./utils/friction-equation-pool"));
exports.FrictionEquationPool = friction_equation_pool_1.default;
var gear_constraint_1 = __importDefault(_dereq_("./constraints/gear-constraint"));
exports.GearConstraint = gear_constraint_1.default;
var gs_solver_1 = __importDefault(_dereq_("./solver/gs-solver"));
exports.GSSolver = gs_solver_1.default;
var heightfield_1 = __importDefault(_dereq_("./shapes/heightfield"));
exports.Heightfield = heightfield_1.default;
var line_1 = __importDefault(_dereq_("./shapes/line"));
exports.Line = line_1.default;
var lock_constraint_1 = __importDefault(_dereq_("./constraints/lock-constraint"));
exports.LockConstraint = lock_constraint_1.default;
var material_1 = __importDefault(_dereq_("./material/material"));
exports.Material = material_1.default;
var narrowphase_1 = __importDefault(_dereq_("./collision/narrowphase"));
exports.Narrowphase = narrowphase_1.default;
var naive_broadphase_1 = __importDefault(_dereq_("./collision/naive-broadphase"));
exports.NaiveBroadphase = naive_broadphase_1.default;
var particle_1 = __importDefault(_dereq_("./shapes/particle"));
exports.Particle = particle_1.default;
var plane_1 = __importDefault(_dereq_("./shapes/plane"));
exports.Plane = plane_1.default;
var pool_1 = __importDefault(_dereq_("./utils/pool"));
exports.Pool = pool_1.default;
var revolute_constraint_1 = __importDefault(_dereq_("./constraints/revolute-constraint"));
exports.RevoluteConstraint = revolute_constraint_1.default;
var prismatic_constraint_1 = __importDefault(_dereq_("./constraints/prismatic-constraint"));
exports.PrismaticConstraint = prismatic_constraint_1.default;
var ray_1 = __importDefault(_dereq_("./collision/ray"));
exports.Ray = ray_1.default;
var raycast_result_1 = __importDefault(_dereq_("./collision/raycast-result"));
exports.RaycastResult = raycast_result_1.default;
var Box_1 = __importDefault(_dereq_("./shapes/Box"));
exports.Box = Box_1.default;
var rotational_velocity_equation_1 = __importDefault(_dereq_("./equations/rotational-velocity-equation"));
exports.RotationalVelocityEquation = rotational_velocity_equation_1.default;
var sap_broadphase_1 = __importDefault(_dereq_("./collision/sap-broadphase"));
exports.SAPBroadphase = sap_broadphase_1.default;
var shape_1 = __importDefault(_dereq_("./shapes/shape"));
exports.Shape = shape_1.default;
var solver_1 = __importDefault(_dereq_("./solver/solver"));
exports.Solver = solver_1.default;
var spring_1 = __importDefault(_dereq_("./objects/spring"));
exports.Spring = spring_1.default;
var top_down_vehicle_1 = __importDefault(_dereq_("./objects/top-down-vehicle"));
exports.TopDownVehicle = top_down_vehicle_1.default;
var linear_spring_1 = __importDefault(_dereq_("./objects/linear-spring"));
exports.LinearSpring = linear_spring_1.default;
var rotational_spring_1 = __importDefault(_dereq_("./objects/rotational-spring"));
exports.RotationalSpring = rotational_spring_1.default;
var utils_1 = __importDefault(_dereq_("./utils/utils"));
exports.Utils = utils_1.default;
var world_1 = __importDefault(_dereq_("./world/world"));
exports.World = world_1.default;
var vec2_1 = __importDefault(_dereq_("./math/vec2"));
exports.vec2 = vec2_1.default;

},{"./collision/aabb":1,"./collision/broadphase":2,"./collision/naive-broadphase":3,"./collision/narrowphase":4,"./collision/ray":5,"./collision/raycast-result":6,"./collision/sap-broadphase":7,"./constraints/constraint":8,"./constraints/distance-constraint":9,"./constraints/gear-constraint":10,"./constraints/lock-constraint":11,"./constraints/prismatic-constraint":12,"./constraints/revolute-constraint":13,"./equations/angle-lock-equation":15,"./equations/contact-equation":16,"./equations/equation":17,"./equations/friction-equation":18,"./equations/rotational-velocity-equation":20,"./events/event-emitter":21,"./material/contact-material":24,"./material/material":25,"./math/vec2":28,"./objects/body":30,"./objects/linear-spring":31,"./objects/rotational-spring":32,"./objects/spring":33,"./objects/top-down-vehicle":34,"./shapes/Box":35,"./shapes/capsule":39,"./shapes/circle":40,"./shapes/convex":41,"./shapes/heightfield":42,"./shapes/line":43,"./shapes/particle":44,"./shapes/plane":45,"./shapes/shape":46,"./solver/gs-solver":47,"./solver/solver":48,"./utils/contact-equation-pool":49,"./utils/friction-equation-pool":50,"./utils/pool":54,"./utils/utils":56,"./world/world":58}],23:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Material = /** @class */ (function () {
    /**
     * Defines a physics material. To be used with {{#crossLink "ContactMaterial"}}{{/crossLink}}.
     * @class Material
     * @constructor
     * @author schteppe
     * @example
     *     // Create a wooden box
     *     var woodMaterial = new Material();
     *     var boxShape = new Box({
     *         material: woodMaterial
     *     });
     *     body.addShape(boxShape);
     */
    function Material() {
        /**
         * The material identifier. Read only.
         * @readonly
         * @property id
         * @type {Number}
         */
        this.id = ++Material.idCounter;
    }
    Material.idCounter = 0;
    return Material;
}());
exports.default = Material;

},{}],24:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Material_1 = __importDefault(_dereq_("./Material"));
var Equation_1 = __importDefault(_dereq_("../equations/Equation"));
var ContactMaterial = /** @class */ (function () {
    /**
     * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters. Also see {{#crossLink "Material"}}{{/crossLink}}.
     * @class ContactMaterial
     * @constructor
     * @param {Material} materialA
     * @param {Material} materialB
     * @param {Object}   [options]
     * @param {Number}   [options.friction=0.3]       Friction coefficient.
     * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
     * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
     * @param {Number}   [options.relaxation]         ContactEquation relaxation.
     * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
     * @param {Number}   [options.stiffness]          ContactEquation stiffness.
     * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
     * @author schteppe
     * @example
     *     var ice = new Material();
     *     var wood = new Material();
     *     var iceWoodContactMaterial = new ContactMaterial(ice, wood, {
     *         friction: 0.2,
     *         restitution: 0.3
     *     });
     *     world.addContactMaterial(iceWoodContactMaterial);
     */
    function ContactMaterial(materialA, materialB, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.
         * @property friction
         * @type {Number}
         * @default 0.3
         */
        this.friction = 0.3;
        /**
         * Restitution, or "bounciness" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.
         * @property restitution
         * @type {Number}
         * @default 0
         */
        this.restitution = 0;
        /**
         * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property stiffness
         * @type {Number}
         */
        this.stiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property relaxation
         * @type {Number}
         */
        this.relaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink "Equation/DEFAULT_STIFFNESS:property"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.
         * @property frictionStiffness
         * @type {Number}
         */
        this.frictionStiffness = Equation_1.default.DEFAULT_STIFFNESS;
        /**
         * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink "Equation/DEFAULT_RELAXATION:property"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.
         * @property frictionRelaxation
         * @type {Number}
         */
        this.frictionRelaxation = Equation_1.default.DEFAULT_RELAXATION;
        /**
         * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
         * @property {Number} surfaceVelocity
         * @default 0
         */
        this.surfaceVelocity = 0;
        /**
         * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
         * @property contactSkinSize
         * @type {Number}
         */
        this.contactSkinSize = 0.005;
        if (!(materialA instanceof Material_1.default) || !(materialB instanceof Material_1.default)) {
            throw new Error("First two arguments must be Material instances.");
        }
        this.id = ++ContactMaterial.idCounter;
        this.materialA = materialA;
        this.materialB = materialB;
        this.friction = (_a = options === null || options === void 0 ? void 0 : options.friction) !== null && _a !== void 0 ? _a : 0.3;
        this.restitution = (_b = options === null || options === void 0 ? void 0 : options.restitution) !== null && _b !== void 0 ? _b : 0;
        this.stiffness = (_c = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _c !== void 0 ? _c : Equation_1.default.DEFAULT_STIFFNESS;
        this.relaxation = (_d = options === null || options === void 0 ? void 0 : options.relaxation) !== null && _d !== void 0 ? _d : Equation_1.default.DEFAULT_RELAXATION;
        this.frictionStiffness = (_e = options === null || options === void 0 ? void 0 : options.frictionStiffness) !== null && _e !== void 0 ? _e : Equation_1.default.DEFAULT_STIFFNESS;
        this.frictionRelaxation = (_f = options === null || options === void 0 ? void 0 : options.frictionRelaxation) !== null && _f !== void 0 ? _f : Equation_1.default.DEFAULT_RELAXATION;
        this.surfaceVelocity = (_g = options === null || options === void 0 ? void 0 : options.surfaceVelocity) !== null && _g !== void 0 ? _g : 0;
        this.contactSkinSize = 0.005;
    }
    ContactMaterial.idCounter = 0;
    return ContactMaterial;
}());
exports.default = ContactMaterial;

},{"../equations/Equation":14,"./Material":23}],25:[function(_dereq_,module,exports){
module.exports=_dereq_(23)
},{}],26:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1, l2, precision) {
    if (precision === void 0) { precision = 0; }
    var i = new Float32Array(2); // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}
/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da = q2[0] - q1[0];
    var db = q2[1] - q1[1];
    // segments are parallel
    if ((da * dy - db * dx) === 0) {
        return false;
    }
    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
    return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
}
/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a, b, c) {
    return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1])));
}
function isLeft(a, b, c) {
    return triangleArea(a, b, c) > 0;
}
function isLeftOn(a, b, c) {
    return triangleArea(a, b, c) >= 0;
}
function isRight(a, b, c) {
    return triangleArea(a, b, c) < 0;
}
function isRightOn(a, b, c) {
    return triangleArea(a, b, c) <= 0;
}
var tmpPoint1 = new Float32Array(2), tmpPoint2 = new Float32Array(2);
/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
        return triangleArea(a, b, c) === 0;
    }
    else {
        var ab = tmpPoint1, bc = tmpPoint2;
        ab[0] = b[0] - a[0];
        ab[1] = b[1] - a[1];
        bc[0] = c[0] - b[0];
        bc[1] = c[1] - b[1];
        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
        return angle < thresholdAngle;
    }
}
function sqdist(a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}
/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i) {
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}
/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon) {
    polygon.length = 0;
}
/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to) {
    for (var i = from; i < to; i++) {
        polygon.push(poly[i]);
    }
}
/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon) {
    var br = 0, v = polygon;
    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }
    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon) {
    var tmp = [];
    var N = polygon.length;
    for (var i = 0; i !== N; i++) {
        var p = polygon.pop();
        tmp.push(p);
    }
    for (var i = 0; i !== N; i++) {
        polygon[i] = tmp[i];
    }
}
/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i) {
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}
var tmpLine1 = [], tmpLine2 = [];
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a, b) {
    var p, dist, l1 = tmpLine1, l2 = tmpLine2;
    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a) { // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1, l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }
    return true;
}
/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee2(polygon, a, b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
        // ignore incident edges
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
            continue;
        }
        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
            return false;
        }
    }
    return true;
}
/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i, j, targetPoly) {
    var p = targetPoly !== null && targetPoly !== void 0 ? targetPoly : [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for (var k = i; k <= j; k++) {
            p.push(polygon[k]);
        }
    }
    else {
        // Insert vertices 0 to j
        for (var k = 0; k <= j; k++) {
            p.push(polygon[k]);
        }
        // Insert vertices i to end
        for (var k = i; k < polygon.length; k++) {
            p.push(polygon[k]);
        }
    }
    return p;
}
/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
    var nDiags = Infinity;
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                    for (var k = 0; k < tmp2.length; k++) {
                        tmp1.push(tmp2[k]);
                    }
                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        var p = [polygonAt(polygon, i), polygonAt(polygon, j)];
                        min.push(p);
                    }
                }
            }
        }
    }
    return min;
}
/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon) {
    var edges = polygonGetCutEdges(polygon);
    if (edges.length > 0) {
        return polygonSlice(polygon, edges);
    }
    else {
        return [polygon];
    }
}
/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @warning The inner workings of this function was massively modified when switching to typescript. Needs thorough testing.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges) {
    if (cutEdges.length === 0) {
        return [polygon];
    }
    if (cutEdges[0].length === 2) {
        var polys = [polygon];
        for (var i = 0; i < cutEdges.length; i++) {
            var cutEdge = [cutEdges[i]];
            // Cut all polys
            for (var j = 0; j < polys.length; j++) {
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if (result) {
                    // Found poly! Cut and quit
                    polys.splice(j, 1);
                    polys.push(result[0]);
                    polys.push(result[1]);
                    break;
                }
            }
        }
        return polys;
    }
    else {
        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0][0]);
        var j = polygon.indexOf(cutEdge[0][1]);
        if (i !== -1 && j !== -1) {
            return [polygonCopy(polygon, i, j),
                polygonCopy(polygon, j, i)];
        }
        else {
            return new Array();
        }
    }
}
/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon) {
    var path = polygon, i;
    // Check
    for (i = 0; i < path.length - 1; i++) {
        for (var j = 0; j < i - 1; j++) {
            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                return false;
            }
        }
    }
    // Check the segment between the last and the first point to all others
    for (i = 1; i < path.length - 2; i++) {
        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
            return false;
        }
    }
    return true;
}
function getIntersectionPoint(p1, p2, q1, q2, delta) {
    if (delta === void 0) { delta = 0; }
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = (a1 * p1[0]) + (b1 * p1[1]);
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = (a2 * q1[0]) + (b2 * q1[1]);
    var det = (a1 * b2) - (a2 * b1);
    var pt = new Float32Array(2);
    if (!scalar_eq(det, 0, delta)) {
        pt[0] = ((b2 * c1) - (b1 * c2)) / det;
        pt[1] = ((a1 * c2) - (a2 * c1)) / det;
        return pt;
    }
    else {
        pt[0] = 0;
        pt[1] = 0;
        return pt;
    }
}
/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    if (result === void 0) { result = new Array(); }
    if (reflexVertices === void 0) { reflexVertices = []; }
    if (steinerPoints === void 0) { steinerPoints = []; }
    if (delta === void 0) { delta = 25; }
    if (maxlevel === void 0) { maxlevel = 100; }
    if (level === void 0) { level = 0; }
    // TODO: should upperInt really be initialized here? It looks like it's overwritten.
    var upperInt = new Float32Array(2), lowerInt = new Float32Array(2), p = new Float32Array(2); // Points
    upperInt[0] = 0;
    upperInt[1] = 0;
    lowerInt[0] = 0;
    lowerInt[1] = 0;
    p[0] = 0;
    p[1] = 0;
    var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0; // scalars
    var upperIndex = 0, lowerIndex = 0, closestIndex = 0; // Integers
    var lowerPoly = new Array(), upperPoly = new Array(); // polygons
    var poly = polygon, v = polygon;
    if (v.length < 3) {
        return result;
    }
    level++;
    if (level > maxlevel) {
        //console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }
    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Infinity;
            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }
            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);
                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0) {
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly, i, poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly, lowerIndex, i + 1);
                }
            }
            else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");
                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Infinity;
                if (upperIndex < lowerIndex) {
                    return result;
                }
                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&
                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }
                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                    if (closestIndex !== 0) {
                        polygonAppend(upperPoly, poly, closestIndex, v.length);
                    }
                    polygonAppend(upperPoly, poly, 0, i + 1);
                }
                else {
                    if (i !== 0) {
                        polygonAppend(lowerPoly, poly, i, v.length);
                    }
                    polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                    polygonAppend(upperPoly, poly, closestIndex, i + 1);
                }
            }
            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            else {
                polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
                polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            return result;
        }
    }
    result.push(polygon);
    return result;
}
/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision) {
    var num = 0;
    for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
        if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
            // Remove the middle point
            polygon.splice(i % polygon.length, 1);
            num++;
        }
    }
    return num;
}
/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */
function polygonRemoveDuplicatePoints(polygon, precision) {
    for (var i = polygon.length - 1; i >= 1; --i) {
        var pi = polygon[i];
        for (var j = i - 1; j >= 0; --j) {
            if (points_eq(pi, polygon[j], precision)) {
                polygon.splice(i, 1);
                continue;
            }
        }
    }
}
/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a, b, precision) {
    precision = precision || 0;
    return Math.abs(a - b) <= precision;
}
/**
 * Check if two points are equal
 * @static
 * @method points_eq
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function points_eq(a, b, precision) {
    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
}
exports.default = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
};

},{}],27:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
var PolyK = /** @class */ (function () {
    function PolyK() {
    }
    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    IsSimple(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new this._P(), a2 = new this._P();
        var b1 = new this._P(), b2 = new this._P();
        var c = new this._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(this._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    IsConvex(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!this._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!this._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!this._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.prototype.GetArea = function (p) {
        if (p.length < 6)
            return 0;
        var l = p.length - 2;
        var sum = 0;
        for (var i = 0; i < l; i += 2)
            sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
        sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
        return -sum * 0.5;
    };
    /*
    GetAABB(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */
    PolyK.prototype.Triangulate = function (p) {
        var n = p.length >> 1;
        if (n < 3)
            return [];
        var tgs = [];
        var avl = [];
        for (var i = 0; i < n; i++)
            avl.push(i);
        var i = 0;
        var al = n;
        while (al > 3) {
            var i0 = avl[(i + 0) % al];
            var i1 = avl[(i + 1) % al];
            var i2 = avl[(i + 2) % al];
            var ax = p[2 * i0], ay = p[2 * i0 + 1];
            var bx = p[2 * i1], by = p[2 * i1 + 1];
            var cx = p[2 * i2], cy = p[2 * i2 + 1];
            var earFound = false;
            if (this._convex(ax, ay, bx, by, cx, cy)) {
                earFound = true;
                for (var j = 0; j < al; j++) {
                    var vi = avl[j];
                    if (vi == i0 || vi == i1 || vi == i2)
                        continue;
                    if (this._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
                        earFound = false;
                        break;
                    }
                }
            }
            if (earFound) {
                tgs.push(i0);
                tgs.push(i1);
                tgs.push(i2);
                avl.splice((i + 1) % al, 1);
                al--;
                i = 0;
            }
            else if (i++ > 3 * al)
                break; // no convex angles :(
        }
        tgs.push(avl[0]);
        tgs.push(avl[1]);
        tgs.push(avl[2]);
        return tgs;
    };
    /*
    ContainsPoint(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    Slice(p, ax, ay, bx, by)
    {
        if(this.ContainsPoint(p, ax, ay) || this.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new this._P(ax, ay);
        var b = new this._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new this._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new this._P(0,0);
            isc = this._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp(u,v) {return this._P.dist(a,u) - this._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(this._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = this._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = this._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    Raycast(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = this._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) this._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    ClosestEdge(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = this._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            this._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        this._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    _pointLineDist(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    _updateISC(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = this._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/this._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    _getPoints(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    _firstWithFlag(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK.prototype._PointInTriangle = function (px, py, ax, ay, bx, by, cx, cy) {
        var v0x = cx - ax;
        var v0y = cy - ay;
        var v1x = bx - ax;
        var v1y = by - ay;
        var v2x = px - ax;
        var v2y = py - ay;
        var dot00 = v0x * v0x + v0y * v0y;
        var dot01 = v0x * v1x + v0y * v1y;
        var dot02 = v0x * v2x + v0y * v2y;
        var dot11 = v1x * v1x + v1y * v1y;
        var dot12 = v1x * v2x + v1y * v2y;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    };
    /*
    _RayLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!this._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    _GetLineIntersection(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(this._InRect(I, a1, a2) && this._InRect(I, b1, b2)) return I;
        return null;
    }

    _InRect(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK.prototype._convex = function (ax, ay, bx, by, cx, cy) {
        return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;
    };
    return PolyK;
}());
exports.default = new PolyK();

},{}],28:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */
var Vec2 = /** @class */ (function () {
    function Vec2() {
    }
    /**
     * Make a cross product and only return the z component
     * @method crossLength
     * @static
     * @param  {Array} a
     * @param  {Array} b
     * @return {Number}
     */
    Vec2.prototype.crossLength = function (a, b) {
        return a[0] * b[1] - a[1] * b[0];
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossVZ
     * @static
     * @param  {Array} out
     * @param  {Array} vec
     * @param  {Number} zcomp
     * @return {Array}
     */
    Vec2.prototype.crossVZ = function (out, vec, zcomp) {
        this.rotate(out, vec, -Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Cross product between a vector and the Z component of a vector
     * @method crossZV
     * @static
     * @param  {Array} out
     * @param  {Number} zcomp
     * @param  {Array} vec
     * @return {Array}
     */
    Vec2.prototype.crossZV = function (out, zcomp, vec) {
        this.rotate(out, vec, Math.PI / 2); // Rotate according to the right hand rule
        this.scale(out, out, zcomp); // Scale with z
        return out;
    };
    ;
    /**
     * Rotate a vector by an angle
     * @method rotate
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Number} angle
     * @return {Array}
     */
    Vec2.prototype.rotate = function (out, a, angle) {
        if (angle !== 0) {
            var c = Math.cos(angle), s = Math.sin(angle), x = a[0], y = a[1];
            out[0] = c * x - s * y;
            out[1] = s * x + c * y;
        }
        else {
            out[0] = a[0];
            out[1] = a[1];
        }
        return out;
    };
    ;
    /**
     * Rotate a vector 90 degrees clockwise
     * @method rotate90cw
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @return {Array}
     */
    Vec2.prototype.rotate90cw = function (out, a) {
        var x = a[0];
        var y = a[1];
        out[0] = y;
        out[1] = -x;
        return out;
    };
    ;
    /**
     * Transform a point position to local frame.
     * @method toLocalFrame
     * @param  {Array} out
     * @param  {Array} worldPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.toLocalFrame = function (out, worldPoint, framePosition, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldPoint[0] - framePosition[0], y = worldPoint[1] - framePosition[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /**
     * Transform a point position to global frame.
     * @method toGlobalFrame
     * @param  {Array} out
     * @param  {Array} localPoint
     * @param  {Array} framePosition
     * @param  {Number} frameAngle
     */
    Vec2.prototype.toGlobalFrame = function (out, localPoint, framePosition, frameAngle) {
        var c = Math.cos(frameAngle), s = Math.sin(frameAngle), x = localPoint[0], y = localPoint[1], addX = framePosition[0], addY = framePosition[1];
        out[0] = c * x - s * y + addX;
        out[1] = s * x + c * y + addY;
    };
    ;
    /**
     * Transform a vector to local frame.
     * @method vectorToLocalFrame
     * @param  {Array} out
     * @param  {Array} worldVector
     * @param  {Number} frameAngle
     * @return {Array}
     */
    Vec2.prototype.vectorToLocalFrame = function (out, worldVector, frameAngle) {
        var c = Math.cos(-frameAngle), s = Math.sin(-frameAngle), x = worldVector[0], y = worldVector[1];
        out[0] = c * x - s * y;
        out[1] = s * x + c * y;
        return out;
    };
    ;
    /*
     * Transform a vector to global frame.
     * @method vectorToGlobalFrame
     * @param  {Array} out
     * @param  {Array} localVector
     * @param  {Number} frameAngle
     */
    //vectorToGlobalFrame = vec2.rotate;
    /**
     * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
     * @method centroid
     * @static
     * @param  {Array} out
     * @param  {Array} a
     * @param  {Array} b
     * @param  {Array} c
     * @return  {Array} The "out" vector.
     */
    Vec2.prototype.centroid = function (out, a, b, c) {
        this.add(out, a, b);
        this.add(out, out, c);
        this.scale(out, out, 1 / 3);
        return out;
    };
    ;
    /**
     * Creates a new, empty vec2
     * @static
     * @method create
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.create = function () {
        var out = new Float32Array(2);
        out[0] = 0;
        out[1] = 0;
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with values from an existing vector
     * @static
     * @method clone
     * @param {Array} a vector to clone
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.clone = function (a) {
        var out = new Float32Array(2);
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Creates a new vec2 initialized with the given values
     * @static
     * @method fromValues
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} a new 2D vector
     */
    Vec2.prototype.fromValues = function (x, y) {
        var out = new Float32Array(2);
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Copy the values from one vec2 to another
     * @static
     * @method copy
     * @param {Array} out the receiving vector
     * @param {Array} a the source vector
     * @return {Array} out
     */
    Vec2.prototype.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        return out;
    };
    ;
    /**
     * Set the components of a vec2 to the given values
     * @static
     * @method set
     * @param {Array} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @return {Array} out
     */
    Vec2.prototype.set = function (out, x, y) {
        out[0] = x;
        out[1] = y;
        return out;
    };
    ;
    /**
     * Adds two vec2's
     * @static
     * @method add
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.add = function (out, a, b) {
        out[0] = a[0] + b[0];
        out[1] = a[1] + b[1];
        return out;
    };
    ;
    /**
     * Subtracts two vec2's
     * @static
     * @method subtract
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.subtract = function (out, a, b) {
        out[0] = a[0] - b[0];
        out[1] = a[1] - b[1];
        return out;
    };
    ;
    /**
     * Multiplies two vec2's
     * @static
     * @method multiply
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.multiply = function (out, a, b) {
        out[0] = a[0] * b[0];
        out[1] = a[1] * b[1];
        return out;
    };
    ;
    /**
     * Divides two vec2's
     * @static
     * @method divide
     * @param {Array} out the receiving vector
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Array} out
     */
    Vec2.prototype.divide = function (out, a, b) {
        out[0] = a[0] / b[0];
        out[1] = a[1] / b[1];
        return out;
    };
    ;
    /**
     * Scales a vec2 by a scalar number
     * @static
     * @method scale
     * @param {Array} out the receiving vector
     * @param {Array} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @return {Array} out
     */
    Vec2.prototype.scale = function (out, a, b) {
        out[0] = a[0] * b;
        out[1] = a[1] * b;
        return out;
    };
    ;
    /**
     * Calculates the euclidian distance between two vec2's
     * @static
     * @method distance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} distance between a and b
     */
    Vec2.prototype.distance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared euclidian distance between two vec2's
     * @static
     * @method squaredDistance
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} squared distance between a and b
     */
    Vec2.prototype.squaredDistance = function (a, b) {
        var x = b[0] - a[0], y = b[1] - a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Calculates the length of a vec2
     * @static
     * @method length
     * @param {Array} a vector to calculate length of
     * @return {Number} length of a
     */
    Vec2.prototype.length = function (a) {
        var x = a[0], y = a[1];
        return Math.sqrt(x * x + y * y);
    };
    ;
    /**
     * Calculates the squared length of a vec2
     * @static
     * @method squaredLength
     * @param {Array} a vector to calculate squared length of
     * @return {Number} squared length of a
     */
    Vec2.prototype.squaredLength = function (a) {
        var x = a[0], y = a[1];
        return x * x + y * y;
    };
    ;
    /**
     * Negates the components of a vec2
     * @static
     * @method negate
     * @param {Array} out the receiving vector
     * @param {Array} a vector to negate
     * @return {Array} out
     */
    Vec2.prototype.negate = function (out, a) {
        out[0] = -a[0];
        out[1] = -a[1];
        return out;
    };
    ;
    /**
     * Normalize a vec2
     * @static
     * @method normalize
     * @param {Array} out the receiving vector
     * @param {Array} a vector to normalize
     * @return {Array} out
     */
    Vec2.prototype.normalize = function (out, a) {
        var x = a[0], y = a[1];
        var len = x * x + y * y;
        if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
        }
        return out;
    };
    ;
    /**
     * Calculates the dot product of two vec2's
     * @static
     * @method dot
     * @param {Array} a the first operand
     * @param {Array} b the second operand
     * @return {Number} dot product of a and b
     */
    Vec2.prototype.dot = function (a, b) {
        return a[0] * b[0] + a[1] * b[1];
    };
    ;
    /**
     * Returns a string representation of a vector
     * @static
     * @method str
     * @param {Array} vec vector to represent as a string
     * @return {String} string representation of the vector
     */
    Vec2.prototype.str = function (a) {
        throw "vec2.str is not supported in the typescript version of p2.";
        return 'vec2(' + a[0] + ', ' + a[1] + ')';
    };
    ;
    /**
     * Linearly interpolate/mix two vectors.
     * @static
     * @method lerp
     * @param {Array} out
     * @param {Array} a First vector
     * @param {Array} b Second vector
     * @param {number} t Lerp factor
     * @return {array}
     */
    Vec2.prototype.lerp = function (out, a, b, t) {
        var ax = a[0], ay = a[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
    };
    ;
    /**
     * Reflect a vector along a normal.
     * @static
     * @method reflect
     * @param {Array} out
     * @param {Array} vector
     * @param {Array} normal
     */
    Vec2.prototype.reflect = function (out, vector, normal) {
        var dot = vector[0] * normal[0] + vector[1] * normal[1];
        out[0] = vector[0] - 2 * normal[0] * dot;
        out[1] = vector[1] - 2 * normal[1] * dot;
    };
    ;
    /**
     * Get the intersection point between two line segments.
     * @static
     * @method getLineSegmentsIntersection
     * @param  {Array} out
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {boolean} True if there was an intersection, otherwise false.
     */
    Vec2.prototype.getLineSegmentsIntersection = function (out, p0, p1, p2, p3) {
        var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);
        if (t < 0) {
            return false;
        }
        else {
            out[0] = p0[0] + (t * (p1[0] - p0[0]));
            out[1] = p0[1] + (t * (p1[1] - p0[1]));
            return true;
        }
    };
    ;
    /**
     * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)
     * @static
     * @method getLineSegmentsIntersectionFraction
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.
     */
    Vec2.prototype.getLineSegmentsIntersectionFraction = function (p0, p1, p2, p3) {
        var s1_x = p1[0] - p0[0];
        var s1_y = p1[1] - p0[1];
        var s2_x = p3[0] - p2[0];
        var s2_y = p3[1] - p2[1];
        var s, t;
        s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);
        t = (s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);
        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected
            return t;
        }
        return -1; // No collision
    };
    ;
    return Vec2;
}());
var vec2 = new Vec2();
exports.default = vec2;

},{}],29:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var add = vec2_1.default.add, sub = vec2_1.default.subtract, vec2create = vec2_1.default.create;
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var poly_decomp_1 = __importDefault(_dereq_("../math/poly-decomp"));
var Convex_1 = __importDefault(_dereq_("../shapes/Convex"));
var ray_1 = __importDefault(_dereq_("../collision/ray"));
var raycast_result_1 = __importDefault(_dereq_("../collision/raycast-result"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
//decomp = require('poly-decomp')
var integrate_fhMinv = vec2create();
var integrate_velodt = vec2create();
var _tmp = vec2create();
var _idCounter = 0;
var Body = /** @class */ (function (_super) {
    __extends(Body, _super);
    /**
     * A rigid body. Has got a center of mass, position, velocity and a number of
     * shapes that are used for collisions.
     *
     * @class Body
     * @constructor
     * @extends EventEmitter
     * @param {Object} [options]
     * @param {Boolean} [options.allowSleep=true]
     * @param {Number} [options.angle=0]
     * @param {Number} [options.angularDamping=0.1]
     * @param {Number} [options.angularForce=0]
     * @param {Number} [options.angularVelocity=0]
     * @param {Number} [options.ccdIterations=10]
     * @param {Number} [options.ccdSpeedThreshold=-1]
     * @param {Boolean} [options.collisionResponse]
     * @param {Number} [options.damping=0.1]
     * @param {Boolean} [options.fixedRotation=false]
     * @param {Boolean} [options.fixedX=false]
     * @param {Boolean} [options.fixedY=false]
     * @param {Array} [options.force]
     * @param {Number} [options.gravityScale=1]
     * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.
     * @param {Array} [options.position]
     * @param {Number} [options.sleepSpeedLimit]
     * @param {Number} [options.sleepTimeLimit]
     * @param {Number} [options.type] See {{#crossLink "Body/type:property"}}{{/crossLink}}
     * @param {Array} [options.velocity]
     *
     * @example
     *
     *     // Create a typical dynamic body
     *     var body = new Body({
     *         mass: 1, // non-zero mass will set type to Body.DYNAMIC
     *         position: [0, 5],
     *         angle: 0,
     *         velocity: [0, 0],
     *         angularVelocity: 0
     *     });
     *
     *     // Add a circular shape to the body
     *     var circleShape = new Circle({ radius: 0.5 });
     *     body.addShape(circleShape);
     *
     *     // Add the body to the world
     *     world.addBody(body);
     *
     * @example
     *
     *     // Create a static plane body
     *     var planeBody = new Body({
     *         mass: 0, // zero mass will set type to Body.STATIC
     *         position: [0, 0]
     *     });
     *     var planeShape = new Plane();
     *     planeBody.addShape(planeShape);
     *     world.addBody(planeBody);
     *
     * @example
     *
     *     // Create a moving kinematic box body
     *     var platformBody = new Body({
     *         type: Body.KINEMATIC,
     *         position: [0, 3],
     *         velocity: [1, 0]
     *     });
     *     var boxShape = new Box({ width: 2, height: 0.5 });
     *     platformBody.addShape(boxShape);
     *     world.addBody(platformBody);
     */
    function Body(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        var _this = _super.call(this) || this;
        /**
         * The body identifier. Read only!
         * @readonly
         * @property id
         * @type {Number}
        */
        _this.id = -1;
        /**
         * Index of the body in the World .bodies array. Is set to -1 if the body isn't added to a World.
         * @readonly
         * @property index
         * @type {Number}
         */
        _this.index = 0;
        /**
         * The world that this body is added to (read only). This property is set to NULL if the body is not added to any world.
         * @readonly
         * @property world
         * @type {World}
         */
        _this.world = null;
        /**
         * The shapes of the body.
         *
         * @property shapes
         * @type {Array}
         */
        _this.shapes = [];
        /**
         * The mass of the body. If you change this number, you should call {{#crossLink "Body/updateMassProperties:method"}}{{/crossLink}}.
         *
         * @property mass
         * @type {number}
         *
         * @example
         *     body.mass = 1;
         *     body.updateMassProperties();
         */
        _this.mass = 0;
        /**
         * The inverse mass of the body.
         *
         * @readonly
         * @property invMass
         * @type {number}
         */
        _this.invMass = 0;
        /**
         * The inertia of the body around the Z axis.
         * @readonly
         * @property inertia
         * @type {number}
         */
        _this.inertia = 0;
        /**
         * The inverse inertia of the body.
         * @readonly
         * @property invInertia
         * @type {number}
         */
        _this.invInertia = 0;
        _this.invMassSolve = 0;
        _this.invInertiaSolve = 0;
        /**
         * Set to true if you want to fix the rotation of the body.
         *
         * @property fixedRotation
         * @type {Boolean}
         *
         * @example
         *     // Fix rotation during runtime
         *     body.fixedRotation = true;
         *     body.updateMassProperties();
         */
        _this.fixedRotation = true;
        /**
         * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.
         * @property {Boolean} fixedX
         *
         * @example
         *     // Fix X movement on body creation
         *     var body = new Body({ mass: 1, fixedX: true });
         *
         * @example
         *     // Fix X movement during runtime
         *     body.fixedX = true;
         *     body.updateMassProperties();
         */
        _this.fixedX = false;
        /**
         * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X. See .fixedX
         * @property {Boolean} fixedY
         */
        _this.fixedY = false;
        /**
         * Angular constraint velocity that was added to the body during last step.
         * @readonly
         * @property wlambda
         * @type {Array} // This was array before the port, but hte assignment was always 0.
         */
        _this.wlambda = 0;
        /**
         * The angle of the body, in radians.
         * @property angle
         * @type {number}
         * @example
         *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
         *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
         *     function normalizeAngle(angle){
         *         angle = angle % (2*Math.PI);
         *         if(angle < 0){
         *             angle += (2*Math.PI);
         *         }
         *         return angle;
         *     }
         */
        _this.angle = 0;
        /**
         * The previous angle of the body.
         * @readonly
         * @property previousAngle
         * @type {Number}
         */
        _this.previousAngle = 0;
        /**
         * The interpolated angle of the body. Use this for rendering.
         * @readonly
         * @property interpolatedAngle
         * @type {Number}
         */
        _this.interpolatedAngle = 0;
        /**
         * The angular velocity of the body, in radians per second.
         * @property angularVelocity
         * @type {number}
         */
        _this.angularVelocity = 0;
        /**
         * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
         * @property angularForce
         * @type {number}
         */
        _this.angularForce = 0;
        /**
         * The angular force acting on the body. Should be a value between 0 and 1.
         * @property angularDamping
         * @type {Number}
         * @default 0.1
         */
        _this.angularDamping = 0.1;
        /**
         * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
         *
         * * Static bodies do not move, and they do not respond to forces or collision.
         * * Dynamic bodies body can move and respond to collisions and forces.
         * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
         *
         * @property type
         * @type {number}
         *
         * @example
         *     // Bodies are static by default. Static bodies will never move.
         *     var body = new Body();
         *     console.log(body.type == Body.STATIC); // true
         *
         * @example
         *     // By setting the mass of a body to a nonzero number, the body
         *     // will become dynamic and will move and interact with other bodies.
         *     var dynamicBody = new Body({
         *         mass : 1
         *     });
         *     console.log(dynamicBody.type == Body.DYNAMIC); // true
         *
         * @example
         *     // Kinematic bodies will only move if you change their velocity.
         *     var kinematicBody = new Body({
         *         type: Body.KINEMATIC // Type can be set via the options object.
         *     });
         */
        _this.type = Body.STATIC;
        /**
         * Bounding circle radius. Update with {{#crossLink "Body/updateBoundingRadius:method"}}{{/crossLink}}.
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        /**
         * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}{{/crossLink}}.
         * @property aabbNeedsUpdate
         * @type {Boolean}
         * @see updateAABB
         *
         * @example
         *     // Force update the AABB
         *     body.aabbNeedsUpdate = true;
         *     body.updateAABB();
         *     console.log(body.aabbNeedsUpdate); // false
         */
        _this.aabbNeedsUpdate = true;
        /**
         * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
         * @property allowSleep
         * @type {Boolean}
         * @default true
         */
        _this.allowSleep = true;
        _this.wantsToSleep = false;
        /**
         * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
         *
         * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
         *
         * @property sleepState
         * @type {Number}
         * @default Body.AWAKE
         */
        _this.sleepState = Body.AWAKE;
        /**
         * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
         * @property sleepSpeedLimit
         * @type {Number}
         * @default 0.2
         */
        _this.sleepSpeedLimit = 0.2;
        /**
         * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
         * @property sleepTimeLimit
         * @type {Number}
         * @default 1
         */
        _this.sleepTimeLimit = 1;
        /**
         * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
         * @property {Number} gravityScale
         * @default 1
         */
        _this.gravityScale = 1;
        /**
         * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
         * @property {Boolean} collisionResponse
         */
        _this.collisionResponse = true;
        /**
         * How long the body has been sleeping.
         * @readonly
         * @property {Number} idleTime
         */
        _this.idleTime = 0;
        /**
         * The last time when the body went to SLEEPY state.
         * @readonly
         * @property {Number} timeLastSleepy
         * @private
         */
        _this.timeLastSleepy = 0;
        /**
         * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
         * @property {number} ccdSpeedThreshold
         * @default -1
         */
        _this.ccdSpeedThreshold = -1;
        /**
         * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
         * @property {number} ccdIterations
         * @default 10
         */
        _this.ccdIterations = 10;
        /**
         * @property {number} islandId
         */
        _this.islandId = -1;
        _this.concavePath = null;
        // Should be private, but used by world.
        _this._wakeUpAfterNarrowphase = false;
        _this._shapeAABB = new aabb_1.default();
        _this.id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : ++_idCounter;
        _this.mass = (_b = options === null || options === void 0 ? void 0 : options.mass) !== null && _b !== void 0 ? _b : 0;
        _this.fixedRotation = (_c = options === null || options === void 0 ? void 0 : options.fixedRotation) !== null && _c !== void 0 ? _c : false;
        _this.fixedX = (_d = options === null || options === void 0 ? void 0 : options.fixedX) !== null && _d !== void 0 ? _d : false;
        _this.fixedY = (_e = options === null || options === void 0 ? void 0 : options.fixedY) !== null && _e !== void 0 ? _e : false;
        _this.massMultiplier = vec2create();
        _this.position = (options === null || options === void 0 ? void 0 : options.position) ? vec2_1.default.clone(options.position) : vec2create();
        _this.interpolatedPosition = vec2_1.default.clone(_this.position);
        _this.previousPosition = vec2_1.default.clone(_this.position);
        _this.velocity = (options === null || options === void 0 ? void 0 : options.velocity) ? vec2_1.default.clone(options.velocity) : vec2create();
        _this.vlambda = vec2create();
        _this.angle = (_f = options === null || options === void 0 ? void 0 : options.angle) !== null && _f !== void 0 ? _f : 0;
        _this.previousAngle = _this.angle;
        _this.interpolatedAngle = _this.angle;
        _this.angularVelocity = (_g = options === null || options === void 0 ? void 0 : options.angularVelocity) !== null && _g !== void 0 ? _g : 0;
        _this.force = (options === null || options === void 0 ? void 0 : options.force) ? vec2_1.default.clone(options.force) : vec2create();
        _this.angularForce = (_h = options === null || options === void 0 ? void 0 : options.angularForce) !== null && _h !== void 0 ? _h : 0;
        _this.damping = (_j = options === null || options === void 0 ? void 0 : options.damping) !== null && _j !== void 0 ? _j : 0.1;
        _this.angularDamping = (_k = options === null || options === void 0 ? void 0 : options.angularDamping) !== null && _k !== void 0 ? _k : 0.1;
        _this.sleepTimeLimit = (_l = options === null || options === void 0 ? void 0 : options.sleepTimeLimit) !== null && _l !== void 0 ? _l : 1;
        if ((options === null || options === void 0 ? void 0 : options.type) !== undefined) {
            _this.type = options.type;
        }
        else if (!(options === null || options === void 0 ? void 0 : options.mass)) {
            _this.type = Body.STATIC;
        }
        else {
            _this.type = Body.DYNAMIC;
        }
        _this.aabb = new aabb_1.default();
        _this.allowSleep = (_m = options === null || options === void 0 ? void 0 : options.allowSleep) !== null && _m !== void 0 ? _m : true;
        _this.sleepSpeedLimit = (_o = options === null || options === void 0 ? void 0 : options.sleepSpeedLimit) !== null && _o !== void 0 ? _o : 0.2;
        _this.gravityScale = (_p = options === null || options === void 0 ? void 0 : options.gravityScale) !== null && _p !== void 0 ? _p : 1;
        _this.collisionResponse = (_q = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _q !== void 0 ? _q : true;
        _this.ccdSpeedThreshold = (_r = options === null || options === void 0 ? void 0 : options.ccdSpeedThreshold) !== null && _r !== void 0 ? _r : -1;
        _this.ccdIterations = (_s = options === null || options === void 0 ? void 0 : options.ccdIterations) !== null && _s !== void 0 ? _s : 10;
        _this.updateMassProperties();
        return _this;
    }
    /**
     * @private
     * @method updateSolveMassProperties
     */
    Body.prototype.updateSolveMassProperties = function () {
        if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
            this.invMassSolve = 0;
            this.invInertiaSolve = 0;
        }
        else {
            this.invMassSolve = this.invMass;
            this.invInertiaSolve = this.invInertia;
        }
    };
    ;
    /**
     * Set the total density of the body
     * @method setDensity
     * @param {number} density
     */
    Body.prototype.setDensity = function (density) {
        var totalArea = this.getArea();
        this.mass = totalArea * density;
        this.updateMassProperties();
    };
    ;
    /**
     * Get the total area of all shapes in the body
     * @method getArea
     * @return {Number}
     */
    Body.prototype.getArea = function () {
        var totalArea = 0;
        for (var i = 0; i < this.shapes.length; i++) {
            totalArea += this.shapes[i].area;
        }
        return totalArea;
    };
    ;
    /**
     * Get the AABB from the body. The AABB is updated if necessary.
     * @method getAABB
     * @return {AABB} The AABB instance from the body.
     */
    Body.prototype.getAABB = function () {
        if (this.aabbNeedsUpdate) {
            this.updateAABB();
        }
        return this.aabb;
    };
    ;
    /**
     * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.
     * @method updateAABB
     */
    Body.prototype.updateAABB = function () {
        var shapes = this.shapes, N = shapes.length, offset = _tmp, bodyAngle = this.angle;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], angle = shape.angle + bodyAngle;
            // Get shape world offset
            vec2_1.default.rotate(offset, shape.position, bodyAngle);
            vec2_1.default.add(offset, offset, this.position);
            // Get shape AABB
            shape.computeAABB(this._shapeAABB, offset, angle);
            if (i === 0) {
                this.aabb.copy(this._shapeAABB);
            }
            else {
                this.aabb.extend(this._shapeAABB);
            }
        }
        this.aabbNeedsUpdate = false;
    };
    ;
    /**
     * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.
     * @method updateBoundingRadius
     */
    Body.prototype.updateBoundingRadius = function () {
        var shapes = this.shapes, N = shapes.length, radius = 0;
        for (var i = 0; i !== N; i++) {
            var shape = shapes[i], offset = vec2_1.default.length(shape.position), r = shape.boundingRadius;
            if (offset + r > radius) {
                radius = offset + r;
            }
        }
        this.boundingRadius = radius;
    };
    ;
    /**
     * Add a shape to the body. You can pass a local transform when adding a shape,
     * so that the shape gets an offset and angle relative to the body center of mass.
     * Will automatically update the mass properties and bounding radius.
     *
     * @method addShape
     * @param  {Shape}              shape
     * @param  {Array} [offset] Local body offset of the shape.
     * @param  {Number}             [angle]  Local body angle.
     *
     * @example
     *     var body = new Body(),
     *         shape = new Circle({ radius: 1 });
     *
     *     // Add the shape to the body, positioned in the center
     *     body.addShape(shape);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
     *     body.addShape(shape,[1,0]);
     *
     *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
     *     body.addShape(shape,[0,1],Math.PI/2);
     */
    Body.prototype.addShape = function (shape, offset, angle) {
        if (angle === void 0) { angle = 0; }
        if (shape.body) {
            throw new Error('A shape can only be added to one body.');
        }
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be added during step.');
        }
        shape.body = this;
        // Copy the offset vector
        if (offset) {
            vec2_1.default.copy(shape.position, offset);
        }
        else {
            vec2_1.default.set(shape.position, 0, 0);
        }
        shape.angle = angle || 0;
        this.shapes.push(shape);
        this.updateMassProperties();
        this.updateBoundingRadius();
        this.aabbNeedsUpdate = true;
    };
    ;
    /**
     * Remove a shape.
     * @method removeShape
     * @param  {Shape} shape
     * @return {Boolean} True if the shape was found and removed, else false.
     */
    Body.prototype.removeShape = function (shape) {
        var world = this.world;
        if (world && world.stepping) {
            throw new Error('A shape cannot be removed during step.');
        }
        var idx = this.shapes.indexOf(shape);
        if (idx !== -1) {
            this.shapes.splice(idx, 1);
            this.aabbNeedsUpdate = true;
            shape.body = undefined;
            return true;
        }
        else {
            return false;
        }
    };
    ;
    /**
     * Updates .inertia, .invMass, .invInertia for this Body. Should be called when changing the structure or mass of the Body.
     *
     * @method updateMassProperties
     *
     * @example
     *     body.mass += 1;
     *     body.updateMassProperties();
     */
    Body.prototype.updateMassProperties = function () {
        if (this.type === Body.STATIC || this.type === Body.KINEMATIC) {
            // Consider making it infinity.
            this.mass = Infinity;
            this.invMass = 0;
            this.inertia = Infinity;
            this.invInertia = 0;
        }
        else {
            var shapes = this.shapes, N = shapes.length, I = 0;
            if (!this.fixedRotation) {
                for (var i = 0; i < N; i++) {
                    var shape = shapes[i], r2 = vec2_1.default.squaredLength(shape.position), Icm = shape.computeMomentOfInertia();
                    I += Icm + r2;
                }
                this.inertia = this.mass * I;
                this.invInertia = I > 0 ? 1 / I : 0;
            }
            else {
                this.inertia = Infinity;
                this.invInertia = 0;
            }
            // Inverse mass properties are easy
            this.invMass = 1 / this.mass;
            vec2_1.default.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForce
     * @param  {Array} force The force vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [1, 0]; // Will apply the force at [body.position[0] + 1, body.position[1]]
     *     var force = [0, 1]; // up
     *     body.applyForce(force, relativePoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForce = function (force, relativePoint) {
        // Add linear force
        add(this.force, this.force, force);
        if (relativePoint) {
            // Compute produced rotational force
            var rotForce = vec2_1.default.crossLength(relativePoint, force);
            // Add rotational force
            this.angularForce += rotForce;
        }
    };
    ;
    /**
     * Apply force to a point relative to the center of mass of the body. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.angularForce.
     * @method applyForceLocal
     * @param  {Array} localForce The force vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the force will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1 locally in the body
     *     var localForce = [0, 1]; // up, locally in the body
     *     body.applyForceLocal(localForce, localPoint);
     *     console.log(body.force); // [0, 1]
     *     console.log(body.angularForce); // 1
     */
    Body.prototype.applyForceLocal = function (localForce, localPoint) {
        // These 3 lines were originally outside of this function. Not sure why.
        var Body_applyForce_forceWorld = vec2create();
        var Body_applyForce_pointWorld = vec2create();
        var Body_applyForce_pointLocal = vec2create();
        localPoint = localPoint || Body_applyForce_pointLocal;
        var worldForce = Body_applyForce_forceWorld;
        var worldPoint = Body_applyForce_pointWorld;
        this.vectorToWorldFrame(worldForce, localForce);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyForce(worldForce, worldPoint);
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulse
     * @param  {Array} impulseVector The impulse vector to add, oriented in world space.
     * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var relativePoint = [0, 0]; // center of the body
     *     var impulseVector = [0, 1]; // world up
     *     body.applyImpulse(impulseVector, relativePoint);
     */
    Body.prototype.applyImpulse = function (impulseVector, relativePoint) {
        var Body_applyImpulse_velo = vec2create(); // Was originally outside of this function. 
        if (this.type !== Body.DYNAMIC) {
            return;
        }
        // Compute produced central impulse velocity
        var velo = Body_applyImpulse_velo;
        vec2_1.default.scale(velo, impulseVector, this.invMass);
        vec2_1.default.multiply(velo, this.massMultiplier, velo);
        // Add linear impulse
        add(this.velocity, velo, this.velocity);
        if (relativePoint) {
            // Compute produced rotational impulse velocity
            var rotVelo = vec2_1.default.crossLength(relativePoint, impulseVector);
            rotVelo *= this.invInertia;
            // Add rotational Impulse
            this.angularVelocity += rotVelo;
        }
    };
    ;
    /**
     * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
     * @method applyImpulseLocal
     * @param  {Array} localImpulse The impulse vector to add, oriented in local body space.
     * @param  {Array} [localPoint] A point relative to the body in local body space. If not given, it is set to zero and all of the impulse will be exerted on the center of mass.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var localPoint = [1, 0]; // x=1, locally in the body
     *     var localImpulse = [0, 1]; // up, locally in the body
     *     body.applyImpulseLocal(localImpulse, localPoint);
     *     console.log(body.velocity); // [1, 0]
     *     console.log(body.angularVelocity); // 1
     */
    Body.prototype.applyImpulseLocal = function (localImpulse, localPoint) {
        // Originally outside of this function.
        var Body_applyImpulse_impulseWorld = vec2create();
        var Body_applyImpulse_pointWorld = vec2create();
        var Body_applyImpulse_pointLocal = vec2create();
        localPoint = localPoint || Body_applyImpulse_pointLocal;
        var worldImpulse = Body_applyImpulse_impulseWorld;
        var worldPoint = Body_applyImpulse_pointWorld;
        this.vectorToWorldFrame(worldImpulse, localImpulse);
        this.vectorToWorldFrame(worldPoint, localPoint);
        this.applyImpulse(worldImpulse, worldPoint);
    };
    ;
    /**
     * Transform a world point to local body frame.
     * @method toLocalFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} worldPoint   The input world point
     */
    Body.prototype.toLocalFrame = function (out, worldPoint) {
        vec2_1.default.toLocalFrame(out, worldPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a local point to world frame.
     * @method toWorldFrame
     * @param  {Array} out          The point to store the result in
     * @param  {Array} localPoint   The input local point
     */
    Body.prototype.toWorldFrame = function (out, localPoint) {
        vec2_1.default.toGlobalFrame(out, localPoint, this.position, this.angle);
    };
    ;
    /**
     * Transform a world vector to local body frame.
     * @method vectorToLocalFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} worldVector  The input world vector
     */
    Body.prototype.vectorToLocalFrame = function (out, worldVector) {
        vec2_1.default.vectorToLocalFrame(out, worldVector, this.angle);
    };
    ;
    /**
     * Transform a local vector to world frame.
     * @method vectorToWorldFrame
     * @param  {Array} out          The vector to store the result in
     * @param  {Array} localVector  The input local vector
     */
    Body.prototype.vectorToWorldFrame = function (out, localVector) {
        vec2_1.default.rotate(out, localVector, this.angle);
    };
    ;
    /**
     * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
     * @method fromPolygon
     * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
     * @param {Object} [options]
     * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
     * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
     * @param {Number} [options.removeCollinearPoints=0] Set to a number (angle threshold value) to remove collinear points, or 0 to keep all points.
     * @return {Boolean} True on success, else false.
     * @example
     *     var body = new Body();
     *     var path = [
     *         [-1, 1],
     *         [-1, 0],
     *         [1, 0],
     *         [1, 1],
     *         [0.5, 0.5]
     *     ];
     *     body.fromPolygon(path);
     *     console.log(body.shapes); // [Convex, Convex, ...]
     */
    Body.prototype.fromPolygon = function (path, options) {
        var _a, _b, _c;
        // Remove all shapes
        for (var i = this.shapes.length; i >= 0; --i) {
            this.removeShape(this.shapes[i]);
        }
        // Copy the path
        var p = [];
        for (var i = 0; i < path.length; i++) {
            p[i] = vec2_1.default.clone(path[i]);
        }
        // Make it counter-clockwise
        poly_decomp_1.default.makeCCW(p);
        if ((options === null || options === void 0 ? void 0 : options.removeCollinearPoints) != 0) {
            poly_decomp_1.default.removeCollinearPoints(p, (_a = options === null || options === void 0 ? void 0 : options.removeCollinearPoints) !== null && _a !== void 0 ? _a : 0);
        }
        // Check if any line segment intersects the path itself
        if (!(options === null || options === void 0 ? void 0 : options.skipSimpleCheck)) {
            if (!poly_decomp_1.default.isSimple(p)) {
                return false;
            }
        }
        // Save this path for later
        this.concavePath = [];
        for (var i = 0; i < p.length; i++) {
            this.concavePath[i] = vec2_1.default.clone(p[i]);
        }
        // Slow or fast decomp?
        var convexes;
        if (options === null || options === void 0 ? void 0 : options.optimalDecomp) {
            convexes = (_b = poly_decomp_1.default.decomp(p)) !== null && _b !== void 0 ? _b : new Array();
        }
        else {
            convexes = (_c = poly_decomp_1.default.quickDecomp(p)) !== null && _c !== void 0 ? _c : new Array();
        }
        var cm = vec2create();
        // Add convexes
        for (var i = 0; i !== convexes.length; i++) {
            // Create convex
            var c = new Convex_1.default(undefined, convexes[i]);
            // Move all vertices so its center of mass is in the local center of the convex
            for (var j = 0; j !== c.vertices.length; j++) {
                var v = c.vertices[j];
                sub(v, v, c.centerOfMass);
            }
            vec2_1.default.copy(cm, c.centerOfMass);
            c = new Convex_1.default(undefined, c.vertices);
            // Add the shape
            this.addShape(c, cm);
        }
        this.adjustCenterOfMass();
        this.aabbNeedsUpdate = true;
        return true;
    };
    /**
     * Moves the shape offsets so their center of mass becomes the body center of mass.
     * @method adjustCenterOfMass
     * @example
     *     var body = new Body({ position: [0, 0] });
     *     var shape = new Circle({ radius: 1 });
     *     body.addShape(shape, [1, 0], 0);
     *     body.adjustCenterOfMass();
     *     console.log(body.position); // [1, 0]
     *     console.log(shape.position); // [0, 0]
     */
    Body.prototype.adjustCenterOfMass = function () {
        var adjustCenterOfMass_tmp2 = vec2create(), adjustCenterOfMass_tmp3 = vec2create(), adjustCenterOfMass_tmp4 = vec2create();
        var offset_times_area = adjustCenterOfMass_tmp2, sum = adjustCenterOfMass_tmp3, cm = adjustCenterOfMass_tmp4, totalArea = 0;
        vec2_1.default.set(sum, 0, 0);
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            vec2_1.default.scale(offset_times_area, s.position, s.area);
            add(sum, sum, offset_times_area);
            totalArea += s.area;
        }
        vec2_1.default.scale(cm, sum, 1 / totalArea);
        // Now move all shapes
        for (var i = 0; i !== this.shapes.length; i++) {
            var s = this.shapes[i];
            sub(s.position, s.position, cm);
        }
        // Move the body position too
        add(this.position, this.position, cm);
        // And concave path
        for (var i = 0; this.concavePath && i < this.concavePath.length; i++) {
            sub(this.concavePath[i], this.concavePath[i], cm);
        }
        this.updateMassProperties();
        this.updateBoundingRadius();
    };
    /**
     * Sets the force on the body to zero.
     * @method setZeroForce
     */
    Body.prototype.setZeroForce = function () {
        var f = this.force;
        f[0] = f[1] = this.angularForce = 0;
    };
    Body.prototype.resetConstraintVelocity = function () {
        var b = this, vlambda = b.vlambda;
        vec2_1.default.set(vlambda, 0, 0);
        b.wlambda = 0;
    };
    Body.prototype.addConstraintVelocity = function () {
        var b = this, v = b.velocity;
        add(v, v, b.vlambda);
        b.angularVelocity += b.wlambda;
    };
    /**
     * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
     * @method applyDamping
     * @param  {number} dt Current time step
     */
    Body.prototype.applyDamping = function (dt) {
        if (this.type === Body.DYNAMIC) { // Only for dynamic bodies
            var v = this.velocity;
            vec2_1.default.scale(v, v, Math.pow(1 - this.damping, dt));
            this.angularVelocity *= Math.pow(1 - this.angularDamping, dt);
        }
    };
    /**
     * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
     * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
     * @method wakeUp
     */
    Body.prototype.wakeUp = function () {
        var s = this.sleepState;
        this.sleepState = Body.AWAKE;
        this.idleTime = 0;
        if (s !== Body.AWAKE) {
            _super.prototype.emit.call(this, wakeUpEvent);
        }
    };
    /**
     * Force body sleep
     * @method sleep
     */
    Body.prototype.sleep = function () {
        this.sleepState = Body.SLEEPING;
        this.angularVelocity = this.angularForce = 0;
        vec2_1.default.set(this.velocity, 0, 0);
        vec2_1.default.set(this.force, 0, 0);
        _super.prototype.emit.call(this, sleepEvent);
    };
    /**
     * Called every timestep to update internal sleep timer and change sleep state if needed.
     * @method sleepTick
     * @param {number} time The world time in seconds
     * @param {boolean} dontSleep
     * @param {number} dt
     */
    Body.prototype.sleepTick = function (time, dontSleep, dt) {
        if (!this.allowSleep || this.type === Body.SLEEPING) {
            return;
        }
        this.wantsToSleep = false;
        var speedSquared = vec2_1.default.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2), speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
        // Add to idle time
        if (speedSquared >= speedLimitSquared) {
            this.idleTime = 0;
            this.sleepState = Body.AWAKE;
        }
        else {
            this.idleTime += dt;
            if (this.sleepState !== Body.SLEEPY) {
                this.sleepState = Body.SLEEPY;
                _super.prototype.emit.call(this, sleepyEvent);
            }
        }
        if (this.idleTime > this.sleepTimeLimit) {
            if (!dontSleep) {
                this.sleep();
            }
            else {
                this.wantsToSleep = true;
            }
        }
    };
    /**
     * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
     * @method overlaps
     * @param  {Body} body
     * @return {boolean}
     */
    Body.prototype.overlaps = function (body) {
        if (!this.world)
            return false;
        return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
    };
    /**
     * Move the body forward in time given its current velocity.
     * @method integrate
     * @param  {Number} dt
     */
    Body.prototype.integrate = function (dt) {
        var minv = this.invMass, f = this.force, pos = this.position, velo = this.velocity;
        // Save old position
        vec2_1.default.copy(this.previousPosition, this.position);
        this.previousAngle = this.angle;
        // Velocity update
        if (!this.fixedRotation) {
            this.angularVelocity += this.angularForce * this.invInertia * dt;
        }
        vec2_1.default.scale(integrate_fhMinv, f, dt * minv);
        vec2_1.default.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);
        add(velo, integrate_fhMinv, velo);
        // CCD
        if (!this.integrateToTimeOfImpact(dt)) {
            // Regular position update
            vec2_1.default.scale(integrate_velodt, velo, dt);
            add(pos, pos, integrate_velodt);
            if (!this.fixedRotation) {
                this.angle += this.angularVelocity * dt;
            }
        }
        this.aabbNeedsUpdate = true;
    };
    Body.prototype.integrateToTimeOfImpact = function (dt) {
        var _a;
        if (!this.world)
            return false;
        var result = new raycast_result_1.default();
        var ray = new ray_1.default({
            mode: ray_1.default.CLOSEST,
            skipBackfaces: true
        });
        var direction = vec2create();
        var end = vec2create();
        var startToEnd = vec2create();
        var rememberPosition = vec2create();
        if (this.ccdSpeedThreshold < 0 || vec2_1.default.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
            return false;
        }
        // Ignore all the ignored body pairs
        // This should probably be done somewhere else for optimization
        var ignoreBodies = [];
        var disabledPairs = this.world.disabledBodyCollisionPairs;
        for (var i = 0; i < disabledPairs.length; i += 2) {
            var bodyA = disabledPairs[i];
            var bodyB = disabledPairs[i + 1];
            if (bodyA === this) {
                ignoreBodies.push(bodyB);
            }
            else if (bodyB === this) {
                ignoreBodies.push(bodyA);
            }
        }
        vec2_1.default.normalize(direction, this.velocity);
        vec2_1.default.scale(end, this.velocity, dt);
        add(end, end, this.position);
        sub(startToEnd, end, this.position);
        var startToEndAngle = this.angularVelocity * dt;
        var len = vec2_1.default.length(startToEnd);
        var timeOfImpact = 1;
        var hitBody = null;
        vec2_1.default.copy(ray.from, this.position);
        vec2_1.default.copy(ray.to, end);
        ray.update();
        for (var i = 0; i < this.shapes.length; i++) {
            var shape = this.shapes[i];
            result.reset();
            ray.collisionGroup = shape.collisionGroup;
            ray.collisionMask = shape.collisionMask;
            this.world.raycast(result, ray);
            hitBody = (_a = result.body) !== null && _a !== void 0 ? _a : null;
            if (!hitBody)
                continue;
            if (hitBody === this || ignoreBodies.indexOf(hitBody) !== -1) {
                hitBody = null;
            }
            if (hitBody) {
                break;
            }
        }
        if (!hitBody || !timeOfImpact) {
            return false;
        }
        result.getHitPoint(end, ray);
        sub(startToEnd, end, this.position);
        timeOfImpact = vec2_1.default.distance(end, this.position) / len; // guess
        var rememberAngle = this.angle;
        vec2_1.default.copy(rememberPosition, this.position);
        // Got a start and end point. Approximate time of impact using binary search
        var iter = 0;
        var tmin = 0;
        var tmid = timeOfImpact;
        var tmax = 1;
        while (tmax >= tmin && iter < this.ccdIterations) {
            iter++;
            // calculate the midpoint
            tmid = (tmax + tmin) / 2;
            // Move the body to that point
            vec2_1.default.scale(integrate_velodt, startToEnd, tmid);
            add(this.position, rememberPosition, integrate_velodt);
            this.angle = rememberAngle + startToEndAngle * tmid;
            this.updateAABB();
            // check overlap
            var overlaps = this.aabb.overlaps(hitBody.aabb) && this.world.narrowphase.bodiesOverlap(this, hitBody, true);
            if (overlaps) {
                // change max to search lower interval
                tmax = tmid;
            }
            else {
                // change min to search upper interval
                tmin = tmid;
            }
        }
        timeOfImpact = tmax; // Need to guarantee overlap to resolve collisions
        vec2_1.default.copy(this.position, rememberPosition);
        this.angle = rememberAngle;
        // move to TOI
        vec2_1.default.scale(integrate_velodt, startToEnd, timeOfImpact);
        add(this.position, this.position, integrate_velodt);
        if (!this.fixedRotation) {
            this.angle += startToEndAngle * timeOfImpact;
        }
        return true;
    };
    /**
     * Get velocity of a point in the body.
     * @method getVelocityAtPoint
     * @param  {Array} result A vector to store the result in
     * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from
     * @return {Array} The result vector
     * @example
     *     var body = new Body({
     *         mass: 1,
     *         velocity: [1, 0],
     *         angularVelocity: 1
     *     });
     *     var result = [];
     *     var point = [1, 0];
     *     body.getVelocityAtPoint(result, point);
     *     console.log(result); // [1, 1]
     */
    Body.prototype.getVelocityAtPoint = function (result, relativePoint) {
        vec2_1.default.crossVZ(result, relativePoint, this.angularVelocity);
        vec2_1.default.subtract(result, this.velocity, result);
        return result;
    };
    /**
     * Dynamic body.
     * @property DYNAMIC
     * @type {Number}
     * @static
     */
    Body.DYNAMIC = 1;
    /**
     * Static body.
     * @property STATIC
     * @type {Number}
     * @static
     */
    Body.STATIC = 2;
    /**
     * Kinematic body.
     * @property KINEMATIC
     * @type {Number}
     * @static
     */
    Body.KINEMATIC = 4;
    /**
     * @property AWAKE
     * @type {Number}
     * @static
     */
    Body.AWAKE = 0;
    /**
     * @property SLEEPY
     * @type {Number}
     * @static
     */
    Body.SLEEPY = 1;
    /**
     * @property SLEEPING
     * @type {Number}
     * @static
     */
    Body.SLEEPING = 2;
    return Body;
}(event_emitter_1.default));
exports.default = Body;
/**
 * @event sleepy
 */
var sleepyEvent = {
    type: "sleepy"
};
/**
 * @event sleep
 */
var sleepEvent = {
    type: "sleep"
};
/**
 * @event wakeup
 */
var wakeUpEvent = {
    type: "wakeup"
};

},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],30:[function(_dereq_,module,exports){
module.exports=_dereq_(29)
},{"../collision/aabb":1,"../collision/ray":5,"../collision/raycast-result":6,"../events/event-emitter":21,"../math/poly-decomp":26,"../math/vec2":28,"../shapes/Convex":37}],31:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var spring_1 = __importDefault(_dereq_("./spring"));
var applyForce_r = vec2_1.default.create(), applyForce_r_unit = vec2_1.default.create(), applyForce_u = vec2_1.default.create(), applyForce_f = vec2_1.default.create(), applyForce_worldAnchorA = vec2_1.default.create(), applyForce_worldAnchorB = vec2_1.default.create(), applyForce_ri = vec2_1.default.create(), applyForce_rj = vec2_1.default.create(), applyForce_tmp = vec2_1.default.create();
var LinearSpring = /** @class */ (function (_super) {
    __extends(LinearSpring, _super);
    /**
     * A spring, connecting two bodies.
     *
     * The Spring explicitly adds force and angularForce to the bodies.
     *
     * @class LinearSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     *
     * @example
     *     var spring = new LinearSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1,
     *         localAnchorA: [0,0], // center of bodyA
     *         localAnchorB: [0,0] // center of bodyB
     *     });
     *     world.addSpring(spring);
     */
    function LinearSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        _this.localAnchorA = vec2_1.default.create();
        _this.localAnchorB = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localAnchorA) {
            vec2_1.default.copy(_this.localAnchorA, options.localAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.localAnchorB) {
            vec2_1.default.copy(_this.localAnchorB, options.localAnchorB);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorA) {
            _this.setWorldAnchorA(options.worldAnchorA);
        }
        if (options === null || options === void 0 ? void 0 : options.worldAnchorB) {
            _this.setWorldAnchorB(options.worldAnchorB);
        }
        var worldAnchorA = vec2_1.default.create();
        var worldAnchorB = vec2_1.default.create();
        _this.getWorldAnchorA(worldAnchorA);
        _this.getWorldAnchorB(worldAnchorB);
        var worldDistance = vec2_1.default.distance(worldAnchorA, worldAnchorB);
        _this.restLength = (_a = options === null || options === void 0 ? void 0 : options.restLength) !== null && _a !== void 0 ? _a : worldDistance;
        return _this;
    }
    /**
     * Set the anchor point on body A, using world coordinates.
     * @method setWorldAnchorA
     * @param {Array} worldAnchorA
     */
    LinearSpring.prototype.setWorldAnchorA = function (worldAnchorA) {
        this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
    };
    /**
     * Set the anchor point on body B, using world coordinates.
     * @method setWorldAnchorB
     * @param {Array} worldAnchorB
     */
    LinearSpring.prototype.setWorldAnchorB = function (worldAnchorB) {
        this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
    };
    /**
     * Get the anchor point on body A, in world coordinates.
     * @method getWorldAnchorA
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorA = function (result) {
        this.bodyA.toWorldFrame(result, this.localAnchorA);
    };
    /**
     * Get the anchor point on body B, in world coordinates.
     * @method getWorldAnchorB
     * @param {Array} result The vector to store the result in.
     */
    LinearSpring.prototype.getWorldAnchorB = function (result) {
        this.bodyB.toWorldFrame(result, this.localAnchorB);
    };
    /**
     * Apply the spring force to the connected bodies.
     * @private
     * @method applyForce
     */
    LinearSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
        var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj;
        // Get world anchors
        this.getWorldAnchorA(worldAnchorA);
        this.getWorldAnchorB(worldAnchorB);
        // Get offset points
        vec2_1.default.subtract(ri, worldAnchorA, bodyA.position);
        vec2_1.default.subtract(rj, worldAnchorB, bodyB.position);
        // Compute distance vector between world anchor points
        vec2_1.default.subtract(r, worldAnchorB, worldAnchorA);
        var rlen = vec2_1.default.length(r);
        vec2_1.default.normalize(r_unit, r);
        // Compute relative velocity of the anchor points, u
        vec2_1.default.subtract(u, bodyB.velocity, bodyA.velocity);
        vec2_1.default.crossZV(tmp, bodyB.angularVelocity, rj);
        vec2_1.default.add(u, u, tmp);
        vec2_1.default.crossZV(tmp, bodyA.angularVelocity, ri);
        vec2_1.default.subtract(u, u, tmp);
        // F = - k * ( x - L ) - D * ( u )
        vec2_1.default.scale(f, r_unit, -k * (rlen - l) - d * vec2_1.default.dot(u, r_unit));
        // Add forces to bodies
        vec2_1.default.subtract(bodyA.force, bodyA.force, f);
        vec2_1.default.add(bodyB.force, bodyB.force, f);
        // Angular force
        var ri_x_f = vec2_1.default.crossLength(ri, f);
        var rj_x_f = vec2_1.default.crossLength(rj, f);
        bodyA.angularForce -= ri_x_f;
        bodyB.angularForce += rj_x_f;
    };
    return LinearSpring;
}(spring_1.default));
exports.default = LinearSpring;

},{"../math/vec2":28,"./spring":33}],32:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var spring_1 = __importDefault(_dereq_("./spring"));
var RotationalSpring = /** @class */ (function (_super) {
    __extends(RotationalSpring, _super);
    /**
     * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
     *
     * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
     *
     * @class RotationalSpring
     * @extends Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
     * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1] A number >= 0.
     *
     * @example
     *     var spring = new RotationalSpring(bodyA, bodyB, {
     *         stiffness: 100,
     *         damping: 1
     *     });
     *     world.addSpring(spring);
     */
    function RotationalSpring(bodyA, bodyB, options) {
        var _a;
        var _this = _super.call(this, bodyA, bodyB, options) || this;
        /**
         * Rest angle of the spring.
         * @property restAngle
         * @type {number}
         */
        _this.restAngle = (_a = options === null || options === void 0 ? void 0 : options.restAngle) !== null && _a !== void 0 ? _a : bodyB.angle - bodyA.angle;
        return _this;
    }
    /**
     * Apply the spring force to the connected bodies.
     * @method applyForce
     */
    RotationalSpring.prototype.applyForce = function () {
        var k = this.stiffness, d = this.damping, l = this.restAngle, bodyA = this.bodyA, bodyB = this.bodyB, x = bodyB.angle - bodyA.angle, u = bodyB.angularVelocity - bodyA.angularVelocity;
        var torque = -k * (x - l) - d * u;
        bodyA.angularForce -= torque;
        bodyB.angularForce += torque;
    };
    ;
    return RotationalSpring;
}(spring_1.default));
exports.default = RotationalSpring;

},{"./spring":33}],33:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Spring = /** @class */ (function () {
    /**
     * Base class for {{#crossLink "LinearSpring"}}{{/crossLink}} and {{#crossLink "RotationalSpring"}}{{/crossLink}}. Not supposed to be used directly.
     *
     * @class Spring
     * @constructor
     * @param {Body} bodyA
     * @param {Body} bodyB
     * @param {Object} [options]
     * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
     * @param {number} [options.damping=1]      A number >= 0. Default: 1
     * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
     * @param {Array}  [options.localAnchorB]
     * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
     * @param {Array}  [options.worldAnchorB]
     */
    function Spring(bodyA, bodyB, options) {
        var _a, _b;
        this.stiffness = (_a = options === null || options === void 0 ? void 0 : options.stiffness) !== null && _a !== void 0 ? _a : 100;
        this.damping = (_b = options === null || options === void 0 ? void 0 : options.damping) !== null && _b !== void 0 ? _b : 1;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    }
    return Spring;
}());
exports.default = Spring;

},{}],34:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var body_1 = __importDefault(_dereq_("./body"));
var constraint_1 = __importDefault(_dereq_("../constraints/constraint"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var worldVelocity = vec2_1.default.create();
var relativePoint = vec2_1.default.create();
var tmpVec = vec2_1.default.create();
var TopDownVehicle = /** @class */ (function () {
    /**
     * @class TopDownVehicle
     * @constructor
     *
     * @deprecated This class will be moved out of the core library in future versions.
     *
     * @param {Body} chassisBody A dynamic body, already added to the world.
     * @param {Object} [options]
     *
     * @example
     *
     *     // Create a dynamic body for the chassis
     *     var chassisBody = new Body({
     *         mass: 1
     *     });
     *     var boxShape = new Box({ width: 0.5, height: 1 });
     *     chassisBody.addShape(boxShape);
     *     world.addBody(chassisBody);
     *
     *     // Create the vehicle
     *     var vehicle = new TopDownVehicle(chassisBody);
     *
     *     // Add one front wheel and one back wheel - we don't actually need four :)
     *     var frontWheel = vehicle.addWheel({
     *         localPosition: [0, 0.5] // front
     *     });
     *     frontWheel.setSideFriction(4);
     *
     *     // Back wheel
     *     var backWheel = vehicle.addWheel({
     *         localPosition: [0, -0.5] // back
     *     });
     *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift
     *     vehicle.addToWorld(world);
     *
     *     // Steer value zero means straight forward. Positive is left and negative right.
     *     frontWheel.steerValue = Math.PI / 16;
     *
     *     // Engine force forward
     *     backWheel.engineForce = 10;
     *     backWheel.setBrakeForce(0);
     */
    function TopDownVehicle(chassisBody, options) {
        var _this = this;
        // A dummy body to constrain the chassis to
        this.groundBody = new body_1.default({ mass: 0 });
        this.wheels = [];
        this.chassisBody = chassisBody;
        this.preStepCallback = function () {
            _this.update();
        };
    }
    /**
     * @method addToWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.addToWorld = function (world) {
        this.world = world;
        world.addBody(this.groundBody);
        world.on("preStep", this.preStepCallback, this);
        for (var i = 0; i < this.wheels.length; i++) {
            var wheel = this.wheels[i];
            world.addConstraint(wheel);
        }
    };
    ;
    /**
     * @method removeFromWorld
     * @param {World} world
     */
    TopDownVehicle.prototype.removeFromWorld = function () {
        var world = this.world;
        if (world) {
            world.removeBody(this.groundBody);
            world.off('preStep', this.preStepCallback);
            for (var i = 0; i < this.wheels.length; i++) {
                var wheel = this.wheels[i];
                world.removeConstraint(wheel);
            }
            this.world = undefined;
        }
    };
    ;
    /**
     * @method addWheel
     * @param {object} [wheelOptions]
     * @return {WheelConstraint}
     */
    TopDownVehicle.prototype.addWheel = function (wheelOptions) {
        var wheel = new WheelConstraint(this, wheelOptions);
        this.wheels.push(wheel);
        return wheel;
    };
    ;
    /**
     * @method update
     */
    TopDownVehicle.prototype.update = function () {
        for (var i = 0; i < this.wheels.length; i++) {
            this.wheels[i].update();
        }
    };
    ;
    return TopDownVehicle;
}());
exports.default = TopDownVehicle;
var WheelConstraint = /** @class */ (function (_super) {
    __extends(WheelConstraint, _super);
    /**
     * @class WheelConstraint
     * @constructor
     * @extends {Constraint}
     * @param {Vehicle} vehicle
     * @param {object} [options]
     * @param {Array} [options.localForwardVector] The local wheel forward vector in local body space. Default is zero.
     * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.
     * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.
     */
    function WheelConstraint(vehicle, options) {
        var _a;
        var _this = 
        // TODO: I have no idea what kind of constraint this is supposed to be. It seems this was undefined in the original code.
        _super.call(this, vehicle.chassisBody, vehicle.groundBody, 0) || this;
        _this.steerValue = 0;
        /**
         * @property {number} engineForce
         */
        _this.engineForce = 0;
        _this.vehicle = vehicle;
        _this.forwardEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.sideEquation = new friction_equation_1.default(vehicle.chassisBody, vehicle.groundBody);
        _this.setSideFriction((_a = options === null || options === void 0 ? void 0 : options.sideFriction) !== null && _a !== void 0 ? _a : 5);
        /**
         * @property {Array} localForwardVector
         */
        _this.localForwardVector = vec2_1.default.fromValues(0, 1);
        if (options === null || options === void 0 ? void 0 : options.localForwardVector) {
            vec2_1.default.copy(_this.localForwardVector, options.localForwardVector);
        }
        /**
         * @property {Array} localPosition
         */
        _this.localPosition = vec2_1.default.create();
        if (options === null || options === void 0 ? void 0 : options.localPosition) {
            vec2_1.default.copy(_this.localPosition, options.localPosition);
        }
        _this.equations.push(_this.forwardEquation);
        _this.equations.push(_this.sideEquation);
        _this.setBrakeForce(0);
        return _this;
    }
    /**
     * @method setBrakeForce
     */
    WheelConstraint.prototype.setBrakeForce = function (force) {
        this.forwardEquation.setSlipForce(force);
    };
    /**
     * @method setSideFriction
     */
    WheelConstraint.prototype.setSideFriction = function (force) {
        this.sideEquation.setSlipForce(force);
    };
    /**
     * @method getSpeed
     */
    WheelConstraint.prototype.getSpeed = function () {
        var body = this.vehicle.chassisBody;
        body.vectorToWorldFrame(relativePoint, this.localForwardVector);
        body.getVelocityAtPoint(worldVelocity, relativePoint);
        return vec2_1.default.dot(worldVelocity, relativePoint);
    };
    /**
     * @method update
     */
    WheelConstraint.prototype.update = function () {
        var body = this.vehicle.chassisBody;
        var forwardEquation = this.forwardEquation;
        var sideEquation = this.sideEquation;
        var steerValue = this.steerValue;
        // Directional
        body.vectorToWorldFrame(forwardEquation.t, this.localForwardVector);
        vec2_1.default.rotate(sideEquation.t, this.localForwardVector, Math.PI / 2);
        body.vectorToWorldFrame(sideEquation.t, sideEquation.t);
        vec2_1.default.rotate(forwardEquation.t, forwardEquation.t, steerValue);
        vec2_1.default.rotate(sideEquation.t, sideEquation.t, steerValue);
        // Attachment point
        body.toWorldFrame(forwardEquation.contactPointB, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointB, forwardEquation.contactPointB);
        body.vectorToWorldFrame(forwardEquation.contactPointA, this.localPosition);
        vec2_1.default.copy(sideEquation.contactPointA, forwardEquation.contactPointA);
        // Add engine force
        vec2_1.default.normalize(tmpVec, forwardEquation.t);
        vec2_1.default.scale(tmpVec, tmpVec, this.engineForce);
        this.vehicle.chassisBody.applyForce(tmpVec, forwardEquation.contactPointA);
    };
    return WheelConstraint;
}(constraint_1.default));

},{"../constraints/constraint":8,"../equations/friction-equation":18,"../math/vec2":28,"./body":30}],35:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var vec2 = require('../math/vec2')
// ,   Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   Convex = require('./Convex');
var Convex_1 = __importDefault(_dereq_("./Convex"));
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Box = /** @class */ (function (_super) {
    __extends(Box, _super);
    /**
     * Box shape class.
     * @class Box
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.width=1] Total width of the box
     * @param {Number} [options.height=1] Total height of the box
     * @extends Convex
     * @example
     *     var body = new Body({ mass: 1 });
     *     var boxShape = new Box({
     *         width: 2,
     *         height: 1
     *     });
     *     body.addShape(boxShape);
     */
    function Box(options) {
        var _a, _b;
        var _this = this;
        var width = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : 1;
        var height = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : 1;
        var hw = width / 2;
        var hh = height / 2;
        _this = _super.call(this, shape_1.default.BOX, [
            vec2_1.default.fromValues(-hw, -hh),
            vec2_1.default.fromValues(hw, -hh),
            vec2_1.default.fromValues(hw, hh),
            vec2_1.default.fromValues(-hw, hh)
        ], options) || this;
        _this.height = height;
        _this.width = width;
        return _this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Box.prototype.computeMomentOfInertia = function () {
        var w = this.width, h = this.height;
        return (h * h + w * w) / 12;
    };
    ;
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Box.prototype.updateBoundingRadius = function () {
        var w = this.width, h = this.height;
        this.boundingRadius = Math.sqrt(w * w + h * h) / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Box.prototype.computeAABB = function (out, position, angle) {
        var c = Math.abs(Math.cos(angle)), s = Math.abs(Math.sin(angle)), w = this.width, h = this.height;
        var height = (w * s + h * c) * 0.5;
        var width = (h * s + w * c) * 0.5;
        var l = out.lowerBound;
        var u = out.upperBound;
        var px = position[0];
        var py = position[1];
        l[0] = px - width;
        l[1] = py - height;
        u[0] = px + width;
        u[1] = py + height;
    };
    ;
    Box.prototype.updateArea = function () {
        this.area = this.width * this.height;
        return this.area;
    };
    ;
    Box.prototype.pointTest = function (localPoint) {
        return Math.abs(localPoint[0]) <= this.width * 0.5 && Math.abs(localPoint[1]) <= this.height * 0.5;
    };
    ;
    return Box;
}(Convex_1.default));
exports.default = Box;

},{"../math/vec2":28,"./Convex":37,"./shape":46}],36:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Ray_intersectSphere_intersectionPoint = vec2_1.default.create();
var Ray_intersectSphere_normal = vec2_1.default.create();
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * Circle shape class.
     * @class Circle
     * @extends Shape
     * @constructor
     * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {number} [options.radius=1] The radius of this circle
     *
     * @example
     *     var body = new Body({ mass: 1 });
     *     var circleShape = new Circle({
     *         radius: 1
     *     });
     *     body.addShape(circleShape);
     */
    function Circle(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.CIRCLE, options) || this;
        /**
         * The radius of the circle.
         * @property radius
         * @type {number}
         */
        _this.radius = (_a = options === null || options === void 0 ? void 0 : options.radius) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Circle.prototype.computeMomentOfInertia = function () {
        var r = this.radius;
        return r * r / 2;
    };
    /**
     * @method updateBoundingRadius
     * @return {Number}
     */
    Circle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     * @return {Number}
     */
    Circle.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Circle.prototype.computeAABB = function (out, position /*, angle: f32*/) {
        var r = this.radius;
        vec2_1.default.set(out.upperBound, r, r);
        vec2_1.default.set(out.lowerBound, -r, -r);
        if (position) {
            vec2_1.default.add(out.lowerBound, out.lowerBound, position);
            vec2_1.default.add(out.upperBound, out.upperBound, position);
        }
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Circle.prototype.raycast = function (result, ray, position /*, angle: f32*/) {
        var from = ray.from, to = ray.to, r = this.radius;
        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
        var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
        var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);
        var delta = Math.pow(b, 2) - 4 * a * c;
        var intersectionPoint = Ray_intersectSphere_intersectionPoint;
        var normal = Ray_intersectSphere_normal;
        if (delta < 0) {
            // No intersection
            return;
        }
        else if (delta === 0) {
            // single intersection point
            vec2_1.default.lerp(intersectionPoint, from, to, delta);
            vec2_1.default.subtract(normal, intersectionPoint, position);
            vec2_1.default.normalize(normal, normal);
            ray.reportIntersection(result, delta, normal, -1);
        }
        else {
            var sqrtDelta = Math.sqrt(delta);
            var inv2a = 1 / (2 * a);
            var d1 = (-b - sqrtDelta) * inv2a;
            var d2 = (-b + sqrtDelta) * inv2a;
            if (d1 >= 0 && d1 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d1);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d1, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
            if (d2 >= 0 && d2 <= 1) {
                vec2_1.default.lerp(intersectionPoint, from, to, d2);
                vec2_1.default.subtract(normal, intersectionPoint, position);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, d2, normal, -1);
            }
        }
    };
    Circle.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        return vec2_1.default.squaredLength(localPoint) <= radius * radius;
    };
    return Circle;
}(Shape_1.default));
exports.default = Circle;

},{"../math/vec2":28,"./Shape":38}],37:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Shape_1 = __importDefault(_dereq_("./Shape"));
var polyk_1 = __importDefault(_dereq_("../math/polyk"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var dot = vec2_1.default.dot;
var updateCenterOfMass_centroid = vec2_1.default.create(), updateCenterOfMass_centroid_times_mass = vec2_1.default.create(), updateCenterOfMass_a = vec2_1.default.create(), updateCenterOfMass_b = vec2_1.default.create(), updateCenterOfMass_c = vec2_1.default.create();
var tmpVec1 = vec2_1.default.create();
var intersectConvex_rayStart = vec2_1.default.create();
var intersectConvex_rayEnd = vec2_1.default.create();
var intersectConvex_normal = vec2_1.default.create();
var pic_r0 = vec2_1.default.create();
var pic_r1 = vec2_1.default.create();
var tmpVec2 = vec2_1.default.create();
var worldAxis = tmpVec2;
var Convex = /** @class */ (function (_super) {
    __extends(Convex, _super);
    /**
     * Convex shape class.
     * @class Convex
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
     *     var convexShape = new Convex({
     *         vertices: vertices
     *     });
     *     body.addShape(convexShape);
     */
    function Convex(type, vertices, options) {
        var _this = _super.call(this, type !== null && type !== void 0 ? type : Shape_1.default.CONVEX, options) || this;
        // TODO: this would be more efficient if I didn't use float32array[]s. Just convert to a big float32array with double the size.
        // Let's get this working first then switch it.
        /**
         * Vertices defined in the local frame.
         * @property vertices
         * @type {Array}
         */
        _this.vertices = [];
        /**
         * Edge normals defined in the local frame, pointing out of the shape.
         * @property normals
         * @type {Array}
         */
        _this.normals = [];
        /**
         * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
         * @property triangles
         * @type {Array}
         */
        _this.triangles = [];
        // Copy the verts
        var newVertices = vertices !== null && vertices !== void 0 ? vertices : [];
        _this.vertices = [];
        _this.normals = [];
        for (var i = 0; i < newVertices.length; i++) {
            _this.vertices.push(vec2_1.default.clone(newVertices[i]));
            _this.normals.push(vec2_1.default.create());
        }
        // These are called in the shape constructor, but need to call again here because verts weren't set up yet!
        _this.updateBoundingRadius();
        _this.updateArea();
        _this.updateNormals();
        _this.centerOfMass = vec2_1.default.create();
        _this.triangles = [];
        if (_this.vertices.length) {
            _this.updateTriangles();
            _this.updateCenterOfMass();
        }
        /**
         * The bounding radius of the convex
         * @property boundingRadius
         * @type {Number}
         */
        _this.boundingRadius = 0;
        _this.updateBoundingRadius();
        _this.updateArea();
        if (_this.area < 0) {
            throw new Error("Convex vertices must be given in counter-clockwise winding.");
        }
        return _this;
    }
    Convex.prototype.updateNormals = function () {
        var vertices = this.vertices;
        var normals = this.normals;
        for (var i = 0; i < vertices.length; i++) {
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i + 1) % vertices.length];
            var normal = normals[i];
            vec2_1.default.subtract(normal, worldPoint1, worldPoint0);
            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2_1.default.rotate90cw(normal, normal);
            vec2_1.default.normalize(normal, normal);
        }
    };
    /**
     * Project a Convex onto a world-oriented axis
     * @method projectOntoAxis
     * @static
     * @param  {Array} offset
     * @param  {Array} localAxis
     * @param  {Array} result
     */
    Convex.prototype.projectOntoLocalAxis = function (localAxis, result) {
        var max = -Infinity, min = Infinity, v, value, localAxis = tmpVec1;
        // Get projected position of all vertices
        for (var i = 0; i < this.vertices.length; i++) {
            v = this.vertices[i];
            value = dot(v, localAxis);
            if (value > max) {
                max = value;
            }
            if (value < min) {
                min = value;
            }
        }
        if (min > max) {
            var t = min;
            min = max;
            max = t;
        }
        vec2_1.default.set(result, min, max);
    };
    Convex.prototype.ConvexprojectOntoWorldAxis = function (localAxis, shapeOffset, shapeAngle, result) {
        this.projectOntoLocalAxis(localAxis, result);
        // Project the position of the body onto the axis - need to add this to the result
        if (shapeAngle !== 0) {
            vec2_1.default.rotate(worldAxis, localAxis, shapeAngle);
        }
        else {
            worldAxis = localAxis;
        }
        var offset = dot(shapeOffset, worldAxis);
        vec2_1.default.set(result, result[0] + offset, result[1] + offset);
    };
    /**
     * Update the .triangles property
     * @method updateTriangles
     */
    Convex.prototype.updateTriangles = function () {
        this.triangles.length = 0;
        // Rewrite on polyk notation, array of numbers
        var polykVerts = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var v = this.vertices[i];
            polykVerts.push(v[0]);
            polykVerts.push(v[1]);
        }
        // Triangulate
        var triangles = polyk_1.default.Triangulate(polykVerts);
        // Loop over all triangles, add their inertia contributions to I
        for (var i = 0; i < triangles.length; i += 3) {
            var id1 = triangles[i], id2 = triangles[i + 1], id3 = triangles[i + 2];
            // Add to triangles
            var T = new Float32Array(3);
            T[0] = id1;
            T[1] = id2;
            T[2] = id3;
            this.triangles.push(T);
        }
    };
    /**
     * Update the .centerOfMass property.
     * @method updateCenterOfMass
     */
    Convex.prototype.updateCenterOfMass = function () {
        var triangles = this.triangles, verts = this.vertices, cm = this.centerOfMass, centroid = updateCenterOfMass_centroid, a = updateCenterOfMass_a, b = updateCenterOfMass_b, c = updateCenterOfMass_c, centroid_times_mass = updateCenterOfMass_centroid_times_mass;
        vec2_1.default.set(cm, 0, 0);
        var totalArea = 0;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            vec2_1.default.centroid(centroid, a, b, c);
            // Get mass for the triangle (density=1 in this case)
            // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
            var m = Convex.triangleArea(a, b, c);
            totalArea += m;
            // Add to center of mass
            vec2_1.default.scale(centroid_times_mass, centroid, m);
            vec2_1.default.add(cm, cm, centroid_times_mass);
        }
        vec2_1.default.scale(cm, cm, 1 / totalArea);
    };
    /**
     * Compute the moment of inertia of the Convex.
     * @method computeMomentOfInertia
     * @return {Number}
     * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
     */
    Convex.prototype.computeMomentOfInertia = function () {
        var denom = 0.0, numer = 0.0, N = this.vertices.length;
        for (var j = N - 1, i = 0; i < N; j = i, i++) {
            var p0 = this.vertices[j];
            var p1 = this.vertices[i];
            var a = Math.abs(vec2_1.default.crossLength(p0, p1));
            var b = dot(p1, p1) + dot(p1, p0) + dot(p0, p0);
            denom += a * b;
            numer += a;
        }
        return (1.0 / 6.0) * (denom / numer);
    };
    /**
     * Updates the .boundingRadius property
     * @method updateBoundingRadius
     */
    Convex.prototype.updateBoundingRadius = function () {
        var verts = this.vertices, r2 = 0;
        if (!verts || verts.length == 0)
            return 0;
        for (var i = 0; i !== verts.length; i++) {
            var l2 = vec2_1.default.squaredLength(verts[i]);
            if (l2 > r2) {
                r2 = l2;
            }
        }
        this.boundingRadius = Math.sqrt(r2);
        return this.boundingRadius;
    };
    /**
     * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
     * @static
     * @method triangleArea
     * @param {Array} a
     * @param {Array} b
     * @param {Array} c
     * @return {Number}
     * @deprecated
     */
    Convex.triangleArea = function (a, b, c) {
        return (((b[0] - a[0]) * (c[1] - a[1])) - ((c[0] - a[0]) * (b[1] - a[1]))) * 0.5;
    };
    /**
     * Update the .area
     * @method updateArea
     */
    Convex.prototype.updateArea = function () {
        if (!this.vertices)
            return 0;
        this.updateTriangles();
        this.area = 0;
        var triangles = this.triangles, verts = this.vertices;
        for (var i = 0; i !== triangles.length; i++) {
            var t = triangles[i], a = verts[t[0]], b = verts[t[1]], c = verts[t[2]];
            // Get mass for the triangle (density=1 in this case)
            var m = Convex.triangleArea(a, b, c);
            this.area += m;
        }
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     * @todo: approximate with a local AABB?
     */
    Convex.prototype.computeAABB = function (out, position, angle) {
        out.setFromPoints(this.vertices, position, angle, 0);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Convex.prototype.raycast = function (result, ray, position, angle) {
        var rayStart = intersectConvex_rayStart;
        var rayEnd = intersectConvex_rayEnd;
        var normal = intersectConvex_normal;
        var vertices = this.vertices;
        // Transform to local shape space
        vec2_1.default.toLocalFrame(rayStart, ray.from, position, angle);
        vec2_1.default.toLocalFrame(rayEnd, ray.to, position, angle);
        var n = vertices.length;
        for (var i = 0; i < n && !result.shouldStop(ray); i++) {
            var q1 = vertices[i];
            var q2 = vertices[(i + 1) % n];
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);
            if (delta >= 0) {
                vec2_1.default.subtract(normal, q2, q1);
                vec2_1.default.rotate(normal, normal, -Math.PI / 2 + angle);
                vec2_1.default.normalize(normal, normal);
                ray.reportIntersection(result, delta, normal, i);
            }
        }
    };
    Convex.prototype.pointTest = function (localPoint) {
        var r0 = pic_r0, r1 = pic_r1, verts = this.vertices, lastCross = null, numVerts = verts.length;
        for (var i = 0; i < numVerts + 1; i++) {
            var v0 = verts[i % numVerts], v1 = verts[(i + 1) % numVerts];
            vec2_1.default.subtract(r0, v0, localPoint);
            vec2_1.default.subtract(r1, v1, localPoint);
            var cross = vec2_1.default.crossLength(r0, r1);
            if (lastCross === null) {
                lastCross = cross;
            }
            // If we got a different sign of the distance vector, the point is out of the polygon
            if (cross * lastCross < 0) {
                return false;
            }
            lastCross = cross;
        }
        return true;
    };
    return Convex;
}(Shape_1.default));
exports.default = Convex;

},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],38:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var Shape = /** @class */ (function () {
    /**
     * Base class for shapes. Not to be used directly.
     * @class Shape
     * @constructor
     * @param {object} [options]
     * @param {number} [options.angle=0]
     * @param {number} [options.collisionGroup=1]
     * @param {number} [options.collisionMask=1]
     * @param {number} [options.id] Optional - specify an ID for this shape. Possibly useful for replacing shapes. Careful to avoid duplicates!
     * @param {boolean} [options.collisionResponse=true]
     * @param {Material} [options.material=null]
     * @param {array} [options.position]
     * @param {boolean} [options.sensor=false]
     * @param {object} [options.type=0]
     */
    function Shape(type, options) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Body-local position of the shape.
         * @property {Array} position
         */
        this.position = vec2_1.default.create();
        /**
         * Body-local angle of the shape.
         * @property {number} angle
         */
        this.angle = 0;
        /**
         * The type of the shape. One of:
         *
         * <ul>
         * <li><a href="Shape.html#property_CIRCLE">Shape.CIRCLE</a></li>
         * <li><a href="Shape.html#property_PARTICLE">Shape.PARTICLE</a></li>
         * <li><a href="Shape.html#property_PLANE">Shape.PLANE</a></li>
         * <li><a href="Shape.html#property_CONVEX">Shape.CONVEX</a></li>
         * <li><a href="Shape.html#property_LINE">Shape.LINE</a></li>
         * <li><a href="Shape.html#property_BOX">Shape.BOX</a></li>
         * <li><a href="Shape.html#property_CAPSULE">Shape.CAPSULE</a></li>
         * <li><a href="Shape.html#property_HEIGHTFIELD">Shape.HEIGHTFIELD</a></li>
         * </ul>
         *
         * @property {number} type
         */
        this.type = 0;
        /**
         * Shape object identifier. Read only.
         * @readonly
         * @type {Number}
         * @property id
         */
        this.id = 0;
        /**
         * Bounding circle radius of this shape
         * @readonly
         * @property boundingRadius
         * @type {Number}
         */
        this.boundingRadius = 0;
        /**
         * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
         * @property collisionGroup
         * @type {Number}
         * @example
         *     // Setup bits for each available group
         *     var PLAYER = Math.pow(2,0),
         *         ENEMY =  Math.pow(2,1),
         *         GROUND = Math.pow(2,2)
         *
         *     // Put shapes into their groups
         *     player1Shape.collisionGroup = PLAYER;
         *     player2Shape.collisionGroup = PLAYER;
         *     enemyShape  .collisionGroup = ENEMY;
         *     groundShape .collisionGroup = GROUND;
         *
         *     // Assign groups that each shape collide with.
         *     // Note that the players can collide with ground and enemies, but not with other players.
         *     player1Shape.collisionMask = ENEMY | GROUND;
         *     player2Shape.collisionMask = ENEMY | GROUND;
         *     enemyShape  .collisionMask = PLAYER | GROUND;
         *     groundShape .collisionMask = PLAYER | ENEMY;
         *
         * @example
         *     // How collision check is done
         *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
         *         // The shapes will collide
         *     }
         */
        this.collisionGroup = 1;
        /**
         * Area of this shape.
         * @property area
         * @type {Number}
         */
        this.area = 0;
        if (options === null || options === void 0 ? void 0 : options.position) {
            vec2_1.default.copy(this.position, options.position);
        }
        this.angle = (_a = options === null || options === void 0 ? void 0 : options.angle) !== null && _a !== void 0 ? _a : 0;
        this.type = type;
        this.id = (_b = options === null || options === void 0 ? void 0 : options.id) !== null && _b !== void 0 ? _b : ++Shape.idCounter;
        this.collisionGroup = (_c = options === null || options === void 0 ? void 0 : options.collisionGroup) !== null && _c !== void 0 ? _c : 1;
        this.collisionResponse = (_d = options === null || options === void 0 ? void 0 : options.collisionResponse) !== null && _d !== void 0 ? _d : true;
        this.collisionMask = (_e = options === null || options === void 0 ? void 0 : options.collisionMask) !== null && _e !== void 0 ? _e : 1;
        this.material = options === null || options === void 0 ? void 0 : options.material;
        this.sensor = (_f = options === null || options === void 0 ? void 0 : options.sensor) !== null && _f !== void 0 ? _f : false;
        if (this.type) {
            this.updateBoundingRadius();
        }
        this.updateArea();
    }
    /**
     * Test if a point is inside this shape.
     * @method pointTest
     * @param {array} localPoint
     * @return {boolean}
     */
    Shape.prototype.pointTest = function (localPoint) { return false; };
    /**
     * Transform a world point to local shape space (assumed the shape is transformed by both itself and the body).
     * @method worldPointToLocal
     * @param {array} out
     * @param {array} worldPoint
     */
    Shape.prototype.worldPointToLocal = function (out, worldPoint) {
        var shapeWorldPosition = vec2_1.default.create();
        var body = this.body;
        if (!body)
            return;
        vec2_1.default.rotate(shapeWorldPosition, this.position, body.angle);
        vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
        vec2_1.default.toLocalFrame(out, worldPoint, shapeWorldPosition, body.angle + this.angle);
    };
    Shape.idCounter = 0;
    /**
     * @static
     * @property {Number} CIRCLE
     */
    Shape.CIRCLE = 1;
    /**
     * @static
     * @property {Number} PARTICLE
     */
    Shape.PARTICLE = 2;
    /**
     * @static
     * @property {Number} PLANE
     */
    Shape.PLANE = 4;
    /**
     * @static
     * @property {Number} CONVEX
     */
    Shape.CONVEX = 8;
    /**
     * @static
     * @property {Number} LINE
     */
    Shape.LINE = 16;
    /**
     * @static
     * @property {Number} BOX
     */
    Shape.BOX = 32;
    /**
     * @static
     * @property {Number} CAPSULE
     */
    Shape.CAPSULE = 64;
    /**
     * @static
     * @property {Number} HEIGHTFIELD
     */
    Shape.HEIGHTFIELD = 128;
    return Shape;
}());
exports.default = Shape;

},{"../math/vec2":28}],39:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
var shape_1 = __importDefault(_dereq_("./shape"));
var shallowClone = utils_1.default.shallowClone;
function boxI(w, h) {
    return w * h * (Math.pow(w, 2) + Math.pow(h, 2)) / 12;
}
function semiA(r) {
    return Math.PI * Math.pow(r, 2) / 2;
}
// http://www.efunda.com/math/areas/CircleHalf.cfm
function semiI(r) {
    return ((Math.PI / 4) - (8 / (9 * Math.PI))) * Math.pow(r, 4);
}
function semiC(r) {
    return (4 * r) / (3 * Math.PI);
}
// https://en.wikipedia.org/wiki/Second_moment_of_area#Parallel_axis_theorem
function capsuleA(l, r) {
    return l * 2 * r + Math.PI * Math.pow(r, 2);
}
function capsuleI(l, r) {
    var d = l / 2 + semiC(r);
    return boxI(l, 2 * r) + 2 * (semiI(r) + semiA(r) * Math.pow(d, 2));
}
var intersectCapsule_hitPointWorld = vec2_1.default.create();
var intersectCapsule_normal = vec2_1.default.create();
var intersectCapsule_l0 = vec2_1.default.create();
var intersectCapsule_l1 = vec2_1.default.create();
var intersectCapsule_unit_y = vec2_1.default.fromValues(0, 1);
var Capsule = /** @class */ (function (_super) {
    __extends(Capsule, _super);
    /**
     * Capsule shape.
     * @class Capsule
     * @constructor
     * @extends Shape
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The distance between the end points, extends along the X axis.
     * @param {Number} [options.radius=1] Radius of the capsule.
     * @example
     *     var body = new Body({ mass: 1 });
     *     var capsuleShape = new Capsule({
     *         length: 1,
     *         radius: 2
     *     });
     *     body.addShape(capsuleShape);
     */
    function Capsule(options) {
        var _a, _b;
        var _this = _super.call(this, shape_1.default.CAPSULE, options) || this;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        _this.radius = (_b = options === null || options === void 0 ? void 0 : options.radius) !== null && _b !== void 0 ? _b : 1;
        return _this;
    }
    /**
     * Compute the mass moment of inertia of the Capsule.
     * @method conputeMomentOfInertia
     * @return {Number}
     * @todo
     */
    Capsule.prototype.computeMomentOfInertia = function () {
        // http://www.efunda.com/math/areas/rectangle.cfm
        var r = this.radius, l = this.length, area = capsuleA(l, r);
        return (area > 0) ? capsuleI(l, r) / area : 0;
    };
    /**
     * @method updateBoundingRadius
     */
    Capsule.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.radius + this.length / 2;
        return this.boundingRadius;
    };
    /**
     * @method updateArea
     */
    Capsule.prototype.updateArea = function () {
        this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Capsule.prototype.computeAABB = function (out, position, angle) {
        var r = vec2_1.default.create();
        var radius = this.radius;
        // Compute center position of one of the the circles, world oriented, but with local offset
        vec2_1.default.set(r, this.length / 2, 0);
        if (angle !== 0) {
            vec2_1.default.rotate(r, r, angle);
        }
        // Get bounds
        vec2_1.default.set(out.upperBound, Math.max(r[0] + radius, -r[0] + radius), Math.max(r[1] + radius, -r[1] + radius));
        vec2_1.default.set(out.lowerBound, Math.min(r[0] - radius, -r[0] - radius), Math.min(r[1] - radius, -r[1] - radius));
        // Add offset
        vec2_1.default.add(out.lowerBound, out.lowerBound, position);
        vec2_1.default.add(out.upperBound, out.upperBound, position);
    };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Capsule.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var hitPointWorld = intersectCapsule_hitPointWorld;
        var normal = intersectCapsule_normal;
        var l0 = intersectCapsule_l0;
        var l1 = intersectCapsule_l1;
        // The sides
        var halfLen = this.length / 2;
        for (var i = 0; i < 2; i++) {
            // get start and end of the line
            var y = this.radius * (i * 2 - 1);
            vec2_1.default.set(l0, -halfLen, y);
            vec2_1.default.set(l1, halfLen, y);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            vec2_1.default.toGlobalFrame(l1, l1, position, angle);
            var delta = vec2_1.default.getLineSegmentsIntersectionFraction(from, to, l0, l1);
            if (delta >= 0) {
                vec2_1.default.rotate(normal, intersectCapsule_unit_y, angle);
                vec2_1.default.scale(normal, normal, (i * 2 - 1));
                ray.reportIntersection(result, delta, normal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
        // Circles
        var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);
        for (var i = 0; i < 2; i++) {
            vec2_1.default.set(l0, halfLen * (i * 2 - 1), 0);
            vec2_1.default.toGlobalFrame(l0, l0, position, angle);
            var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
            var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));
            var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);
            var delta = Math.pow(b, 2) - 4 * a * c;
            if (delta < 0) {
                // No intersection
                continue;
            }
            else if (delta === 0) {
                // single intersection point
                vec2_1.default.lerp(hitPointWorld, from, to, delta);
                if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                    vec2_1.default.subtract(normal, hitPointWorld, l0);
                    vec2_1.default.normalize(normal, normal);
                    ray.reportIntersection(result, delta, normal, -1);
                    if (result.shouldStop(ray)) {
                        return;
                    }
                }
            }
            else {
                var sqrtDelta = Math.sqrt(delta);
                var inv2a = 1 / (2 * a);
                var d1 = (-b - sqrtDelta) * inv2a;
                var d2 = (-b + sqrtDelta) * inv2a;
                if (d1 >= 0 && d1 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d1);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d1, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
                if (d2 >= 0 && d2 <= 1) {
                    vec2_1.default.lerp(hitPointWorld, from, to, d2);
                    if (vec2_1.default.squaredDistance(hitPointWorld, position) > diagonalLengthSquared) {
                        vec2_1.default.subtract(normal, hitPointWorld, l0);
                        vec2_1.default.normalize(normal, normal);
                        ray.reportIntersection(result, d2, normal, -1);
                        if (result.shouldStop(ray)) {
                            return;
                        }
                    }
                }
            }
        }
    };
    Capsule.prototype.pointTest = function (localPoint) {
        var radius = this.radius;
        var halfLength = this.length * 0.5;
        if ((Math.abs(localPoint[0]) <= halfLength && Math.abs(localPoint[1]) <= radius)) {
            return true;
        }
        if (Math.pow(localPoint[0] - halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        if (Math.pow(localPoint[0] + halfLength, 2) + Math.pow(localPoint[1], 2) <= radius * radius) {
            return true;
        }
        return false;
    };
    return Capsule;
}(shape_1.default));
exports.default = Capsule;

},{"../math/vec2":28,"../utils/utils":56,"./shape":46}],40:[function(_dereq_,module,exports){
module.exports=_dereq_(36)
},{"../math/vec2":28,"./Shape":38}],41:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{"../math/polyk":27,"../math/vec2":28,"./Shape":38}],42:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,    vec2 = require('../math/vec2')
// ,    shallowClone = require('../utils/Utils').shallowClone;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectHeightfield_worldNormal = vec2_1.default.create();
var intersectHeightfield_l0 = vec2_1.default.create();
var intersectHeightfield_l1 = vec2_1.default.create();
var intersectHeightfield_localFrom = vec2_1.default.create();
var intersectHeightfield_localTo = vec2_1.default.create();
var Heightfield = /** @class */ (function (_super) {
    __extends(Heightfield, _super);
    /**
     * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
     * @class Heightfield
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.
     * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
     * @param {Number} [options.maxValue] Maximum value.
     * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
     *
     * @example
     *     // Generate some height data (y-values).
     *     var heights = [];
     *     for(var i = 0; i < 1000; i++){
     *         var y = 0.5 * Math.cos(0.2 * i);
     *         heights.push(y);
     *     }
     *
     *     // Create the heightfield shape
     *     var shape = new Heightfield({
     *         heights: heights,
     *         elementWidth: 1 // Distance between the data points in X direction
     *     });
     *     var body = new Body();
     *     body.addShape(shape);
     *     world.addBody(body);
     *
     * @todo Should use a scale property with X and Y direction instead of just elementWidth
     */
    function Heightfield(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.HEIGHTFIELD, options) || this;
        /**
         * An array of numbers, or height values, that are spread out along the x axis.
         * @property {array} heights
         */
        _this.heights = [];
        /**
         * Max value of the heights
         * @property {number} maxValue
         */
        _this.maxValue = 0;
        /**
         * Max value of the heights
         * @property {number} minValue
         */
        _this.minValue = 0;
        /**
         * The width of each element
         * @property {number} elementWidth
         */
        _this.elementWidth = 0;
        _this.heights = (options === null || options === void 0 ? void 0 : options.heights) ? options.heights.slice(0) : [];
        _this.elementWidth = (_a = options === null || options === void 0 ? void 0 : options.elementWidth) !== null && _a !== void 0 ? _a : 0.1;
        _this.updateArea();
        if ((options === null || options === void 0 ? void 0 : options.maxValue) && (options === null || options === void 0 ? void 0 : options.minValue)) {
            _this.maxValue = options === null || options === void 0 ? void 0 : options.maxValue;
            _this.minValue = options === null || options === void 0 ? void 0 : options.minValue;
        }
        else
            _this.updateMaxMinValues();
        return _this;
    }
    /**
     * Update the .minValue and the .maxValue
     * @method updateMaxMinValues
     */
    Heightfield.prototype.updateMaxMinValues = function () {
        var data = this.heights;
        var maxValue = data[0];
        var minValue = data[0];
        for (var i = 0; i !== data.length; i++) {
            var v = data[i];
            if (v > maxValue) {
                maxValue = v;
            }
            if (v < minValue) {
                minValue = v;
            }
        }
        this.maxValue = maxValue;
        this.minValue = minValue;
    };
    /**
     * @method computeMomentOfInertia
     * @return {Number}
     */
    Heightfield.prototype.computeMomentOfInertia = function () {
        return Infinity;
    };
    Heightfield.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return this.boundingRadius;
    };
    Heightfield.prototype.updateArea = function () {
        var data = this.heights, area = 0;
        if (!data)
            return 0;
        for (var i = 0; i < data.length - 1; i++) {
            area += (data[i] + data[i + 1]) / 2 * this.elementWidth;
        }
        this.area = area;
        return this.area;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Heightfield.prototype.computeAABB = function (out, position, angle) {
        var points = [
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create(),
            vec2_1.default.create()
        ];
        vec2_1.default.set(points[0], 0, this.maxValue);
        vec2_1.default.set(points[1], this.elementWidth * this.heights.length, this.maxValue);
        vec2_1.default.set(points[2], this.elementWidth * this.heights.length, this.minValue);
        vec2_1.default.set(points[3], 0, this.minValue);
        out.setFromPoints(points, position, angle);
    };
    /**
     * Get a line segment in the heightfield
     * @method getLineSegment
     * @param  {array} start Where to store the resulting start point
     * @param  {array} end Where to store the resulting end point
     * @param  {number} i
     */
    Heightfield.prototype.getLineSegment = function (start, end, i) {
        var data = this.heights;
        var width = this.elementWidth;
        vec2_1.default.set(start, i * width, data[i]);
        vec2_1.default.set(end, (i + 1) * width, data[i + 1]);
    };
    Heightfield.prototype.getSegmentIndex = function (position) {
        return Math.floor(position[0] / this.elementWidth);
    };
    Heightfield.prototype.getClampedSegmentIndex = function (position) {
        var i = this.getSegmentIndex(position);
        i = Math.min(this.heights.length, Math.max(i, 0)); // clamp
        return i;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Heightfield.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var worldNormal = intersectHeightfield_worldNormal;
        var l0 = intersectHeightfield_l0;
        var l1 = intersectHeightfield_l1;
        var localFrom = intersectHeightfield_localFrom;
        var localTo = intersectHeightfield_localTo;
        // get local ray start and end
        vec2_1.default.toLocalFrame(localFrom, from, position, angle);
        vec2_1.default.toLocalFrame(localTo, to, position, angle);
        // Get the segment range
        var i0 = this.getClampedSegmentIndex(localFrom);
        var i1 = this.getClampedSegmentIndex(localTo);
        if (i0 > i1) {
            var tmp = i0;
            i0 = i1;
            i1 = tmp;
        }
        // The segments
        for (var i = 0; i < this.heights.length - 1; i++) {
            this.getLineSegment(l0, l1, i);
            var t = vec2_1.default.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);
            if (t >= 0) {
                vec2_1.default.subtract(worldNormal, l1, l0);
                vec2_1.default.rotate(worldNormal, worldNormal, angle + Math.PI / 2);
                vec2_1.default.normalize(worldNormal, worldNormal);
                ray.reportIntersection(result, t, worldNormal, -1);
                if (result.shouldStop(ray)) {
                    return;
                }
            }
        }
    };
    return Heightfield;
}(Shape_1.default));
exports.default = Heightfield;

},{"../math/vec2":28,"./Shape":38}],43:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   vec2 = require('../math/vec2');
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var raycast_normal = vec2_1.default.create();
var raycast_l0 = vec2_1.default.create();
var raycast_l1 = vec2_1.default.create();
var raycast_unit_y = vec2_1.default.fromValues(0, 1);
var Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    /**
     * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
     * @class Line
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @param {Number} [options.length=1] The total length of the line
     * @extends Shape
     * @constructor
     * @example
     *     var body = new Body();
     *     var lineShape = new Line({
     *         length: 1
     *     });
     *     body.addShape(lineShape);
     */
    function Line(options) {
        var _a;
        var _this = _super.call(this, Shape_1.default.LINE, options) || this;
        /**
         * Length of this line
         * @property {Number} length
         * @default 1
         */
        _this.length = 1;
        _this.length = (_a = options === null || options === void 0 ? void 0 : options.length) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    Line.prototype.computeMomentOfInertia = function () {
        return Math.pow(this.length, 2) / 12;
    };
    ;
    Line.prototype.updateBoundingRadius = function () {
        this.boundingRadius = this.length / 2;
        return this.boundingRadius;
    };
    ;
    /**
     * @method computeAABB
     * @param  {AABB}   out      The resulting AABB.
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Line.prototype.computeAABB = function (out, position, angle) {
        var points = [vec2_1.default.create(), vec2_1.default.create()];
        var l2 = this.length / 2;
        vec2_1.default.set(points[0], -l2, 0);
        vec2_1.default.set(points[1], l2, 0);
        out.setFromPoints(points, position, angle, 0);
    };
    ;
    Line.prototype.updateArea = function () { return 0; };
    /**
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @param  {number} angle
     * @param  {array} position
     */
    Line.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var l0 = raycast_l0;
        var l1 = raycast_l1;
        // get start and end of the line
        var halfLen = this.length / 2;
        vec2_1.default.set(l0, -halfLen, 0);
        vec2_1.default.set(l1, halfLen, 0);
        vec2_1.default.toGlobalFrame(l0, l0, position, angle);
        vec2_1.default.toGlobalFrame(l1, l1, position, angle);
        var fraction = vec2_1.default.getLineSegmentsIntersectionFraction(l0, l1, from, to);
        if (fraction >= 0) {
            var normal = raycast_normal;
            vec2_1.default.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from
            ray.reportIntersection(result, fraction, normal, -1);
        }
    };
    ;
    return Line;
}(Shape_1.default));
exports.default = Line;

},{"../math/vec2":28,"./Shape":38}],44:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// var Shape = require('./Shape')
// ,   shallowClone = require('../utils/Utils').shallowClone
// ,   copy = require('../math/vec2').copy;
var Shape_1 = __importDefault(_dereq_("./Shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var copy = vec2_1.default.copy;
var Particle = /** @class */ (function (_super) {
    __extends(Particle, _super);
    /**
     * Particle shape class.
     * @class Particle
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @extends Shape
     * @example
     *     var body = new Body();
     *     var shape = new Particle();
     *     body.addShape(shape);
     */
    function Particle(options) {
        return _super.call(this, Shape_1.default.PARTICLE, options) || this;
    }
    Particle.prototype.computeMomentOfInertia = function () {
        return 0; // Can't rotate a particle
    };
    ;
    Particle.prototype.updateBoundingRadius = function () {
        this.boundingRadius = 0;
        return 0;
    };
    ;
    Particle.prototype.updateArea = function () { return 0; };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Particle.prototype.computeAABB = function (out, position /*, angle*/) {
        copy(out.lowerBound, position);
        copy(out.upperBound, position);
    };
    ;
    Particle.prototype.raycast = function (result, ray, position, angle) { 1; };
    return Particle;
}(Shape_1.default));
exports.default = Particle;

},{"../math/vec2":28,"./Shape":38}],45:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var shape_1 = __importDefault(_dereq_("./shape"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var intersectPlane_planePointToFrom = vec2_1.default.create();
var intersectPlane_normal = vec2_1.default.create();
var intersectPlane_len = vec2_1.default.create();
var Plane = /** @class */ (function (_super) {
    __extends(Plane, _super);
    /**
     * Plane shape class. The plane is facing in the Y direction.
     * @class Plane
     * @extends Shape
     * @constructor
     * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink "Shape"}}{{/crossLink}} constructor.)
     * @example
     *     var body = new Body();
     *     var shape = new Plane();
     *     body.addShape(shape);
     */
    function Plane(options) {
        return _super.call(this, shape_1.default.PLANE, options) || this;
    }
    /**
     * Compute moment of inertia
     * @method computeMomentOfInertia
     */
    Plane.prototype.computeMomentOfInertia = function () {
        return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
    };
    /**
     * Update the bounding radius
     * @method updateBoundingRadius
     */
    Plane.prototype.updateBoundingRadius = function () {
        this.boundingRadius = Infinity;
        return Infinity;
    };
    /**
     * @method computeAABB
     * @param  {AABB}   out
     * @param  {Array}  position
     * @param  {Number} angle
     */
    Plane.prototype.computeAABB = function (out, position, angle) {
        var a = angle % (2 * Math.PI);
        var set = vec2_1.default.set;
        var max = 1e7;
        var lowerBound = out.lowerBound;
        var upperBound = out.upperBound;
        // Set max bounds
        set(lowerBound, -max, -max);
        set(upperBound, max, max);
        if (a === 0) {
            // y goes from -inf to 0
            upperBound[1] = position[1];
        }
        else if (a === Math.PI / 2) {
            // x goes from 0 to inf
            lowerBound[0] = position[0];
        }
        else if (a === Math.PI) {
            // y goes from 0 to inf
            lowerBound[1] = position[1];
        }
        else if (a === 3 * Math.PI / 2) {
            // x goes from -inf to 0
            upperBound[0] = position[0];
        }
    };
    Plane.prototype.updateArea = function () {
        this.area = Infinity;
        return Infinity;
    };
    /**
     * @method raycast
     * @param  {RayResult} result
     * @param  {Ray} ray
     * @param  {array} position
     * @param  {number} angle
     */
    Plane.prototype.raycast = function (result, ray, position, angle) {
        var from = ray.from;
        var to = ray.to;
        var direction = ray.direction;
        var planePointToFrom = intersectPlane_planePointToFrom;
        var normal = intersectPlane_normal;
        var len = intersectPlane_len;
        // Get plane normal
        vec2_1.default.set(normal, 0, 1);
        vec2_1.default.rotate(normal, normal, angle);
        vec2_1.default.subtract(len, from, position);
        var planeToFrom = vec2_1.default.dot(len, normal);
        vec2_1.default.subtract(len, to, position);
        var planeToTo = vec2_1.default.dot(len, normal);
        if (planeToFrom * planeToTo > 0) {
            // "from" and "to" are on the same side of the plane... bail out
            return;
        }
        if (vec2_1.default.squaredDistance(from, to) < planeToFrom * planeToFrom) {
            return;
        }
        var n_dot_dir = vec2_1.default.dot(normal, direction);
        vec2_1.default.subtract(planePointToFrom, from, position);
        var t = -vec2_1.default.dot(normal, planePointToFrom) / n_dot_dir / ray.length;
        ray.reportIntersection(result, t, normal, -1);
    };
    ;
    Plane.prototype.pointTest = function (localPoint) {
        return localPoint[1] <= 0;
    };
    return Plane;
}(shape_1.default));
exports.default = Plane;

},{"../math/vec2":28,"./shape":46}],46:[function(_dereq_,module,exports){
module.exports=_dereq_(38)
},{"../math/vec2":28}],47:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var solver_1 = __importDefault(_dereq_("./solver"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
// Sets the .multiplier property of each equation
function updateMultipliers(equations, invDt) {
    var l = equations.length;
    while (l--) {
        var eq = equations[l];
        eq.multiplier = eq.lambda * invDt;
    }
}
function iterateEquation(eq) {
    // Compute iteration
    var B = eq.B, eps = eq.epsilon, invC = eq.invC, lambdaj = eq.lambda, GWlambda = eq.computeGWlambda(), maxForce_dt = eq.maxForceDt, minForce_dt = eq.minForceDt;
    var deltalambda = invC * (B - GWlambda - eps * lambdaj);
    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if (lambdaj_plus_deltalambda < minForce_dt) {
        deltalambda = minForce_dt - lambdaj;
    }
    else if (lambdaj_plus_deltalambda > maxForce_dt) {
        deltalambda = maxForce_dt - lambdaj;
    }
    eq.lambda += deltalambda;
    eq.addToWlambda(deltalambda);
    return deltalambda;
}
var GSSolver = /** @class */ (function (_super) {
    __extends(GSSolver, _super);
    /**
     * Iterative Gauss-Seidel constraint equation solver.
     *
     * @class GSSolver
     * @constructor
     * @extends Solver
     * @param {Object} [options]
     * @param {Number} [options.iterations=10]
     * @param {Number} [options.tolerance=0]
     */
    function GSSolver(options) {
        var _a, _b, _c;
        var _this = _super.call(this, options, solver_1.default.GS) || this;
        /**
         * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
         * @property {Number} usedIterations
         */
        _this.usedIterations = 0;
        _this.iterations = (_a = options === null || options === void 0 ? void 0 : options.iterations) !== null && _a !== void 0 ? _a : 10;
        _this.tolerance = (_b = options === null || options === void 0 ? void 0 : options.tolerance) !== null && _b !== void 0 ? _b : 1e-7;
        _this.frictionIterations = (_c = options === null || options === void 0 ? void 0 : options.frictionIterations) !== null && _c !== void 0 ? _c : 0;
        return _this;
    }
    /**
     * Solve the system of equations
     * @method solve
     * @param  {Number}  h       Time step
     * @param  {World}   world    World to solve
     */
    GSSolver.prototype.solve = function (h, world) {
        this.sortEquations();
        var iter = 0, maxIter = this.iterations, maxFrictionIter = this.frictionIterations, equations = this.equations, Neq = equations.length, tolSquared = Math.pow(this.tolerance * Neq, 2), bodies = world.bodies, Nbodies = bodies.length;
        this.usedIterations = 0;
        if (Neq) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Update solve mass
                b.updateSolveMassProperties();
            }
        }
        for (var i_1 = 0; i_1 !== Neq; i_1++) {
            var c_1 = equations[i_1];
            c_1.lambda = 0;
            if (c_1.timeStep !== h || c_1.needsUpdate) {
                c_1.timeStep = h;
                c_1.update();
            }
            c_1.B = c_1.computeB(c_1.a, c_1.b, h);
            c_1.invC = c_1.computeInvC(c_1.epsilon);
            c_1.maxForceDt = c_1.maxForce * h;
            c_1.minForceDt = c_1.minForce * h;
        }
        var c, deltalambdaTot, j;
        if (Neq !== 0) {
            for (i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                // Reset vlambda
                b.resetConstraintVelocity();
            }
            if (maxFrictionIter) {
                // Iterate over contact equations to get normal forces
                for (iter = 0; iter !== maxFrictionIter; iter++) {
                    // Accumulate the total error for each iteration.
                    deltalambdaTot = 0.0;
                    for (j = 0; j !== Neq; j++) {
                        c = equations[j];
                        var deltalambda = iterateEquation(c);
                        deltalambdaTot += Math.abs(deltalambda);
                    }
                    this.usedIterations++;
                    // If the total error is small enough - stop iterate
                    if (deltalambdaTot * deltalambdaTot <= tolSquared) {
                        break;
                    }
                }
                updateMultipliers(equations, 1 / h);
                // Set computed friction force
                for (j = 0; j !== Neq; j++) {
                    var eq = equations[j];
                    if (eq instanceof friction_equation_1.default) {
                        var f = 0.0;
                        for (var k = 0; k !== eq.contactEquations.length; k++) {
                            f += eq.contactEquations[k].multiplier;
                        }
                        f *= eq.frictionCoefficient / eq.contactEquations.length;
                        eq.maxForce = f;
                        eq.minForce = -f;
                        eq.maxForceDt = f * h;
                        eq.minForceDt = -f * h;
                    }
                }
            }
            // Iterate over all equations
            for (iter = 0; iter !== maxIter; iter++) {
                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;
                for (j = 0; j !== Neq; j++) {
                    c = equations[j];
                    var deltalambda = iterateEquation(c);
                    deltalambdaTot += Math.abs(deltalambda);
                }
                this.usedIterations++;
                // If the total error is small enough - stop iterate
                if (deltalambdaTot * deltalambdaTot < tolSquared) {
                    break;
                }
            }
            // Add result to velocity
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].addConstraintVelocity();
            }
            updateMultipliers(equations, 1 / h);
        }
    };
    ;
    return GSSolver;
}(solver_1.default));
exports.default = GSSolver;

},{"../equations/friction-equation":18,"./solver":48}],48:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var Solver = /** @class */ (function (_super) {
    __extends(Solver, _super);
    /**
     * Base class for constraint solvers.
     * @class Solver
     * @constructor
     * @extends EventEmitter
     */
    function Solver(options, type) {
        var _a;
        var _this = _super.call(this) || this;
        _this.type = type;
        /**
         * Current equations in the solver.
         *
         * @property equations
         * @type {Array}
         */
        _this.equations = [];
        /**
         * Function that is used to sort all equations before each solve.
         * @property equationSortFunction
         * @type {function|boolean}
         */
        _this.equationSortFunction = (_a = options === null || options === void 0 ? void 0 : options.equationSortFunction) !== null && _a !== void 0 ? _a : undefined;
        return _this;
    }
    /**
     * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
     * @method sortEquations
     */
    Solver.prototype.sortEquations = function () {
        if (this.equationSortFunction) {
            this.equations.sort(this.equationSortFunction);
        }
    };
    ;
    /**
     * Add an equation to be solved.
     *
     * @method addEquation
     * @param {Equation} eq
     */
    Solver.prototype.addEquation = function (eq) {
        if (eq.enabled) {
            this.equations.push(eq);
        }
    };
    ;
    /**
     * Add equations. Same as .addEquation, but this time the argument is an array of Equations
     *
     * @method addEquations
     * @param {Array} eqs
     */
    Solver.prototype.addEquations = function (eqs) {
        for (var i = 0, N = eqs.length; i !== N; i++) {
            var eq = eqs[i];
            if (eq.enabled) {
                this.equations.push(eq);
            }
        }
    };
    ;
    /**
     * Remove an equation.
     *
     * @method removeEquation
     * @param {Equation} eq
     */
    Solver.prototype.removeEquation = function (eq) {
        var i = this.equations.indexOf(eq);
        if (i !== -1) {
            this.equations.splice(i, 1);
        }
    };
    ;
    /**
     * Remove all currently added equations.
     *
     * @method removeAllEquations
     */
    Solver.prototype.removeAllEquations = function () {
        this.equations.length = 0;
    };
    ;
    /**
     * Gauss-Seidel solver.
     * @property GS
     * @type {Number}
     * @static
     */
    Solver.GS = 1;
    return Solver;
}(event_emitter_1.default));
exports.default = Solver;

},{"../events/event-emitter":21}],49:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var contact_equation_1 = __importDefault(_dereq_("../equations/contact-equation"));
var ContactEquationPool = /** @class */ (function (_super) {
    __extends(ContactEquationPool, _super);
    /**
     * @class
     */
    function ContactEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {ContactEquation}
     */
    ContactEquationPool.prototype.create = function () {
        return new contact_equation_1.default();
    };
    /**
     * @method destroy
     * @param {ContactEquation} equation
     * @return {ContactEquationPool}
     */
    ContactEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    return ContactEquationPool;
}(pool_1.default));
exports.default = ContactEquationPool;

},{"../equations/contact-equation":16,"./pool":54}],50:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var friction_equation_1 = __importDefault(_dereq_("../equations/friction-equation"));
var FrictionEquationPool = /** @class */ (function (_super) {
    __extends(FrictionEquationPool, _super);
    /**
     * @class
     */
    function FrictionEquationPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {FrictionEquation}
     */
    FrictionEquationPool.prototype.create = function () {
        return new friction_equation_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {FrictionEquation} equation
     * @return {FrictionEquationPool}
     */
    FrictionEquationPool.prototype.destroy = function (equation) {
        equation.bodyA = equation.bodyB = null;
        return this;
    };
    ;
    return FrictionEquationPool;
}(pool_1.default));
exports.default = FrictionEquationPool;

},{"../equations/friction-equation":18,"./pool":54}],51:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var pool_1 = __importDefault(_dereq_("./pool"));
var overlap_keeper_record_1 = __importDefault(_dereq_("./overlap-keeper-record"));
var OverlapKeeperRecordPool = /** @class */ (function (_super) {
    __extends(OverlapKeeperRecordPool, _super);
    /**
     * @class
     */
    function OverlapKeeperRecordPool(options) {
        return _super.call(this, options) || this;
    }
    /**
     * @method create
     * @return {OverlapKeeperRecord}
     */
    OverlapKeeperRecordPool.prototype.create = function () {
        return new overlap_keeper_record_1.default();
    };
    ;
    /**
     * @method destroy
     * @param {OverlapKeeperRecord} record
     * @return {OverlapKeeperRecordPool}
     */
    OverlapKeeperRecordPool.prototype.destroy = function (record) {
        record.set(undefined, undefined, undefined, undefined);
        return this;
    };
    ;
    return OverlapKeeperRecordPool;
}(pool_1.default));
exports.default = OverlapKeeperRecordPool;

},{"./overlap-keeper-record":52,"./pool":54}],52:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OverlapKeeperRecord = /** @class */ (function () {
    /**
     * Overlap data container for the OverlapKeeper
     * @class OverlapKeeperRecord
     * @constructor
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB) {
        this.set(bodyA, shapeA, bodyB, shapeB);
    }
    /**
     * Set the data for the record
     * @method set
     * @param {Body} bodyA
     * @param {Shape} shapeA
     * @param {Body} bodyB
     * @param {Shape} shapeB
     */
    OverlapKeeperRecord.prototype.set = function (bodyA, shapeA, bodyB, shapeB) {
        this.shapeA = shapeA;
        this.shapeB = shapeB;
        this.bodyA = bodyA;
        this.bodyB = bodyB;
    };
    ;
    return OverlapKeeperRecord;
}());
exports.default = OverlapKeeperRecord;

},{}],53:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tuple_dictionary_1 = __importDefault(_dereq_("./tuple-dictionary"));
var overlap_keeper_record_pool_1 = __importDefault(_dereq_("./overlap-keeper-record-pool"));
var OverlapKeeper = /** @class */ (function () {
    /**
     * Keeps track of overlaps in the current state and the last step state.
     * @class OverlapKeeper
     * @constructor
     */
    function OverlapKeeper() {
        this.overlappingShapesLastState = new tuple_dictionary_1.default();
        this.overlappingShapesCurrentState = new tuple_dictionary_1.default();
        this.recordPool = new overlap_keeper_record_pool_1.default({ size: 16 });
        this.tmpDict = new tuple_dictionary_1.default();
        this.tmpArray1 = [];
    }
    /**
     * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
     * @method tick
     */
    OverlapKeeper.prototype.tick = function () {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Save old objects into pool
        var l = last.keys.length;
        while (l--) {
            var key = last.keys[l];
            var lastObject = last.getByKey(key);
            if (lastObject) {
                // The record is only used in the "last" dict, and will be removed. We might as well pool it.
                this.recordPool.release(lastObject);
            }
        }
        // Clear last object
        last.reset();
        // Transfer from new object to old
        last.copy(current);
        // Clear current object
        current.reset();
    };
    /**
     * @method setOverlapping
     * @param {Body} bodyA
     * @param {Body} shapeA
     * @param {Body} bodyB
     * @param {Body} shapeB
     */
    OverlapKeeper.prototype.setOverlapping = function (bodyA, shapeA, bodyB, shapeB) {
        var current = this.overlappingShapesCurrentState;
        // Store current contact state
        if (!current.get(shapeA.id, shapeB.id)) {
            var data = this.recordPool.get();
            data.set(bodyA, shapeA, bodyB, shapeB);
            current.set(shapeA.id, shapeB.id, data);
        }
    };
    OverlapKeeper.prototype.getNewOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
    };
    OverlapKeeper.prototype.getEndOverlaps = function (result) {
        return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
    };
    /**
     * Checks if two bodies are currently overlapping.
     * @method bodiesAreOverlapping
     * @param  {Body} bodyA
     * @param  {Body} bodyB
     * @return {boolean}
     */
    OverlapKeeper.prototype.bodiesAreOverlapping = function (bodyA, bodyB) {
        var current = this.overlappingShapesCurrentState;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if ((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA) {
                return true;
            }
        }
        return false;
    };
    OverlapKeeper.prototype.getDiff = function (dictA, dictB, result) {
        var result = result || [];
        var last = dictA;
        var current = dictB;
        result.length = 0;
        var l = current.keys.length;
        while (l--) {
            var key = current.keys[l];
            var data = current.data[key];
            if (!data) {
                throw new Error('Key ' + key + ' had no data!');
            }
            var lastData = last.data[key];
            if (!lastData) {
                // Not overlapping in last state, but in current.
                result.push(data);
            }
        }
        return result;
    };
    OverlapKeeper.prototype.isNewOverlap = function (shapeA, shapeB) {
        var last = this.overlappingShapesLastState;
        var current = this.overlappingShapesCurrentState;
        // Not in last but in new
        return !last.get(shapeA.id, shapeB.id) && !!current.get(shapeA.id, shapeB.id);
    };
    OverlapKeeper.prototype.getNewBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getNewOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getEndBodyOverlaps = function (result) {
        this.tmpArray1.length = 0;
        var overlaps = this.getEndOverlaps(this.tmpArray1);
        return this.getBodyDiff(overlaps, result);
    };
    OverlapKeeper.prototype.getBodyDiff = function (overlaps, result) {
        result = result || [];
        var accumulator = this.tmpDict;
        var l = overlaps.length;
        while (l--) {
            var data = overlaps[l];
            // Since we use body id's for the accumulator, these will be a subset of the original one
            accumulator.set(data.bodyA.id | 0, data.bodyB.id | 0, data);
        }
        l = accumulator.keys.length;
        while (l--) {
            var data = accumulator.getByKey(accumulator.keys[l]);
            if (data) {
                result.push(data.bodyA);
                result.push(data.bodyB);
            }
        }
        accumulator.reset();
        return result;
    };
    return OverlapKeeper;
}());
exports.default = OverlapKeeper;

},{"./overlap-keeper-record-pool":51,"./tuple-dictionary":55}],54:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool = /** @class */ (function () {
    /**
     * Object pooling utility.
     * @class Pool
     * @constructor
     */
    function Pool(options) {
        /**
         * @property {Array} objects
         * @type {Array}
         */
        this.objects = [];
        if (options === null || options === void 0 ? void 0 : options.size) {
            this.resize(options === null || options === void 0 ? void 0 : options.size);
        }
    }
    /**
     * @method resize
     * @param {number} size
     * @return {Pool} Self, for chaining
     */
    Pool.prototype.resize = function (size) {
        var objects = this.objects;
        while (objects.length > size) {
            objects.pop();
        }
        while (objects.length < size) {
            objects.push(this.create());
        }
        return this;
    };
    /**
     * Get an object from the pool or create a new instance.
     * @method get
     * @return {Object}
     */
    Pool.prototype.get = function () {
        var objects = this.objects;
        return objects.length ? objects.pop() : this.create();
    };
    /**
     * Clean up and put the object back into the pool for later use.
     * @method release
     * @param {Object} object
     * @return {Pool} Self for chaining
     */
    Pool.prototype.release = function (object) {
        this.destroy(object);
        this.objects.push(object);
        return this;
    };
    return Pool;
}());
exports.default = Pool;

},{}],55:[function(_dereq_,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __importDefault(_dereq_("./utils"));
var TupleDictionary = /** @class */ (function () {
    /**
     * @class TupleDictionary
     * @constructor
     */
    function TupleDictionary() {
        /**
         * The data storage
         * @property data
         * @type {Object}
         */
        this.data = {};
        /**
         * Keys that are currently used.
         * @property {Array} keys
         */
        this.keys = [];
    }
    /**
     * Generate a key given two integers
     * @method getKey
     * @param  {number} i
     * @param  {number} j
     * @return {number}
     */
    TupleDictionary.prototype.getKey = function (id1, id2) {
        if ((id1) === (id2)) {
            return -1;
        }
        // valid for values < 2^16
        return ((id1) > (id2) ?
            (id1 << 16) | (id2 & 0xFFFF) :
            (id2 << 16) | (id1 & 0xFFFF)) | 0;
    };
    /**
     * @method getByKey
     * @param  {Number} key
     * @return {Object}
     */
    TupleDictionary.prototype.getByKey = function (key) {
        key = key;
        return this.data[key];
    };
    /**
     * @method get
     * @param  {Number} i
     * @param  {Number} j
     * @return {Number}
     */
    TupleDictionary.prototype.get = function (i, j) {
        return this.data[this.getKey(i, j)];
    };
    /**
     * Set a value.
     * @method set
     * @param  {Number} i
     * @param  {Number} j
     * @param {Number} value
     */
    TupleDictionary.prototype.set = function (i, j, value) {
        if (!value) {
            throw new Error("No data!");
        }
        var key = this.getKey(i, j);
        // Check if key already exists
        if (!this.data[key]) {
            this.keys.push(key);
        }
        this.data[key] = value;
        return key;
    };
    /**
     * Remove all data.
     * @method reset
     */
    TupleDictionary.prototype.reset = function () {
        var data = this.data, keys = this.keys;
        var l = keys.length;
        while (l--) {
            delete data[keys[l]];
        }
        keys.length = 0;
    };
    /**
     * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
     * @method copy
     * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
     */
    TupleDictionary.prototype.copy = function (dict) {
        this.reset();
        utils_1.default.appendArray(this.keys, dict.keys);
        var l = dict.keys.length;
        while (l--) {
            var key = dict.keys[l];
            this.data[key] = dict.data[key];
        }
    };
    return TupleDictionary;
}());
exports.default = TupleDictionary;

},{"./utils":56}],56:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* global P2_ARRAY_TYPE */
/**
 * Misc utility functions
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
     * @method appendArray
     * @static
     * @param  {Array} a
     * @param  {Array} b
     */
    Utils.prototype.appendArray = function (a, b) {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    };
    /**
     * Garbage free Array.splice(). Does not allocate a new array.
     * @method splice
     * @static
     * @param  {Array} array
     * @param  {Number} index
     * @param  {Number} howmany
     */
    Utils.prototype.splice = function (array, index, howmany) {
        howmany = howmany || 1;
        for (var i = index, len = array.length - howmany; i < len; i++) {
            array[i] = array[i + howmany];
        }
        array.length = len;
    };
    /**
     * Remove an element from an array, if the array contains the element.
     * @method arrayRemove
     * @static
     * @param  {Array} array
     * @param  {Number} element
     */
    Utils.prototype.arrayRemove = function (array, element) {
        var idx = array.indexOf(element);
        if (idx !== -1) {
            this.splice(array, idx, 1);
        }
    };
    /**
     * Extend an object with the properties of another
     * @static
     * @method extend
     * @param  {object} a
     * @param  {object} b
     */
    Utils.prototype.extend = function (a, b) {
        for (var key in b) {
            a[key] = b[key];
        }
    };
    /**
     * Shallow clone an object. Returns a new object instance with the same properties as the input instance.
     * @static
     * @method shallowClone
     * @param  {object} obj
     */
    Utils.prototype.shallowClone = function (obj) {
        var newObj = {};
        this.extend(newObj, obj);
        return newObj;
    };
    return Utils;
}());
exports.default = new Utils();

},{}],57:[function(_dereq_,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnionFind = /** @class */ (function () {
    /**
     * Weighted Quick Union-Find with Path Compression. Based on https://github.com/juzerali/unionfind, but optimized for performance.
     * @class UnionFind
     * @constructor
     * @param {number} size
     */
    function UnionFind(size) {
        this.id = [];
        this.sz = [];
        /**
         * The number of elements.
         * @property {number} size
         */
        this.size = size;
        /**
         * The number of distinct groups.
         * @property {number} count
         */
        this.count = size;
        this.resize(size);
    }
    /**
     * Initialize the UnionFind data structure with number of distinct groups to begin with. Each group will be referred to as index of the array of size size starting at 0.
     * @method resize
     * @param {number} size
     */
    UnionFind.prototype.resize = function (size) {
        this.count = this.size = size;
        var sz = this.sz;
        var id = this.id;
        for (var i = 0; i < size; i++) {
            id[i] = i;
            sz[i] = 1;
        }
    };
    /**
     * Return the root (value) of the group in which p is.
     * @method find
     * @param {number} p
     */
    UnionFind.prototype.find = function (p) {
        var id = this.id;
        while (p !== id[p]) {
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    };
    /**
     * Combine elements in groups p and q into a single group. In other words connect the two groups.
     * @method union
     * @param {number} p
     * @param {number} q
     */
    UnionFind.prototype.union = function (p, q) {
        var i = this.find(p), j = this.find(q);
        if (i === j) {
            return;
        }
        var sz = this.sz;
        var id = this.id;
        if (sz[i] < sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        }
        else {
            id[j] = i;
            sz[i] += sz[j];
        }
        this.count--;
        return;
    };
    return UnionFind;
}());
exports.default = UnionFind;

},{}],58:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var gs_solver_1 = __importDefault(_dereq_("../solver/gs-solver"));
var vec2_1 = __importDefault(_dereq_("../math/vec2"));
var shape_1 = __importDefault(_dereq_("../shapes/shape"));
var event_emitter_1 = __importDefault(_dereq_("../events/event-emitter"));
var body_1 = __importDefault(_dereq_("../objects/body"));
var material_1 = __importDefault(_dereq_("../material/material"));
var contact_material_1 = __importDefault(_dereq_("../material/contact-material"));
var aabb_1 = __importDefault(_dereq_("../collision/aabb"));
var sap_broadphase_1 = __importDefault(_dereq_("../collision/sap-broadphase"));
var narrowphase_1 = __importDefault(_dereq_("../collision/narrowphase"));
var utils_1 = __importDefault(_dereq_("../utils/utils"));
//import arrayRemove from  "ayRemo"; // Get rid of this dependency!
var overlap_keeper_1 = __importDefault(_dereq_("../utils/overlap-keeper"));
var union_find_1 = __importDefault(_dereq_("./union-find"));
//import f32 from "f32";
/**
 * Fired after the step().
 * @event postStep
 */
var postStepEvent = {
    type: "postStep"
};
/**
 * Fired when a body is added to the world.
 * @event addBody
 * @param {Body} body
 */
var AddBodyEvent = /** @class */ (function () {
    function AddBodyEvent() {
        this.type = "addBody";
        this.body = null;
    }
    return AddBodyEvent;
}());
var addBodyEvent = new AddBodyEvent();
/**
 * Fired when a body is removed from the world.
 * @event removeBody
 * @param {Body} body
 */
var RemoveBodyEvent = /** @class */ (function () {
    function RemoveBodyEvent() {
        this.type = "removeBody";
        this.body = null;
    }
    return RemoveBodyEvent;
}());
var removeBodyEvent = new RemoveBodyEvent();
/**
 * Fired when a spring is added to the world.
 * @event addSpring
 * @param {Spring} spring
 */
var AddSpringEvent = /** @class */ (function () {
    function AddSpringEvent() {
        this.type = "addSpring";
        this.spring = null;
    }
    return AddSpringEvent;
}());
var addSpringEvent = new AddSpringEvent();
/**
 * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
 * @event impact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @deprecated Impact event will be removed. Use beginContact instead.
 */
var ImpactEvent = /** @class */ (function () {
    function ImpactEvent() {
        this.type = "impact";
        this.bodyA = null;
        this.bodyB = null;
        this.shapeA = null;
        this.shapeB = null;
        this.contactEquation = null;
    }
    return ImpactEvent;
}());
var impactEvent = new ImpactEvent();
/**
 * Fired after the Broadphase has collected collision pairs in the world.
 * Inside the event handler, you can modify the pairs array as you like, to
 * prevent collisions between objects that you don't want.
 * @event postBroadphase
 * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
 */
var PostBroadphaseEvent = /** @class */ (function () {
    function PostBroadphaseEvent() {
        this.type = "postBroadphase";
        this.pairs = null;
    }
    return PostBroadphaseEvent;
}());
var postBroadphaseEvent = new PostBroadphaseEvent;
var BeginContactEvent = /** @class */ (function () {
    function BeginContactEvent() {
        this.type = "beginContact";
        this.shapeA = null;
        this.shapeB = null;
        this.bodyA = null;
        this.bodyB = null;
        this.contactEquations = [];
    }
    return BeginContactEvent;
}());
/**
 * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
 * @event beginContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 * @param {Array} contactEquations
 */
var beginContactEvent = new BeginContactEvent();
/**
 * Fired when two shapes stop overlapping, after the narrowphase (during step).
 * @event endContact
 * @param {Shape} shapeA
 * @param {Shape} shapeB
 * @param {Body}  bodyA
 * @param {Body}  bodyB
 */
var endContactEvent = {
    type: "endContact",
    shapeA: null,
    shapeB: null,
    bodyA: null,
    bodyB: null
};
var hitTest_tmp1 = vec2_1.default.create(), hitTest_tmp2 = vec2_1.default.create();
/**
 * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
 * @event preSolve
 * @param {Array} contactEquations  An array of contacts to be solved.
 * @param {Array} frictionEquations An array of friction equations to be solved.
 */
var PreSolveEvent = /** @class */ (function () {
    function PreSolveEvent() {
        this.type = "preSolve";
        this.contactEquations = null;
        this.frictionEquations = null;
    }
    return PreSolveEvent;
}());
var preSolveEvent = new PreSolveEvent();
function sortBodiesByIsland(a, b) {
    return a.islandId - b.islandId;
}
function sortEquationsByIsland(equationA, equationB) {
    if (!(equationA === null || equationA === void 0 ? void 0 : equationA.bodyA) || !(equationA === null || equationA === void 0 ? void 0 : equationA.bodyB) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyA) || !(equationB === null || equationB === void 0 ? void 0 : equationB.bodyB))
        return 0;
    var islandA = equationA.bodyA.islandId > 0 ? equationA.bodyA.islandId : equationA.bodyB.islandId;
    var islandB = equationB.bodyA.islandId > 0 ? equationB.bodyA.islandId : equationB.bodyB.islandId;
    if (islandA !== islandB) {
        return islandA - islandB;
    }
    else {
        // Sort by equation type if same island
        return equationA.index - equationB.index;
    }
}
// Why not just make this a private method in world?
// What are all these props???
function runNarrowphase(world, np, bi, si, xi, ai, bj, sj, xj, aj, cm, glen) {
    var xiw = vec2_1.default.create();
    var xjw = vec2_1.default.create();
    // Check collision groups and masks
    if (!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)) {
        return;
    }
    // Get world position and angle of each shape
    vec2_1.default.toGlobalFrame(xiw, xi, bi.position, bi.angle);
    vec2_1.default.toGlobalFrame(xjw, xj, bj.position, bj.angle);
    if (vec2_1.default.distance(xiw, xjw) > si.boundingRadius + sj.boundingRadius) {
        return;
    }
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;
    np.enableFriction = cm.friction > 0;
    var reducedMass;
    if (bi.type === body_1.default.STATIC || bi.type === body_1.default.KINEMATIC) {
        reducedMass = bj.mass;
    }
    else if (bj.type === body_1.default.STATIC || bj.type === body_1.default.KINEMATIC) {
        reducedMass = bi.mass;
    }
    else {
        reducedMass = (bi.mass * bj.mass) / (bi.mass + bj.mass);
    }
    np.slipForce = cm.friction * glen * reducedMass;
    np.currentContactMaterial = cm;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    var sensor = si.sensor || sj.sensor;
    var numFrictionBefore = np.frictionEquations.length;
    var numContacts = np.testContact(bi, si, xiw, bj, sj, xjw, sensor);
    var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;
    if (numContacts) {
        if (bi.allowSleep &&
            bi.type === body_1.default.DYNAMIC &&
            bi.sleepState === body_1.default.SLEEPING &&
            bj.sleepState === body_1.default.AWAKE &&
            bj.type !== body_1.default.STATIC) {
            var speedSquaredB = vec2_1.default.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity, 2);
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
            if (speedSquaredB >= speedLimitSquaredB * 2) {
                bi._wakeUpAfterNarrowphase = true;
            }
        }
        if (bj.allowSleep &&
            bj.type === body_1.default.DYNAMIC &&
            bj.sleepState === body_1.default.SLEEPING &&
            bi.sleepState === body_1.default.AWAKE &&
            bi.type !== body_1.default.STATIC) {
            var speedSquaredA = vec2_1.default.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity, 2);
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
            if (speedSquaredA >= speedLimitSquaredA * 2) {
                bj._wakeUpAfterNarrowphase = true;
            }
        }
        world.overlapKeeper.setOverlapping(bi, si, bj, sj);
        if (world.has('beginContact') && world.overlapKeeper.isNewOverlap(si, sj)) {
            // Report new shape overlap
            var e = beginContactEvent;
            e.shapeA = si;
            e.shapeB = sj;
            e.bodyA = bi;
            e.bodyB = bj;
            // Reset contact equations
            e.contactEquations.length = 0;
            if (!sensor) {
                for (var i = np.contactEquations.length - numContacts; i < np.contactEquations.length; i++) {
                    e.contactEquations.push(np.contactEquations[i]);
                }
            }
            world.emit(e);
        }
        // divide the max friction force by the number of contacts
        if (!sensor && numFrictionEquations > 1) { // Why divide by 1?
            for (var i = np.frictionEquations.length - numFrictionEquations; i < np.frictionEquations.length; i++) {
                var f = np.frictionEquations[i];
                f.setSlipForce(f.getSlipForce() / numFrictionEquations);
            }
        }
    }
}
function setGlobalEquationParams(world, params) {
    var _a, _b;
    var constraints = world.constraints;
    for (var i = 0; i !== constraints.length; i++) {
        var c = constraints[i];
        var eqs = c.equations;
        for (var j = 0; j !== eqs.length; j++) {
            var eq = eqs[j];
            eq.relaxation = (_a = params === null || params === void 0 ? void 0 : params.relaxation) !== null && _a !== void 0 ? _a : eq.relaxation;
            eq.stiffness = (_b = params === null || params === void 0 ? void 0 : params.stiffness) !== null && _b !== void 0 ? _b : eq.stiffness;
            eq.needsUpdate = true;
        }
    }
}
var World = /** @class */ (function (_super) {
    __extends(World, _super);
    /**
     * The dynamics world, where all bodies and constraints live.
     *
     * @class World
     * @constructor
     * @param {Object} [options]
     * @param {Solver} [options.solver] Defaults to GSSolver.
     * @param {Array} [options.gravity] Defaults to y=-9.78.
     * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase
     * @param {Boolean} [options.islandSplit=true]
     * @extends EventEmitter
     *
     * @example
     *     var world = new World({
     *         gravity: [0, -10],
     *         broadphase: new SAPBroadphase()
     *     });
     *     world.addBody(new Body());
     */
    function World(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this) || this;
        /**
         * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
         *
         * @property springs
         * @type {Array}
         */
        _this.springs = [];
        /**
         * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
         * @property {Array} bodies
         */
        _this.bodies = [];
        /**
         * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
         * @private
         * @property {Array} disabledBodyCollisionPairs
         */
        _this.disabledBodyCollisionPairs = [];
        /**
         * The narrowphase to use to generate contacts.
         *
         * @property narrowphase
         * @type {Narrowphase}
         */
        _this.narrowphase = new narrowphase_1.default();
        /**
         * Gravity in the world. This is applied on all bodies in the beginning of each step().
         *
         * @property gravity
         * @type {Array}
         */
        _this.gravity = vec2_1.default.fromValues(0, -9.78);
        /**
         * Gravity to use when approximating the friction max force (mu*mass*gravity).
         * @property {Number} frictionGravity
         */
        _this.frictionGravity = 10;
        /**
         * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
         * @property {Boolean} useWorldGravityAsFrictionGravity
         * @default true
         */
        _this.useWorldGravityAsFrictionGravity = true;
        /**
         * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
         * @property {Boolean} useFrictionGravityOnZeroGravity
         * @default true
         */
        _this.useFrictionGravityOnZeroGravity = true;
        /**
         * User-added constraints.
         *
         * @property constraints
         * @type {Array}
         */
        _this.constraints = [];
        /**
         * Dummy default material in the world, used in .defaultContactMaterial
         * @property {Material} defaultMaterial
         */
        _this.defaultMaterial = new material_1.default();
        /**
         * For keeping track of what time step size we used last step
         * @property lastTimeStep
         * @type {Number}
         */
        _this.lastTimeStep = 1 / 60;
        /**
         * Enable to automatically apply spring forces each step.
         * @property applySpringForces
         * @type {Boolean}
         * @default true
         */
        _this.applySpringForces = true;
        /**
         * Enable to automatically apply body damping each step.
         * @property applyDamping
         * @type {Boolean}
         * @default true
         */
        _this.applyDamping = true;
        /**
         * Enable to automatically apply gravity each step.
         * @property applyGravity
         * @type {Boolean}
         * @default true
         */
        _this.applyGravity = true;
        /**
         * Enable/disable constraint solving in each step.
         * @property solveConstraints
         * @type {Boolean}
         * @default true
         */
        _this.solveConstraints = true;
        /**
         * The ContactMaterials added to the World.
         * @property contactMaterials
         * @type {Array}
         */
        _this.contactMaterials = [];
        /**
         * World time.
         * @property time
         * @type {Number}
         */
        _this.time = 0.0;
        _this.accumulator = 0;
        /**
         * Is true during step().
         * @property {Boolean} stepping
         */
        _this.stepping = false;
        /**
         * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance.
         * @property {Boolean} islandSplit
         * @default false
         */
        _this.islandSplit = true;
        /**
         * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
         * @property emitImpactEvent
         * @type {Boolean}
         * @default true
         * @deprecated Impact event will be removed. Use beginContact instead.
         */
        _this.emitImpactEvent = true;
        /**
         * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
         * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
         * @property sleepMode
         * @type {number}
         * @default World.NO_SLEEPING
         */
        _this.sleepMode = World.NO_SLEEPING;
        /**
         * @property {UnionFind} unionFind
         */
        _this.unionFind = new union_find_1.default(1);
        // Id counters
        _this._constraintIdCounter = 0;
        _this._bodyIdCounter = 0;
        /**
         * @property {OverlapKeeper} overlapKeeper
         */
        _this.overlapKeeper = new overlap_keeper_1.default();
        _this.solver = (_a = options === null || options === void 0 ? void 0 : options.solver) !== null && _a !== void 0 ? _a : new gs_solver_1.default();
        if (options === null || options === void 0 ? void 0 : options.gravity) {
            vec2_1.default.copy(_this.gravity, options.gravity);
        }
        _this.frictionGravity = (_b = vec2_1.default.length(_this.gravity)) !== null && _b !== void 0 ? _b : 10;
        _this.broadphase = (_c = options === null || options === void 0 ? void 0 : options.broadphase) !== null && _c !== void 0 ? _c : new sap_broadphase_1.default();
        _this.broadphase.setWorld(_this);
        _this.defaultContactMaterial = new contact_material_1.default(_this.defaultMaterial, _this.defaultMaterial);
        _this.islandSplit = (_d = options === null || options === void 0 ? void 0 : options.islandSplit) !== null && _d !== void 0 ? _d : true;
        return _this;
    }
    /**
     * Add a constraint to the simulation. Note that both bodies connected to the constraint must be added to the world first. Also note that you can't run this method during step.
     *
     * @method addConstraint
     * @param {Constraint} constraint
     * @example
     *     var constraint = new LockConstraint(bodyA, bodyB);
     *     world.addConstraint(constraint);
     */
    World.prototype.addConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be added during step.');
        }
        var bodies = this.bodies;
        if (bodies.indexOf(constraint.bodyA) === -1) {
            throw new Error('Cannot add Constraint: bodyA is not added to the World.');
        }
        if (bodies.indexOf(constraint.bodyB) === -1) {
            throw new Error('Cannot add Constraint: bodyB is not added to the World.');
        }
        this.constraints.push(constraint);
    };
    /**
     * Add a ContactMaterial to the simulation.
     * @method addContactMaterial
     * @param {ContactMaterial} contactMaterial
     */
    World.prototype.addContactMaterial = function (contactMaterial) {
        this.contactMaterials.push(contactMaterial);
    };
    /**
     * Removes a contact material
     *
     * @method removeContactMaterial
     * @param {ContactMaterial} cm
     */
    World.prototype.removeContactMaterial = function (cm) {
        utils_1.default.arrayRemove(this.contactMaterials, cm);
    };
    /**
     * Get a contact material given two materials
     * @method getContactMaterial
     * @param {Material} materialA
     * @param {Material} materialB
     * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
     * @todo Use faster hash map to lookup from material id's
     */
    World.prototype.getContactMaterial = function (materialA, materialB) {
        var cmats = this.contactMaterials;
        for (var i = 0, N = cmats.length; i !== N; i++) {
            var cm = cmats[i];
            if ((cm.materialA === materialA && cm.materialB === materialB) || (cm.materialA === materialB && cm.materialB === materialA)) {
                return cm;
            }
        }
        return null;
    };
    /**
     * Removes a constraint. Note that you can't run this method during step.
     *
     * @method removeConstraint
     * @param {Constraint} constraint
     */
    World.prototype.removeConstraint = function (constraint) {
        if (this.stepping) {
            throw new Error('Constraints cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.constraints, constraint);
    };
    /**
     * Step the physics world forward in time.
     *
     * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
     *
     * @method step
     * @param {Number} dt                       The fixed time step size to use.
     * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
     * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
     *
     * @example
     *     // Simple fixed timestepping without interpolation
     *     var fixedTimeStep = 1 / 60;
     *     var world = new World();
     *     var body = new Body({ mass: 1 });
     *     world.addBody(body);
     *
     *     function animate(){
     *         requestAnimationFrame(animate);
     *         world.step(fixedTimeStep);
     *         renderBody(body.position, body.angle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @example
     *     // Fixed timestepping with interpolation
     *     var maxSubSteps = 10;
     *     var lastTimeSeconds;
     *
     *     function animate(time){
     *         requestAnimationFrame(animate);
     *         var timeSeconds = time / 1000;
     *
     *         if(lastTimeSeconds){
     *             var deltaTime = timeSeconds - lastTimeSeconds;
     *             world.step(fixedTimeStep, deltaTime, maxSubSteps);
     *         }
     *
     *         lastTimeSeconds = timeSeconds;
     *
     *         renderBody(body.interpolatedPosition, body.interpolatedAngle);
     *     }
     *
     *     // Start animation loop
     *     requestAnimationFrame(animate);
     *
     * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
     */
    World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
        maxSubSteps = maxSubSteps || 10;
        timeSinceLastCalled = timeSinceLastCalled || 0;
        if (timeSinceLastCalled === 0) { // Fixed, simple stepping
            this.internalStep(dt);
            // Increment time
            this.time += dt;
        }
        else {
            this.accumulator += timeSinceLastCalled;
            var substeps = 0;
            while (this.accumulator >= dt && substeps < maxSubSteps) {
                // Do fixed steps to catch up
                this.internalStep(dt);
                this.time += dt;
                this.accumulator -= dt;
                substeps++;
            }
            var t = (this.accumulator % dt) / dt;
            for (var j = 0; j !== this.bodies.length; j++) {
                var b = this.bodies[j];
                vec2_1.default.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);
                b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);
            }
        }
    };
    /**
     * Make a fixed step.
     * @method internalStep
     * @param  {number} dt
     * @private
     */
    World.prototype.internalStep = function (dt) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var step_mg = vec2_1.default.create();
        var endOverlaps = [];
        this.stepping = true;
        var Nsprings = this.springs.length, springs = this.springs, bodies = this.bodies, g = this.gravity, solver = this.solver, Nbodies = this.bodies.length, broadphase = this.broadphase, np = this.narrowphase, constraints = this.constraints, mg = step_mg, add = vec2_1.default.add;
        this.overlapKeeper.tick();
        this.lastTimeStep = dt;
        // Update approximate friction gravity.
        if (this.useWorldGravityAsFrictionGravity) {
            var gravityLen = vec2_1.default.length(this.gravity);
            if (!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)) {
                // Nonzero gravity. Use it.
                this.frictionGravity = gravityLen;
            }
        }
        // Add gravity to bodies
        if (this.applyGravity) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i], fi = b.force;
                if (b.type !== body_1.default.DYNAMIC || b.sleepState === body_1.default.SLEEPING) {
                    continue;
                }
                vec2_1.default.scale(mg, g, b.mass * b.gravityScale); // F=m*g
                add(fi, fi, mg);
            }
        }
        // Add spring forces
        if (this.applySpringForces) {
            for (var i = 0; i !== Nsprings; i++) {
                var s = springs[i];
                s.applyForce();
            }
        }
        if (this.applyDamping) {
            for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i];
                if (b.type === body_1.default.DYNAMIC) {
                    b.applyDamping(dt);
                }
            }
        }
        // Broadphase
        var result = broadphase.getCollisionPairs(this);
        // Remove ignored collision pairs
        var ignoredPairs = this.disabledBodyCollisionPairs;
        for (var i = ignoredPairs.length - 2; i >= 0; i -= 2) {
            for (var j = result.length - 2; j >= 0; j -= 2) {
                if ((ignoredPairs[i] === result[j] && ignoredPairs[i + 1] === result[j + 1]) ||
                    (ignoredPairs[i + 1] === result[j] && ignoredPairs[i] === result[j + 1])) {
                    result.splice(j, 2);
                }
            }
        }
        // Remove constrained pairs with collideConnected == false
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            var c = constraints[i];
            if (!c.collideConnected) {
                for (var j = result.length - 2; j >= 0; j -= 2) {
                    if ((c.bodyA === result[j] && c.bodyB === result[j + 1]) ||
                        (c.bodyB === result[j] && c.bodyA === result[j + 1])) {
                        result.splice(j, 2);
                    }
                }
            }
        }
        // postBroadphase event
        postBroadphaseEvent.pairs = result;
        this.emit(postBroadphaseEvent);
        postBroadphaseEvent.pairs = null;
        // Narrowphase
        np.reset();
        var defaultContactMaterial = this.defaultContactMaterial;
        var frictionGravity = this.frictionGravity;
        for (var i = 0, Nresults = result.length; i !== Nresults; i += 2) {
            var bi = result[i], bj = result[i + 1];
            // Loop over all shapes of body i
            for (var k = 0, Nshapesi = bi.shapes.length; k !== Nshapesi; k++) {
                var si = bi.shapes[k], xi = si.position, ai = si.angle;
                // All shapes of body j
                for (var l = 0, Nshapesj = bj.shapes.length; l !== Nshapesj; l++) {
                    var sj = bj.shapes[l], xj = sj.position, aj = sj.angle;
                    var contactMaterial = null;
                    if (si.material && sj.material) {
                        contactMaterial = this.getContactMaterial(si.material, sj.material);
                    }
                    runNarrowphase(this, np, bi, si, xi, ai, bj, sj, xj, aj, contactMaterial !== null && contactMaterial !== void 0 ? contactMaterial : defaultContactMaterial, frictionGravity);
                }
            }
        }
        // Wake up bodies
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body._wakeUpAfterNarrowphase) {
                body.wakeUp();
                body._wakeUpAfterNarrowphase = false;
            }
        }
        // Emit end overlap events
        if (_super.prototype.has.call(this, "endContact")) {
            this.overlapKeeper.getEndOverlaps(endOverlaps);
            var e = endContactEvent;
            var l = endOverlaps.length;
            while (l--) {
                var data = endOverlaps[l];
                e.shapeA = data.shapeA;
                e.shapeB = data.shapeB;
                e.bodyA = data.bodyA;
                e.bodyB = data.bodyB;
                this.emit(e);
            }
            endOverlaps.length = 0;
        }
        preSolveEvent.contactEquations = np.contactEquations;
        preSolveEvent.frictionEquations = np.frictionEquations;
        this.emit(preSolveEvent);
        preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;
        // update constraint equations
        var Nconstraints = constraints.length;
        for (i = 0; i !== Nconstraints; i++) {
            constraints[i].update();
        }
        if (np.contactEquations.length || np.frictionEquations.length || Nconstraints) {
            // Get all equations
            var equations = [];
            utils_1.default.appendArray(equations, np.contactEquations);
            utils_1.default.appendArray(equations, np.frictionEquations);
            for (i = 0; i !== Nconstraints; i++) {
                utils_1.default.appendArray(equations, constraints[i].equations);
            }
            if (this.islandSplit) {
                // Initialize the UnionFind
                var unionFind = this.unionFind;
                unionFind.resize(this.bodies.length + 1);
                // Update equation index
                for (var i = 0; i < equations.length; i++) {
                    equations[i].index = i;
                }
                // Unite bodies if they are connected by an equation
                for (var i = 0; i < equations.length; i++) {
                    var bodyA = equations[i].bodyA;
                    var bodyB = equations[i].bodyB;
                    if (!bodyA || !bodyB)
                        continue;
                    if (bodyA.type === body_1.default.DYNAMIC && bodyB.type === body_1.default.DYNAMIC) {
                        unionFind.union(bodyA.index, bodyB.index);
                    }
                }
                // Find the body islands
                for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    body.islandId = body.type === body_1.default.DYNAMIC ? unionFind.find(body.index) : -1;
                }
                // Sort equations by island
                equations = equations.sort(sortEquationsByIsland);
                var equationIndex = 0;
                while (equationIndex < equations.length) {
                    var equation = equations[equationIndex++];
                    solver.addEquation(equation);
                    if (!equation.bodyA || !equation.bodyB)
                        continue;
                    var currentIslandId = equation.bodyA.islandId > 0 ? equation.bodyA.islandId : equation.bodyB.islandId;
                    var nextIslandId = -1;
                    var ei = equations[equationIndex];
                    if (ei) {
                        if (ei.bodyA && ei.bodyB)
                            continue;
                        nextIslandId = ((_b = (_a = ei.bodyA) === null || _a === void 0 ? void 0 : _a.islandId) !== null && _b !== void 0 ? _b : 0) > 0 ? (_d = (_c = ei.bodyA) === null || _c === void 0 ? void 0 : _c.islandId) !== null && _d !== void 0 ? _d : 0 : (_f = (_e = ei.bodyB) === null || _e === void 0 ? void 0 : _e.islandId) !== null && _f !== void 0 ? _f : 0;
                    }
                    if (nextIslandId !== currentIslandId || equationIndex === equations.length) {
                        // Solve this island
                        if (this.solveConstraints) {
                            solver.solve(dt, this);
                        }
                        solver.removeAllEquations();
                    }
                }
            }
            else {
                // Solve all as one island
                solver.addEquations(equations);
                if (this.solveConstraints) {
                    solver.solve(dt, this);
                }
                solver.removeAllEquations();
            }
        }
        // Step forward
        for (var i = 0; i !== Nbodies; i++) {
            var body = bodies[i];
            if (body.type === body_1.default.DYNAMIC || body.type === body_1.default.KINEMATIC) {
                body.integrate(dt);
            }
        }
        // Reset force
        for (var i = 0; i !== Nbodies; i++) {
            bodies[i].setZeroForce();
        }
        // Emit impact event
        if (this.emitImpactEvent && this.has('impact')) {
            var ev = impactEvent;
            for (var i = 0; i !== np.contactEquations.length; i++) {
                var eq = np.contactEquations[i];
                if (eq.firstImpact) {
                    ev.bodyA = (_g = eq.bodyA) !== null && _g !== void 0 ? _g : null;
                    ev.bodyB = (_h = eq.bodyB) !== null && _h !== void 0 ? _h : null;
                    ev.shapeA = eq.shapeA;
                    ev.shapeB = eq.shapeB;
                    ev.contactEquation = eq;
                    this.emit(ev);
                }
            }
        }
        // Sleeping update
        if (this.sleepMode === World.BODY_SLEEPING) {
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, false, dt);
            }
        }
        else if (this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit) {
            // Tell all bodies to sleep tick but dont sleep yet
            for (i = 0; i !== Nbodies; i++) {
                bodies[i].sleepTick(this.time, true, dt);
            }
            // Sleep islands
            var bodiesSortedByIsland = bodies.sort(sortBodiesByIsland);
            var islandEnd = 1;
            for (var islandStart = 0; islandStart < bodiesSortedByIsland.length; islandStart = islandEnd) {
                var islandId = bodiesSortedByIsland[islandStart].islandId;
                // Get islandEnd index
                /* jshint ignore:start */
                for (islandEnd = islandStart + 1; islandEnd < bodiesSortedByIsland.length && bodiesSortedByIsland[islandEnd].islandId === islandId; islandEnd++) { }
                /* jshint ignore:end */
                // Don't check static objects
                if (islandId === -1) {
                    continue;
                }
                var islandShouldSleep = true;
                for (var i = islandStart; i < islandEnd; i++) {
                    if (!bodiesSortedByIsland[i].wantsToSleep) {
                        islandShouldSleep = false;
                        break;
                    }
                }
                if (islandShouldSleep) {
                    for (var i = islandStart; i < islandEnd; i++) {
                        bodiesSortedByIsland[i].sleep();
                    }
                }
            }
        }
        this.stepping = false;
        _super.prototype.emit.call(this, postStepEvent);
    };
    /**
     * Add a spring to the simulation. Note that this operation can't be done during step.
     *
     * @method addSpring
     * @param {Spring} spring
     */
    World.prototype.addSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be added during step.');
        }
        this.springs.push(spring);
        addSpringEvent.spring = spring;
        this.emit(addSpringEvent);
        addSpringEvent.spring = null;
    };
    /**
     * Remove a spring. Note that this operation can't be done during step.
     *
     * @method removeSpring
     * @param {Spring} spring
     */
    World.prototype.removeSpring = function (spring) {
        if (this.stepping) {
            throw new Error('Springs cannot be removed during step.');
        }
        utils_1.default.arrayRemove(this.springs, spring);
    };
    /**
     * Add a body to the simulation. Note that you can't add a body during step: you have to wait until after the step (see the postStep event).
     * Also note that bodies can only be added to one World at a time.
     *
     * @method addBody
     * @param {Body} body
     *
     * @example
     *     var world = new World(),
     *         body = new Body();
     *     world.addBody(body);
     */
    World.prototype.addBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be added during step.');
        }
        // Already added?
        if (body.world) {
            throw new Error('Body is already added to a World.');
        }
        body.index = this.bodies.length;
        this.bodies.push(body);
        body.world = this;
        addBodyEvent.body = body;
        this.emit(addBodyEvent);
        addBodyEvent.body = null;
    };
    /**
     * Remove a body from the simulation. Note that bodies cannot be removed during step (for example, inside the beginContact event). In that case you need to wait until the step is done (see the postStep event).
     *
     * Also note that any constraints connected to the body must be removed before the body.
     *
     * @method removeBody
     * @param {Body} body
     *
     * @example
     *     var removeBody;
     *     world.on("beginContact",function(event){
     *         // We cannot remove the body here since the world is still stepping.
     *         // Instead, schedule the body to be removed after the step is done.
     *         removeBody = body;
     *     });
     *     world.on("postStep",function(event){
     *         if(removeBody){
     *             // Safely remove the body from the world.
     *             world.removeBody(removeBody);
     *             removeBody = null;
     *         }
     *     });
     */
    World.prototype.removeBody = function (body) {
        if (this.stepping) {
            throw new Error('Bodies cannot be removed during step.');
        }
        // TODO: would it be smart to have a .constraints array on the body?
        var constraints = this.constraints;
        var l = constraints.length;
        while (l--) {
            if (constraints[l].bodyA === body || constraints[l].bodyB === body) {
                throw new Error('Cannot remove Body from World: it still has constraints connected to it.');
            }
        }
        body.world = null;
        var bodies = this.bodies;
        utils_1.default.arrayRemove(bodies, body);
        body.index = -1;
        var l = bodies.length;
        while (l--) {
            bodies[l].index = l;
        }
        // Emit removeBody event
        removeBodyEvent.body = body;
        body.resetConstraintVelocity();
        this.emit(removeBodyEvent);
        removeBodyEvent.body = null;
        // Remove disabled body collision pairs that involve body
        var pairs = this.disabledBodyCollisionPairs;
        var i = 0;
        while (i < pairs.length) {
            if (pairs[i] === body || pairs[i + 1] === body) {
                pairs.splice(i, 2);
            }
            else {
                i += 2;
            }
        }
    };
    /**
     * Get a body by its id.
     * @method getBodyById
     * @param {number} id
     * @return {Body} The body, or false if it was not found.
     */
    World.prototype.getBodyById = function (id) {
        var bodies = this.bodies;
        for (var i = 0; i < bodies.length; i++) {
            var b = bodies[i];
            if (b.id === id) {
                return b;
            }
        }
        return null;
    };
    /**
     * Disable collision between two bodies
     * @method disableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.disableBodyCollision = function (bodyA, bodyB) {
        this.disabledBodyCollisionPairs.push(bodyA);
        this.disabledBodyCollisionPairs.push(bodyB);
    };
    /**
     * Enable collisions between the given two bodies, if they were previously disabled using .disableBodyCollision().
     * @method enableBodyCollision
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    World.prototype.enableBodyCollision = function (bodyA, bodyB) {
        var pairs = this.disabledBodyCollisionPairs;
        for (var i = 0; i < pairs.length; i += 2) {
            if ((pairs[i] === bodyA && pairs[i + 1] === bodyB) || (pairs[i + 1] === bodyA && pairs[i] === bodyB)) {
                pairs.splice(i, 2);
                return;
            }
        }
    };
    /**
     * Removes all bodies, constraints, springs, and contact materials from the world.
     * @method clear
     */
    World.prototype.clear = function () {
        // Remove all solver equations
        this.solver.removeAllEquations();
        // Remove all constraints
        var cs = this.constraints;
        var i = cs.length;
        while (i--) {
            this.removeConstraint(cs[i]);
        }
        // Remove all bodies
        var bodies = this.bodies;
        i = bodies.length;
        while (i--) {
            this.removeBody(bodies[i]);
        }
        // Remove all springs
        var springs = this.springs;
        i = springs.length;
        while (i--) {
            this.removeSpring(springs[i]);
        }
        // Remove all contact materials
        var cms = this.contactMaterials;
        i = cms.length;
        while (i--) {
            this.removeContactMaterial(cms[i]);
        }
    };
    /**
     * Test if a world point overlaps bodies
     * @method hitTest
     * @param  {Array} worldPoint Point to use for intersection tests
     * @param  {Array} bodies A list of objects to check for intersection
     * @param  {Number} precision Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
     * @return {Array} Array of bodies that overlap the point
     * @todo Should use an api similar to the raycast function
     * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient
     * @todo Should use the broadphase
     * @todo Returning the hit shape would be fine - it carries a reference to the body now
     */
    World.prototype.hitTest = function (worldPoint, bodies, precision) {
        precision = precision || 0;
        // Create a dummy particle body with a particle shape to test against the bodies
        var shapeWorldPosition = hitTest_tmp1, shapeLocalPoint = hitTest_tmp2;
        var result = [];
        // Check bodies
        for (var i = 0, N = bodies.length; i !== N; i++) {
            var body = bodies[i];
            for (var j = 0, NS = body.shapes.length; j !== NS; j++) {
                var shape = body.shapes[j];
                // Get local point position in the shape
                shape.worldPointToLocal(shapeLocalPoint, worldPoint);
                if (shape.pointTest(shapeLocalPoint)) {
                    result.push(body);
                }
                else {
                    // Get shape world position
                    vec2_1.default.rotate(shapeWorldPosition, shape.position, body.angle);
                    vec2_1.default.add(shapeWorldPosition, shapeWorldPosition, body.position);
                    if (shape.type === shape_1.default.PARTICLE && vec2_1.default.squaredDistance(shapeWorldPosition, worldPoint) < precision * precision) {
                        result.push(body);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Set the stiffness for all equations and contact materials.
     * @method setGlobalStiffness
     * @param {Number} stiffness
     */
    World.prototype.setGlobalStiffness = function (stiffness) {
        setGlobalEquationParams(this, { stiffness: stiffness });
        // Set for all contact materials
        var contactMaterials = this.contactMaterials;
        for (var i = 0; i !== contactMaterials.length; i++) {
            var c = contactMaterials[i];
            c.stiffness = c.frictionStiffness = stiffness;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.stiffness = c.frictionStiffness = stiffness;
    };
    /**
     * Set the relaxation for all equations and contact materials.
     * @method setGlobalRelaxation
     * @param {Number} relaxation
     */
    World.prototype.setGlobalRelaxation = function (relaxation) {
        setGlobalEquationParams(this, { relaxation: relaxation });
        // Set for all contact materials
        for (var i = 0; i !== this.contactMaterials.length; i++) {
            var c = this.contactMaterials[i];
            c.relaxation = c.frictionRelaxation = relaxation;
        }
        // Set for default contact material
        var c = this.defaultContactMaterial;
        c.relaxation = c.frictionRelaxation = relaxation;
    };
    /**
     * Ray cast against all bodies in the world.
     * @method raycast
     * @param  {RaycastResult} result
     * @param  {Ray} ray
     * @return {boolean} True if any body was hit.
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.CLOSEST, // or ANY
     *         from: [0, 0],
     *         to: [10, 0],
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     *
     *     // Get the hit point
     *     var hitPoint = vec2.create();
     *     result.getHitPoint(hitPoint, ray);
     *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     * @example
     *     var ray = new Ray({
     *         mode: Ray.ALL,
     *         from: [0, 0],
     *         to: [10, 0],
     *         callback: function(result){
     *
     *             // Print some info about the hit
     *             console.log('Hit body and shape: ', result.body, result.shape);
     *
     *             // Get the hit point
     *             var hitPoint = vec2.create();
     *             result.getHitPoint(hitPoint, ray);
     *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));
     *
     *             // If you are happy with the hits you got this far, you can stop the traversal here:
     *             result.stop();
     *         }
     *     });
     *     var result = new RaycastResult();
     *     world.raycast(result, ray);
     */
    World.prototype.raycast = function (result, ray) {
        var tmpAABB = new aabb_1.default();
        var tmpArray = [];
        // Get all bodies within the ray AABB
        ray.getAABB(tmpAABB);
        this.broadphase.aabbQuery(this, tmpAABB, tmpArray);
        ray.intersectBodies(result, tmpArray);
        tmpArray.length = 0;
        return result.hasHit();
    };
    /**
     * Never deactivate bodies.
     * @static
     * @property {number} NO_SLEEPING
     */
    World.NO_SLEEPING = 1;
    /**
     * Deactivate individual bodies if they are sleepy.
     * @static
     * @property {number} BODY_SLEEPING
     */
    World.BODY_SLEEPING = 2;
    /**
     * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
     * @static
     * @property {number} ISLAND_SLEEPING
     */
    World.ISLAND_SLEEPING = 4;
    return World;
}(event_emitter_1.default));
exports.default = World;

},{"../collision/aabb":1,"../collision/narrowphase":4,"../collision/sap-broadphase":7,"../events/event-emitter":21,"../material/contact-material":24,"../material/material":25,"../math/vec2":28,"../objects/body":30,"../shapes/shape":46,"../solver/gs-solver":47,"../utils/overlap-keeper":53,"../utils/utils":56,"./union-find":57}]},{},[22])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcam9zaF9cXE9uZURyaXZlXFxEZXNrdG9wXFxQUk9KRUNUU1xcR0lUSFVCXFxnZWFyYm94MmRcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYWFiYi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFpdmUtYnJvYWRwaGFzZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vbmFycm93cGhhc2UuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3JheS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb2xsaXNpb24vcmF5Y2FzdC1yZXN1bHQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29sbGlzaW9uL3NhcC1icm9hZHBoYXNlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL2NvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvZGlzdGFuY2UtY29uc3RyYWludC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9jb25zdHJhaW50cy9nZWFyLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvY29uc3RyYWludHMvbG9jay1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3ByaXNtYXRpYy1jb25zdHJhaW50LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2NvbnN0cmFpbnRzL3Jldm9sdXRlLWNvbnN0cmFpbnQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvZXF1YXRpb25zL0VxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9hbmdsZS1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9jb250YWN0LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvbi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9lcXVhdGlvbnMvcm90YXRpb25hbC1sb2NrLWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2VxdWF0aW9ucy9yb3RhdGlvbmFsLXZlbG9jaXR5LWVxdWF0aW9uLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2V2ZW50cy9ldmVudC1lbWl0dGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL2luZGV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL01hdGVyaWFsLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGVyaWFsL2NvbnRhY3QtbWF0ZXJpYWwuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvbWF0aC9wb2x5LWRlY29tcC5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9tYXRoL3BvbHlrLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL21hdGgvdmVjMi5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9vYmplY3RzL0JvZHkuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9saW5lYXItc3ByaW5nLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL29iamVjdHMvcm90YXRpb25hbC1zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy9zcHJpbmcuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvb2JqZWN0cy90b3AtZG93bi12ZWhpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9Cb3guanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL0NpcmNsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvQ29udmV4LmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9TaGFwZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvY2Fwc3VsZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zaGFwZXMvaGVpZ2h0ZmllbGQuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL2xpbmUuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvc2hhcGVzL3BhcnRpY2xlLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NoYXBlcy9wbGFuZS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC9zb2x2ZXIvZ3Mtc29sdmVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3NvbHZlci9zb2x2ZXIuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvY29udGFjdC1lcXVhdGlvbi1wb29sLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLXBvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvb3ZlcmxhcC1rZWVwZXItcmVjb3JkLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL292ZXJsYXAta2VlcGVyLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3V0aWxzL3Bvb2wuanMiLCJDOi9Vc2Vycy9qb3NoXy9PbmVEcml2ZS9EZXNrdG9wL1BST0pFQ1RTL0dJVEhVQi9nZWFyYm94MmQvYnVpbGQvdXRpbHMvdHVwbGUtZGljdGlvbmFyeS5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC91dGlscy91dGlscy5qcyIsIkM6L1VzZXJzL2pvc2hfL09uZURyaXZlL0Rlc2t0b3AvUFJPSkVDVFMvR0lUSFVCL2dlYXJib3gyZC9idWlsZC93b3JsZC91bmlvbi1maW5kLmpzIiwiQzovVXNlcnMvam9zaF8vT25lRHJpdmUvRGVza3RvcC9QUk9KRUNUUy9HSVRIVUIvZ2VhcmJveDJkL2J1aWxkL3dvcmxkL3dvcmxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIEFBQkIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXHJcbiAgICAgKiBAY2xhc3MgQUFCQlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKHtcclxuICAgICAqICAgICAgICAgdXBwZXJCb3VuZDogWzEsIDFdLFxyXG4gICAgICogICAgICAgICBsb3dlckJvdW5kOiBbLTEsIC0xXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBQUJCKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRtcCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSBvcHRpb25zLmxvd2VyQm91bmQgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvd2VyQm91bmQpIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51cHBlckJvdW5kID0gb3B0aW9ucy51cHBlckJvdW5kID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy51cHBlckJvdW5kKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLCB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGFuZ2xlLlxyXG4gICAgICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYW5nbGU9MF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpblNpemU9MF0gU29tZSBtYXJnaW4gdG8gYmUgYWRkZWQgdG8gdGhlIEFBQkIuXHJcbiAgICAgKi9cclxuICAgIEFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKSB7XHJcbiAgICAgICAgaWYgKHNraW5TaXplID09PSB2b2lkIDApIHsgc2tpblNpemUgPSAwOyB9XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsIHUgPSB0aGlzLnVwcGVyQm91bmQ7XHJcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xyXG4gICAgICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcclxuICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKGwsIHBvaW50c1swXSwgYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsLCBwb2ludHNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHUsIGwpO1xyXG4gICAgICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXHJcbiAgICAgICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLCBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHBbMF0sIHkgPSBwWzFdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50bXBbMF0gPSBjb3NBbmdsZSAqIHggLSBzaW5BbmdsZSAqIHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRtcFsxXSA9IHNpbkFuZ2xlICogeCArIGNvc0FuZ2xlICogeTtcclxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLnRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBbal0gPiB1W2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdVtqXSA9IHBbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocFtqXSA8IGxbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgb2Zmc2V0XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChsLCBsLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1LCB1LCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChza2luU2l6ZSkge1xyXG4gICAgICAgICAgICBsWzBdIC09IHNraW5TaXplO1xyXG4gICAgICAgICAgICBsWzFdIC09IHNraW5TaXplO1xyXG4gICAgICAgICAgICB1WzBdICs9IHNraW5TaXplO1xyXG4gICAgICAgICAgICB1WzFdICs9IHNraW5TaXplO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYm91bmRzIGZyb20gYW4gQUFCQiB0byB0aGlzIEFBQkJcclxuICAgICAqIEBtZXRob2QgY29weVxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGFhYmIpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMubG93ZXJCb3VuZCwgYWFiYi5sb3dlckJvdW5kKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgQUFCQi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGFhYmIpIHtcclxuICAgICAgICB2YXIgbG93ZXIgPSB0aGlzLmxvd2VyQm91bmQsIHVwcGVyID0gdGhpcy51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciB4IGFuZCB5XHJcbiAgICAgICAgdmFyIGkgPSAyO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXHJcbiAgICAgICAgICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kW2ldO1xyXG4gICAgICAgICAgICBpZiAobG93ZXJbaV0gPiBsKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlcltpXSA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBwZXJcclxuICAgICAgICAgICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmRbaV07XHJcbiAgICAgICAgICAgIGlmICh1cHBlcltpXSA8IHUpIHtcclxuICAgICAgICAgICAgICAgIHVwcGVyW2ldID0gdTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXHJcbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChhYWJiKSB7XHJcbiAgICAgICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLCB1MSA9IHRoaXMudXBwZXJCb3VuZCwgbDIgPSBhYWJiLmxvd2VyQm91bmQsIHUyID0gYWFiYi51cHBlckJvdW5kO1xyXG4gICAgICAgIC8vICAgICAgbDIgICAgICAgIHUyXHJcbiAgICAgICAgLy8gICAgICB8LS0tLS0tLS0tfFxyXG4gICAgICAgIC8vIHwtLS0tLS0tLXxcclxuICAgICAgICAvLyBsMSAgICAgICB1MVxyXG4gICAgICAgIHJldHVybiAoKGwyWzBdIDw9IHUxWzBdICYmIHUxWzBdIDw9IHUyWzBdKSB8fCAobDFbMF0gPD0gdTJbMF0gJiYgdTJbMF0gPD0gdTFbMF0pKSAmJlxyXG4gICAgICAgICAgICAoKGwyWzFdIDw9IHUxWzFdICYmIHUxWzFdIDw9IHUyWzFdKSB8fCAobDFbMV0gPD0gdTJbMV0gJiYgdTJbMV0gPD0gdTFbMV0pKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29udGFpbnNQb2ludFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBBQUJCLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsIHUgPSB0aGlzLnVwcGVyQm91bmQ7XHJcbiAgICAgICAgcmV0dXJuIGxbMF0gPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gdVswXSAmJiBsWzFdIDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDw9IHVbMV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuXHJcbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzUmF5XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSBpZiBubyBoaXQsIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpZiBoaXQsIGluZGljYXRpbmcgdGhlIHBvc2l0aW9uIGJldHdlZW4gdGhlIFwiZnJvbVwiIGFuZCBcInRvXCIgcG9pbnRzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYWFiYiA9IG5ldyBBQUJCKHtcclxuICAgICAqICAgICAgICAgdXBwZXJCb3VuZDogWzEsIDFdLFxyXG4gICAgICogICAgICAgICBsb3dlckJvdW5kOiBbLTEsIC0xXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByYXkgPSBuZXcgUmF5KHtcclxuICAgICAqICAgICAgICAgZnJvbTogWy0yLCAwXSxcclxuICAgICAqICAgICAgICAgdG86IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBmcmFjdGlvbiA9IGFhYmIub3ZlcmxhcHNSYXkocmF5KTsgLy8gZnJhY3Rpb24gPT0gMC41XHJcbiAgICAgKi9cclxuICAgIEFBQkIucHJvdG90eXBlLm92ZXJsYXBzUmF5ID0gZnVuY3Rpb24gKHJheSkge1xyXG4gICAgICAgIC8vIHJheS5kaXJlY3Rpb24gaXMgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIG9mIHJheVxyXG4gICAgICAgIHZhciBkaXJGcmFjWCA9IDEgLyByYXkuZGlyZWN0aW9uWzBdO1xyXG4gICAgICAgIHZhciBkaXJGcmFjWSA9IDEgLyByYXkuZGlyZWN0aW9uWzFdO1xyXG4gICAgICAgIC8vIHRoaXMubG93ZXJCb3VuZCBpcyB0aGUgY29ybmVyIG9mIEFBQkIgd2l0aCBtaW5pbWFsIGNvb3JkaW5hdGVzIC0gbGVmdCBib3R0b20sIHJ0IGlzIG1heGltYWwgY29ybmVyXHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbTtcclxuICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IHRoaXMubG93ZXJCb3VuZDtcclxuICAgICAgICB2YXIgdXBwZXJCb3VuZCA9IHRoaXMudXBwZXJCb3VuZDtcclxuICAgICAgICB2YXIgdDEgPSAobG93ZXJCb3VuZFswXSAtIGZyb21bMF0pICogZGlyRnJhY1g7XHJcbiAgICAgICAgdmFyIHQyID0gKHVwcGVyQm91bmRbMF0gLSBmcm9tWzBdKSAqIGRpckZyYWNYO1xyXG4gICAgICAgIHZhciB0MyA9IChsb3dlckJvdW5kWzFdIC0gZnJvbVsxXSkgKiBkaXJGcmFjWTtcclxuICAgICAgICB2YXIgdDQgPSAodXBwZXJCb3VuZFsxXSAtIGZyb21bMV0pICogZGlyRnJhY1k7XHJcbiAgICAgICAgdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKTtcclxuICAgICAgICB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpO1xyXG4gICAgICAgIC8vIGlmIHRtYXggPCAwLCByYXkgKGxpbmUpIGlzIGludGVyc2VjdGluZyBBQUJCLCBidXQgd2hvbGUgQUFCQiBpcyBiZWhpbmcgdXNcclxuICAgICAgICBpZiAodG1heCA8IDApIHtcclxuICAgICAgICAgICAgLy90ID0gdG1heDtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0bWluID4gdG1heCwgcmF5IGRvZXNuJ3QgaW50ZXJzZWN0IEFBQkJcclxuICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHtcclxuICAgICAgICAgICAgLy90ID0gdG1heDtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG1pbiAvIHJheS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFBQkI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFBQkI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBCb2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL29iamVjdHMvQm9keVwiKSk7XHJcbi8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBzdXBwb3NlZCB0byBiZSBhYnN0cmFjdC5cclxudmFyIEJyb2FkcGhhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zLiBEb24ndCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseS5cclxuICAgICAqIEBjbGFzcyBCcm9hZHBoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnJvYWRwaGFzZSh0eXBlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdWx0XHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBmb3IgY29sbGlzaW9uIHBhaXJzIGluLiBUbyBjaGFuZ2UgaXQsIHVzZSAuc2V0V29ybGQoKVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxyXG4gICAgICAgICAqIEB0eXBlIHtXb3JsZH1cclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgdm9sdW1lIHR5cGUgdG8gdXNlIGluIHRoZSBicm9hZHBoYXNlIGFsZ29yaXRobXMuIFNob3VsZCBiZSBzZXQgdG8gQnJvYWRwaGFzZS5BQUJCIG9yIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1ZvbHVtZVR5cGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSA9IEJyb2FkcGhhc2UuQUFCQjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogbW92ZSB0byBjb25zdHJ1Y3RvciFcclxuICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZCA9IHdvcmxkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qXHJcbiAgICAgKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKHdvcmxkKSB7XHJcbiAgICAgICAgLy8gSSBndWVzcyB0aGlzIHNob3VsZCBiZSBvdmVycmlkZGVuP1xyXG4gICAgICAgIC8vIFRPRE86IHBvc3NpYmxlIGFic3RyYWN0IG1ldGhvZC5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIGQyID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbiksIHIgPSBib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgICAgIHJldHVybiBkMiA8PSByICogcjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIEFBQkIgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYWFiYkNoZWNrXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIEJyb2FkcGhhc2UuYWFiYkNoZWNrID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHJldHVybiBib2R5QS5nZXRBQUJCKCkub3ZlcmxhcHMoYm9keUIuZ2V0QUFCQigpKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHZvbHVtZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxyXG4gICAgICogQG1ldGhvZCAgYm91bmRpbmdWb2x1bWVDaGVja1xyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBCcm9hZHBoYXNlLmFhYmJDaGVjayhib2R5QSwgYm9keUIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kaW5nIHZvbHVtZSB0eXBlIG5vdCByZWNvZ25pemVkOiAnICsgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGNvbGxpZGUgYXQgYWxsLlxyXG4gICAgICogQG1ldGhvZCAgY2FuQ29sbGlkZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLmNhbkNvbGxpZGUgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIEtJTkVNQVRJQyA9IEJvZHlfMS5kZWZhdWx0LktJTkVNQVRJQztcclxuICAgICAgICB2YXIgU1RBVElDID0gQm9keV8xLmRlZmF1bHQuU1RBVElDO1xyXG4gICAgICAgIHZhciB0eXBlQSA9IGJvZHlBLnR5cGU7XHJcbiAgICAgICAgdmFyIHR5cGVCID0gYm9keUIudHlwZTtcclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBzdGF0aWMgYm9kaWVzXHJcbiAgICAgICAgaWYgKHR5cGVBID09PSBTVEFUSUMgJiYgdHlwZUIgPT09IFNUQVRJQykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyB2cyBraW5lbWF0aWMgYm9kaWVzXHJcbiAgICAgICAgaWYgKCh0eXBlQSA9PT0gS0lORU1BVElDICYmIHR5cGVCID09PSBTVEFUSUMpIHx8XHJcbiAgICAgICAgICAgICh0eXBlQSA9PT0gU1RBVElDICYmIHR5cGVCID09PSBLSU5FTUFUSUMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2Fubm90IGNvbGxpZGUga2luZW1hdGljIHZzIGtpbmVtYXRpY1xyXG4gICAgICAgIGlmICh0eXBlQSA9PT0gS0lORU1BVElDICYmIHR5cGVCID09PSBLSU5FTUFUSUMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xyXG4gICAgICAgIGlmIChib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5XzEuZGVmYXVsdC5TTEVFUElORyAmJiBib2R5Qi5zbGVlcFN0YXRlID09PSBCb2R5XzEuZGVmYXVsdC5TTEVFUElORykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbm5vdCBjb2xsaWRlIGlmIG9uZSBpcyBzdGF0aWMgYW5kIHRoZSBvdGhlciBpcyBzbGVlcGluZ1xyXG4gICAgICAgIGlmICgoYm9keUEuc2xlZXBTdGF0ZSA9PT0gQm9keV8xLmRlZmF1bHQuU0xFRVBJTkcgJiYgdHlwZUIgPT09IFNUQVRJQykgfHxcclxuICAgICAgICAgICAgKGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HICYmIHR5cGVBID09PSBTVEFUSUMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxyXG4gICAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24gKHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcclxuICAgICAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLy8gTW9kZTpcclxuICAgIEJyb2FkcGhhc2UuTkFJVkUgPSAxO1xyXG4gICAgQnJvYWRwaGFzZS5TQVAgPSAyO1xyXG4gICAgLy8gQm91bmRpbmcgYm94OlxyXG4gICAgLyoqXHJcbiAgICAgKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHR5cGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQUFCQlxyXG4gICAgICovXHJcbiAgICBCcm9hZHBoYXNlLkFBQkIgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcclxuICAgICAqL1xyXG4gICAgQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xyXG4gICAgcmV0dXJuIEJyb2FkcGhhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJyb2FkcGhhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBicm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnJvYWRwaGFzZVwiKSk7XHJcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmFpdmVCcm9hZHBoYXNlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLiBEb2VzIE5eMiB0ZXN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEJyb2FkcGhhc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBicm9hZHBoYXNlXzEuZGVmYXVsdC5OQUlWRSkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLCByZXN1bHQgPSB0aGlzLnJlc3VsdDtcclxuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTmNvbGxpZGluZyA9IGJvZGllcy5sZW5ndGg7IGkgIT09IE5jb2xsaWRpbmc7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJvYWRwaGFzZV8xLmRlZmF1bHQuY2FuQ29sbGlkZShiaSwgYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSwgYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cclxuICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24gKHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgaWYgKGIuYWFiYk5lZWRzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBOYWl2ZUJyb2FkcGhhc2U7XHJcbn0oYnJvYWRwaGFzZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTmFpdmVCcm9hZHBoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgc3ViID0gdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QsIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZCwgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90LCByb3RhdGUgPSB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUsIG5vcm1hbGl6ZSA9IHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSwgY29weSA9IHZlYzJfMS5kZWZhdWx0LmNvcHksIHNjYWxlID0gdmVjMl8xLmRlZmF1bHQuc2NhbGUsIHNxdWFyZWRMZW5ndGggPSB2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkTGVuZ3RoLCBjcmVhdGVWZWMyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlO1xyXG52YXIgQ2lyY2xlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9DaXJjbGVcIikpO1xyXG52YXIgQ29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Db252ZXhcIikpO1xyXG52YXIgQm94XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Cb3hcIikpO1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2NvbnRhY3QtZXF1YXRpb24tcG9vbFwiKSk7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2ZyaWN0aW9uLWVxdWF0aW9uLXBvb2xcIikpO1xyXG52YXIgdHVwbGVfZGljdGlvbmFyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy90dXBsZS1kaWN0aW9uYXJ5XCIpKTtcclxudmFyIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIHRtcDEgPSBjcmVhdGVWZWMyKCksIHRtcDIgPSBjcmVhdGVWZWMyKCksIHRtcDMgPSBjcmVhdGVWZWMyKCksIHRtcDQgPSBjcmVhdGVWZWMyKCksIHRtcDUgPSBjcmVhdGVWZWMyKCksIHRtcDYgPSBjcmVhdGVWZWMyKCksIHRtcDcgPSBjcmVhdGVWZWMyKCksIHRtcDggPSBjcmVhdGVWZWMyKCksIHRtcDkgPSBjcmVhdGVWZWMyKCksIHRtcDEwID0gY3JlYXRlVmVjMigpLCB0bXAxMSA9IGNyZWF0ZVZlYzIoKSwgdG1wMTIgPSBjcmVhdGVWZWMyKCksIHRtcDEzID0gY3JlYXRlVmVjMigpLCB0bXAxNCA9IGNyZWF0ZVZlYzIoKSwgdG1wMTUgPSBjcmVhdGVWZWMyKCksIHRtcEFycmF5ID0gW107XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl92MSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgZmluZE1heFNlcGFyYXRpb25fdG1wID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kTWF4U2VwYXJhdGlvbl90bXAyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBmaW5kSW5jaWRlbnRFZGdlX25vcm1hbDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc190ZW1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfdG1wVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfbG9jYWxUYW5nZW50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfbG9jYWxOb3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19wbGFuZVBvaW50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfdGFuZ2VudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX25vcm1hbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX25lZ2F0aXZlVGFuZ2VudCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3YxMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX3YxMiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2Rpc3QgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGNvbGxpZGVQb2x5Z29uc19jbGlwUG9pbnRzMSA9IFt2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCldO1xyXG52YXIgY29sbGlkZVBvbHlnb25zX2NsaXBQb2ludHMyID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbnZhciBjb2xsaWRlUG9seWdvbnNfaW5jaWRlbnRFZGdlID0gW3ZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKV07XHJcbnZhciBwaWNfbG9jYWxQb2ludCA9IGNyZWF0ZVZlYzIoKSwgcGljX3IwID0gY3JlYXRlVmVjMigpLCBwaWNfcjEgPSBjcmVhdGVWZWMyKCk7XHJcbnZhciBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BID0gY3JlYXRlVmVjMigpLCBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEgPSBjcmVhdGVWZWMyKCksIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gY3JlYXRlVmVjMigpO1xyXG52YXIgcGxhbmVDYXBzdWxlX3RtcDEgPSBjcmVhdGVWZWMyKCksIHBsYW5lQ2Fwc3VsZV90bXAyID0gY3JlYXRlVmVjMigpO1xyXG52YXIgY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0ID0gY3JlYXRlVmVjMigpLCBjaXJjbGVIZWlnaHRmaWVsZF92MCA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfdjEgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSA9IGNyZWF0ZVZlYzIoKSwgY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSBjcmVhdGVWZWMyKCksIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCA9IGNyZWF0ZVZlYzIoKTtcclxudmFyIGNvbnZleEhlaWdodGZpZWxkX3YwID0gY3JlYXRlVmVjMigpLCBjb252ZXhIZWlnaHRmaWVsZF92MSA9IGNyZWF0ZVZlYzIoKSwgY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyA9IGNyZWF0ZVZlYzIoKSwgY29udmV4SGVpZ2h0ZmllbGRfdGVtcENvbnZleFNoYXBlID0gbmV3IENvbnZleF8xLmRlZmF1bHQodW5kZWZpbmVkLCBbY3JlYXRlVmVjMigpLCBjcmVhdGVWZWMyKCksIGNyZWF0ZVZlYzIoKSwgY3JlYXRlVmVjMigpXSk7XHJcbmZ1bmN0aW9uIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKGNvbnZleFNoYXBlLCBjYXBzdWxlU2hhcGUpIHtcclxuICAgIHZhciBjYXBzdWxlUmFkaXVzID0gY2Fwc3VsZVNoYXBlLnJhZGl1cztcclxuICAgIHZhciBoYWxmQ2Fwc3VsZUxlbmd0aCA9IGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjU7XHJcbiAgICB2YXIgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcclxuICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2ZXJ0c1swXSwgLWhhbGZDYXBzdWxlTGVuZ3RoLCAtY2Fwc3VsZVJhZGl1cyk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbMV0sIGhhbGZDYXBzdWxlTGVuZ3RoLCAtY2Fwc3VsZVJhZGl1cyk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodmVydHNbMl0sIGhhbGZDYXBzdWxlTGVuZ3RoLCBjYXBzdWxlUmFkaXVzKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2ZXJ0c1szXSwgLWhhbGZDYXBzdWxlTGVuZ3RoLCBjYXBzdWxlUmFkaXVzKTtcclxufVxyXG4vKlxyXG4qIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYSBwb2x5Z29uXHJcbiovXHJcbmZ1bmN0aW9uIHBvaW50SW5Db252ZXgod29ybGRQb2ludCwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUpIHtcclxuICAgIHZhciBsb2NhbFBvaW50ID0gcGljX2xvY2FsUG9pbnQsIHIwID0gcGljX3IwLCByMSA9IHBpY19yMSwgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcywgbGFzdENyb3NzID0gbnVsbDtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFBvaW50LCB3b3JsZFBvaW50LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDsgaSAhPT0gbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpICUgbnVtVmVydHNdLCB2MSA9IHZlcnRzWyhpICsgMSkgJSBudW1WZXJ0c107XHJcbiAgICAgICAgc3ViKHIwLCB2MCwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgc3ViKHIxLCB2MSwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgdmFyIGNyb3NzID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocjAsIHIxKTtcclxuICAgICAgICBpZiAobGFzdENyb3NzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgaWYgKGNyb3NzICogbGFzdENyb3NzIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLypcclxuKiBDaGVjayBpZiBhIHBvaW50IGlzIGluIGEgcG9seWdvblxyXG4qL1xyXG5mdW5jdGlvbiBwb2ludEluQ29udmV4TG9jYWwobG9jYWxQb2ludCwgY29udmV4U2hhcGUpIHtcclxuICAgIHZhciByMCA9IHBpY19yMCwgcjEgPSBwaWNfcjEsIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXMsIGxhc3RDcm9zcyA9IG51bGwsIG51bVZlcnRzID0gdmVydHMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0cyArIDE7IGkrKykge1xyXG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kgJSBudW1WZXJ0c10sIHYxID0gdmVydHNbKGkgKyAxKSAlIG51bVZlcnRzXTtcclxuICAgICAgICBzdWIocjAsIHYwLCBsb2NhbFBvaW50KTtcclxuICAgICAgICBzdWIocjEsIHYxLCBsb2NhbFBvaW50KTtcclxuICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyMCwgcjEpO1xyXG4gICAgICAgIGlmIChsYXN0Q3Jvc3MgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdvdCBhIGRpZmZlcmVudCBzaWduIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3IsIHRoZSBwb2ludCBpcyBvdXQgb2YgdGhlIHBvbHlnb25cclxuICAgICAgICBpZiAoY3Jvc3MgKiBsYXN0Q3Jvc3MgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBhZGRTdWIob3V0LCBhLCBiLCBjKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXSAtIGNbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXSAtIGNbMV07XHJcbn1cclxuZnVuY3Rpb24gZmluZE1heFNlcGFyYXRpb24obWF4U2VwYXJhdGlvbk91dCwgcG9seTEsIHBvc2l0aW9uMSwgYW5nbGUxLCBwb2x5MiwgcG9zaXRpb24yLCBhbmdsZTIpIHtcclxuICAgIC8vIEZpbmQgdGhlIG1heCBzZXBhcmF0aW9uIGJldHdlZW4gcG9seTEgYW5kIHBvbHkyIHVzaW5nIGVkZ2Ugbm9ybWFscyBmcm9tIHBvbHkxLlxyXG4gICAgdmFyIGNvdW50MSA9IHBvbHkxLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHZhciBjb3VudDIgPSBwb2x5Mi52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICB2YXIgbjFzID0gcG9seTEubm9ybWFscztcclxuICAgIHZhciB2MXMgPSBwb2x5MS52ZXJ0aWNlcztcclxuICAgIHZhciB2MnMgPSBwb2x5Mi52ZXJ0aWNlcztcclxuICAgIHZhciBuID0gZmluZE1heFNlcGFyYXRpb25fbjtcclxuICAgIHZhciB2MSA9IGZpbmRNYXhTZXBhcmF0aW9uX3YxO1xyXG4gICAgdmFyIHRtcCA9IGZpbmRNYXhTZXBhcmF0aW9uX3RtcDtcclxuICAgIHZhciB0bXAyID0gZmluZE1heFNlcGFyYXRpb25fdG1wMjtcclxuICAgIHZhciBhbmdsZSA9IGFuZ2xlMSAtIGFuZ2xlMjtcclxuICAgIHZhciBiZXN0SW5kZXggPSAwO1xyXG4gICAgdmFyIG1heFNlcGFyYXRpb24gPSAtSW5maW5pdHk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MTsgKytpKSB7XHJcbiAgICAgICAgLy8gR2V0IHBvbHkxIG5vcm1hbCBpbiBmcmFtZTIuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG4sIG4xc1tpXSwgYW5nbGUpO1xyXG4gICAgICAgIC8vIEdldCBwb2x5MSB2ZXJ0ZXggaW4gZnJhbWUyXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh0bXAyLCB2MXNbaV0sIHBvc2l0aW9uMSwgYW5nbGUxKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUodjEsIHRtcDIsIHBvc2l0aW9uMiwgYW5nbGUyKTtcclxuICAgICAgICAvLyBGaW5kIGRlZXBlc3QgcG9pbnQgZm9yIG5vcm1hbCBpLlxyXG4gICAgICAgIHZhciBzaSA9IEluZmluaXR5O1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQyOyArK2opIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodG1wLCB2MnNbal0sIHYxKTtcclxuICAgICAgICAgICAgdmFyIHNpaiA9IHZlYzJfMS5kZWZhdWx0LmRvdChuLCB0bXApO1xyXG4gICAgICAgICAgICBpZiAoc2lqIDwgc2kpIHtcclxuICAgICAgICAgICAgICAgIHNpID0gc2lqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaSA+IG1heFNlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgbWF4U2VwYXJhdGlvbiA9IHNpO1xyXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFVzZSBhIHZlYzIgZm9yIHN0b3JpbmcgdGhlIGZsb2F0IHZhbHVlIGFuZCBhbHdheXMgcmV0dXJuIGludCwgZm9yIHBlcmZcclxuICAgIG1heFNlcGFyYXRpb25PdXRbMF0gPSBtYXhTZXBhcmF0aW9uO1xyXG4gICAgcmV0dXJuIGJlc3RJbmRleDtcclxufVxyXG5mdW5jdGlvbiBmaW5kSW5jaWRlbnRFZGdlKGNsaXBWZXJ0aWNlc091dCwgcG9seTEsIHBvc2l0aW9uMSwgYW5nbGUxLCBlZGdlMSwgcG9seTIsIHBvc2l0aW9uMiwgYW5nbGUyKSB7XHJcbiAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5ub3JtYWxzO1xyXG4gICAgdmFyIGNvdW50MiA9IHBvbHkyLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi52ZXJ0aWNlcztcclxuICAgIHZhciBub3JtYWxzMiA9IHBvbHkyLm5vcm1hbHM7XHJcbiAgICAvLyBHZXQgdGhlIG5vcm1hbCBvZiB0aGUgcmVmZXJlbmNlIGVkZ2UgaW4gcG9seTIncyBmcmFtZS5cclxuICAgIHZhciBub3JtYWwxID0gZmluZEluY2lkZW50RWRnZV9ub3JtYWwxO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG5vcm1hbDEsIG5vcm1hbHMxW2VkZ2UxXSwgYW5nbGUxIC0gYW5nbGUyKTtcclxuICAgIC8vIEZpbmQgdGhlIGluY2lkZW50IGVkZ2Ugb24gcG9seTIuXHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIG1pbkRvdCA9IEluZmluaXR5O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xyXG4gICAgICAgIHZhciBkb3RfMSA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwxLCBub3JtYWxzMltpXSk7XHJcbiAgICAgICAgaWYgKGRvdF8xIDwgbWluRG90KSB7XHJcbiAgICAgICAgICAgIG1pbkRvdCA9IGRvdF8xO1xyXG4gICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgdGhlIGNsaXAgdmVydGljZXMgZm9yIHRoZSBpbmNpZGVudCBlZGdlLlxyXG4gICAgdmFyIGkxID0gaW5kZXg7XHJcbiAgICB2YXIgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xyXG4gICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShjbGlwVmVydGljZXNPdXRbMF0sIHZlcnRpY2VzMltpMV0sIHBvc2l0aW9uMiwgYW5nbGUyKTtcclxuICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2xpcFZlcnRpY2VzT3V0WzFdLCB2ZXJ0aWNlczJbaTJdLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbn1cclxuZnVuY3Rpb24gY2xpcFNlZ21lbnRUb0xpbmUodk91dCwgdkluLCBub3JtYWwsIG9mZnNldCkge1xyXG4gICAgLy8gU3RhcnQgd2l0aCBubyBvdXRwdXQgcG9pbnRzXHJcbiAgICB2YXIgbnVtT3V0ID0gMDtcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgZW5kIHBvaW50cyB0byB0aGUgbGluZVxyXG4gICAgdmFyIGRpc3RhbmNlMCA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHZJblswXSkgLSBvZmZzZXQ7XHJcbiAgICB2YXIgZGlzdGFuY2UxID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdkluWzFdKSAtIG9mZnNldDtcclxuICAgIC8vIElmIHRoZSBwb2ludHMgYXJlIGJlaGluZCB0aGUgcGxhbmVcclxuICAgIGlmIChkaXN0YW5jZTAgPD0gMC4wKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2T3V0W251bU91dCsrXSwgdkluWzBdKTtcclxuICAgIH1cclxuICAgIGlmIChkaXN0YW5jZTEgPD0gMC4wKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2T3V0W251bU91dCsrXSwgdkluWzFdKTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBwb2ludHMgYXJlIG9uIGRpZmZlcmVudCBzaWRlcyBvZiB0aGUgcGxhbmVcclxuICAgIGlmIChkaXN0YW5jZTAgKiBkaXN0YW5jZTEgPCAwLjApIHtcclxuICAgICAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBwb2ludCBvZiBlZGdlIGFuZCBwbGFuZVxyXG4gICAgICAgIHZhciBpbnRlcnAgPSBkaXN0YW5jZTAgLyAoZGlzdGFuY2UwIC0gZGlzdGFuY2UxKTtcclxuICAgICAgICB2YXIgdiA9IHZPdXRbbnVtT3V0XTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh2LCB2SW5bMV0sIHZJblswXSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodiwgdiwgaW50ZXJwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQodiwgdiwgdkluWzBdKTtcclxuICAgICAgICArK251bU91dDtcclxuICAgIH1cclxuICAgIHJldHVybiBudW1PdXQ7XHJcbn1cclxudmFyIE5hcnJvd3BoYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYXJyb3dwaGFzZS4gQ3JlYXRlcyBjb250YWN0cyBhbmQgZnJpY3Rpb24gZ2l2ZW4gc2hhcGVzIGFuZCB0cmFuc2Zvcm1zLlxyXG4gICAgICogQGNsYXNzIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTmFycm93cGhhc2UoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZyaWN0aW9uRXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZnJpY3Rpb24gZXF1YXRpb25zIGluIHRoZSB1cGNvbWluZyBjb250YWN0cy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZXF1YXRpb25zIGVuYWJsZWQgaW4gdXBjb21pbmcgY29udGFjdHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGVuYWJsZWRFcXVhdGlvbnNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWRFcXVhdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmcmljdGlvbiBzbGlwIGZvcmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xpcEZvcmNlXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNsaXBGb3JjZSA9IDEwLjA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFsbG9jYXRlZCBDb250YWN0RXF1YXRpb25zLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9uUG9vbH0gY29udGFjdEVxdWF0aW9uUG9vbFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBBbGxvY2F0ZSBhIGZldyBlcXVhdGlvbnMgYmVmb3JlIHN0YXJ0aW5nIHRoZSBzaW11bGF0aW9uLlxyXG4gICAgICAgICAqICAgICAvLyBUaGlzIHdheSwgbm8gY29udGFjdCBvYmplY3RzIG5lZWQgdG8gYmUgY3JlYXRlZCBvbiB0aGUgZmx5IGluIHRoZSBnYW1lIGxvb3AuXHJcbiAgICAgICAgICogICAgIHdvcmxkLm5hcnJvd3BoYXNlLmNvbnRhY3RFcXVhdGlvblBvb2wucmVzaXplKDEwMjQpO1xyXG4gICAgICAgICAqICAgICB3b3JsZC5uYXJyb3dwaGFzZS5mcmljdGlvbkVxdWF0aW9uUG9vbC5yZXNpemUoMTAyNCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25Qb29sID0gbmV3IGNvbnRhY3RfZXF1YXRpb25fcG9vbF8xLmRlZmF1bHQoeyBzaXplOiAzMiB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYWxsb2NhdGVkIENvbnRhY3RFcXVhdGlvbnMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGcmljdGlvbkVxdWF0aW9uUG9vbH0gZnJpY3Rpb25FcXVhdGlvblBvb2xcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gbmV3IGZyaWN0aW9uX2VxdWF0aW9uX3Bvb2xfMS5kZWZhdWx0KHsgc2l6ZTogNjQgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY29sbGlkaW5nIGJvZGllcyBsYXN0IHN0ZXAuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXBcclxuICAgICAgICAgKiBAdHlwZSB7VHVwbGVEaWN0aW9uYXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAgPSBuZXcgdHVwbGVfZGljdGlvbmFyeV8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkgY3VycmVudENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICAgICAqIEB0eXBlIHtDb250YWN0TWF0ZXJpYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBib2RpZXNPdmVybGFwXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtjaGVja0NvbGxpc2lvbk1hc2tzPWZhbHNlXVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmJvZGllc092ZXJsYXAgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBjaGVja0NvbGxpc2lvbk1hc2tzKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uTWFza3MgPT09IHZvaWQgMCkgeyBjaGVja0NvbGxpc2lvbk1hc2tzID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgc2hhcGVQb3NpdGlvbkEgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25BO1xyXG4gICAgICAgIHZhciBzaGFwZVBvc2l0aW9uQiA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkI7XHJcbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keUFcclxuICAgICAgICBmb3IgKHZhciBrID0gMCwgTnNoYXBlc2kgPSBib2R5QS5zaGFwZXMubGVuZ3RoOyBrICE9PSBOc2hhcGVzaTsgaysrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZUEgPSBib2R5QS5zaGFwZXNba107XHJcbiAgICAgICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXHJcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBOc2hhcGVzaiA9IGJvZHlCLnNoYXBlcy5sZW5ndGg7IGwgIT09IE5zaGFwZXNqOyBsKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZUIgPSBib2R5Qi5zaGFwZXNbbF07XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uTWFza3MgJiYgISgoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spICE9PSAwICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykgIT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBzaGFwZUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgYm9keUIudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25CLCBzaGFwZUIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudGVzdENvbnRhY3QoYm9keUEsIHNoYXBlQSwgc2hhcGVQb3NpdGlvbkEsIGJvZHlCLCBzaGFwZUIsIHNoYXBlUG9zaXRpb25CLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIGJvZGllcyB3ZXJlIGluIGNvbnRhY3Qgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cclxuICAgICAqIEBtZXRob2QgY29sbGlkZWRMYXN0U3RlcFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29sbGlkZWRMYXN0U3RlcCA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgaWQxID0gYm9keUEuaWQgfCAwLCBpZDIgPSBib2R5Qi5pZCB8IDA7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5nZXQoaWQxLCBpZDIpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGF3YXkgdGhlIG9sZCBlcXVhdGlvbnMgYW5kIGdldHMgcmVhZHkgdG8gY3JlYXRlIG5ld1xyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcC5yZXNldCgpO1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnM7XHJcbiAgICAgICAgdmFyIGwgPSBlcXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gZXFzW2xdLCBpZDEgPSBlcS5ib2R5QS5pZCwgaWQyID0gZXEuYm9keUIuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuc2V0KGlkMSwgaWQyLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNlID0gdGhpcy5jb250YWN0RXF1YXRpb25zLCBmZSA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wucmVsZWFzZShjZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5yZWxlYXNlKGZlW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVzZXRcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIENvbnRhY3RFcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wuZ2V0KCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XHJcbiAgICAgICAgYy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIGMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICBjLnNoYXBlQSA9IHNoYXBlQTtcclxuICAgICAgICBjLnNoYXBlQiA9IHNoYXBlQjtcclxuICAgICAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XHJcbiAgICAgICAgYy5maXJzdEltcGFjdCA9ICF0aGlzLmNvbGxpZGVkTGFzdFN0ZXAoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICBjLnJlc3RpdHV0aW9uID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5yZXN0aXR1dGlvbjtcclxuICAgICAgICBjLnN0aWZmbmVzcyA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuc3RpZmZuZXNzO1xyXG4gICAgICAgIGMucmVsYXhhdGlvbiA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwucmVsYXhhdGlvbjtcclxuICAgICAgICBjLm9mZnNldCA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuY29udGFjdFNraW5TaXplO1xyXG4gICAgICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24gPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBzaGFwZUEsIHNoYXBlQikge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5nZXQoKTtcclxuICAgICAgICB2YXIgY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcclxuICAgICAgICBjLmJvZHlBID0gYm9keUE7XHJcbiAgICAgICAgYy5ib2R5QiA9IGJvZHlCO1xyXG4gICAgICAgIGMuc2hhcGVBID0gc2hhcGVBO1xyXG4gICAgICAgIGMuc2hhcGVCID0gc2hhcGVCO1xyXG4gICAgICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcclxuICAgICAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XHJcbiAgICAgICAgYy5mcmljdGlvbkNvZWZmaWNpZW50ID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5mcmljdGlvbjtcclxuICAgICAgICBjLnJlbGF0aXZlVmVsb2NpdHkgPSBjdXJyZW50Q29udGFjdE1hdGVyaWFsLnN1cmZhY2VWZWxvY2l0eTtcclxuICAgICAgICBjLnN0aWZmbmVzcyA9IGN1cnJlbnRDb250YWN0TWF0ZXJpYWwuZnJpY3Rpb25TdGlmZm5lc3M7XHJcbiAgICAgICAgYy5yZWxheGF0aW9uID0gY3VycmVudENvbnRhY3RNYXRlcmlhbC5mcmljdGlvblJlbGF4YXRpb247XHJcbiAgICAgICAgYy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgYy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiBnaXZlbiB0aGUgZGF0YSBpbiB0aGUgQ29udGFjdEVxdWF0aW9uLiBVc2VzIHNhbWUgb2Zmc2V0IHZlY3RvcnMgcmkgYW5kIHJqLCBidXQgdGhlIHRhbmdlbnQgdmVjdG9yIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgY29sbGlzaW9uIG5vcm1hbC5cclxuICAgICAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdFxyXG4gICAgICogQHBhcmFtICB7Q29udGFjdEVxdWF0aW9ufSBjb250YWN0RXF1YXRpb25cclxuICAgICAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XHJcbiAgICAgKi9cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcclxuICAgICAgICBjb3B5KGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XHJcbiAgICAgICAgY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3coZXEudCwgYy5ub3JtYWxBKTtcclxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgcmV0dXJuIGVxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uIChudW1Db250YWN0cykge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb24oYy5ib2R5QSwgYy5ib2R5QiwgYy5zaGFwZUEsIGMuc2hhcGVCKTtcclxuICAgICAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoZXEuY29udGFjdFBvaW50QiwgMCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGVxLnQsIDAsIDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29udGFjdHM7IGkrKykge1xyXG4gICAgICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XHJcbiAgICAgICAgICAgIGlmIChjLmJvZHlBID09PSBib2R5QSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcclxuICAgICAgICAgICAgICAgIGFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBhZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRCKTtcclxuICAgICAgICAgICAgICAgIGFkZChlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzO1xyXG4gICAgICAgIHNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcclxuICAgICAgICBzY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XHJcbiAgICAgICAgbm9ybWFsaXplKGVxLnQsIGVxLnQpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XHJcbiAgICAgICAgcmV0dXJuIGVxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS50ZXN0Q29udGFjdCA9IGZ1bmN0aW9uIChib2R5QSwgc2hhcGVBLCBvZmZzZXRBLCBib2R5Qiwgc2hhcGVCLCBvZmZzZXRCLCBqdXN0VGVzdFxyXG4gICAgLy8gbWV0YT86IHtcclxuICAgIC8vIFx0cmFkaXVzQT86IGYzMixcclxuICAgIC8vIFx0cmFkaXVzQj86IGYzMlxyXG4gICAgLy8gfVxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IDA7XHJcbiAgICAgICAgaWYgKHNoYXBlQS50eXBlID4gc2hhcGVCLnR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGJUbXAgPSBib2R5QjtcclxuICAgICAgICAgICAgYm9keUIgPSBib2R5QTtcclxuICAgICAgICAgICAgYm9keUEgPSBiVG1wO1xyXG4gICAgICAgICAgICB2YXIgc1RtcCA9IHNoYXBlQjtcclxuICAgICAgICAgICAgc2hhcGVCID0gc2hhcGVBO1xyXG4gICAgICAgICAgICBzaGFwZUEgPSBzVG1wO1xyXG4gICAgICAgICAgICB2YXIgcFRtcCA9IG9mZnNldEI7XHJcbiAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXRBO1xyXG4gICAgICAgICAgICBvZmZzZXRBID0gcFRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChzaGFwZUEudHlwZSB8IHNoYXBlQi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTogeyAvLyBDaXJjbGUvY2lyY2xlXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNpcmNsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwganVzdFRlc3QsIHNhLnJhZGl1cywgc2IucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzogeyAvLyBQYXJ0aWNsZS9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZVBhcnRpY2xlKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDU6IHsgLy8gUGxhbmUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVQbGFuZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAzMzogLy8gQm94L2NpcmNsZS5cclxuICAgICAgICAgICAgY2FzZSA5OiB7IC8vIENvbnZleC9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNvbnZleChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QsIHNhLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDE3OiB7IC8vIExpbmUvY2lyY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaXJjbGVMaW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCwgMCwgc2EucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjU6IHsgLy8gQ2Fwc3VsZS9jaXJjbGUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNpcmNsZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTI5OiB7IC8vIEhlaWdodGZpZWxkL2NpcmNsZS5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2lyY2xlSGVpZ2h0ZmllbGQoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGp1c3RUZXN0LCBzYS5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA2OiB7IC8vIFBsYW5lL3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZVBsYW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBCb3gvcGFydGljbGUuXHJcbiAgICAgICAgICAgIGNhc2UgMTA6IHsgLy8gQ29udmV4L3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZUNvbnZleChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxMDogeyAvLyBDYXBzdWxlL3BhcnRpY2xlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJ0aWNsZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzY6IC8vIEJveC9wbGFuZS5cclxuICAgICAgICAgICAgY2FzZSAxMjogeyAvLyBDb252ZXgvcGxhbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBsYW5lQ29udmV4KGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSwgYm9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDIwOiB7IC8vIExpbmUvcGxhbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBsYW5lTGluZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA2ODogeyAvLyBDYXBzdWxlL3BsYW5lLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wbGFuZUNhcHN1bGUoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMzI6IC8vIEJveC9ib3guXHJcbiAgICAgICAgICAgIGNhc2UgNDA6IC8vIEJveC9jb252ZXguXHJcbiAgICAgICAgICAgIGNhc2UgODogeyAvLyBDb252ZXgvY29udmV4LlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb252ZXhDb252ZXgoYm9keUEsIHNhLCBvZmZzZXRBLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLCBib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMjQ6IHsgLy8gTGluZS9jb252ZXguXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5jb252ZXhMaW5lKGJvZHlBLCBzYSwgb2Zmc2V0QSwgYm9keUEuYW5nbGUgKyBzYS5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0Ym9keUIsIHNiLCBvZmZzZXRCLCBib2R5Qi5hbmdsZSArIHNiLmFuZ2xlLCBcclxuICAgICAgICAgICAgICAgIC8vIFx0anVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA3MjogeyAvLyBDYXBzdWxlL2NvbnZleC5cclxuICAgICAgICAgICAgICAgIHZhciBzYSA9IHNoYXBlQTtcclxuICAgICAgICAgICAgICAgIHZhciBzYiA9IHNoYXBlQjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udmV4Q2Fwc3VsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxMzY6IHsgLy8gSGVpZ2h0ZmllbGQvY29udmV4LlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb252ZXhIZWlnaHRmaWVsZChib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAxNjogeyAvLyBMaW5lL2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lTGluZShib2R5QSwgc2EsIHNoYXBlUG9zaXRpb25BLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNDg6IHsgLy8gQm94L2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lQm94KGJvZHlBLCBzYSwgc2hhcGVQb3NpdGlvbkEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSxcclxuICAgICAgICAgICAgICAgIC8vIFx0anVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSA4MDogeyAvLyBDYXBzdWxlL2xpbmUuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBzaGFwZUE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBzaGFwZUI7XHJcbiAgICAgICAgICAgICAgICAvLyBOT1QgU1VQUE9SVEVEIVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gdGhpcy5saW5lQ2Fwc3VsZShib2R5QSwgc2EsIHNoYXBlUG9zaXRpb25BLCBib2R5QS5hbmdsZSArIHNhLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgLy8gXHRib2R5Qiwgc2IsIG9mZnNldEIsIGJvZHlCLmFuZ2xlICsgc2IuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBcdGp1c3RUZXN0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgNjQ6IHsgLy8gQ2Fwc3VsZS9jYXBzdWxlLlxyXG4gICAgICAgICAgICAgICAgdmFyIHNhID0gc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNiID0gc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jYXBzdWxlQ2Fwc3VsZShib2R5QSwgc2EsIG9mZnNldEEsIGJvZHlBLmFuZ2xlICsgc2EuYW5nbGUsIGJvZHlCLCBzYiwgb2Zmc2V0QiwgYm9keUIuYW5nbGUgKyBzYi5hbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZleC9saW5lIG5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIGNvbnZleExpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyBJbXBsZW1lbnQgbWUhXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhMaW5lID0gZnVuY3Rpb24gKFxyXG4gICAgLypcclxuICAgIGNvbnZleEJvZHksXHJcbiAgICBjb252ZXhTaGFwZSxcclxuICAgIGNvbnZleE9mZnNldCxcclxuICAgIGNvbnZleEFuZ2xlLFxyXG4gICAgbGluZUJvZHksXHJcbiAgICBsaW5lU2hhcGUsXHJcbiAgICBsaW5lT2Zmc2V0LFxyXG4gICAgbGluZUFuZ2xlLFxyXG4gICAganVzdFRlc3RcclxuICAgICovXHJcbiAgICApIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lL2JveCBuYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBsaW5lQm94XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBsaW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJveEJvZHlcclxuICAgICAqIEBwYXJhbSAge0JveH0gIGJveFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBib3hPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGJveEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUJveCA9IGZ1bmN0aW9uIChcclxuICAgIC8qXHJcbiAgICBsaW5lQm9keSxcclxuICAgIGxpbmVTaGFwZSxcclxuICAgIGxpbmVPZmZzZXQsXHJcbiAgICBsaW5lQW5nbGUsXHJcbiAgICBib3hCb2R5LFxyXG4gICAgYm94U2hhcGUsXHJcbiAgICBib3hPZmZzZXQsXHJcbiAgICBib3hBbmdsZSxcclxuICAgIGp1c3RUZXN0XHJcbiAgICAqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmV4L2NhcHN1bGUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY29udmV4Q2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgY29udmV4Qm9keVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSAgICAgY29udmV4U2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNvbnZleFBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENhcHN1bGUgPSBmdW5jdGlvbiAoY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwgY2Fwc3VsZUJvZHksIGNhcHN1bGVTaGFwZSwgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgQm94XzEuZGVmYXVsdCh7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcclxuICAgICAgICAvLyBBZGQgb2Zmc2V0cyFcclxuICAgICAgICB2YXIgY2lyY2xlUG9zID0gY29udmV4Q2Fwc3VsZV90ZW1wVmVjO1xyXG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0gY2Fwc3VsZVNoYXBlLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGNpcmNsZVBvcywgaGFsZkxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShjaXJjbGVQb3MsIGNpcmNsZVBvcywgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksIGNhcHN1bGVTaGFwZSwgY2lyY2xlUG9zLCBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zaXRpb24sIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cyk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGNpcmNsZVBvcywgLWhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zLCBjaXJjbGVQb3MsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlKTtcclxuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXMuY2lyY2xlQ29udmV4KGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNpcmNsZVBvcywgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleFBvc2l0aW9uLCBjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xyXG4gICAgICAgIGlmIChqdXN0VGVzdCAmJiAocmVzdWx0MSArIHJlc3VsdDIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBjZW50ZXIgcmVjdFxyXG4gICAgICAgIHZhciByID0gY29udmV4Q2Fwc3VsZV90ZW1wUmVjdDtcclxuICAgICAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyLCBjYXBzdWxlU2hhcGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zaXRpb24sIGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSwgciwgY2Fwc3VsZVBvc2l0aW9uLCBjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcmVzdWx0MSArIHJlc3VsdDI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYXBzdWxlL2xpbmUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgbGluZUNhcHN1bGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmxpbmVDYXBzdWxlID0gZnVuY3Rpb24gKFxyXG4gICAgLypcclxuICAgIGxpbmVCb2R5LFxyXG4gICAgbGluZVNoYXBlLFxyXG4gICAgbGluZVBvc2l0aW9uLFxyXG4gICAgbGluZUFuZ2xlLFxyXG4gICAgY2Fwc3VsZUJvZHksXHJcbiAgICBjYXBzdWxlU2hhcGUsXHJcbiAgICBjYXBzdWxlUG9zaXRpb24sXHJcbiAgICBjYXBzdWxlQW5nbGUsXHJcbiAgICBqdXN0VGVzdFxyXG4gICAgKi9cclxuICAgICkge1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhcHN1bGUvY2Fwc3VsZSBuYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBjYXBzdWxlQ2Fwc3VsZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcclxuICAgICAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNpXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICB4aVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWlcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXHJcbiAgICAgKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzalxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGpcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFqXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jYXBzdWxlQ2Fwc3VsZSA9IGZ1bmN0aW9uIChiaSwgc2ksIHhpLCBhaSwgYmosIHNqLCB4aiwgYWosIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdGhyb3cgXCJDYXBzdWxlLWNhcHN1bGUgY29sbGlzaW9ucyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXCI7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gbGV0IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MSA9IG5ldyBCb3goeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0pO1xyXG4gICAgICAgIC8vIGxldCBlbmFibGVGcmljdGlvbkJlZm9yZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIC8vIC8vIENoZWNrIHRoZSBjaXJjbGVzXHJcbiAgICAgICAgLy8gLy8gQWRkIG9mZnNldHMhXHJcbiAgICAgICAgLy8gbGV0IGNpcmNsZVBvc2kgPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMSxcclxuICAgICAgICAvLyBcdGNpcmNsZVBvc2ogPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMjtcclxuICAgICAgICAvLyBsZXQgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIC8vIC8vIE5lZWQgNCBjaXJjbGUgY2hlY2tzLCBiZXR3ZWVuIGFsbFxyXG4gICAgICAgIC8vIGZvcihsZXQgaT0wOyBpPDI7IGkrKyl7XHJcbiAgICAgICAgLy8gXHR2ZWMyLnNldChjaXJjbGVQb3NpLChpPT09MD8tMToxKSpzaS5sZW5ndGgvMiwwKTtcclxuICAgICAgICAvLyBcdHZlYzIudG9HbG9iYWxGcmFtZShjaXJjbGVQb3NpLCBjaXJjbGVQb3NpLCB4aSwgYWkpO1xyXG4gICAgICAgIC8vIFx0Zm9yKGxldCBqPTA7IGo8MjsgaisrKXtcclxuICAgICAgICAvLyBcdFx0dmVjMi5zZXQoY2lyY2xlUG9zaiwoaj09PTA/LTE6MSkqc2oubGVuZ3RoLzIsIDApO1xyXG4gICAgICAgIC8vIFx0XHR2ZWMyLnRvR2xvYmFsRnJhbWUoY2lyY2xlUG9zaiwgY2lyY2xlUG9zaiwgeGosIGFqKTtcclxuICAgICAgICAvLyBcdFx0Ly8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cclxuICAgICAgICAvLyBcdFx0aWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRcdFx0ZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xyXG4gICAgICAgIC8vIFx0XHRcdHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAvLyBcdFx0fVxyXG4gICAgICAgIC8vIFx0XHRsZXQgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYmksc2ksY2lyY2xlUG9zaSwgYmosc2osY2lyY2xlUG9zaiwganVzdFRlc3QsIHNpLnJhZGl1cywgc2oucmFkaXVzKTtcclxuICAgICAgICAvLyBcdFx0aWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRcdFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIC8vIFx0XHR9XHJcbiAgICAgICAgLy8gXHRcdGlmKGp1c3RUZXN0ICYmIHJlc3VsdCAhPT0gMCl7XHJcbiAgICAgICAgLy8gXHRcdFx0cmV0dXJuIDE7XHJcbiAgICAgICAgLy8gXHRcdH1cclxuICAgICAgICAvLyBcdFx0bnVtQ29udGFjdHMgKz0gcmVzdWx0O1xyXG4gICAgICAgIC8vIFx0fVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcclxuICAgICAgICAvLyBcdC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXHJcbiAgICAgICAgLy8gXHRlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIC8vIENoZWNrIGNpcmNsZXMgYWdhaW5zdCB0aGUgY2VudGVyIGJveHNcclxuICAgICAgICAvLyBsZXQgcmVjdCA9IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MTtcclxuICAgICAgICAvLyBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNpKTtcclxuICAgICAgICAvLyBsZXQgcmVzdWx0MSA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaSxyZWN0LHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QpO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0dGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZihqdXN0VGVzdCAmJiByZXN1bHQxICE9PSAwKXtcclxuICAgICAgICAvLyBcdHJldHVybiAxO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBudW1Db250YWN0cyArPSByZXN1bHQxO1xyXG4gICAgICAgIC8vIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xyXG4gICAgICAgIC8vIFx0Ly8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cclxuICAgICAgICAvLyBcdGxldCBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2opO1xyXG4gICAgICAgIC8vIGxldCByZXN1bHQyID0gdGhpcy5jb252ZXhDYXBzdWxlKGJqLHJlY3QseGosYWosIGJpLHNpLHhpLGFpLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgLy8gaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHR0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDIgIT09IDApe1xyXG4gICAgICAgIC8vIFx0cmV0dXJuIDE7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIG51bUNvbnRhY3RzICs9IHJlc3VsdDI7XHJcbiAgICAgICAgLy8gaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XHJcbiAgICAgICAgLy8gXHRpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcclxuICAgICAgICAvLyBcdFx0dGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xyXG4gICAgICAgIC8vIFx0fVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyByZXR1cm4gbnVtQ29udGFjdHM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lL2xpbmUgbmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgbGluZUxpbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlBXHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QlxyXG4gICAgICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVCXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkJcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICogQHRvZG8gSW1wbGVtZW50IG1lIVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5MSU5FXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUxpbmUgPSBmdW5jdGlvbiAoXHJcbiAgICAvKiBib2R5QSxcclxuICAgICAgICBzaGFwZUEsXHJcbiAgICAgICAgcG9zaXRpb25BLFxyXG4gICAgICAgIGFuZ2xlQSxcclxuICAgICAgICBib2R5QixcclxuICAgICAgICBzaGFwZUIsXHJcbiAgICAgICAgcG9zaXRpb25CLFxyXG4gICAgICAgIGFuZ2xlQixcclxuICAgICAgICBqdXN0VGVzdCovXHJcbiAgICApIHtcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFuZS9saW5lIE5hcnJvd3BoYXNlXHJcbiAgICAgKiBAbWV0aG9kIHBsYW5lTGluZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gICBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BsYW5lfSAgcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBwbGFuZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGxpbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgIGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBsaW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUxpbmUgPSBmdW5jdGlvbiAocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwgbGluZUJvZHksIGxpbmVTaGFwZSwgbGluZU9mZnNldCwgbGluZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLCB3b3JsZFZlcnRleDEgPSB0bXAyLCB3b3JsZFZlcnRleDAxID0gdG1wMywgd29ybGRWZXJ0ZXgxMSA9IHRtcDQsIHdvcmxkRWRnZSA9IHRtcDUsIHdvcmxkRWRnZVVuaXQgPSB0bXA2LCBkaXN0ID0gdG1wNywgd29ybGROb3JtYWwgPSB0bXA4LCB3b3JsZFRhbmdlbnQgPSB0bXA5LCB2ZXJ0cyA9IHRtcEFycmF5LCBudW1Db250YWN0cyA9IDA7XHJcbiAgICAgICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHdvcmxkVmVydGV4MCwgLWxpbmVTaGFwZS5sZW5ndGggLyAyLCAwKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQod29ybGRWZXJ0ZXgxLCBsaW5lU2hhcGUubGVuZ3RoIC8gMiwgMCk7XHJcbiAgICAgICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZU9mZnNldCwgbGluZUFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MSwgbGluZU9mZnNldCwgbGluZUFuZ2xlKTtcclxuICAgICAgICBjb3B5KHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwMSk7XHJcbiAgICAgICAgY29weSh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MTEpO1xyXG4gICAgICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcclxuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgbm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XHJcbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xyXG4gICAgICAgIC8vIENoZWNrIGxpbmUgZW5kc1xyXG4gICAgICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xyXG4gICAgICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcclxuICAgICAgICAgICAgc3ViKGRpc3QsIHYsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgICAgICBpZiAoZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGxpbmVCb2R5LCBwbGFuZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgbnVtQ29udGFjdHMrKztcclxuICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgdmVjdG9yIGFsb25nIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgc2NhbGUoZGlzdCwgd29ybGROb3JtYWwsIGQpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBsaW5lIGNlbnRlciB0byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlUG9zaXRpb24sIGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNhcHN1bGVQb3NpdGlvbiwgY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUocGFydGljbGVCb2R5LCBwYXJ0aWNsZVNoYXBlLCBwYXJ0aWNsZVBvc2l0aW9uLCBjYXBzdWxlQm9keSwgY2Fwc3VsZVNoYXBlLCBjYXBzdWxlUG9zaXRpb24sIGNhcHN1bGVBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMsIDApO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL2xpbmUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlTGluZVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gbGluZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0xpbmV9IGxpbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxpbmVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0IElmIHNldCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgKGludGVyc2VjdGlvbiBvciBub3QpIHdpdGhvdXQgYWRkaW5nIGVxdWF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lUmFkaXVzIFJhZGl1cyB0byBhZGQgdG8gdGhlIGxpbmUuIENhbiBiZSB1c2VkIHRvIHRlc3QgQ2Fwc3VsZXMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIElmIHNldCwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIGNpcmNsZSBzaGFwZSByYWRpdXMuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkxJTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVMaW5lID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVPZmZzZXQsIFxyXG4gICAgLy9jaXJjbGVBbmdsZTogZjMyLFxyXG4gICAgbGluZUJvZHksIGxpbmVTaGFwZSwgbGluZU9mZnNldCwgbGluZUFuZ2xlLCBqdXN0VGVzdCwgbGluZVJhZGl1cywgY2lyY2xlUmFkaXVzKSB7XHJcbiAgICAgICAgbGluZVJhZGl1cyA9IGxpbmVSYWRpdXMgIT09IG51bGwgJiYgbGluZVJhZGl1cyAhPT0gdm9pZCAwID8gbGluZVJhZGl1cyA6IDA7XHJcbiAgICAgICAgdmFyIG9ydGhvRGlzdCA9IHRtcDE7XHJcbiAgICAgICAgdmFyIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCA9IHRtcDI7XHJcbiAgICAgICAgdmFyIHByb2plY3RlZFBvaW50ID0gdG1wMztcclxuICAgICAgICB2YXIgY2VudGVyRGlzdCA9IHRtcDQ7XHJcbiAgICAgICAgdmFyIHdvcmxkVGFuZ2VudCA9IHRtcDU7XHJcbiAgICAgICAgdmFyIHdvcmxkRWRnZSA9IHRtcDY7XHJcbiAgICAgICAgdmFyIHdvcmxkRWRnZVVuaXQgPSB0bXA3O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXA4O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDEgPSB0bXA5O1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAxID0gdG1wMTA7XHJcbiAgICAgICAgdmFyIHdvcmxkVmVydGV4MTEgPSB0bXAxMTtcclxuICAgICAgICB2YXIgZGlzdCA9IHRtcDEyO1xyXG4gICAgICAgIHZhciBsaW5lVG9DaXJjbGUgPSB0bXAxMztcclxuICAgICAgICB2YXIgbGluZUVuZFRvTGluZVJhZGl1cyA9IHRtcDE0O1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IHRtcEFycmF5O1xyXG4gICAgICAgIHZhciBoYWxmTGluZUxlbmd0aCA9IGxpbmVTaGFwZS5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIEdldCBzdGFydCBhbmQgZW5kIHBvaW50c1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh3b3JsZFZlcnRleDAsIC1oYWxmTGluZUxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHdvcmxkVmVydGV4MSwgaGFsZkxpbmVMZW5ndGgsIDApO1xyXG4gICAgICAgIC8vIE5vdCBzdXJlIHdoeSB3ZSBoYXZlIHRvIHVzZSB3b3JsZFZlcnRleCoxIGhlcmUsIGJ1dCBpdCB3b24ndCB3b3JrIG90aGVyd2lzZS4gVGlyZWQuXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVPZmZzZXQsIGxpbmVBbmdsZSk7XHJcbiAgICAgICAgY29weSh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MDEpO1xyXG4gICAgICAgIGNvcHkod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDExKTtcclxuICAgICAgICAvLyBHZXQgdmVjdG9yIGFsb25nIHRoZSBsaW5lXHJcbiAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgIG5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xyXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcclxuICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBwbGFuZSBzcGFubmVkIGJ5IHRoZSBlZGdlIHZzIHRoZSBjaXJjbGVcclxuICAgICAgICBzdWIoZGlzdCwgY2lyY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xyXG4gICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyIG9mIGxpbmUgdG8gY2lyY2xlIGNlbnRlclxyXG4gICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgIHN1YihsaW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgdmFyIHJhZGl1c1N1bSA9IGNpcmNsZVJhZGl1cyArIGxpbmVSYWRpdXM7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGQpIDwgcmFkaXVzU3VtKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdyBwcm9qZWN0IHRoZSBjaXJjbGUgb250byB0aGUgZWRnZVxyXG4gICAgICAgICAgICBzY2FsZShvcnRob0Rpc3QsIHdvcmxkVGFuZ2VudCwgZCk7XHJcbiAgICAgICAgICAgIHN1Yihwcm9qZWN0ZWRQb2ludCwgY2lyY2xlT2Zmc2V0LCBvcnRob0Rpc3QpO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG1pc3NpbmcgbGluZSByYWRpdXNcclxuICAgICAgICAgICAgc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCB3b3JsZFRhbmdlbnQsIGRvdCh3b3JsZFRhbmdlbnQsIGxpbmVUb0NpcmNsZSkpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xyXG4gICAgICAgICAgICBzY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFkZChwcm9qZWN0ZWRQb2ludCwgcHJvamVjdGVkUG9pbnQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGVkZ2Ugc3BhblxyXG4gICAgICAgICAgICB2YXIgcG9zID0gZG90KHdvcmxkRWRnZVVuaXQsIHByb2plY3RlZFBvaW50KTtcclxuICAgICAgICAgICAgdmFyIHBvczAgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgdmFyIHBvczEgPSBkb3Qod29ybGRFZGdlVW5pdCwgd29ybGRWZXJ0ZXgxKTtcclxuICAgICAgICAgICAgaWYgKHBvcyA+IHBvczAgJiYgcG9zIDwgcG9zMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZ290IGNvbnRhY3QhXHJcbiAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgbGluZUJvZHksIGNpcmNsZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUoYy5ub3JtYWxBLCBvcnRob0Rpc3QsIC0xKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwcm9qZWN0ZWRQb2ludCwgbGluZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgY29ybmVyXHJcbiAgICAgICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XHJcbiAgICAgICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xyXG4gICAgICAgICAgICBzdWIoZGlzdCwgdiwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKHNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXNTdW0sIDIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSwgbGluZUJvZHksIGNpcmNsZVNoYXBlLCBsaW5lU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcclxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsIGxpbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgc2NhbGUobGluZUVuZFRvTGluZVJhZGl1cywgYy5ub3JtYWxBLCAtbGluZVJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVFbmRUb0xpbmVSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUvY2Fwc3VsZSBOYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBjaXJjbGVDYXBzdWxlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGJpXHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IHNpXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHhpXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgIGJqXHJcbiAgICAgKiBAcGFyYW0gIHtMaW5lfSAgIHNqXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHhqXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNBUFNVTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDYXBzdWxlID0gZnVuY3Rpb24gKGJpLCBzaSwgeGksIGJqLCBzaiwgeGosIGFqLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNpcmNsZUxpbmUoYmksIHNpLCB4aSwgYmosIHNqLCB4aiwgYWosIGp1c3RUZXN0LCAwLCBzaS5yYWRpdXMpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2lyY2xlL2NvbnZleCBOYXJyb3dwaGFzZS5cclxuICAgICAqIEBtZXRob2QgY2lyY2xlQ29udmV4XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVSYWRpdXNcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIFNob3VsZCBwcm9iYWJseSBkbyBhIHNlcGFyYXRpbmcgYXhpcyB0ZXN0IGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2VyaW5jYXR0by9Cb3gyRC9ibG9iL21hc3Rlci9Cb3gyRC9Cb3gyRC9Db2xsaXNpb24vYjJDb2xsaWRlQ2lyY2xlLmNwcCNMNjJcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5CT1hdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDb252ZXggPSBmdW5jdGlvbiAoY2lyY2xlQm9keSwgY2lyY2xlU2hhcGUsIGNpcmNsZU9mZnNldCwgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSwgd29ybGRWZXJ0ZXgxID0gdG1wMiwgZWRnZSA9IHRtcDMsIGVkZ2VVbml0ID0gdG1wNCwgbm9ybWFsID0gdG1wNSwgemVybyA9IHRtcDYsIGxvY2FsQ2lyY2xlUG9zaXRpb24gPSB0bXA3LCByID0gdG1wOCwgZGlzdCA9IHRtcDEwLCB3b3JsZFZlcnRleCA9IHRtcDExLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsIGNhbmRpZGF0ZSA9IHRtcDE0LCBjYW5kaWRhdGVEaXN0ID0gdG1wMTUsIGZvdW5kID0gLTEsIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHplcm8sIDAsIDApO1xyXG4gICAgICAgIC8vIE5ldyBhbGdvcml0aG06XHJcbiAgICAgICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBwb2x5Z29uLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cclxuICAgICAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXHJcbiAgICAgICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbENpcmNsZVBvc2l0aW9uLCBjaXJjbGVPZmZzZXQsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBub3JtYWxzID0gY29udmV4U2hhcGUubm9ybWFscztcclxuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG5vcm1hbEluZGV4ID0gLTE7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgbWluIHNlcGFyYXRpbmcgZWRnZS5cclxuICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IC1JbmZpbml0eTtcclxuICAgICAgICB2YXIgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdSYWRpdXMgKyBjaXJjbGVSYWRpdXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1YihyLCBsb2NhbENpcmNsZVBvc2l0aW9uLCB2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgIHZhciBzID0gZG90KG5vcm1hbHNbaV0sIHIpO1xyXG4gICAgICAgICAgICBpZiAocyA+IHJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHMgPiBzZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSBub3JtYWxJbmRleCArIG51bVZlcnRpY2VzIC0gMTsgaSA8IG5vcm1hbEluZGV4ICsgbnVtVmVydGljZXMgKyAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydGljZXNbaSAlIG51bVZlcnRpY2VzXSwgbiA9IG5vcm1hbHNbaSAlIG51bVZlcnRpY2VzXTtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgY29udmV4XHJcbiAgICAgICAgICAgIHNjYWxlKGNhbmRpZGF0ZSwgbiwgLWNpcmNsZVJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFkZChjYW5kaWRhdGUsIGNhbmRpZGF0ZSwgbG9jYWxDaXJjbGVQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChwb2ludEluQ29udmV4TG9jYWwoY2FuZGlkYXRlLCBjb252ZXhTaGFwZSkpIHtcclxuICAgICAgICAgICAgICAgIHN1YihjYW5kaWRhdGVEaXN0LCB2MCwgY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKGRvdChjYW5kaWRhdGVEaXN0LCBuKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdjAgPSB2ZXJ0aWNlc1tmb3VuZCAlIG51bVZlcnRpY2VzXSwgdjEgPSB2ZXJ0aWNlc1soZm91bmQgKyAxKSAlIG51bVZlcnRpY2VzXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgc3ViKGVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKGVkZ2VVbml0LCBlZGdlKTtcclxuICAgICAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZVVuaXQpO1xyXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBjb252ZXhcclxuICAgICAgICAgICAgc2NhbGUoY2FuZGlkYXRlLCBub3JtYWwsIC1jaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQoY2FuZGlkYXRlLCBjYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIG5vcm1hbCwgbWluQ2FuZGlkYXRlRGlzdGFuY2UpO1xyXG4gICAgICAgICAgICBhZGQoY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LCBjb252ZXhCb2R5LCBjaXJjbGVTaGFwZSwgY29udmV4U2hhcGUpO1xyXG4gICAgICAgICAgICBzdWIoYy5ub3JtYWxBLCBjYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgY2xvc2VzdCB2ZXJ0aWNlc1xyXG4gICAgICAgIGlmIChjaXJjbGVSYWRpdXMgPiAwICYmIG5vcm1hbEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbm9ybWFsSW5kZXggKyBudW1WZXJ0aWNlczsgaSA8IG5vcm1hbEluZGV4ICsgbnVtVmVydGljZXMgKyAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFZlcnRleCA9IHZlcnRpY2VzW2kgJSBudW1WZXJ0aWNlc107XHJcbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgbG9jYWxWZXJ0ZXgsIGxvY2FsQ2lyY2xlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZWRMZW5ndGgoZGlzdCkgPCBjaXJjbGVSYWRpdXMgKiBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUod29ybGRWZXJ0ZXgsIGxvY2FsVmVydGV4LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LCBjb252ZXhCb2R5LCBjaXJjbGVTaGFwZSwgY29udmV4U2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJ0aWNsZS9jb252ZXggTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgcGFydGljbGVDb252ZXhcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKiBAdG9kbyB1c2UgcG9pbnRJbkNvbnZleCBhbmQgY29kZSBtb3JlIHNpbWlsYXIgdG8gY2lyY2xlQ29udmV4XHJcbiAgICAgKiBAdG9kbyBkb24ndCB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXgsIGJ1dCB0cmFuc2Zvcm0gdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHRvIGNvbnZleC1sb2NhbCBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkJPWF0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ29udmV4ID0gZnVuY3Rpb24gKHBhcnRpY2xlQm9keSwgcGFydGljbGVTaGFwZSwgcGFydGljbGVPZmZzZXQsIGNvbnZleEJvZHksIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlLCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLCB3b3JsZFZlcnRleDEgPSB0bXAyLCB3b3JsZEVkZ2UgPSB0bXAzLCB3b3JsZEVkZ2VVbml0ID0gdG1wNCwgd29ybGRUYW5nZW50ID0gdG1wNSwgY2VudGVyRGlzdCA9IHRtcDYsIGNvbnZleFRvcGFydGljbGUgPSB0bXA3LCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsIGNhbmRpZGF0ZURpc3QgPSB0bXAxNCwgbWluRWRnZU5vcm1hbCA9IHRtcDE1LCBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IEluZmluaXR5LCBmb3VuZCA9IGZhbHNlLCB2ZXJ0cyA9IGNvbnZleFNoYXBlLnZlcnRpY2VzO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyBpbiB0aGUgcG9seWdvbiBhdCBhbGxcclxuICAgICAgICBpZiAoIXBvaW50SW5Db252ZXgocGFydGljbGVPZmZzZXQsIGNvbnZleFNoYXBlLCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDsgaSAhPT0gbnVtVmVydHMgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gdmVydHNbaSAlIG51bVZlcnRzXSwgdjEgPSB2ZXJ0c1soaSArIDEpICUgbnVtVmVydHNdO1xyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcclxuICAgICAgICAgICAgLy8gQHRvZG8gdHJhbnNmb3JtIHBvaW50IHRvIGxvY2FsIHNwYWNlIGluc3RlYWRcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XHJcbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXHJcbiAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XHJcbiAgICAgICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBpbmZpbml0ZSBsaW5lIChzcGFubmVkIGJ5IHRoZSBlZGdlKSB0byB0aGUgcGFydGljbGVcclxuICAgICAgICAgICAgLy9zdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XHJcbiAgICAgICAgICAgIC8vbGV0IGQgPSBkb3QoZGlzdCwgd29ybGRUYW5nZW50KTtcclxuICAgICAgICAgICAgc3ViKGNlbnRlckRpc3QsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGNvbnZleFRvcGFydGljbGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBzdWIoY2FuZGlkYXRlRGlzdCwgd29ybGRWZXJ0ZXgwLCBwYXJ0aWNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKGRvdChjYW5kaWRhdGVEaXN0LCB3b3JsZFRhbmdlbnQpKTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZURpc3RhbmNlIDwgbWluQ2FuZGlkYXRlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCB3b3JsZFRhbmdlbnQsIGNhbmRpZGF0ZURpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBwYXJ0aWNsZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBjb3B5KG1pbkVkZ2VOb3JtYWwsIHdvcmxkVGFuZ2VudCk7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGFydGljbGVCb2R5LCBjb252ZXhCb2R5LCBwYXJ0aWNsZVNoYXBlLCBjb252ZXhTaGFwZSk7XHJcbiAgICAgICAgICAgIHNjYWxlKGMubm9ybWFsQSwgbWluRWRnZU5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAvLyBQYXJ0aWNsZSBoYXMgbm8gZXh0ZW50IHRvIHRoZSBjb250YWN0IHBvaW50XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChjLmNvbnRhY3RQb2ludEEsIDAsIDApO1xyXG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0KTtcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyBGcm9tIGNvbnZleCBjZW50ZXIgdG8gcG9pbnRcclxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcclxuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xyXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENpcmNsZS9jaXJjbGUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlQ2lyY2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRBXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUJcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRCXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0FdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNCXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2lyY2xlID0gZnVuY3Rpb24gKGJvZHlBLCBzaGFwZUEsIG9mZnNldEEsIGJvZHlCLCBzaGFwZUIsIG9mZnNldEIsIGp1c3RUZXN0LCByYWRpdXNBLCByYWRpdXNCKSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAxO1xyXG4gICAgICAgIHN1YihkaXN0LCBvZmZzZXRBLCBvZmZzZXRCKTtcclxuICAgICAgICB2YXIgciA9IHJhZGl1c0EgKyByYWRpdXNCO1xyXG4gICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpID4gciAqIHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKTtcclxuICAgICAgICB2YXIgY3BBID0gYy5jb250YWN0UG9pbnRBO1xyXG4gICAgICAgIHZhciBjcEIgPSBjLmNvbnRhY3RQb2ludEI7XHJcbiAgICAgICAgdmFyIG5vcm1hbEEgPSBjLm5vcm1hbEE7XHJcbiAgICAgICAgc3ViKG5vcm1hbEEsIG9mZnNldEIsIG9mZnNldEEpO1xyXG4gICAgICAgIG5vcm1hbGl6ZShub3JtYWxBLCBub3JtYWxBKTtcclxuICAgICAgICBzY2FsZShjcEEsIG5vcm1hbEEsIHJhZGl1c0EpO1xyXG4gICAgICAgIHNjYWxlKGNwQiwgbm9ybWFsQSwgLXJhZGl1c0IpO1xyXG4gICAgICAgIGFkZFN1YihjcEEsIGNwQSwgb2Zmc2V0QSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgIGFkZFN1YihjcEIsIGNwQiwgb2Zmc2V0QiwgYm9keUIucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBsYW5lL0NvbnZleCBOYXJyb3dwaGFzZVxyXG4gICAgICogQG1ldGhvZCBwbGFuZUNvbnZleFxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcclxuICAgICAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqIEB0b2RvIG9ubHkgdXNlIHRoZSBkZWVwZXN0IGNvbnRhY3QgcG9pbnQgKyB0aGUgY29udGFjdCBwb2ludCBmdXJ0aGVzdCBhd2F5IGZyb20gaXRcclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DT05WRVhdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbiAocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwgY29udmV4Qm9keSwgY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gdG1wMSwgd29ybGROb3JtYWwgPSB0bXAyLCBkaXN0ID0gdG1wMywgbG9jYWxQbGFuZU9mZnNldCA9IHRtcDQsIGxvY2FsUGxhbmVOb3JtYWwgPSB0bXA1LCBsb2NhbERpc3QgPSB0bXA2O1xyXG4gICAgICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XHJcbiAgICAgICAgcm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XHJcbiAgICAgICAgLy8gR2V0IGNvbnZleC1sb2NhbCBwbGFuZSBvZmZzZXQgYW5kIG5vcm1hbFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnZlY3RvclRvTG9jYWxGcmFtZShsb2NhbFBsYW5lTm9ybWFsLCB3b3JsZE5vcm1hbCwgY29udmV4QW5nbGUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShsb2NhbFBsYW5lT2Zmc2V0LCBwbGFuZU9mZnNldCwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gY29udmV4U2hhcGUudmVydGljZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bVZlcnRzID0gdmVydGljZXMubGVuZ3RoOyBpICE9PSBudW1WZXJ0czsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHN1Yihsb2NhbERpc3QsIHYsIGxvY2FsUGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoZG90KGxvY2FsRGlzdCwgbG9jYWxQbGFuZU5vcm1hbCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHdvcmxkVmVydGV4LCB2LCBjb252ZXhPZmZzZXQsIGNvbnZleEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gRm91bmQgdmVydGV4XHJcbiAgICAgICAgICAgICAgICBudW1SZXBvcnRlZCsrO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNvbnZleEJvZHksIHBsYW5lU2hhcGUsIGNvbnZleFNoYXBlKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIGMubm9ybWFsQSk7XHJcbiAgICAgICAgICAgICAgICBzY2FsZShkaXN0LCBjLm5vcm1hbEEsIGQpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmogaXMgZnJvbSBjb252ZXggY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHdvcmxkVmVydGV4LCBkaXN0KTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bVJlcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVJlcG9ydGVkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bVJlcG9ydGVkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTmFycm93cGhhc2UgZm9yIHBhcnRpY2xlIHZzIHBsYW5lXHJcbiAgICAgKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9ICAgcGFydGljbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGFydGljbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBsYW5lQm9keVxyXG4gICAgICogQHBhcmFtICB7UGxhbmV9ICAgICAgcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGxhbmVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICAgIHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGp1c3RUZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuUExBTkVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZVBsYW5lID0gZnVuY3Rpb24gKHBhcnRpY2xlQm9keSwgcGFydGljbGVTaGFwZSwgcGFydGljbGVPZmZzZXQsIHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSB0bXAxLCB3b3JsZE5vcm1hbCA9IHRtcDI7XHJcbiAgICAgICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcclxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICByb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcclxuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgaWYgKGQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBwYXJ0aWNsZUJvZHksIHBsYW5lU2hhcGUsIHBhcnRpY2xlU2hhcGUpO1xyXG4gICAgICAgIGNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgc2NhbGUoZGlzdCwgYy5ub3JtYWxBLCBkKTtcclxuICAgICAgICAvLyBkaXN0IGlzIG5vdyB0aGUgZGlzdGFuY2UgdmVjdG9yIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgLy8gcmkgaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCBkb3duIG9udG8gdGhlIHBsYW5lLCBmcm9tIHRoZSBwbGFuZSBjZW50ZXJcclxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCwgZGlzdCk7XHJcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIC8vIHJqIGlzIGZyb20gdGhlIGJvZHkgY2VudGVyIHRvIHRoZSBwYXJ0aWNsZSBjZW50ZXJcclxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwYXJ0aWNsZU9mZnNldCwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUvUGFydGljbGUgTmFycm93cGhhc2VcclxuICAgICAqIEBtZXRob2QgY2lyY2xlUGFydGljbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxyXG4gICAgICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUEFSVElDTEVdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChjaXJjbGVCb2R5LCBjaXJjbGVTaGFwZSwgY2lyY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHksIHBhcnRpY2xlU2hhcGUsIHBhcnRpY2xlT2Zmc2V0LCBqdXN0VGVzdCkge1xyXG4gICAgICAgIHZhciBkaXN0ID0gdG1wMTtcclxuICAgICAgICB2YXIgY2lyY2xlUmFkaXVzID0gY2lyY2xlU2hhcGUucmFkaXVzO1xyXG4gICAgICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICBpZiAoc3F1YXJlZExlbmd0aChkaXN0KSA+IGNpcmNsZVJhZGl1cyAqIGNpcmNsZVJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksIHBhcnRpY2xlQm9keSwgY2lyY2xlU2hhcGUsIHBhcnRpY2xlU2hhcGUpO1xyXG4gICAgICAgIHZhciBub3JtYWxBID0gYy5ub3JtYWxBO1xyXG4gICAgICAgIHZhciBjb250YWN0UG9pbnRBID0gYy5jb250YWN0UG9pbnRBO1xyXG4gICAgICAgIHZhciBjb250YWN0UG9pbnRCID0gYy5jb250YWN0UG9pbnRCO1xyXG4gICAgICAgIGNvcHkobm9ybWFsQSwgZGlzdCk7XHJcbiAgICAgICAgbm9ybWFsaXplKG5vcm1hbEEsIG5vcm1hbEEpO1xyXG4gICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcclxuICAgICAgICBzY2FsZShjb250YWN0UG9pbnRBLCBub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgIGFkZChjb250YWN0UG9pbnRBLCBjb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xyXG4gICAgICAgIHN1Yihjb250YWN0UG9pbnRBLCBjb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBwYXJ0aWNsZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludCBpcyB6ZXJvXHJcbiAgICAgICAgc3ViKGNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcGxhbmVDYXBzdWxlXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge0NpcmNsZX0gcGxhbmVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcclxuICAgICAqIEBwYXJhbSAge0JvZHl9IGNhcHN1bGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtQYXJ0aWNsZX0gY2Fwc3VsZVNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gY2Fwc3VsZU9mZnNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjYXBzdWxlQW5nbGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DQVBTVUxFXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDYXBzdWxlID0gZnVuY3Rpb24gKHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGNhcHN1bGVCb2R5LCBjYXBzdWxlU2hhcGUsIGNhcHN1bGVPZmZzZXQsIGNhcHN1bGVBbmdsZSwganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgcGxhbmVDYXBzdWxlX3RtcENpcmNsZSA9IG5ldyBDaXJjbGVfMS5kZWZhdWx0KHsgcmFkaXVzOiAxIH0pO1xyXG4gICAgICAgIHZhciBlbmQxID0gcGxhbmVDYXBzdWxlX3RtcDEsIGVuZDIgPSBwbGFuZUNhcHN1bGVfdG1wMiwgY2lyY2xlID0gcGxhbmVDYXBzdWxlX3RtcENpcmNsZSwgaGFsZkxlbmd0aCA9IGNhcHN1bGVTaGFwZS5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIENvbXB1dGUgd29ybGQgZW5kIHBvc2l0aW9uc1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChlbmQxLCAtaGFsZkxlbmd0aCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGVuZDIsIGhhbGZMZW5ndGgsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUoZW5kMSwgZW5kMSwgY2Fwc3VsZU9mZnNldCwgY2Fwc3VsZUFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGVuZDIsIGVuZDIsIGNhcHN1bGVPZmZzZXQsIGNhcHN1bGVBbmdsZSk7XHJcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9IGNhcHN1bGVTaGFwZS5yYWRpdXM7XHJcbiAgICAgICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcclxuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gTmFycm93cGhhc2UgYXMgdHdvIGNpcmNsZXNcclxuICAgICAgICB2YXIgbnVtQ29udGFjdHMxID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSwgY2lyY2xlLCBlbmQxLCBwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLCBqdXN0VGVzdCksIG51bUNvbnRhY3RzMiA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksIGNpcmNsZSwgZW5kMiwgcGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSwganVzdFRlc3QpO1xyXG4gICAgICAgIC8vIFJlc3RvcmUgZnJpY3Rpb25cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG51bVRvdGFsID0gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bVRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Ub3RhbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1Ub3RhbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNpcmNsZVBsYW5lXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICBjaXJjbGVCb2R5XHJcbiAgICAgKiBAcGFyYW0gIHtDaXJjbGV9ICBjaXJjbGVTaGFwZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICAgY2lyY2xlT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICBwbGFuZUJvZHlcclxuICAgICAqIEBwYXJhbSAge1BsYW5lfSAgIHBsYW5lU2hhcGVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgIHBsYW5lT2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBwbGFuZUFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QTEFORV0gPVxyXG4gICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBsYW5lID0gZnVuY3Rpb24gKGNpcmNsZUJvZHksIGNpcmNsZVNoYXBlLCBjaXJjbGVPZmZzZXQsIHBsYW5lQm9keSwgcGxhbmVTaGFwZSwgcGxhbmVPZmZzZXQsIHBsYW5lQW5nbGUsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IGNpcmNsZVNoYXBlLnJhZGl1cztcclxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBwbGFuZSB0byBjaXJjbGVcclxuICAgICAgICB2YXIgcGxhbmVUb0NpcmNsZSA9IHRtcDEsIHdvcmxkTm9ybWFsID0gdG1wMiwgdGVtcCA9IHRtcDM7XHJcbiAgICAgICAgc3ViKHBsYW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xyXG4gICAgICAgIC8vIFdvcmxkIHBsYW5lIG5vcm1hbFxyXG4gICAgICAgIHJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xyXG4gICAgICAgIC8vIE5vcm1hbCBkaXJlY3Rpb24gZGlzdGFuY2VcclxuICAgICAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCwgcGxhbmVUb0NpcmNsZSk7XHJcbiAgICAgICAgaWYgKGQgPiBjaXJjbGVSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIE5vIG92ZXJsYXAuIEFib3J0LlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanVzdFRlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBjb250YWN0XHJcbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNpcmNsZUJvZHksIHBsYW5lU2hhcGUsIGNpcmNsZVNoYXBlKTtcclxuICAgICAgICAvLyBuaSBpcyB0aGUgcGxhbmUgd29ybGQgbm9ybWFsXHJcbiAgICAgICAgY29weShjb250YWN0Lm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAvLyByaiBpcyB0aGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byB0aGUgY29udGFjdCBwb2ludFxyXG4gICAgICAgIHZhciBjcEIgPSBjb250YWN0LmNvbnRhY3RQb2ludEI7XHJcbiAgICAgICAgc2NhbGUoY3BCLCBjb250YWN0Lm5vcm1hbEEsIC1jaXJjbGVSYWRpdXMpO1xyXG4gICAgICAgIGFkZChjcEIsIGNwQiwgY2lyY2xlT2Zmc2V0KTtcclxuICAgICAgICBzdWIoY3BCLCBjcEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIC8vIHJpIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0LlxyXG4gICAgICAgIHZhciBjcEEgPSBjb250YWN0LmNvbnRhY3RQb2ludEE7XHJcbiAgICAgICAgc2NhbGUodGVtcCwgY29udGFjdC5ub3JtYWxBLCBkKTtcclxuICAgICAgICBzdWIoY3BBLCBwbGFuZVRvQ2lyY2xlLCB0ZW1wKTsgLy8gU3VidHJhY3Qgbm9ybWFsIGRpc3RhbmNlIHZlY3RvciBmcm9tIHRoZSBkaXN0YW5jZSB2ZWN0b3JcclxuICAgICAgICBhZGQoY3BBLCBjcEEsIHBsYW5lT2Zmc2V0KTtcclxuICAgICAgICBzdWIoY3BBLCBjcEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goY29udGFjdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjb250YWN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQSAtIHJldHVybiBpZiBzZXBhcmF0aW5nIGF4aXMgaXMgZm91bmRcclxuICAgIC8vIEZpbmQgZWRnZSBub3JtYWwgb2YgbWF4IHNlcGFyYXRpb24gb24gQiAtIHJldHVybiBpZiBzZXBhcmF0aW9uIGF4aXMgaXMgZm91bmRcclxuICAgIC8vIENob29zZSByZWZlcmVuY2UgZWRnZSBhcyBtaW4obWluQSwgbWluQilcclxuICAgIC8vIEZpbmQgaW5jaWRlbnQgZWRnZVxyXG4gICAgLy8gQ2xpcFxyXG4gICAgLy8gVGhlIG5vcm1hbCBwb2ludHMgZnJvbSAxIHRvIDJcclxuICAgIC8qZnVuY3Rpb24gY29sbGlkZVBvbHlnb25zKFxyXG4gICAgICAgIG1hbmlmb2xkLFxyXG4gICAgICAgIHBvbHlBLCBwb3NpdGlvbkEsIGFuZ2xlQSxcclxuICAgICAgICBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsXHJcbiAgICAgICAgaW5jaWRlbnRFZGdlXHJcbiAgICApIHsqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXgvY29udmV4IE5hcnJvd3BoYXNlLlNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1wiPnRoaXMgYXJ0aWNsZTwvYT4gZm9yIG1vcmUgaW5mby5cclxuICAgICAqIEBtZXRob2QgY29udmV4Q29udmV4XHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBiaVxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBzaVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHhpXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBialxyXG4gICAgICogQHBhcmFtICB7Q29udmV4fSBzalxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHhqXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVhdID1cclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkJPWF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24gKGJvZHlBLCBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEsIGJvZHlCLCBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsIGp1c3RUZXN0KSB7XHJcbiAgICAgICAgdmFyIG1heE1hbmlmb2xkUG9pbnRzID0gMjtcclxuICAgICAgICB2YXIgdG90YWxSYWRpdXMgPSAwO1xyXG4gICAgICAgIHZhciBkaXN0ID0gY29sbGlkZVBvbHlnb25zX2Rpc3Q7XHJcbiAgICAgICAgdmFyIHRlbXBWZWMgPSBjb2xsaWRlUG9seWdvbnNfdGVtcFZlYztcclxuICAgICAgICB2YXIgdG1wVmVjID0gY29sbGlkZVBvbHlnb25zX3RtcFZlYztcclxuICAgICAgICB2YXIgZWRnZUEgPSBmaW5kTWF4U2VwYXJhdGlvbih0ZW1wVmVjLCBwb2x5QSwgcG9zaXRpb25BLCBhbmdsZUEsIHBvbHlCLCBwb3NpdGlvbkIsIGFuZ2xlQik7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRpb25BID0gdGVtcFZlY1swXTtcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVkZ2VCID0gZmluZE1heFNlcGFyYXRpb24odG1wVmVjLCBwb2x5QiwgcG9zaXRpb25CLCBhbmdsZUIsIHBvbHlBLCBwb3NpdGlvbkEsIGFuZ2xlQSk7XHJcbiAgICAgICAgdmFyIHNlcGFyYXRpb25CID0gdG1wVmVjWzBdO1xyXG4gICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9seTE7IC8vIHJlZmVyZW5jZSBwb2x5Z29uXHJcbiAgICAgICAgdmFyIHBvbHkyOyAvLyBpbmNpZGVudCBwb2x5Z29uXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uMTtcclxuICAgICAgICB2YXIgcG9zaXRpb24yO1xyXG4gICAgICAgIHZhciBhbmdsZTE7XHJcbiAgICAgICAgdmFyIGFuZ2xlMjtcclxuICAgICAgICB2YXIgYm9keTE7XHJcbiAgICAgICAgdmFyIGJvZHkyO1xyXG4gICAgICAgIHZhciBlZGdlMTsgLy8gcmVmZXJlbmNlIGVkZ2VcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkIgPiBzZXBhcmF0aW9uQSkge1xyXG4gICAgICAgICAgICBwb2x5MSA9IHBvbHlCO1xyXG4gICAgICAgICAgICBwb2x5MiA9IHBvbHlBO1xyXG4gICAgICAgICAgICBib2R5MSA9IGJvZHlCO1xyXG4gICAgICAgICAgICBib2R5MiA9IGJvZHlBO1xyXG4gICAgICAgICAgICBwb3NpdGlvbjEgPSBwb3NpdGlvbkI7XHJcbiAgICAgICAgICAgIGFuZ2xlMSA9IGFuZ2xlQjtcclxuICAgICAgICAgICAgcG9zaXRpb24yID0gcG9zaXRpb25BO1xyXG4gICAgICAgICAgICBhbmdsZTIgPSBhbmdsZUE7XHJcbiAgICAgICAgICAgIGVkZ2UxID0gZWRnZUI7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxOyAvLyBmYWNlQlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG9seTEgPSBwb2x5QTtcclxuICAgICAgICAgICAgcG9seTIgPSBwb2x5QjtcclxuICAgICAgICAgICAgYm9keTEgPSBib2R5QTtcclxuICAgICAgICAgICAgYm9keTIgPSBib2R5QjtcclxuICAgICAgICAgICAgcG9zaXRpb24xID0gcG9zaXRpb25BO1xyXG4gICAgICAgICAgICBhbmdsZTEgPSBhbmdsZUE7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uMiA9IHBvc2l0aW9uQjtcclxuICAgICAgICAgICAgYW5nbGUyID0gYW5nbGVCO1xyXG4gICAgICAgICAgICBlZGdlMSA9IGVkZ2VBO1xyXG4gICAgICAgICAgICB0eXBlID0gMDsgLy8gZmFjZUFcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluY2lkZW50RWRnZSA9IGNvbGxpZGVQb2x5Z29uc19pbmNpZGVudEVkZ2U7XHJcbiAgICAgICAgZmluZEluY2lkZW50RWRnZShpbmNpZGVudEVkZ2UsIHBvbHkxLCBwb3NpdGlvbjEsIGFuZ2xlMSwgZWRnZTEsIHBvbHkyLCBwb3NpdGlvbjIsIGFuZ2xlMik7XHJcbiAgICAgICAgdmFyIGNvdW50MSA9IHBvbHkxLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgdmVydGljZXMxID0gcG9seTEudmVydGljZXM7XHJcbiAgICAgICAgdmFyIGl2MSA9IGVkZ2UxO1xyXG4gICAgICAgIHZhciBpdjIgPSBlZGdlMSArIDEgPCBjb3VudDEgPyBlZGdlMSArIDEgOiAwO1xyXG4gICAgICAgIHZhciB2MTEgPSBjb2xsaWRlUG9seWdvbnNfdjExO1xyXG4gICAgICAgIHZhciB2MTIgPSBjb2xsaWRlUG9seWdvbnNfdjEyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodjExLCB2ZXJ0aWNlczFbaXYxXSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh2MTIsIHZlcnRpY2VzMVtpdjJdKTtcclxuICAgICAgICB2YXIgbG9jYWxUYW5nZW50ID0gY29sbGlkZVBvbHlnb25zX2xvY2FsVGFuZ2VudDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsb2NhbFRhbmdlbnQsIHYxMiwgdjExKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobG9jYWxUYW5nZW50LCBsb2NhbFRhbmdlbnQpO1xyXG4gICAgICAgIHZhciBsb2NhbE5vcm1hbCA9IGNvbGxpZGVQb2x5Z29uc19sb2NhbE5vcm1hbDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcm9zc1ZaKGxvY2FsTm9ybWFsLCBsb2NhbFRhbmdlbnQsIDEuMCk7XHJcbiAgICAgICAgdmFyIHBsYW5lUG9pbnQgPSBjb2xsaWRlUG9seWdvbnNfcGxhbmVQb2ludDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQocGxhbmVQb2ludCwgdjExLCB2MTIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHBsYW5lUG9pbnQsIHBsYW5lUG9pbnQsIDAuNSk7XHJcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBjb2xsaWRlUG9seWdvbnNfdGFuZ2VudDsgLy8gdGFuZ2VudCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0YW5nZW50LCBsb2NhbFRhbmdlbnQsIGFuZ2xlMSk7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IGNvbGxpZGVQb2x5Z29uc19ub3JtYWw7IC8vIG5vcm1hbCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzVloobm9ybWFsLCB0YW5nZW50LCAxLjApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUodjExLCB2MTEsIHBvc2l0aW9uMSwgYW5nbGUxKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHYxMiwgdjEyLCBwb3NpdGlvbjEsIGFuZ2xlMSk7XHJcbiAgICAgICAgLy8gRmFjZSBvZmZzZXQuXHJcbiAgICAgICAgdmFyIGZyb250T2Zmc2V0ID0gdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdjExKTtcclxuICAgICAgICAvLyBTaWRlIG9mZnNldHMsIGV4dGVuZGVkIGJ5IHBvbHl0b3BlIHNraW4gdGhpY2tuZXNzLlxyXG4gICAgICAgIHZhciBzaWRlT2Zmc2V0MSA9IC12ZWMyXzEuZGVmYXVsdC5kb3QodGFuZ2VudCwgdjExKSArIHRvdGFsUmFkaXVzO1xyXG4gICAgICAgIHZhciBzaWRlT2Zmc2V0MiA9IHZlYzJfMS5kZWZhdWx0LmRvdCh0YW5nZW50LCB2MTIpICsgdG90YWxSYWRpdXM7XHJcbiAgICAgICAgLy8gQ2xpcCBpbmNpZGVudCBlZGdlIGFnYWluc3QgZXh0cnVkZWQgZWRnZTEgc2lkZSBlZGdlcy5cclxuICAgICAgICB2YXIgY2xpcFBvaW50czEgPSBjb2xsaWRlUG9seWdvbnNfY2xpcFBvaW50czE7XHJcbiAgICAgICAgdmFyIGNsaXBQb2ludHMyID0gY29sbGlkZVBvbHlnb25zX2NsaXBQb2ludHMyO1xyXG4gICAgICAgIHZhciBucCA9IDA7XHJcbiAgICAgICAgLy8gQ2xpcCB0byBib3ggc2lkZSAxXHJcbiAgICAgICAgdmFyIG5lZ2F0aXZlVGFuZ2VudCA9IGNvbGxpZGVQb2x5Z29uc19uZWdhdGl2ZVRhbmdlbnQ7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUobmVnYXRpdmVUYW5nZW50LCB0YW5nZW50LCAtMSk7XHJcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMSwgaW5jaWRlbnRFZGdlLCBuZWdhdGl2ZVRhbmdlbnQsIHNpZGVPZmZzZXQxIC8qLCBpdjEqLyk7XHJcbiAgICAgICAgaWYgKG5wIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xpcCB0byBuZWdhdGl2ZSBib3ggc2lkZSAxXHJcbiAgICAgICAgbnAgPSBjbGlwU2VnbWVudFRvTGluZShjbGlwUG9pbnRzMiwgY2xpcFBvaW50czEsIHRhbmdlbnQsIHNpZGVPZmZzZXQyIC8qLCBpdjIqLyk7XHJcbiAgICAgICAgaWYgKG5wIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50Q291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TWFuaWZvbGRQb2ludHM7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIGNsaXBQb2ludHMyW2ldKSAtIGZyb250T2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICArK3BvaW50Q291bnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHkxLCBib2R5MiwgcG9seTEsIHBvbHkyKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoYy5ub3JtYWxBLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShjLmNvbnRhY3RQb2ludEIsIGNsaXBQb2ludHMyW2ldKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keTIucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoZGlzdCwgbm9ybWFsLCAtc2VwYXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoYy5jb250YWN0UG9pbnRBLCBjbGlwUG9pbnRzMltpXSwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHkxLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24gJiYgIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnRDb3VudCAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShwb2ludENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludENvdW50O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8vTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XHJcbiAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlSGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoY2lyY2xlQm9keSwgY2lyY2xlU2hhcGUsIGNpcmNsZVBvcywgaGZCb2R5LCBoZlNoYXBlLCBoZlBvcywganVzdFRlc3QsIHJhZGl1cykge1xyXG4gICAgICAgIHZhciBkYXRhID0gaGZTaGFwZS5oZWlnaHRzLCB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsIGRpc3QgPSBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0LCBjYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUsIG1pbkNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSwgbWluQ2FuZGlkYXRlTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsLCB3b3JsZE5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsLCB2MCA9IGNpcmNsZUhlaWdodGZpZWxkX3YwLCB2MSA9IGNpcmNsZUhlaWdodGZpZWxkX3YxO1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcclxuICAgICAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoKGNpcmNsZVBvc1swXSAtIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcpLCBpZHhCID0gTWF0aC5jZWlsKChjaXJjbGVQb3NbMF0gKyByYWRpdXMgLSBoZlBvc1swXSkgLyB3KTtcclxuICAgICAgICAvKmlmKGlkeEIgPCAwIHx8IGlkeEEgPj0gZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDsqL1xyXG4gICAgICAgIGlmIChpZHhBIDwgMCkge1xyXG4gICAgICAgICAgICBpZHhBID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeEIgPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IG1heCBhbmQgbWluXHJcbiAgICAgICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sIG1pbiA9IGRhdGFbaWR4Ql07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkeEE7IGkgPCBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNpcmNsZVBvc1sxXSAtIHJhZGl1cyA+IG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICBpZihjaXJjbGVQb3NbMV0rcmFkaXVzIDwgbWluKXtcclxuICAgICAgICAgICAgLy8gQmVsb3cgdGhlIG1pbmltdW0gcG9pbnQuLi4gV2UgY2FuIGp1c3QgZ3Vlc3MuXHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIGZpZWxkLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cclxuICAgICAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXHJcbiAgICAgICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXHJcbiAgICAgICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxyXG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDwgaWR4QjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBwb2ludHNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHYwLCBpICogdywgZGF0YVtpXSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2MSwgKGkgKyAxKSAqIHcsIGRhdGFbaSArIDFdKTtcclxuICAgICAgICAgICAgYWRkKHYwLCB2MCwgaGZQb3MpOyAvLyBAdG9kbyB0cmFuc2Zvcm0gY2lyY2xlIHRvIGxvY2FsIGhlaWdodGZpZWxkIHNwYWNlIGluc3RlYWRcclxuICAgICAgICAgICAgYWRkKHYxLCB2MSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsXHJcbiAgICAgICAgICAgIHN1Yih3b3JsZE5vcm1hbCwgdjEsIHYwKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCwgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICBub3JtYWxpemUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgZWRnZVxyXG4gICAgICAgICAgICBzY2FsZShjYW5kaWRhdGUsIHdvcmxkTm9ybWFsLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgYWRkKGNhbmRpZGF0ZSwgY2FuZGlkYXRlLCBjaXJjbGVQb3MpO1xyXG4gICAgICAgICAgICAvLyBEaXN0YW5jZSBmcm9tIHYwIHRvIHRoZSBjYW5kaWRhdGUgcG9pbnRcclxuICAgICAgICAgICAgc3ViKGRpc3QsIGNhbmRpZGF0ZSwgdjApO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgZWxlbWVudCBcInN0aWNrXCJcclxuICAgICAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlWzBdID49IHYwWzBdICYmIGNhbmRpZGF0ZVswXSA8IHYxWzBdICYmIGQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2FuZGlkYXRlIHBvaW50LCBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2VcclxuICAgICAgICAgICAgICAgIHNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCAtZCk7XHJcbiAgICAgICAgICAgICAgICBhZGQobWluQ2FuZGlkYXRlLCBjYW5kaWRhdGUsIGRpc3QpO1xyXG4gICAgICAgICAgICAgICAgY29weShtaW5DYW5kaWRhdGVOb3JtYWwsIHdvcmxkTm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LCBjaXJjbGVCb2R5LCBoZlNoYXBlLCBjaXJjbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgaXMgb3V0IG9mIHRoZSBoZWlnaHRmaWVsZFxyXG4gICAgICAgICAgICAgICAgY29weShjLm5vcm1hbEEsIG1pbkNhbmRpZGF0ZU5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gaGVpZ2h0ZmllbGRcclxuICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb3B5KGMuY29udGFjdFBvaW50QSwgbWluQ2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcclxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChyYWRpdXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBpZHhBOyBpIDw9IGlkeEI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHBvaW50XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjAsIGkgKiB3LCBkYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIGFkZCh2MCwgdjAsIGhmUG9zKTtcclxuICAgICAgICAgICAgICAgIHN1YihkaXN0LCBjaXJjbGVQb3MsIHYwKTtcclxuICAgICAgICAgICAgICAgIGlmIChzcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzLCAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqdXN0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LCBjaXJjbGVCb2R5LCBoZlNoYXBlLCBjaXJjbGVTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG5vcm1hbCAtIG91dCBvZiBoZWlnaHRmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlKGMuY29udGFjdFBvaW50QiwgYy5ub3JtYWxBLCAtcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2MCwgaGZQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICAvL05hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5CT1ggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxyXG4gICAgLy9OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuSEVJR0hURklFTERdID1cclxuICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSwgaGZCb2R5LCBoZlNoYXBlLCBoZlBvcywganVzdFRlc3QpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGhmU2hhcGUuaGVpZ2h0cywgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLCB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLCB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLCB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcywgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XHJcbiAgICAgICAgdmFyIGlkeEEgPSBNYXRoLmZsb29yKChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcpLCBpZHhCID0gTWF0aC5jZWlsKChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcpO1xyXG4gICAgICAgIGlmIChpZHhBIDwgMCkge1xyXG4gICAgICAgICAgICBpZHhBID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeEIgPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWR4QiA9IGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IG1heCBhbmQgbWluXHJcbiAgICAgICAgdmFyIG1heCA9IGRhdGFbaWR4QV0sIG1pbiA9IGRhdGFbaWR4Ql07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkeEE7IGkgPCBpZHhCOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnZleEJvZHkuYWFiYi5sb3dlckJvdW5kWzFdID4gbWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xyXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcclxuICAgICAgICAvLyBAdG9kbyBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcclxuICAgICAgICAvLyBAdG9kbyB0cmFuc2Zvcm0gY29udmV4IHRvIGxvY2FsIGhlaWdodGZpZWxkIHNwYWNlLlxyXG4gICAgICAgIC8vIEB0b2RvIGJhaWwgb3V0IGlmIHRoZSBoZWlnaHRmaWVsZCB0aWxlIGlzIG5vdCB0YWxsIGVub3VnaC5cclxuICAgICAgICBmb3IgKHZhciBpID0gaWR4QTsgaSA8IGlkeEI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBHZXQgcG9pbnRzXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh2MCwgaSAqIHcsIGRhdGFbaV0pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodjEsIChpICsgMSkgKiB3LCBkYXRhW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIGFkZCh2MCwgdjAsIGhmUG9zKTtcclxuICAgICAgICAgICAgYWRkKHYxLCB2MSwgaGZQb3MpO1xyXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcclxuICAgICAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRpbGVQb3MsICh2MVswXSArIHYwWzBdKSAqIDAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSAqIDAuNSk7XHJcbiAgICAgICAgICAgIHN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzBdLCB2MSwgdGlsZVBvcyk7XHJcbiAgICAgICAgICAgIHN1Yih0aWxlQ29udmV4LnZlcnRpY2VzWzFdLCB2MCwgdGlsZVBvcyk7XHJcbiAgICAgICAgICAgIGNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XHJcbiAgICAgICAgICAgIGNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1szXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1swXSk7XHJcbiAgICAgICAgICAgIHRpbGVDb252ZXgudmVydGljZXNbMl1bMV0gLT0gdGlsZUhlaWdodDtcclxuICAgICAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1szXVsxXSAtPSB0aWxlSGVpZ2h0O1xyXG4gICAgICAgICAgICB0aWxlQ29udmV4LnVwZGF0ZU5vcm1hbHMoKTtcclxuICAgICAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxyXG4gICAgICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSwgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1Db250YWN0cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTmFycm93cGhhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE5hcnJvd3BoYXNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciB2MCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBpbnRlcnNlY3QgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIFJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQSBsaW5lIHdpdGggYSBzdGFydCBhbmQgZW5kIHBvaW50IHRoYXQgaXMgdXNlZCB0byBpbnRlcnNlY3Qgc2hhcGVzLiBGb3IgYW4gZXhhbXBsZSwgc2VlIHt7I2Nyb3NzTGluayBcIldvcmxkL3JheWNhc3Q6bWV0aG9kXCJ9fVdvcmxkLnJheWNhc3R7ey9jcm9zc0xpbmt9fVxyXG4gICAgICogQGNsYXNzIFJheVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5mcm9tXVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMudG9dXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1vZGU9UmF5LkFOWV1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSYXkob3B0aW9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIG9mIHRoZSByYXlcclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICB0aGlzLmZyb20gPSBvcHRpb25zLmZyb20gPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmZyb20pIDogdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy50byA9IG9wdGlvbnMudG8gPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLnRvKSA6IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlIDogdHJ1ZTtcclxuICAgICAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSAhIW9wdGlvbnMuc2tpcEJhY2tmYWNlcztcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSBvcHRpb25zLmNvbGxpc2lvbk1hc2sgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uTWFzayA6IC0xO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSBvcHRpb25zLmNvbGxpc2lvbkdyb3VwICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbkdyb3VwIDogLTE7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vZGUgOiBSYXkuQU5ZO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICggLypyZXN1bHQqLykgeyB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaWYgeW91IGNoYW5nZSB0aGUgZnJvbSBvciB0byBwb2ludC5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSAuZGlyZWN0aW9uIGFuZCAubGVuZ3RoXHJcbiAgICAgICAgdmFyIGQgPSB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChkLCB0aGlzLnRvLCB0aGlzLmZyb20pO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKGQpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShkLCBkKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXJlc3VsdC5zaG91bGRTdG9wKHRoaXMpICYmIGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBhYWJiID0gYm9keS5nZXRBQUJCKCk7XHJcbiAgICAgICAgICAgIGlmIChhYWJiLm92ZXJsYXBzUmF5KHRoaXMpID49IDAgfHwgYWFiYi5jb250YWluc1BvaW50KHRoaXMuZnJvbSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShyZXN1bHQsIGJvZHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2hvb3QgYSByYXkgYXQgYSBib2R5LCBnZXQgYmFjayBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0LlxyXG4gICAgICogQG1ldGhvZCBpbnRlcnNlY3RCb2R5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm9keSA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZHkpIHtcclxuICAgICAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcclxuICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgc2hhcGUuY29sbGlzaW9uTWFzaykgPT09IDAgfHwgKHNoYXBlLmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGFuZ2xlIGFuZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGVcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRBbmdsZSA9IHNoYXBlLmFuZ2xlICsgYm9keS5hbmdsZTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RTaGFwZShyZXN1bHQsIHNoYXBlLCB3b3JsZEFuZ2xlLCB3b3JsZFBvc2l0aW9uLCBib2R5KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaG91bGRTdG9wKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5XHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U2hhcGUgPSBmdW5jdGlvbiAocmVzdWx0LCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICAgICAgLy8gQ2hlY2tpbmcgcmFkaXVzXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCB0aGlzLmRpcmVjdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IHNoYXBlLmJvdW5kaW5nUmFkaXVzICogc2hhcGUuYm91bmRpbmdSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50Qm9keSA9IGJvZHk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgc2hhcGUucmF5Y2FzdChyZXN1bHQsIHRoaXMsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFNoYXBlID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXHJcbiAgICAgKiBAbWV0aG9kIGdldEFBQkJcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcclxuICAgICAqL1xyXG4gICAgUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHZhciB0byA9IHRoaXMudG87XHJcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb207XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHJlc3VsdC5sb3dlckJvdW5kLCBNYXRoLm1pbih0b1swXSwgZnJvbVswXSksIE1hdGgubWluKHRvWzFdLCBmcm9tWzFdKSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHJlc3VsdC51cHBlckJvdW5kLCBNYXRoLm1heCh0b1swXSwgZnJvbVswXSksIE1hdGgubWF4KHRvWzFdLCBmcm9tWzFdKSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJlcG9ydEludGVyc2VjdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZnJhY3Rpb25cclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBub3JtYWxcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2ZhY2VJbmRleD0tMV1cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlIC8vIFRoaXMgbmV2ZXIgcmV0dXJuZWQgYW55dGhpbmcuXHJcbiAgICAgKi9cclxuICAgIFJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCwgZnJhY3Rpb24sIG5vcm1hbCwgZmFjZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5fY3VycmVudFNoYXBlO1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5fY3VycmVudEJvZHk7XHJcbiAgICAgICAgLy8gU2tpcCBiYWNrIGZhY2VzP1xyXG4gICAgICAgIGlmICh0aGlzLnNraXBCYWNrZmFjZXMgJiYgdmVjMl8xLmRlZmF1bHQuZG90KG5vcm1hbCwgdGhpcy5kaXJlY3Rpb24pID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUmF5LkFMTDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQobm9ybWFsLCBzaGFwZSwgYm9keSwgZnJhY3Rpb24sIGZhY2VJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSYXkuQ0xPU0VTVDpcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uIDwgcmVzdWx0LmZyYWN0aW9uIHx8ICFyZXN1bHQuaGFzSGl0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG5vcm1hbCwgc2hhcGUsIGJvZHksIGZyYWN0aW9uLCBmYWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmF5LkFOWTpcclxuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQobm9ybWFsLCBzaGFwZSwgYm9keSwgZnJhY3Rpb24sIGZhY2VJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSB0cmF2ZXJzZSB0aHJvdWdoIGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBvbmx5IHJldHVybiB0aGUgY2xvc2VzdCBvbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQ0xPU0VTVFxyXG4gICAgICovXHJcbiAgICBSYXkuQ0xPU0VTVCA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgbWFrZSB0aGUgUmF5IHN0b3Agd2hlbiBpdCBmaW5kcyB0aGUgZmlyc3QgaW50ZXJzZWN0aW9uIHBvaW50LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEFOWVxyXG4gICAgICovXHJcbiAgICBSYXkuQU5ZID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCB0cmF2ZXJzZSBhbGwgaW50ZXJzZWN0aW9uIHBvaW50cyBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayBmb3IgZWFjaCBvbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gQUxMXHJcbiAgICAgKi9cclxuICAgIFJheS5BTEwgPSA0O1xyXG4gICAgcmV0dXJuIFJheTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmF5O1xyXG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb25TcXVhcmVkKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcclxuICAgIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cclxuICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHYwLCBwb3NpdGlvbiwgZnJvbSk7XHJcbiAgICB2YXIgZG90ID0gdmVjMl8xLmRlZmF1bHQuZG90KHYwLCBkaXJlY3Rpb24pO1xyXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uICogZG90ICsgZnJvbVxyXG4gICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZXJzZWN0LCBkaXJlY3Rpb24sIGRvdCk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoaW50ZXJzZWN0LCBpbnRlcnNlY3QsIGZyb20pO1xyXG4gICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShwb3NpdGlvbiwgaW50ZXJzZWN0KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgcmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmF5XCIpKTtcclxudmFyIFJheWNhc3RSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3JhZ2UgZm9yIFJheSBjYXN0aW5nIGhpdCBkYXRhLlxyXG4gICAgICogQGNsYXNzIFJheWNhc3RSZXN1bHRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSYXljYXN0UmVzdWx0KCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBub3JtYWwgb2YgdGhlIGhpdCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHthcnJheX0gbm9ybWFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgaW5kZXhhYmxlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlSW5kZXhcclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzdGFuY2UgdG8gdGhlIGhpdCwgYXMgYSBmcmFjdGlvbi4gMCBpcyBhdCB0aGUgXCJmcm9tXCIgcG9pbnQsIDEgaXMgYXQgdGhlIFwidG9cIiBwb2ludC4gV2lsbCBiZSBzZXQgdG8gLTEgaWYgdGhlcmUgd2FzIG5vIGhpdCB5ZXQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZyYWN0aW9uXHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyYWN0aW9uID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNTdG9wcGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLiBNdXN0IGJlIGRvbmUgYmVmb3JlIHJlLXVzaW5nIHRoZSByZXN1bHQgb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZCByZXNldFxyXG4gICAgICovXHJcbiAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodGhpcy5ub3JtYWwsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5mcmFjdGlvbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBoaXQgcG9pbnQuXHJcbiAgICAgKiBAbWV0aG9kIGdldEhpdERpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1JheX0gcmF5XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdERpc3RhbmNlID0gZnVuY3Rpb24gKHJheSkge1xyXG4gICAgICAgIHJldHVybiB2ZWMyXzEuZGVmYXVsdC5kaXN0YW5jZShyYXkuZnJvbSwgcmF5LnRvKSAqIHRoaXMuZnJhY3Rpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJheSBoaXQgc29tZXRoaW5nIHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXHJcbiAgICAgKiBAbWV0aG9kIGhhc0hpdFxyXG4gICAgICogQMKuZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmhhc0hpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcmFjdGlvbiAhPT0gLTE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgd29ybGQgaGl0IHBvaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRIaXRQb2ludFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0ge1JheX0gcmF5XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdFBvaW50ID0gZnVuY3Rpb24gKG91dCwgcmF5KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubGVycChvdXQsIHJheS5mcm9tLCByYXkudG8sIHRoaXMuZnJhY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIGNhbGxlZCB3aGlsZSBpdGVyYXRpbmcgb3ZlciBoaXRzIHRvIHN0b3Agc2VhcmNoaW5nIGZvciBoaXQgcG9pbnRzLlxyXG4gICAgICogQG1ldGhvZCBzdG9wXHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzaG91bGRTdG9wXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtSYXl9IHJheVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2hvdWxkU3RvcCA9IGZ1bmN0aW9uIChyYXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1N0b3BwZWQgfHwgKHRoaXMuZnJhY3Rpb24gIT09IC0xICYmIHJheS5tb2RlID09PSByYXlfMS5kZWZhdWx0LkFOWSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5vcm1hbFxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZUluZGV4XHJcbiAgICAgKi9cclxuICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChub3JtYWwsIHNoYXBlLCBib2R5LCBmcmFjdGlvbiwgZmFjZUluZGV4KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLm5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuICAgICAgICB0aGlzLmZyYWN0aW9uID0gZnJhY3Rpb247XHJcbiAgICAgICAgdGhpcy5mYWNlSW5kZXggPSBmYWNlSW5kZXg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJheWNhc3RSZXN1bHQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJheWNhc3RSZXN1bHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBicm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnJvYWRwaGFzZVwiKSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy91dGlsc1wiKSk7XHJcbi8vIFRPRE86IHRoaXMgYXBwZWFycyB0byBiZSBhIGJ1YmJsZSBzb3J0LiBXZSBjb3VsZCBwcm9iYWJseSBkbyBiZXR0ZXIuXHJcbmZ1bmN0aW9uIHNvcnRBeGlzTGlzdChhLCBheGlzSW5kZXgpIHtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgLy8gV2h5IG5vdCBpPTA/XHJcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYVtqICsgMV0gPSBhW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhW2ogKyAxXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufVxyXG52YXIgU0FQQnJvYWRwaGFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTQVBCcm9hZHBoYXNlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNBUEJyb2FkcGhhc2UoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYnJvYWRwaGFzZV8xLmRlZmF1bHQuU0FQKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmF4aXNMaXN0ID0gW107XHJcbiAgICAgICAgX3RoaXMuYXhpc0luZGV4ID0gMDtcclxuICAgICAgICBfdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5heGlzTGlzdC5wdXNoKGUuYm9keSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBfdGhpcy5heGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5heGlzTGlzdC5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHdvcmxkXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkXHJcbiAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxyXG4gICAgICovXHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xyXG4gICAgICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxyXG4gICAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBBZGQgYWxsIGJvZGllcyBmcm9tIHRoZSBuZXcgd29ybGRcclxuICAgICAgICB1dGlsc18xLmRlZmF1bHQuYXBwZW5kQXJyYXkodGhpcy5heGlzTGlzdCwgd29ybGQuYm9kaWVzKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcclxuICAgICAgICB3b3JsZFxyXG4gICAgICAgICAgICAub2ZmKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcilcclxuICAgICAgICAgICAgLm9mZihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xyXG4gICAgICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxyXG4gICAgICAgIC8vIFRPRE86IG5vdyB0aGF0IEkndmUgYWRkZWQgY29udGV4dCwgd2UgY2FuIHRlc3QgbW92aW5nIHRob3NlIGlubGluZSBmdW5jdGlvbnMgdG8gcHJvcGVyIHByaXZhdGUgbWV0aG9kcy5cclxuICAgICAgICB3b3JsZC5vbihcImFkZEJvZHlcIiwgdGhpcy5fYWRkQm9keUhhbmRsZXIsIHRoaXMpXHJcbiAgICAgICAgICAgIC5vbihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCwgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XHJcbiAgICAgICAgLy8gU29ydCB0aGUgbGlzdHNcclxuICAgICAgICBzb3J0QXhpc0xpc3QoYm9kaWVzLCBheGlzSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjb2xsaWRpbmcgcGFpcnNcclxuICAgICAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKCAvKndvcmxkKi8pIHtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCwgcmVzdWx0ID0gdGhpcy5yZXN1bHQsIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgQUFCQnMgaWYgbmVlZGVkXHJcbiAgICAgICAgdmFyIGwgPSBib2RpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbbF07XHJcbiAgICAgICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29ydCB0aGUgbGlzdHNcclxuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XHJcbiAgICAgICAgLy8gTG9vayB0aHJvdWdoIHRoZSBYIGxpc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZGllcy5sZW5ndGggfCAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBOOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcclxuICAgICAgICAgICAgICAgIC8vIEJvdW5kcyBvdmVybGFwP1xyXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gKGJqLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IGJpLmFhYmIudXBwZXJCb3VuZFtheGlzSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChicm9hZHBoYXNlXzEuZGVmYXVsdC5jYW5Db2xsaWRlKGJpLCBiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLCBiaikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxyXG4gICAgICogQG1ldGhvZCBhYWJiUXVlcnlcclxuICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxyXG4gICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX1cclxuICAgICAqIEB0b2RvIHNpbmNlIHRoZSBsaXN0IGlzIHNvcnRlZCwgb3B0aW1pemF0aW9uIGNhbiBiZSBkb25lXHJcbiAgICAgKi9cclxuICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uICh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcclxuICAgICAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKGIuYWFiYk5lZWRzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBTQVBCcm9hZHBoYXNlO1xyXG59KGJyb2FkcGhhc2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNBUEJyb2FkcGhhc2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGNvbnN0cmFpbnQgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIENvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB0eXBlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuICAgICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcclxuICAgICAgICAvLyBXYWtlIHVwIGJvZGllcyB3aGVuIGNvbm5lY3RlZFxyXG4gICAgICAgIGlmICgoKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndha2VVcEJvZGllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEpIHtcclxuICAgICAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGNvbnN0cmFpbnQgcGFyYW1ldGVycyBiZWZvcmUgc29sdmUuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBzdGlmZm5lc3MgZm9yIHRoaXMgY29uc3RyYWludC5cclxuICAgICAqIEBtZXRob2Qgc2V0U3RpZmZuZXNzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldFN0aWZmbmVzcyA9IGZ1bmN0aW9uIChzdGlmZm5lc3MpIHtcclxuICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbaV07XHJcbiAgICAgICAgICAgIGVxLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcclxuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCByZWxheGF0aW9uIGZvciB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAbWV0aG9kIHNldFJlbGF4YXRpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldFJlbGF4YXRpb24gPSBmdW5jdGlvbiAocmVsYXhhdGlvbikge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XHJcbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldE1heEJpYXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhCaWFzXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEJpYXMgPSBmdW5jdGlvbiAobWF4Qmlhcykge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGVxc1tpXTtcclxuICAgICAgICAgICAgZXEubWF4QmlhcyA9IG1heEJpYXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERJU1RBTkNFXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuRElTVEFOQ0UgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gR0VBUlxyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LkdFQVIgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gTE9DS1xyXG4gICAgICovXHJcbiAgICBDb25zdHJhaW50LkxPQ0sgPSAzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUFJJU01BVElDXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuUFJJU01BVElDID0gNDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFVk9MVVRFXHJcbiAgICAgKi9cclxuICAgIENvbnN0cmFpbnQuUkVWT0xVVEUgPSA1O1xyXG4gICAgcmV0dXJuIENvbnN0cmFpbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgcmkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXHJcbnZhciByaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcclxudmFyIERpc3RhbmNlQ29uc3RyYWludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEaXN0YW5jZUNvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvLyB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAvLyB0aGlzLnVwcGVyTGltaXQgPSAxO1xyXG4gICAgLy8gdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgLy8gdGhpcy5sb3dlckxpbWl0ID0gMDtcclxuICAgIC8vIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJhaW50IHRoYXQgdHJpZXMgdG8ga2VlcCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzIGNvbnN0YW50LlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlBLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBbmNob3JCXSBUaGUgYW5jaG9yIHBvaW50IGZvciBib2R5QiwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCIGZyYW1lLiBEZWZhdWx0cyB0byBbMCwwXS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5tYXhGb3JjZT1OdW1iZXIuTUFYX1ZBTFVFXSBNYXhpbXVtIGZvcmNlIHRvIGFwcGx5LlxyXG4gICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gSWYgZGlzdGFuY2UgaXMgbm90IGdpdmVuIGFzIGFuIG9wdGlvbiwgdGhlbiB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib2RpZXMgaXMgdXNlZC5cclxuICAgICAqICAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIHRoZSBib2RpZXMgd2lsbCBiZSBjb25zdHJhaW5lZCB0byBoYXZlIGEgZGlzdGFuY2Ugb2YgMiBiZXR3ZWVuIHRoZWlyIGNlbnRlcnMuXHJcbiAgICAgKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcclxuICAgICAqICAgICB2YXIgYm9keUIgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbMSwgMF0gfSk7XHJcbiAgICAgKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgZGlzdGFuY2UgYW5kIGFuY2hvcnNcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIGRpc3RhbmNlOiAxLCAgICAgICAgICAvLyBEaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIHBvaW50c1xyXG4gICAgICogICAgICAgICBsb2NhbEFuY2hvckE6IFsxLCAwXSwgLy8gUG9pbnQgb24gYm9keUFcclxuICAgICAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbLTEsIDBdIC8vIFBvaW50IG9uIGJvZHlCXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LkRJU1RBTkNFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heCBmb3JjZSB0byBhcHBseS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tYXhGb3JjZSA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSB1cHBlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVwcGVyTGltaXRFbmFibGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdXBwZXIgY29uc3RyYWludCBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdXBwZXJMaW1pdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXQgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93ZXIgY29uc3RyYWludCBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93ZXJMaW1pdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgY29uc3RyYWludCBwb3NpdGlvbi4gVGhpcyBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvY2FsQW5jaG9yQSkgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikgPyB2ZWMyXzEuZGVmYXVsdC5jbG9uZShvcHRpb25zLmxvY2FsQW5jaG9yQikgOiB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgbG9jYWxBbmNob3JBID0gX3RoaXMubG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHZhciBsb2NhbEFuY2hvckIgPSBfdGhpcy5sb2NhbEFuY2hvckI7XHJcbiAgICAgICAgX3RoaXMuZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc3RhbmNlKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgY3VycmVudCB3b3JsZCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCByID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZEFuY2hvckEsIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRBbmNob3JCLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHIsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZEFuY2hvckIpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCByLCB3b3JsZEFuY2hvckEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyLCByLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIF90aGlzLmRpc3RhbmNlID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Rm9yY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbbm9ybWFsXTtcclxuICAgICAgICBfdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgICAgIC8vIGcgPSAoeGkgLSB4aikuZG90KG4pXHJcbiAgICAgICAgLy8gZGcvZHQgPSAodmkgLSB2aikuZG90KG4pID0gRypXID0gW24gMCAtbiAwXSAqIFt2aSB3aSB2aiB3al0nXHJcbiAgICAgICAgLy8gLi4uYW5kIGlmIHdlIHdlcmUgdG8gaW5jbHVkZSBvZmZzZXQgcG9pbnRzOlxyXG4gICAgICAgIC8vIGcgPVxyXG4gICAgICAgIC8vICAgICAgKHhqICsgcmogLSB4aSAtIHJpKS5kb3QobikgLSBkaXN0YW5jZVxyXG4gICAgICAgIC8vIGRnL2R0ID1cclxuICAgICAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XHJcbiAgICAgICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XHJcbiAgICAgICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XHJcbiAgICAgICAgLy8gICAgICBHICogV1xyXG4gICAgICAgIC8vID0+IEcgPSBbLW4gLXJpeG4gbiByanhuXVxyXG4gICAgICAgIHZhciByID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHJpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHZhciByaiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcclxuICAgICAgICB2YXIgdGhhdCA9IF90aGlzO1xyXG4gICAgICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgeGkgPSBib2R5QS5wb3NpdGlvbiwgeGogPSBib2R5Qi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJpLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHIsIHhqLCByaik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHIsIHIsIHJpKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QociwgciwgeGkpO1xyXG4gICAgICAgICAgICAvL3ZlYzIuc3VidHJhY3QociwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0Lmxlbmd0aChyKSAtIHRoYXQuZGlzdGFuY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXHJcbiAgICAgICAgX3RoaXMuc2V0TWF4Rm9yY2UobWF4Rm9yY2UpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBEaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF0sIGJvZHlBID0gdGhpcy5ib2R5QSwgYm9keUIgPSB0aGlzLmJvZHlCLCB4aSA9IGJvZHlBLnBvc2l0aW9uLCB4aiA9IGJvZHlCLnBvc2l0aW9uLCBub3JtYWxFcXVhdGlvbiA9IHRoaXMuZXF1YXRpb25zWzBdLCBHID0gbm9ybWFsLkc7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUocmksIHRoaXMubG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCB0aGlzLmxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQobiwgeGosIHJqKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChuLCBuLCByaSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobiwgbiwgeGkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgobik7XHJcbiAgICAgICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnVwcGVyTGltaXRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5taW5Gb3JjZSA9IC10aGlzLm1heEZvcmNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMudXBwZXJMaW1pdDtcclxuICAgICAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPCB0aGlzLmxvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XHJcbiAgICAgICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodGhpcy5sb3dlckxpbWl0RW5hYmxlZCB8fCB0aGlzLnVwcGVyTGltaXRFbmFibGVkKSAmJiAhdmlvbGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxyXG4gICAgICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9ybWFsRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG4sIG4pO1xyXG4gICAgICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xyXG4gICAgICAgIHZhciByaXhuID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIG4pLCByanhuID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmosIG4pO1xyXG4gICAgICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxyXG4gICAgICAgIEdbMF0gPSAtblswXTtcclxuICAgICAgICBHWzFdID0gLW5bMV07XHJcbiAgICAgICAgR1syXSA9IC1yaXhuO1xyXG4gICAgICAgIEdbM10gPSBuWzBdO1xyXG4gICAgICAgIEdbNF0gPSBuWzFdO1xyXG4gICAgICAgIEdbNV0gPSByanhuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhGb3JjZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlXHJcbiAgICAgKi9cclxuICAgIERpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAobWF4Rm9yY2UpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XHJcbiAgICAgICAgbm9ybWFsLm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG4gICAgICAgIG5vcm1hbC5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2VcclxuICAgICAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbC5tYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlzdGFuY2VDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERpc3RhbmNlQ29uc3RyYWludDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGFuZ2xlX2xvY2tfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2FuZ2xlLWxvY2stZXF1YXRpb25cIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgR2VhckNvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoR2VhckNvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnMgdGhlIGFuZ2xlIG9mIHR3byBib2RpZXMgdG8gZWFjaCBvdGhlciB0byBiZSBlcXVhbC4gSWYgYSBnZWFyIHJhdGlvIGlzIG5vdCBvbmUsIHRoZSBhbmdsZSBvZiBib2R5QSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGFuZ2xlIG9mIGJvZHlCLlxyXG4gICAgICogQGNsYXNzIEdlYXJDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICAgICAgICAgIGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF0gUmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLiBXaWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBhbmdsZSBiZXR3ZWVuIHRoZSBib2RpZXMgKHRoZSBnZWFyIHJhdGlvIGlzIGFjY291bnRlZCBmb3IpLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLnJhdGlvPTFdIEdlYXIgcmF0aW8uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgW29wdGlvbnMubWF4VG9ycXVlXSBNYXhpbXVtIHRvcnF1ZSB0byBhcHBseS5cclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xyXG4gICAgICogICAgICAgICByYXRpbzogMixcclxuICAgICAqICAgICAgICAgbWF4VG9ycXVlOiAxMDAwXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2VhckNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LkdFQVIsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGdlYXIgcmF0aW8uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJhdGlvXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5yYXRpbyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYXRpbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVsYXRpdmUgYW5nbGVcclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmdsZSA6IGJvZHlCLmFuZ2xlIC0gX3RoaXMucmF0aW8gKiBib2R5QS5hbmdsZTtcclxuICAgICAgICAvLyBTZW5kIHNhbWUgcGFyYW1ldGVycyB0byB0aGUgZXF1YXRpb25cclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBhbmdsZV9sb2NrX2VxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIHtcclxuICAgICAgICAgICAgICAgIHJhdGlvOiBfdGhpcy5yYXRpbyxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBfdGhpcy5hbmdsZVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIC8vIFNldCBtYXggdG9ycXVlXHJcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4VG9ycXVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0TWF4VG9ycXVlKG9wdGlvbnMubWF4VG9ycXVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXEgPSB0aGlzLmVxdWF0aW9uc1swXTtcclxuICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLnJhdGlvO1xyXG4gICAgICAgIGlmIChlcS5yYXRpbyAhPT0gcmF0aW8pIHtcclxuICAgICAgICAgICAgZXEuc2V0UmF0aW8ocmF0aW8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlcS5hbmdsZSA9IHRoaXMuYW5nbGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcclxuICAgICAqL1xyXG4gICAgR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcclxuICAgICAgICB0aGlzLmVxdWF0aW9uc1swXS5zZXRNYXhUb3JxdWUodG9ycXVlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWF4IHRvcnF1ZSBmb3IgdGhlIGNvbnN0cmFpbnQuXHJcbiAgICAgKiBAbWV0aG9kIGdldE1heFRvcnF1ZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBHZWFyQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVxdWF0aW9uc1swXS5tYXhGb3JjZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VhckNvbnN0cmFpbnQ7XHJcbn0oY29uc3RyYWludF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2VhckNvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgeEF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDEsIDApO1xyXG52YXIgeUF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG52YXIgTG9ja0NvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTG9ja0NvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxyXG4gICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgY29uc3RyYWludF8xLmRlZmF1bHQuTE9DSywgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICB2YXIgbWF4Rm9yY2UgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Rm9yY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xyXG4gICAgICAgIC8vIFVzZSAzIGVxdWF0aW9uczpcclxuICAgICAgICAvLyBneCA9ICAgKHhqIC0geGkgLSBsKSAqIHhoYXQgPSAwXHJcbiAgICAgICAgLy8gZ3kgPSAgICh4aiAtIHhpIC0gbCkgKiB5aGF0ID0gMFxyXG4gICAgICAgIC8vIGdyID0gICAoeGkgLSB4aiArIHIpICogdGhhdCA9IDBcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIC4uLndoZXJlOlxyXG4gICAgICAgIC8vICAgbCBpcyB0aGUgbG9jYWxPZmZzZXRCIHZlY3RvciByb3RhdGVkIHRvIHdvcmxkIGluIGJvZHlBIGZyYW1lXHJcbiAgICAgICAgLy8gICByIGlzIHRoZSBzYW1lIHZlY3RvciBidXQgcmV2ZXJzZWQgYW5kIHJvdGF0ZWQgZnJvbSBib2R5QiBmcmFtZVxyXG4gICAgICAgIC8vICAgeGhhdCwgeWhhdCBhcmUgd29ybGQgYXhpcyB2ZWN0b3JzXHJcbiAgICAgICAgLy8gICB0aGF0IGlzIHRoZSB0YW5nZW50IG9mIHJcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEZvciB0aGUgZmlyc3QgdHdvIGNvbnN0cmFpbnRzLCB3ZSBnZXRcclxuICAgICAgICAvLyBHKlcgPSAodmogLSB2aSAtIGxkb3QgICkgKiB4aGF0XHJcbiAgICAgICAgLy8gICAgID0gKHZqIC0gdmkgLSB3aSB4IGwpICogeGhhdFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU2luY2UgKHdpIHggbCkgKiB4aGF0ID0gKGwgeCB4aGF0KSAqIHdpLCB3ZSBnZXRcclxuICAgICAgICAvLyBHKlcgPSBbIC0xICAgMCAgICgtbCB4IHhoYXQpICAxICAgMCAgIDBdICogW3ZpIHdpIHZqIHdqXVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGxhc3QgY29uc3RyYWludCBnaXZlc1xyXG4gICAgICAgIC8vIEdXID0gKHZpIC0gdmogKyB3aiB4IHIpICogdGhhdFxyXG4gICAgICAgIC8vICAgID0gWyAgdGhhdCAgIDAgIC10aGF0ICAociB4IHQpIF1cclxuICAgICAgICB2YXIgeCA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSwgeSA9IG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSwgcm90ID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xyXG4gICAgICAgIHZhciBsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGcgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdGhhdCA9IF90aGlzO1xyXG4gICAgICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZywgZywgbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnWzBdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnLCBnLCBsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdbMV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgciA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgcm90LmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHIsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5Qi5hbmdsZSAtIHRoYXQubG9jYWxBbmdsZUIpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShyLCByLCAtMSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGcsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChnLCBnLCByKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHQsIHIsIC1NYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZSh0LCB0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdChnLCB0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbE9mZnNldEJcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsT2Zmc2V0Qikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KF90aGlzLmxvY2FsT2Zmc2V0Qiwgb3B0aW9ucy5sb2NhbE9mZnNldEIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoX3RoaXMubG9jYWxPZmZzZXRCLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUoX3RoaXMubG9jYWxPZmZzZXRCLCBfdGhpcy5sb2NhbE9mZnNldEIsIC1ib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvZmZzZXQgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9jYWxBbmdsZUJcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbEFuZ2xlQiA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuZ2xlQikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh4KTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh5KTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChyb3QpO1xyXG4gICAgICAgIF90aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4aW11bSBmb3JjZSB0byBiZSBhcHBsaWVkLlxyXG4gICAgICogQG1ldGhvZCBzZXRNYXhGb3JjZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvcmNlXHJcbiAgICAgKi9cclxuICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xyXG4gICAgICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9IGZvcmNlO1xyXG4gICAgICAgICAgICBlcXNbaV0ubWluRm9yY2UgPSAtZm9yY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2UuXHJcbiAgICAgKiBAbWV0aG9kIGdldE1heEZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XHJcbiAgICB9O1xyXG4gICAgTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZXF1YXRpb25zWzBdLCB5ID0gdGhpcy5lcXVhdGlvbnNbMV0sIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobCwgdGhpcy5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUociwgdGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLmFuZ2xlIC0gdGhpcy5sb2NhbEFuZ2xlQik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUociwgciwgLTEpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0LCByLCBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKHQsIHQpO1xyXG4gICAgICAgIHguR1swXSA9IC0xO1xyXG4gICAgICAgIHguR1sxXSA9IDA7XHJcbiAgICAgICAgeC5HWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKGwsIHhBeGlzKTtcclxuICAgICAgICB4LkdbM10gPSAxO1xyXG4gICAgICAgIHkuR1swXSA9IDA7XHJcbiAgICAgICAgeS5HWzFdID0gLTE7XHJcbiAgICAgICAgeS5HWzJdID0gLXZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKGwsIHlBeGlzKTtcclxuICAgICAgICB5LkdbNF0gPSAxO1xyXG4gICAgICAgIHJvdC5HWzBdID0gLXRbMF07XHJcbiAgICAgICAgcm90LkdbMV0gPSAtdFsxXTtcclxuICAgICAgICByb3QuR1szXSA9IHRbMF07XHJcbiAgICAgICAgcm90LkdbNF0gPSB0WzFdO1xyXG4gICAgICAgIHJvdC5HWzVdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgociwgdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvY2tDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExvY2tDb25zdHJhaW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvY29udGFjdC1lcXVhdGlvblwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgcm90YXRpb25hbF9sb2NrX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9yb3RhdGlvbmFsLWxvY2stZXF1YXRpb25cIikpO1xyXG52YXIgd29ybGRBeGlzQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB3b3JsZEFuY2hvckEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgd29ybGRBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIG9yaWVudGVkQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBvcmllbnRlZEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdG1wID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBQcmlzbWF0aWNDb25zdHJhaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFByaXNtYXRpY0NvbnN0cmFpbnQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnQgdGhhdCBvbmx5IGFsbG93cyBib2RpZXMgdG8gbW92ZSBhbG9uZyBhIGxpbmUsIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5pZm9yY2UyZC5uZXQvYjJkdHV0L2pvaW50cy1wcmlzbWF0aWNcIj50aGlzIHR1dG9yaWFsPC9hPi4gQWxzbyBjYWxsZWQgXCJzbGlkZXIgY29uc3RyYWludFwiLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBQcmlzbWF0aWNDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIENvbnN0cmFpbnRcclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV0gTWF4IGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gQm9keSBBJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckJdIEJvZHkgQidzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxBeGlzQV0gQW4gYXhpcywgZGVmaW5lZCBpbiBib2R5IEEgZnJhbWUsIHRoYXQgYm9keSBCJ3MgYW5jaG9yIHBvaW50IG1heSBzbGlkZSBhbG9uZy5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrXSBJZiBzZXQgdG8gdHJ1ZSwgYm9keUIgd2lsbCBiZSBmcmVlIHRvIHJvdGF0ZSBhcm91bmQgaXRzIGFuY2hvciBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy51cHBlckxpbWl0XVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvd2VyTGltaXRdXHJcbiAgICAgKiBAdG9kbyBBYmlsaXR5IHRvIGNyZWF0ZSB1c2luZyBvbmx5IGEgcG9pbnQgYW5kIGEgd29ybGRBeGlzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIGxvY2FsQXhpc0E6IFswLCAxXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFByaXNtYXRpY0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBjb25zdHJhaW50XzEuZGVmYXVsdC5QUklTTUFUSUMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gR2V0IGFuY2hvcnNcclxuICAgICAgICB2YXIgbG9jYWxBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGxvY2FsQXhpc0EgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDEsIDApLCBsb2NhbEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQSkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGxvY2FsQW5jaG9yQSwgb3B0aW9ucy5sb2NhbEFuY2hvckEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQXhpc0EpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShsb2NhbEF4aXNBLCBvcHRpb25zLmxvY2FsQXhpc0EpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsQW5jaG9yQikge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KGxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5sb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG4gICAgICAgIF90aGlzLmxvY2FsQXhpc0EgPSBsb2NhbEF4aXNBO1xyXG4gICAgICAgIC8qXHJcblxyXG4gICAgICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBmb3IgdGhlIGNvbW1vbiBheGlzIHBvaW50IGlzXHJcblxyXG4gICAgICAgICAgICBnID0gKCB4aiArIHJqIC0geGkgLSByaSApICogdCAgIDo9ICBnZyp0XHJcblxyXG4gICAgICAgIHdoZXJlIHIgYXJlIGJvZHktbG9jYWwgYW5jaG9yIHBvaW50cywgYW5kIHQgaXMgYSB0YW5nZW50IHRvIHRoZSBjb25zdHJhaW50IGF4aXMgZGVmaW5lZCBpbiBib2R5IGkgZnJhbWUuXHJcblxyXG4gICAgICAgICAgICBnZG90ID0gICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB0ICsgKCB4aiArIHJqIC0geGkgLSByaSApICogKCB3aSB4IHQgKVxyXG5cclxuICAgICAgICBOb3RlIHRoZSB1c2Ugb2YgdGhlIGNoYWluIHJ1bGUuIE5vdyB3ZSBpZGVudGlmeSB0aGUgamFjb2JpYW5cclxuXHJcbiAgICAgICAgICAgIEcqVyA9IFsgLXQgICAgICAtcmkgeCB0ICsgdCB4IGdnICAgICB0ICAgIHJqIHggdCBdICogW3ZpIHdpIHZqIHdqXVxyXG5cclxuICAgICAgICBUaGUgcm90YXRpb25hbCBwYXJ0IGlzIGp1c3QgYSByb3RhdGlvbiBsb2NrLlxyXG5cclxuICAgICAgICAqL1xyXG4gICAgICAgIHZhciBtYXhGb3JjZSA9IF90aGlzLm1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICAvLyBUcmFuc2xhdGlvbmFsIHBhcnRcclxuICAgICAgICB2YXIgdHJhbnMgPSBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7XHJcbiAgICAgICAgdmFyIHJpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHJqID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGdnID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIHByYWN0aWNlLlxyXG4gICAgICAgIHRyYW5zLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHRcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdChnZywgdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIHByYWN0aWNlLlxyXG4gICAgICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgRyA9IHRoaXMuRywgeGkgPSBib2R5QS5wb3NpdGlvbiwgeGogPSBib2R5Qi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJpLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKGdnLCB4aiwgcmopO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChnZywgZ2csIHhpKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoZ2csIGdnLCByaSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh0LCBsb2NhbEF4aXNBLCBib2R5QS5hbmdsZSArIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgR1swXSA9IC10WzBdO1xyXG4gICAgICAgICAgICBHWzFdID0gLXRbMV07XHJcbiAgICAgICAgICAgIEdbMl0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIHQpICsgdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgodCwgZ2cpO1xyXG4gICAgICAgICAgICBHWzNdID0gdFswXTtcclxuICAgICAgICAgICAgR1s0XSA9IHRbMV07XHJcbiAgICAgICAgICAgIEdbNV0gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaCh0cmFucyk7XHJcbiAgICAgICAgLy8gUm90YXRpb25hbCBwYXJ0XHJcbiAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9jaykpIHtcclxuICAgICAgICAgICAgdmFyIHJvdCA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgICAgIF90aGlzLmVxdWF0aW9ucy5wdXNoKHJvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiBhbmNob3IgQSByZWxhdGl2ZSB0byBhbmNob3IgQiwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICAvLyBJcyB0aGlzIG9uZSB1c2VkIGF0IGFsbD9cclxuICAgICAgICBfdGhpcy52ZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxvd2VyTGltaXRFbmFibGVkID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb3dlckxpbWl0KSAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSB1cHBlciBsaW1pdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBwZXJMaW1pdCkgIT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb3dlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb3dlckxpbWl0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwcGVyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHBlckxpbWl0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxO1xyXG4gICAgICAgIC8vIEVxdWF0aW9ucyB1c2VkIGZvciBsaW1pdHNcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24gPSBuZXcgY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICAvLyBTZXQgbWF4L21pbiBmb3JjZXNcclxuICAgICAgICBfdGhpcy51cHBlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSBfdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IF90aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVxdWF0aW9uIHVzZWQgZm9yIHRoZSBtb3Rvci5cclxuICAgICAgICAgKiBAcHJvcGVydHkgbW90b3JFcXVhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtFcXVhdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IEVxdWF0aW9uXzEuZGVmYXVsdChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50IG1vdG9yIHN0YXRlLiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgbW90b3IgdXNpbmcgLmVuYWJsZU1vdG9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1vdG9yRW5hYmxlZFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgdGFyZ2V0IHNwZWVkIGZvciB0aGUgbW90b3IuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1vdG9yU3BlZWRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1vdG9yU3BlZWQgPSAwO1xyXG4gICAgICAgIHZhciB0aGF0ID0gX3RoaXM7XHJcbiAgICAgICAgdmFyIG1vdG9yRXF1YXRpb24gPSBfdGhpcy5tb3RvckVxdWF0aW9uO1xyXG4gICAgICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcclxuICAgICAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEcgPSB0aGlzLkcsIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCLCB2aSA9IGJpLnZlbG9jaXR5LCB2aiA9IGJqLnZlbG9jaXR5LCB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSwgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHZpLCB3aSwgdmosIHdqKSArIHRoYXQubW90b3JTcGVlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zLCB0cmFucyA9IGVxc1swXSwgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCwgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCwgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLCBib2R5QSA9IHRoaXMuYm9keUEsIGJvZHlCID0gdGhpcy5ib2R5QiwgbG9jYWxBeGlzQSA9IHRoaXMubG9jYWxBeGlzQSwgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckEsIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xyXG4gICAgICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuKCk7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIHRoaW5ncyB0byB3b3JsZFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZEF4aXNBLCBsb2NhbEF4aXNBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG9yaWVudGVkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkQW5jaG9yQSwgb3JpZW50ZWRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG9yaWVudGVkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKHdvcmxkQW5jaG9yQiwgb3JpZW50ZWRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIHJlbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZEFuY2hvckIsIHdvcmxkQXhpc0EpIC0gdmVjMl8xLmRlZmF1bHQuZG90KHdvcmxkQW5jaG9yQSwgd29ybGRBeGlzQSk7XHJcbiAgICAgICAgLy8gTW90b3JcclxuICAgICAgICBpZiAodGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgLy8gRyA9IFsgYSAgICAgYSB4IHJpICAgLWEgICAtYSB4IHJqIF1cclxuICAgICAgICAgICAgdmFyIEcgPSB0aGlzLm1vdG9yRXF1YXRpb24uRztcclxuICAgICAgICAgICAgR1swXSA9IHdvcmxkQXhpc0FbMF07XHJcbiAgICAgICAgICAgIEdbMV0gPSB3b3JsZEF4aXNBWzFdO1xyXG4gICAgICAgICAgICBHWzJdID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSwgb3JpZW50ZWRBbmNob3JCKTtcclxuICAgICAgICAgICAgR1szXSA9IC13b3JsZEF4aXNBWzBdO1xyXG4gICAgICAgICAgICBHWzRdID0gLXdvcmxkQXhpc0FbMV07XHJcbiAgICAgICAgICAgIEdbNV0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSwgb3JpZW50ZWRBbmNob3JBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgTGltaXRzIHN0cmF0ZWd5OlxyXG4gICAgICAgICAgICBBZGQgY29udGFjdCBlcXVhdGlvbiwgd2l0aCBub3JtYWwgYWxvbmcgdGhlIGNvbnN0cmFpbnQgYXhpcy5cclxuICAgICAgICAgICAgbWluL21heEZvcmNlIGlzIHNldCBzbyB0aGUgY29uc3RyYWludCBpcyByZXB1bHNpdmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICBTb21lIG9mZnNldCBpcyBhZGRlZCB0byBlaXRoZXIgZXF1YXRpb24uY29udGFjdFBvaW50QSBvciAuY29udGFjdFBvaW50QiB0byBnZXQgdGhlIGNvcnJlY3QgdXBwZXIvbG93ZXIgbGltaXQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF5cclxuICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgdXBwZXJMaW1pdCB4XHJcbiAgICAgICAgICAgICAgICAgICAgfCAgICAtLS0tLS1cclxuICAgICAgICAgICAgYW5jaG9yQiB4PC0tLXwgIEIgfFxyXG4gICAgICAgICAgICAgICAgICAgIHwgICAgfCAgICB8XHJcbiAgICAgICAgICAgIC0tLS0tLSAgIHwgICAgLS0tLS0tXHJcbiAgICAgICAgICAgIHwgICAgfCAgIHxcclxuICAgICAgICAgICAgfCAgQSB8LS0+eCBhbmNob3JBXHJcbiAgICAgICAgICAgIC0tLS0tLSAgIHxcclxuICAgICAgICAgICAgICAgICAgICB4IGxvd2VyTGltaXRcclxuICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgaWYgKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPiB1cHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodXBwZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIC0xKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHRtcCwgd29ybGRBeGlzQSwgdXBwZXJMaW1pdCk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgdXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHRtcCk7XHJcbiAgICAgICAgICAgIGlmIChlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPCBsb3dlckxpbWl0KSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUobG93ZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIDEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodG1wLCB3b3JsZEF4aXNBLCBsb3dlckxpbWl0KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB0bXApO1xyXG4gICAgICAgICAgICBpZiAoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGVxcy5wdXNoKGxvd2VyTGltaXRFcXVhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIHRoZSBtb3RvclxyXG4gICAgICogQG1ldGhvZCBlbmFibGVNb3RvclxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XHJcbiAgICAgICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxyXG4gICAgICogQG1ldGhvZCBkaXNhYmxlTW90b3JcclxuICAgICAqL1xyXG4gICAgUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tb3RvckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29uc3RyYWludCBsaW1pdHMuXHJcbiAgICAgKiBAbWV0aG9kIHNldExpbWl0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGxpbWl0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGxpbWl0LlxyXG4gICAgICovXHJcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAobG93ZXIpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mICh1cHBlcikgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xyXG4gICAgICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQcmlzbWF0aWNDb25zdHJhaW50O1xyXG59KGNvbnN0cmFpbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgcm90YXRpb25hbF92ZWxvY2l0eV9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvcm90YXRpb25hbC12ZWxvY2l0eS1lcXVhdGlvblwiKSk7XHJcbnZhciByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL3JvdGF0aW9uYWwtbG9jay1lcXVhdGlvblwiKSk7XHJcbnZhciBzdWIgPSB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdDtcclxudmFyIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZDtcclxudmFyIGRvdCA9IHZlYzJfMS5kZWZhdWx0LmRvdDtcclxudmFyIHJvdGF0ZSA9IHZlYzJfMS5kZWZhdWx0LnJvdGF0ZTtcclxudmFyIGNvcHkgPSB2ZWMyXzEuZGVmYXVsdC5jb3B5O1xyXG52YXIgY3Jvc3NMZW5ndGggPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aDtcclxudmFyIHdvcmxkUGl2b3RBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkUGl2b3RCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHhBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygxLCAwKSwgeUF4aXMgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpLCBnID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBSZXZvbHV0ZUNvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmV2b2x1dGVDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cclxuICAgICAqIEBjbGFzcyBSZXZvbHV0ZUNvbnN0cmFpbnRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGF1dGhvciBzY2h0ZXBwZVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMud29ybGRQaXZvdF0gQSBwaXZvdCBwb2ludCBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy4gSWYgc3BlY2lmaWVkLCBsb2NhbFBpdm90QSBhbmQgbG9jYWxQaXZvdEIgYXJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgZnJvbSB0aGlzIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90QV0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiBib2R5QSB3aGljaCBib2R5QSBpcyBjb25zdHJhaW5lZCB0by5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEJdIFNlZSBsb2NhbFBpdm90QS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAZXh0ZW5kcyBDb25zdHJhaW50XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgcmV2b2x1dGUgY29uc3RyYWludCBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuIHRoZW0uXHJcbiAgICAgKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWy0xLCAwXSB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keUIpO1xyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxyXG4gICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcclxuICAgICAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIGNvbnN0cmFpbnRfMS5kZWZhdWx0LlJFVk9MVVRFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIHZhciBtYXhGb3JjZSA9IF90aGlzLm1heEZvcmNlID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heEZvcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcclxuICAgICAgICB2YXIgcGl2b3RBID0gX3RoaXMucGl2b3RBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIHBpdm90QiA9IF90aGlzLnBpdm90QiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ybGRQaXZvdCkge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHBpdm90QSBhbmQgcGl2b3RCXHJcbiAgICAgICAgICAgIHN1YihwaXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIocGl2b3RCLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlCLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy8gUm90YXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgICAgICAgIHJvdGF0ZShwaXZvdEEsIHBpdm90QSwgLWJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHBpdm90QiwgcGl2b3RCLCAtYm9keUIuYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gR2V0IHBpdm90QSBhbmQgcGl2b3RCXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWxQaXZvdEEpIHtcclxuICAgICAgICAgICAgICAgIGNvcHkocGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsUGl2b3RCKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5KHBpdm90Qiwgb3B0aW9ucy5sb2NhbFBpdm90Qik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vdG9yRXF1YXRpb24gPSBfdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IHJvdGF0aW9uYWxfdmVsb2NpdHlfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgbW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHVwcGVyTGltaXRFcXVhdGlvbiA9IF90aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgdmFyIGxvd2VyTGltaXRFcXVhdGlvbiA9IF90aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyByb3RhdGlvbmFsX2xvY2tfZXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5Qik7XHJcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gbG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gMDtcclxuICAgICAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcclxuICAgICAgICB2YXIgZXFzID0gX3RoaXMuZXF1YXRpb25zID0gW1xyXG4gICAgICAgICAgICBuZXcgRXF1YXRpb25fMS5kZWZhdWx0KGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSksXHJcbiAgICAgICAgICAgIG5ldyBFcXVhdGlvbl8xLmRlZmF1bHQoYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKSxcclxuICAgICAgICAgICAgbW90b3JFcXVhdGlvbixcclxuICAgICAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLFxyXG4gICAgICAgICAgICBsb3dlckxpbWl0RXF1YXRpb25cclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciB4ID0gZXFzWzBdO1xyXG4gICAgICAgIHZhciB5ID0gZXFzWzFdO1xyXG4gICAgICAgIC8vIFRPRE86IGJhZCBwcmFjdGljZS5cclxuICAgICAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcclxuICAgICAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAgICAgYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XHJcbiAgICAgICAgICAgIHN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHN1YihnLCBnLCB3b3JsZFBpdm90QSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkb3QoZywgeEF4aXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgICAgIGFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzdWIoZywgZywgd29ybGRQaXZvdEEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG90KGcsIHlBeGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHkubWluRm9yY2UgPSB4Lm1pbkZvcmNlID0gLW1heEZvcmNlO1xyXG4gICAgICAgIHkubWF4Rm9yY2UgPSB4Lm1heEZvcmNlID0gbWF4Rm9yY2U7XHJcbiAgICAgICAgLy8gVGhlc2UgbmV2ZXIgY2hhbmdlIGJ1dCB0aGUgYW5ndWxhciBwYXJ0cyBkb1xyXG4gICAgICAgIHguR1swXSA9IC0xO1xyXG4gICAgICAgIHguR1sxXSA9IDA7XHJcbiAgICAgICAgeC5HWzNdID0gMTtcclxuICAgICAgICB4LkdbNF0gPSAwO1xyXG4gICAgICAgIHkuR1swXSA9IDA7XHJcbiAgICAgICAgeS5HWzFdID0gLTE7XHJcbiAgICAgICAgeS5HWzNdID0gMDtcclxuICAgICAgICB5LkdbNF0gPSAxO1xyXG4gICAgICAgIF90aGlzLmFuZ2xlID0gMDtcclxuICAgICAgICBfdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubG93ZXJMaW1pdCA9IDA7XHJcbiAgICAgICAgX3RoaXMudXBwZXJMaW1pdCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvbnN0cmFpbnQgYW5nbGUgbGltaXRzLCBhbmQgZW5hYmxlIHRoZW0uXHJcbiAgICAgKiBAbWV0aG9kIHNldExpbWl0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxyXG4gICAgICovXHJcbiAgICBSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcclxuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcclxuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcclxuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSwgYm9keUIgPSB0aGlzLmJvZHlCLCBwaXZvdEEgPSB0aGlzLnBpdm90QSwgcGl2b3RCID0gdGhpcy5waXZvdEIsIGVxcyA9IHRoaXMuZXF1YXRpb25zLCB4ID0gZXFzWzBdLCB5ID0gZXFzWzFdLCB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LCBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LCB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiwgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb247XHJcbiAgICAgICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XHJcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gdXBwZXJMaW1pdDtcclxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24uZW5hYmxlZCA9IHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPiB1cHBlckxpbWl0O1xyXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbi5hbmdsZSA9IGxvd2VyTGltaXQ7XHJcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmVuYWJsZWQgPSB0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlIDwgbG93ZXJMaW1pdDtcclxuICAgICAgICAvKlxyXG5cclxuICAgICAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gaXNcclxuXHJcbiAgICAgICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxyXG5cclxuICAgICAgICAuLi53aGVyZSB4aSBhbmQgeGogYXJlIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgcmkgYW5kIHJqIHdvcmxkLW9yaWVudGVkIG9mZnNldCB2ZWN0b3JzLiBEaWZmZXJlbnRpYXRlOlxyXG5cclxuICAgICAgICAgICAgZ2RvdCA9IHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaVxyXG5cclxuICAgICAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXHJcblxyXG4gICAgICAgICAgICBnZG90ICogeCA9ICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB4XHJcbiAgICAgICAgICAgICAgICAgICAgPSAoIHZqKnggKyAod2ogeCByaikqeCAtdmkqeCAtKHdpIHggcmkpKnhcclxuICAgICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxyXG4gICAgICAgICAgICAgICAgICAgID0gWyAteCAgIC0ocmkgeCB4KSAgIHggICAocmogeCB4KV0gKiBbdmkgd2kgdmogd2pdXHJcbiAgICAgICAgICAgICAgICAgICAgPSBHKldcclxuXHJcbiAgICAgICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XHJcblxyXG4gICAgICAgICAgICBHeCA9IFsgeCAgIChyaiB4IHgpICAgLXggICAtKHJpIHggeCldXHJcbiAgICAgICAgICAgIEd5ID0gWyB5ICAgKHJqIHggeSkgICAteSAgIC0ocmkgeCB5KV1cclxuXHJcbiAgICAgICAgU28gZm9yIGV4YW1wbGUsIGluIHRoZSBYIGRpcmVjdGlvbiB3ZSB3b3VsZCBnZXQgaW4gMiBkaW1lbnNpb25zXHJcblxyXG4gICAgICAgICAgICBHID0gWyBbMSAgIDAgICAocmogeCBbMSwwXSkgICAtMSAgIDAgICAtKHJpIHggWzEsMF0pXVxyXG4gICAgICAgICAgICAgICAgWzAgICAxICAgKHJqIHggWzAsMV0pICAgIDAgIC0xICAgLShyaSB4IFswLDFdKV1cclxuICAgICAgICAqL1xyXG4gICAgICAgIHJvdGF0ZSh3b3JsZFBpdm90QSwgcGl2b3RBLCBib2R5QS5hbmdsZSk7XHJcbiAgICAgICAgcm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcclxuICAgICAgICAvLyBAdG9kbzogdGhlc2UgYXJlIGEgYml0IHNwYXJzZS4gV2UgY291bGQgc2F2ZSBzb21lIGNvbXB1dGF0aW9ucyBvbiBtYWtpbmcgY3VzdG9tIGVxLmNvbXB1dGVHVyBmdW5jdGlvbnMsIGV0Y1xyXG4gICAgICAgIHZhciB4RyA9IHguRztcclxuICAgICAgICB4R1syXSA9IC1jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSwgeEF4aXMpO1xyXG4gICAgICAgIHhHWzVdID0gY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIsIHhBeGlzKTtcclxuICAgICAgICB2YXIgeUcgPSB5Lkc7XHJcbiAgICAgICAgeUdbMl0gPSAtY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEsIHlBeGlzKTtcclxuICAgICAgICB5R1s1XSA9IGNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLCB5QXhpcyk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUsIFwibW90b3JFbmFibGVkXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IG1vdG9yRW5hYmxlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLCBcIm1vdG9yU3BlZWRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb3RvclNwZWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdG9yRXF1YXRpb24ucmVsYXRpdmVWZWxvY2l0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5yZWxhdGl2ZVZlbG9jaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUsIFwibW90b3JNYXhGb3JjZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vdG9yTWF4Rm9yY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW90b3JFcXVhdGlvbi5tYXhGb3JjZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IHRoaXMubW90b3JFcXVhdGlvbjtcclxuICAgICAgICAgICAgZXEubWF4Rm9yY2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFJldm9sdXRlQ29uc3RyYWludDtcclxufShjb25zdHJhaW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbi8vIFNob3J0Y3V0cy5cclxudmFyIHNjYWxlID0gdmVjMl8xLmRlZmF1bHQuc2NhbGUsIG11bHRpcGx5ID0gdmVjMl8xLmRlZmF1bHQubXVsdGlwbHksIGNyZWF0ZVZlYzIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGU7XHJcbnZhciBFcXVhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBlcXVhdGlvbnMuXHJcbiAgICAgKiBAY2xhc3MgRXF1YXRpb25cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QSBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluRm9yY2UgTWluaW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogLUluZmluaXR5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogSW5maW5pdHlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtaW5Gb3JjZSwgbWF4Rm9yY2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXAgdGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIChHKnEpIHRvIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG1heEJpYXNcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4QmlhcyA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGlmZm5lc3Mgb2YgdGhpcyBlcXVhdGlvbi4gVHlwaWNhbGx5IGNob3NlbiB0byBhIGxhcmdlIG51bWJlciAofjFlNyksIGJ1dCBjYW4gYmUgY2hvc2VuIHNvbWV3aGF0IGZyZWVseSB0byBnZXQgYSBzdGFibGUgc2ltdWxhdGlvbi5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGltZSBzdGVwcyBuZWVkZWQgdG8gc3RhYmlsaXplIHRoZSBjb25zdHJhaW50IGVxdWF0aW9uLiBUeXBpY2FsbHkgYmV0d2VlbiAzIGFuZCA1IHRpbWUgc3RlcHMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5hID0gMDtcclxuICAgICAgICB0aGlzLmIgPSAwO1xyXG4gICAgICAgIHRoaXMuZXBzaWxvbiA9IDA7XHJcbiAgICAgICAgdGhpcy50aW1lU3RlcCA9IDEgLyA2MDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgc3RpZmZuZXNzIG9yIHJlbGF4YXRpb24gd2FzIGNoYW5nZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBuZWVkc1VwZGF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZXN1bHRpbmcgY29uc3RyYWludCBtdWx0aXBsaWVyIGZyb20gdGhlIGxhc3Qgc29sdmUuIFRoaXMgaXMgbW9zdGx5IGVxdWl2YWxlbnQgdG8gdGhlIGZvcmNlIHByb2R1Y2VkIGJ5IHRoZSBjb25zdHJhaW50LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF0aXZlIHZlbG9jaXR5LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxhdGl2ZVZlbG9jaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgZXF1YXRpb24gaXMgZW5hYmxlZCBvciBub3QuIElmIHRydWUsIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNvbHZlci5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIFRlbXAgc3R1ZmZcclxuICAgICAgICB0aGlzLm1heEZvcmNlRHQgPSAwO1xyXG4gICAgICAgIHRoaXMubWluRm9yY2VEdCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnZDID0gMDtcclxuICAgICAgICB0aGlzLkIgPSAwO1xyXG4gICAgICAgIHRoaXMubGFtYmRhID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5taW5Gb3JjZSA9IG1pbkZvcmNlICE9PSBudWxsICYmIG1pbkZvcmNlICE9PSB2b2lkIDAgPyBtaW5Gb3JjZSA6IC1JbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2UgIT09IG51bGwgJiYgbWF4Rm9yY2UgIT09IHZvaWQgMCA/IG1heEZvcmNlIDogSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXhCaWFzID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5ib2R5QSA9IGJvZHlBICE9PSBudWxsICYmIGJvZHlBICE9PSB2b2lkIDAgPyBib2R5QSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCICE9PSBudWxsICYmIGJvZHlCICE9PSB2b2lkIDAgPyBib2R5QiA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5HID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLkdbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBTUE9PSyBwYXJhbWV0ZXJzIC5hLCAuYiBhbmQgLmVwc2lsb24gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMuIFNlZSBlcXVhdGlvbnMgOSwgMTAgYW5kIDExIGluIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTgvVlQwOS9sZWN0dXJlcy9zcG9va25vdGVzLnBkZlwiPlNQT09LIG5vdGVzPC9hPi5cclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcywgZCA9IHRoaXMucmVsYXhhdGlvbiwgaCA9IHRoaXMudGltZVN0ZXA7XHJcbiAgICAgICAgdGhpcy5hID0gNCAvIChoICogKDEgKyA0ICogZCkpO1xyXG4gICAgICAgIHRoaXMuYiA9ICg0ICogZCkgLyAoMSArIDQgKiBkKTtcclxuICAgICAgICB0aGlzLmVwc2lsb24gPSA0IC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSBhIGphY29iaWFuIGVudHJ5IHdpdGggY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgb3IgdmVsb2NpdGllc1xyXG4gICAgICogQG1ldGhvZCBnbXVsdFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuZ211bHQgPSBmdW5jdGlvbiAoRywgdmksIHdpLCB2aiwgd2opIHtcclxuICAgICAgICByZXR1cm4gR1swXSAqIHZpWzBdICtcclxuICAgICAgICAgICAgR1sxXSAqIHZpWzFdICtcclxuICAgICAgICAgICAgR1syXSAqIHdpICtcclxuICAgICAgICAgICAgR1szXSAqIHZqWzBdICtcclxuICAgICAgICAgICAgR1s0XSAqIHZqWzFdICtcclxuICAgICAgICAgICAgR1s1XSAqIHdqO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIFJIUyBvZiB0aGUgU1BPT0sgZXF1YXRpb25cclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUJcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGEsIGIsIGgpIHtcclxuICAgICAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIHZhciBHcSA9IHRoaXMuY29tcHV0ZUdxKCk7XHJcbiAgICAgICAgdmFyIG1heEJpYXMgPSB0aGlzLm1heEJpYXM7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKEdxKSA+IG1heEJpYXMpIHtcclxuICAgICAgICAgICAgR3EgPSBHcSA+IDAgPyBtYXhCaWFzIDogLW1heEJpYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBCID0gLUdxICogYSAtIEdXICogYiAtIEdpTWYgKiBoO1xyXG4gICAgICAgIHJldHVybiBCO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHcVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HLCBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIGFpID0gYmkuYW5nbGUsIGFqID0gYmouYW5nbGU7XHJcbiAgICAgICAgdmFyIHFpID0gY3JlYXRlVmVjMigpLCBxaiA9IGNyZWF0ZVZlYzIoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCBxaSwgYWksIHFqLCBhaikgKyB0aGlzLm9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIEdcXCpXLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHV1xyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HLCBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHZpID0gYmkudmVsb2NpdHksIHZqID0gYmoudmVsb2NpdHksIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LCB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbXVsdChHLCB2aSwgd2ksIHZqLCB3aikgKyB0aGlzLnJlbGF0aXZlVmVsb2NpdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBHXFwqV2xhbWJkYSwgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgRyA9IHRoaXMuRywgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciB2aSA9IGJpLnZsYW1iZGEsIHZqID0gYmoudmxhbWJkYSwgd2kgPSBiaS53bGFtYmRhLCB3aiA9IGJqLndsYW1iZGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRywgdmksIHdpLCB2aiwgd2opO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKmludihNKVxcKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHaU1mXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBmaSA9IGJpLmZvcmNlLCB0aSA9IGJpLmFuZ3VsYXJGb3JjZSwgZmogPSBiai5mb3JjZSwgdGogPSBiai5hbmd1bGFyRm9yY2UsIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSwgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLCBHID0gdGhpcy5HO1xyXG4gICAgICAgIHZhciBpTWZpID0gY3JlYXRlVmVjMigpLCBpTWZqID0gY3JlYXRlVmVjMigpO1xyXG4gICAgICAgIHNjYWxlKGlNZmksIGZpLCBpbnZNYXNzaSk7XHJcbiAgICAgICAgbXVsdGlwbHkoaU1maSwgYmkubWFzc011bHRpcGxpZXIsIGlNZmkpO1xyXG4gICAgICAgIHNjYWxlKGlNZmosIGZqLCBpbnZNYXNzaik7XHJcbiAgICAgICAgbXVsdGlwbHkoaU1maiwgYmoubWFzc011bHRpcGxpZXIsIGlNZmopO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIGlNZmksIHRpICogaW52SWksIGlNZmosIHRqICogaW52SWopO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgR1xcKmludihNKVxcKkcnXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVHaU1HdFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiaSA9IHRoaXMuYm9keUEsIGJqID0gdGhpcy5ib2R5QjtcclxuICAgICAgICBpZiAoIWJpIHx8ICFiailcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLCBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSwgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLCBHID0gdGhpcy5HO1xyXG4gICAgICAgIHJldHVybiBHWzBdICogR1swXSAqIGludk1hc3NpICogYmkubWFzc011bHRpcGxpZXJbMF0gK1xyXG4gICAgICAgICAgICBHWzFdICogR1sxXSAqIGludk1hc3NpICogYmkubWFzc011bHRpcGxpZXJbMV0gK1xyXG4gICAgICAgICAgICBHWzJdICogR1syXSAqIGludklpICtcclxuICAgICAgICAgICAgR1szXSAqIEdbM10gKiBpbnZNYXNzaiAqIGJqLm1hc3NNdWx0aXBsaWVyWzBdICtcclxuICAgICAgICAgICAgR1s0XSAqIEdbNF0gKiBpbnZNYXNzaiAqIGJqLm1hc3NNdWx0aXBsaWVyWzFdICtcclxuICAgICAgICAgICAgR1s1XSAqIEdbNV0gKiBpbnZJajtcclxuICAgIH07XHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUudXBkYXRlSmFjb2JpYW4gPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXHJcbiAgICAgKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXHJcbiAgICAgKi9cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbiAoZGVsdGFsYW1iZGEpIHtcclxuICAgICAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLCBiaiA9IHRoaXMuYm9keUI7XHJcbiAgICAgICAgaWYgKCFiaSB8fCAhYmopXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLCBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSwgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsIEcgPSB0aGlzLkc7XHJcbiAgICAgICAgLy8gdl9sYW1iZGEgPSBHICogaW52KE0pICogZGVsdGFfbGFtYmRhXHJcbiAgICAgICAgYWRkVG9WTGFtYmRhKGJpLnZsYW1iZGEsIEdbMF0sIEdbMV0sIGludk1hc3NpLCBkZWx0YWxhbWJkYSwgYmkubWFzc011bHRpcGxpZXIpO1xyXG4gICAgICAgIGJpLndsYW1iZGEgKz0gaW52SWkgKiBHWzJdICogZGVsdGFsYW1iZGE7XHJcbiAgICAgICAgYWRkVG9WTGFtYmRhKGJqLnZsYW1iZGEsIEdbM10sIEdbNF0sIGludk1hc3NqLCBkZWx0YWxhbWJkYSwgYmoubWFzc011bHRpcGxpZXIpO1xyXG4gICAgICAgIGJqLndsYW1iZGEgKz0gaW52SWogKiBHWzVdICogZGVsdGFsYW1iZGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEdcXCppbnYoTSlcXCpHJyArIGVwc1xyXG4gICAgICogQG1ldGhvZCBjb21wdXRlSW52Q1xyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBlcHNcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVJbnZDID0gZnVuY3Rpb24gKGVwcykge1xyXG4gICAgICAgIHZhciBpbnZDID0gMSAvICh0aGlzLmNvbXB1dGVHaU1HdCgpICsgZXBzKTtcclxuICAgICAgICByZXR1cm4gaW52QztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHN0aWZmbmVzcyB3aGVuIGNyZWF0aW5nIGEgbmV3IEVxdWF0aW9uLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IERFRkFVTFRfU1RJRkZORVNTXHJcbiAgICAgKiBAZGVmYXVsdCAxZTZcclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1MgPSAxZTY7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHJlbGF4YXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1JFTEFYQVRJT05cclxuICAgICAqIEBkZWZhdWx0IDRcclxuICAgICAqL1xyXG4gICAgRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OID0gNDtcclxuICAgIHJldHVybiBFcXVhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXF1YXRpb247XHJcbmZ1bmN0aW9uIGFkZFRvVkxhbWJkYSh2bGFtYmRhLCBHeCwgR3ksIGludk1hc3MsIGRlbHRhbGFtYmRhLCBtYXNzTXVsdGlwbGllcikge1xyXG4gICAgdmxhbWJkYVswXSArPSBHeCAqIGludk1hc3MgKiBkZWx0YWxhbWJkYSAqIG1hc3NNdWx0aXBsaWVyWzBdO1xyXG4gICAgdmxhbWJkYVsxXSArPSBHeSAqIGludk1hc3MgKiBkZWx0YWxhbWJkYSAqIG1hc3NNdWx0aXBsaWVyWzFdO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIEFuZ2xlTG9ja0VxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFuZ2xlTG9ja0VxdWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NrcyB0aGUgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGUgY29uc3RyYWludCB0cmllcyB0byBrZWVwIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byB2ZWN0b3JzLCBsb2NhbCBpbiBlYWNoIGJvZHksIHRvIHplcm8uIFRoZSBsb2NhbCBhbmdsZSBpbiBib2R5IGkgaXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIEFuZ2xlTG9ja0VxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHkgQS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYXRpb10gR2VhciByYXRpb1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbmdsZUxvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLUluZmluaXR5LCBJbmZpbml0eSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5hbmdsZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICBfdGhpcy5yYXRpbyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICBfdGhpcy5zZXRSYXRpbyhfdGhpcy5yYXRpbyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYXRpbyAqIHRoaXMuYm9keUEuYW5nbGUgLSB0aGlzLmJvZHlCLmFuZ2xlICsgdGhpcy5hbmdsZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZ2VhciByYXRpbyBmb3IgdGhpcyBlcXVhdGlvblxyXG4gICAgICogQG1ldGhvZCBzZXRSYXRpb1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXHJcbiAgICAgKi9cclxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xyXG4gICAgICAgIHZhciBHID0gdGhpcy5HO1xyXG4gICAgICAgIEdbMl0gPSByYXRpbztcclxuICAgICAgICBHWzVdID0gLTE7XHJcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBlcXVhdGlvbi5cclxuICAgICAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXHJcbiAgICAgKi9cclxuICAgIEFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbiAodG9ycXVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXhGb3JjZSA9IHRvcnF1ZTtcclxuICAgICAgICB0aGlzLm1pbkZvcmNlID0gLXRvcnF1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQW5nbGVMb2NrRXF1YXRpb247XHJcbn0oRXF1YXRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FcXVhdGlvblwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbmZ1bmN0aW9uIGFkZFN1YlN1YihvdXQsIGEsIGIsIGMsIGQpIHtcclxuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdIC0gY1swXSAtIGRbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXSAtIGNbMV0gLSBkWzFdO1xyXG59XHJcbnZhciB2aSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdmogPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJlbFZlbCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgQ29udGFjdEVxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRhY3RFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb24uIFRyaWVzIHRvIG1ha2UgdGhlIGNvbnRhY3RQb2ludEEgYW5kIGNvbnRhY3RQb2ludEIgdmVjdG9ycyBjb2luY2lkZSwgd2hpbGUga2VlcGluZyB0aGUgYXBwbGllZCBmb3JjZSByZXB1bHNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBJbmZpbml0eSkgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZWN0b3IgZnJvbSBib2R5IGkgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29udGFjdFBvaW50QSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnBlbmV0cmF0aW9uVmVjID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIGZyb20gYm9keSBBIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbm9ybWFsIHZlY3RvciwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBub3JtYWxBXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm5vcm1hbEEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzdGl0dXRpb24gdG8gdXNlICgwPW5vIGJvdW5jaW5lc3MsIDE9bWF4IGJvdW5jaW5lc3MpLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMucmVzdGl0dXRpb24gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaW1wYWN0IGJldHdlZW4gdGhlIGJvZGllcyAobm90IHBlcnNpc3RhbnQgY29udGFjdCkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZpcnN0SW1wYWN0XHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZmlyc3RJbXBhY3QgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc2hhcGVBXHJcbiAgICAgICAgICogQHR5cGUge1NoYXBlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlQSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQlxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zaGFwZUIgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbiAoYSwgYiwgaCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGJpID0gdGhpcy5ib2R5QSwgYmogPSB0aGlzLmJvZHlCLCByaSA9IHRoaXMuY29udGFjdFBvaW50QSwgcmogPSB0aGlzLmNvbnRhY3RQb2ludEIsIHhpID0gKF9hID0gYmkgPT09IG51bGwgfHwgYmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRmxvYXQzMkFycmF5KDIpLCB4aiA9IChfYiA9IGJqID09PSBudWxsIHx8IGJqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiai5wb3NpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICB2YXIgbiA9IHRoaXMubm9ybWFsQSwgRyA9IHRoaXMuRztcclxuICAgICAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcclxuICAgICAgICB2YXIgcml4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCBuKSwgcmp4biA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJqLCBuKTtcclxuICAgICAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cclxuICAgICAgICBHWzBdID0gLW5bMF07XHJcbiAgICAgICAgR1sxXSA9IC1uWzFdO1xyXG4gICAgICAgIEdbMl0gPSAtcml4bjtcclxuICAgICAgICBHWzNdID0gblswXTtcclxuICAgICAgICBHWzRdID0gblsxXTtcclxuICAgICAgICBHWzVdID0gcmp4bjtcclxuICAgICAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxyXG4gICAgICAgIHZhciBHVywgR3E7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RJbXBhY3QgJiYgdGhpcy5yZXN0aXR1dGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBHcSA9IDA7XHJcbiAgICAgICAgICAgIEdXID0gKDEgLyBiKSAqICgxICsgdGhpcy5yZXN0aXR1dGlvbikgKiB0aGlzLmNvbXB1dGVHVygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHEgPSB4aityaiAtKHhpK3JpKSBpLmUuIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcclxuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gdGhpcy5wZW5ldHJhdGlvblZlYztcclxuICAgICAgICAgICAgYWRkU3ViU3ViKHBlbmV0cmF0aW9uVmVjLCB4aiwgcmosIHhpLCByaSk7XHJcbiAgICAgICAgICAgIEdxID0gdmVjMl8xLmRlZmF1bHQuZG90KG4sIHBlbmV0cmF0aW9uVmVjKSArIHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBCID0gLUdxICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xyXG4gICAgICAgIHJldHVybiBCO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByZWxhdGl2ZSB2ZWxvY2l0eSBhbG9uZyB0aGUgbm9ybWFsIHZlY3Rvci5cclxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBbG9uZ05vcm1hbFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBDb250YWN0RXF1YXRpb24ucHJvdG90eXBlLmdldFZlbG9jaXR5QWxvbmdOb3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5QSAmJiB0aGlzLmJvZHlBLmdldFZlbG9jaXR5QXRQb2ludCh2aSwgdGhpcy5jb250YWN0UG9pbnRBKTtcclxuICAgICAgICB0aGlzLmJvZHlCICYmIHRoaXMuYm9keUIuZ2V0VmVsb2NpdHlBdFBvaW50KHZqLCB0aGlzLmNvbnRhY3RQb2ludEIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJlbFZlbCwgdmksIHZqKTtcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuZG90KHRoaXMubm9ybWFsQSwgcmVsVmVsKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gQ29udGFjdEVxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb250YWN0RXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIEZyaWN0aW9uRXF1YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRnJpY3Rpb25FcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBGcmljdGlvbkVxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlwRm9yY2VcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBzbGlwRm9yY2UpIHtcclxuICAgICAgICBpZiAoc2xpcEZvcmNlID09PSB2b2lkIDApIHsgc2xpcEZvcmNlID0gSW5maW5pdHk7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSkgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBBIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQiB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29udGFjdFBvaW50QiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRhbmdlbnQgdmVjdG9yIHRoYXQgdGhlIGZyaWN0aW9uIGZvcmNlIHdpbGwgYWN0IGFsb25nLiBXb3JsZCBvcmllbnRlZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFjdEVxdWF0aW9ucyBjb25uZWN0ZWQgdG8gdGhpcyBmcmljdGlvbiBlcXVhdGlvbi4gVGhlIGNvbnRhY3QgZXF1YXRpb25zIGNhbiBiZSB1c2VkIHRvIHJlc2NhbGUgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGZyaWN0aW9uLiBJZiBtb3JlIHRoYW4gb25lIGNvbnRhY3QgZXF1YXRpb24gaXMgZ2l2ZW4sIHRoZW4gdGhlIG1heCBmb3JjZSBjYW4gYmUgc2V0IHRvIHRoZSBhdmVyYWdlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXHJcbiAgICAgICAgICogQHR5cGUge0NvbnRhY3RFcXVhdGlvbltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQVxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVBLi4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2hhcGVBID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnJpY3Rpb24uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNoYXBlQlxyXG4gICAgICAgICAqIEB0eXBlIHtTaGFwZX1cclxuICAgICAgICAgKiBAdG9kbyBOZWVkZWQ/IFRoZSBzaGFwZSBjYW4gYmUgbG9va2VkIHVwIHZpYSBjb250YWN0RXF1YXRpb24uc2hhcGVCLi4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5mcmljdGlvbkNvZWZmaWNpZW50ID0gMC4zO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzbGlwcGluZyBjb25kaXRpb24gZm9yIHRoZSBjb25zdHJhaW50LiBUaGUgZnJpY3Rpb24gZm9yY2UgY2Fubm90IGJlXHJcbiAgICAgKiBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG1ldGhvZCBzZXRTbGlwRm9yY2VcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gc2xpcEZvcmNlXHJcbiAgICAgKi9cclxuICAgIEZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLnNldFNsaXBGb3JjZSA9IGZ1bmN0aW9uIChzbGlwRm9yY2UpIHtcclxuICAgICAgICB0aGlzLm1heEZvcmNlID0gc2xpcEZvcmNlO1xyXG4gICAgICAgIHRoaXMubWluRm9yY2UgPSAtc2xpcEZvcmNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXggZm9yY2UgZm9yIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICogQG1ldGhvZCBnZXRTbGlwRm9yY2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuZ2V0U2xpcEZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heEZvcmNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGEsIGIsIGgpIHtcclxuICAgICAgICB2YXIgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLCB0ID0gdGhpcy50LCBHID0gdGhpcy5HO1xyXG4gICAgICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxyXG4gICAgICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcclxuICAgICAgICBHWzBdID0gLXRbMF07XHJcbiAgICAgICAgR1sxXSA9IC10WzFdO1xyXG4gICAgICAgIEdbMl0gPSAtdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmksIHQpO1xyXG4gICAgICAgIEdbM10gPSB0WzBdO1xyXG4gICAgICAgIEdbNF0gPSB0WzFdO1xyXG4gICAgICAgIEdbNV0gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyaiwgdCk7XHJcbiAgICAgICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSwgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcclxuICAgICAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC1HVyAqIGIgLSBoICogR2lNZjtcclxuICAgICAgICByZXR1cm4gQjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gRnJpY3Rpb25FcXVhdGlvbjtcclxufShFcXVhdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRnJpY3Rpb25FcXVhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEVxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vRXF1YXRpb25cIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgd29ybGRWZWN0b3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIHdvcmxkVmVjdG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB4QXhpcyA9IHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoMSwgMCksIHlBeGlzID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm90YXRpb25hbExvY2tFcXVhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHlBLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1JbmZpbml0eSwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgdmFyIEcgPSBfdGhpcy5HO1xyXG4gICAgICAgIEdbMl0gPSAxO1xyXG4gICAgICAgIEdbNV0gPSAtMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkVmVjdG9yQSwgeEF4aXMsIHRoaXMuYm9keUEuYW5nbGUgKyB0aGlzLmFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUod29ybGRWZWN0b3JCLCB5QXhpcywgdGhpcy5ib2R5Qi5hbmdsZSk7XHJcbiAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZFZlY3RvckEsIHdvcmxkVmVjdG9yQik7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XHJcbn0oRXF1YXRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpKTtcclxudmFyIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTeW5jcyByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHR3byBib2RpZXMsIG9yIHNldHMgYSByZWxhdGl2ZSB2ZWxvY2l0eSAobW90b3IpLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1JbmZpbml0eSwgSW5maW5pdHkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDE7XHJcbiAgICAgICAgX3RoaXMucmF0aW8gPSAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChhLCBiLCBoKSB7XHJcbiAgICAgICAgdmFyIEcgPSB0aGlzLkc7XHJcbiAgICAgICAgR1syXSA9IC0xO1xyXG4gICAgICAgIEdbNV0gPSB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xyXG4gICAgICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XHJcbiAgICAgICAgdmFyIEIgPSAtR1cgKiBiIC0gaCAqIEdpTWY7XHJcbiAgICAgICAgcmV0dXJuIEI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xyXG59KEVxdWF0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cclxuICogQGNsYXNzIEV2ZW50RW1pdHRlclxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAqICAgICBlbWl0dGVyLm9uKCdteUV2ZW50JywgZnVuY3Rpb24oZXZ0KXtcclxuICogICAgICAgICBjb25zb2xlLmxvZyhldnQubWVzc2FnZSk7XHJcbiAqICAgICB9KTtcclxuICogICAgIGVtaXR0ZXIuZW1pdCh7XHJcbiAqICAgICAgICAgdHlwZTogJ215RXZlbnQnLFxyXG4gKiAgICAgICAgIG1lc3NhZ2U6ICdIZWxsbyB3b3JsZCEnXHJcbiAqICAgICB9KTtcclxuICovXHJcbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgKiBAbWV0aG9kIG9uXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIGVtaXR0ZXIub24oJ215RXZlbnQnLCBmdW5jdGlvbihldnQpe1xyXG4gICAgICogICAgICAgICBjb25zb2xlLmxvZygnbXlFdnQgd2FzIHRyaWdnZXJlZCEnKTtcclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lciwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dHNbdHlwZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0c1t0eXBlXS5wdXNoKGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAgICogQG1ldGhvZCBvZmZcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgZW1pdHRlci5vbignbXlFdmVudCcsIGhhbmRsZXIpOyAvLyBBZGQgaGFuZGxlclxyXG4gICAgICogICAgIGVtaXR0ZXIub2ZmKCdteUV2ZW50JywgaGFuZGxlcik7IC8vIFJlbW92ZSBoYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMgfHwgIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW4gZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcclxuICAgICAqIEBtZXRob2QgaGFzXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW3R5cGVdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW1pdCBhbiBldmVudC5cclxuICAgICAqIEBtZXRob2QgZW1pdFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudC50eXBlXHJcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgZW1pdHRlci5lbWl0KHtcclxuICAgICAqICAgICAgICAgdHlwZTogJ215RXZlbnQnLFxyXG4gICAgICogICAgICAgICBjdXN0b21EYXRhOiAxMjNcclxuICAgICAqICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogdGhlIHVua25vd24gdHlwZSBoZXJlIGlzIGRpc3R1cmJpbmcuXHJcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xyXG4gICAgICAgIHZhciBjb250ZXh0QXJyYXkgPSB0aGlzLl9jb250ZXh0c1tldmVudC50eXBlXTtcclxuICAgICAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY29weSB0aGUgbGlzdGVuZXIgYXJyYXksIGluIGNhc2Ugc29tZSBsaXN0ZW5lciB3YXMgYWRkZWQvcmVtb3ZlZCBpbnNpZGUgYSBsaXN0ZW5lclxyXG4gICAgICAgICAgICB2YXIgdG1wTGlzdGVuZXJBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgdG1wQ29udGV4dEFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRtcExpc3RlbmVyQXJyYXkucHVzaChsaXN0ZW5lckFycmF5W2ldKTtcclxuICAgICAgICAgICAgICAgIHRtcENvbnRleHRBcnJheS5wdXNoKGNvbnRleHRBcnJheVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dEFycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250ZXh0LCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLnZlYzIgPSBleHBvcnRzLldvcmxkID0gZXhwb3J0cy5VdGlscyA9IGV4cG9ydHMuUm90YXRpb25hbFNwcmluZyA9IGV4cG9ydHMuTGluZWFyU3ByaW5nID0gZXhwb3J0cy5Ub3BEb3duVmVoaWNsZSA9IGV4cG9ydHMuU3ByaW5nID0gZXhwb3J0cy5Tb2x2ZXIgPSBleHBvcnRzLlNoYXBlID0gZXhwb3J0cy5TQVBCcm9hZHBoYXNlID0gZXhwb3J0cy5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IGV4cG9ydHMuQm94ID0gZXhwb3J0cy5SYXljYXN0UmVzdWx0ID0gZXhwb3J0cy5SYXkgPSBleHBvcnRzLlByaXNtYXRpY0NvbnN0cmFpbnQgPSBleHBvcnRzLlJldm9sdXRlQ29uc3RyYWludCA9IGV4cG9ydHMuUG9vbCA9IGV4cG9ydHMuUGxhbmUgPSBleHBvcnRzLlBhcnRpY2xlID0gZXhwb3J0cy5OYWl2ZUJyb2FkcGhhc2UgPSBleHBvcnRzLk5hcnJvd3BoYXNlID0gZXhwb3J0cy5NYXRlcmlhbCA9IGV4cG9ydHMuTG9ja0NvbnN0cmFpbnQgPSBleHBvcnRzLkxpbmUgPSBleHBvcnRzLkhlaWdodGZpZWxkID0gZXhwb3J0cy5HU1NvbHZlciA9IGV4cG9ydHMuR2VhckNvbnN0cmFpbnQgPSBleHBvcnRzLkZyaWN0aW9uRXF1YXRpb25Qb29sID0gZXhwb3J0cy5GcmljdGlvbkVxdWF0aW9uID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBleHBvcnRzLkVxdWF0aW9uID0gZXhwb3J0cy5EaXN0YW5jZUNvbnN0cmFpbnQgPSBleHBvcnRzLkNvbnZleCA9IGV4cG9ydHMuQ29udGFjdE1hdGVyaWFsID0gZXhwb3J0cy5Db250YWN0RXF1YXRpb25Qb29sID0gZXhwb3J0cy5Db250YWN0RXF1YXRpb24gPSBleHBvcnRzLkNvbnN0cmFpbnQgPSBleHBvcnRzLkNpcmNsZSA9IGV4cG9ydHMuQ2Fwc3VsZSA9IGV4cG9ydHMuQnJvYWRwaGFzZSA9IGV4cG9ydHMuQm9keSA9IGV4cG9ydHMuQW5nbGVMb2NrRXF1YXRpb24gPSBleHBvcnRzLkFBQkIgPSB2b2lkIDA7XHJcbnZhciB2ZXJzaW9uID0gXCIwLjAuMVwiO1xyXG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG52YXIgYWFiYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9hYWJiXCIpKTtcclxuZXhwb3J0cy5BQUJCID0gYWFiYl8xLmRlZmF1bHQ7XHJcbnZhciBhbmdsZV9sb2NrX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXF1YXRpb25zL2FuZ2xlLWxvY2stZXF1YXRpb25cIikpO1xyXG5leHBvcnRzLkFuZ2xlTG9ja0VxdWF0aW9uID0gYW5nbGVfbG9ja19lcXVhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBib2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2JqZWN0cy9ib2R5XCIpKTtcclxuZXhwb3J0cy5Cb2R5ID0gYm9keV8xLmRlZmF1bHQ7XHJcbnZhciBicm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL2Jyb2FkcGhhc2VcIikpO1xyXG5leHBvcnRzLkJyb2FkcGhhc2UgPSBicm9hZHBoYXNlXzEuZGVmYXVsdDtcclxudmFyIGNhcHN1bGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvY2Fwc3VsZVwiKSk7XHJcbmV4cG9ydHMuQ2Fwc3VsZSA9IGNhcHN1bGVfMS5kZWZhdWx0O1xyXG52YXIgY2lyY2xlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL2NpcmNsZVwiKSk7XHJcbmV4cG9ydHMuQ2lyY2xlID0gY2lyY2xlXzEuZGVmYXVsdDtcclxudmFyIGNvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5Db25zdHJhaW50ID0gY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciBjb250YWN0X2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXF1YXRpb25zL2NvbnRhY3QtZXF1YXRpb25cIikpO1xyXG5leHBvcnRzLkNvbnRhY3RFcXVhdGlvbiA9IGNvbnRhY3RfZXF1YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvY29udGFjdC1lcXVhdGlvbi1wb29sXCIpKTtcclxuZXhwb3J0cy5Db250YWN0RXF1YXRpb25Qb29sID0gY29udGFjdF9lcXVhdGlvbl9wb29sXzEuZGVmYXVsdDtcclxudmFyIGNvbnRhY3RfbWF0ZXJpYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXRlcmlhbC9jb250YWN0LW1hdGVyaWFsXCIpKTtcclxuZXhwb3J0cy5Db250YWN0TWF0ZXJpYWwgPSBjb250YWN0X21hdGVyaWFsXzEuZGVmYXVsdDtcclxudmFyIGNvbnZleF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9jb252ZXhcIikpO1xyXG5leHBvcnRzLkNvbnZleCA9IGNvbnZleF8xLmRlZmF1bHQ7XHJcbnZhciBkaXN0YW5jZV9jb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvZGlzdGFuY2UtY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuRGlzdGFuY2VDb25zdHJhaW50ID0gZGlzdGFuY2VfY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciBlcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VxdWF0aW9ucy9lcXVhdGlvblwiKSk7XHJcbmV4cG9ydHMuRXF1YXRpb24gPSBlcXVhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IGV2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0O1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lcXVhdGlvbnMvZnJpY3Rpb24tZXF1YXRpb25cIikpO1xyXG5leHBvcnRzLkZyaWN0aW9uRXF1YXRpb24gPSBmcmljdGlvbl9lcXVhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBmcmljdGlvbl9lcXVhdGlvbl9wb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvZnJpY3Rpb24tZXF1YXRpb24tcG9vbFwiKSk7XHJcbmV4cG9ydHMuRnJpY3Rpb25FcXVhdGlvblBvb2wgPSBmcmljdGlvbl9lcXVhdGlvbl9wb29sXzEuZGVmYXVsdDtcclxudmFyIGdlYXJfY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL2dlYXItY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuR2VhckNvbnN0cmFpbnQgPSBnZWFyX2NvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgZ3Nfc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc29sdmVyL2dzLXNvbHZlclwiKSk7XHJcbmV4cG9ydHMuR1NTb2x2ZXIgPSBnc19zb2x2ZXJfMS5kZWZhdWx0O1xyXG52YXIgaGVpZ2h0ZmllbGRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvaGVpZ2h0ZmllbGRcIikpO1xyXG5leHBvcnRzLkhlaWdodGZpZWxkID0gaGVpZ2h0ZmllbGRfMS5kZWZhdWx0O1xyXG52YXIgbGluZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NoYXBlcy9saW5lXCIpKTtcclxuZXhwb3J0cy5MaW5lID0gbGluZV8xLmRlZmF1bHQ7XHJcbnZhciBsb2NrX2NvbnN0cmFpbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25zdHJhaW50cy9sb2NrLWNvbnN0cmFpbnRcIikpO1xyXG5leHBvcnRzLkxvY2tDb25zdHJhaW50ID0gbG9ja19jb25zdHJhaW50XzEuZGVmYXVsdDtcclxudmFyIG1hdGVyaWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWF0ZXJpYWwvbWF0ZXJpYWxcIikpO1xyXG5leHBvcnRzLk1hdGVyaWFsID0gbWF0ZXJpYWxfMS5kZWZhdWx0O1xyXG52YXIgbmFycm93cGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb2xsaXNpb24vbmFycm93cGhhc2VcIikpO1xyXG5leHBvcnRzLk5hcnJvd3BoYXNlID0gbmFycm93cGhhc2VfMS5kZWZhdWx0O1xyXG52YXIgbmFpdmVfYnJvYWRwaGFzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbGxpc2lvbi9uYWl2ZS1icm9hZHBoYXNlXCIpKTtcclxuZXhwb3J0cy5OYWl2ZUJyb2FkcGhhc2UgPSBuYWl2ZV9icm9hZHBoYXNlXzEuZGVmYXVsdDtcclxudmFyIHBhcnRpY2xlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL3BhcnRpY2xlXCIpKTtcclxuZXhwb3J0cy5QYXJ0aWNsZSA9IHBhcnRpY2xlXzEuZGVmYXVsdDtcclxudmFyIHBsYW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL3BsYW5lXCIpKTtcclxuZXhwb3J0cy5QbGFuZSA9IHBsYW5lXzEuZGVmYXVsdDtcclxudmFyIHBvb2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9wb29sXCIpKTtcclxuZXhwb3J0cy5Qb29sID0gcG9vbF8xLmRlZmF1bHQ7XHJcbnZhciByZXZvbHV0ZV9jb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uc3RyYWludHMvcmV2b2x1dGUtY29uc3RyYWludFwiKSk7XHJcbmV4cG9ydHMuUmV2b2x1dGVDb25zdHJhaW50ID0gcmV2b2x1dGVfY29uc3RyYWludF8xLmRlZmF1bHQ7XHJcbnZhciBwcmlzbWF0aWNfY29uc3RyYWludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnN0cmFpbnRzL3ByaXNtYXRpYy1jb25zdHJhaW50XCIpKTtcclxuZXhwb3J0cy5QcmlzbWF0aWNDb25zdHJhaW50ID0gcHJpc21hdGljX2NvbnN0cmFpbnRfMS5kZWZhdWx0O1xyXG52YXIgcmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL3JheVwiKSk7XHJcbmV4cG9ydHMuUmF5ID0gcmF5XzEuZGVmYXVsdDtcclxudmFyIHJheWNhc3RfcmVzdWx0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL3JheWNhc3QtcmVzdWx0XCIpKTtcclxuZXhwb3J0cy5SYXljYXN0UmVzdWx0ID0gcmF5Y2FzdF9yZXN1bHRfMS5kZWZhdWx0O1xyXG52YXIgQm94XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVzL0JveFwiKSk7XHJcbmV4cG9ydHMuQm94ID0gQm94XzEuZGVmYXVsdDtcclxudmFyIHJvdGF0aW9uYWxfdmVsb2NpdHlfZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lcXVhdGlvbnMvcm90YXRpb25hbC12ZWxvY2l0eS1lcXVhdGlvblwiKSk7XHJcbmV4cG9ydHMuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSByb3RhdGlvbmFsX3ZlbG9jaXR5X2VxdWF0aW9uXzEuZGVmYXVsdDtcclxudmFyIHNhcF9icm9hZHBoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29sbGlzaW9uL3NhcC1icm9hZHBoYXNlXCIpKTtcclxuZXhwb3J0cy5TQVBCcm9hZHBoYXNlID0gc2FwX2Jyb2FkcGhhc2VfMS5kZWZhdWx0O1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZXMvc2hhcGVcIikpO1xyXG5leHBvcnRzLlNoYXBlID0gc2hhcGVfMS5kZWZhdWx0O1xyXG52YXIgc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc29sdmVyL3NvbHZlclwiKSk7XHJcbmV4cG9ydHMuU29sdmVyID0gc29sdmVyXzEuZGVmYXVsdDtcclxudmFyIHNwcmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMvc3ByaW5nXCIpKTtcclxuZXhwb3J0cy5TcHJpbmcgPSBzcHJpbmdfMS5kZWZhdWx0O1xyXG52YXIgdG9wX2Rvd25fdmVoaWNsZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL29iamVjdHMvdG9wLWRvd24tdmVoaWNsZVwiKSk7XHJcbmV4cG9ydHMuVG9wRG93blZlaGljbGUgPSB0b3BfZG93bl92ZWhpY2xlXzEuZGVmYXVsdDtcclxudmFyIGxpbmVhcl9zcHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vYmplY3RzL2xpbmVhci1zcHJpbmdcIikpO1xyXG5leHBvcnRzLkxpbmVhclNwcmluZyA9IGxpbmVhcl9zcHJpbmdfMS5kZWZhdWx0O1xyXG52YXIgcm90YXRpb25hbF9zcHJpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9vYmplY3RzL3JvdGF0aW9uYWwtc3ByaW5nXCIpKTtcclxuZXhwb3J0cy5Sb3RhdGlvbmFsU3ByaW5nID0gcm90YXRpb25hbF9zcHJpbmdfMS5kZWZhdWx0O1xyXG52YXIgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy91dGlsc1wiKSk7XHJcbmV4cG9ydHMuVXRpbHMgPSB1dGlsc18xLmRlZmF1bHQ7XHJcbnZhciB3b3JsZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dvcmxkL3dvcmxkXCIpKTtcclxuZXhwb3J0cy5Xb3JsZCA9IHdvcmxkXzEuZGVmYXVsdDtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXRoL3ZlYzJcIikpO1xyXG5leHBvcnRzLnZlYzIgPSB2ZWMyXzEuZGVmYXVsdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE1hdGVyaWFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGEgcGh5c2ljcyBtYXRlcmlhbC4gVG8gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIkNvbnRhY3RNYXRlcmlhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAqIEBjbGFzcyBNYXRlcmlhbFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIHdvb2RlbiBib3hcclxuICAgICAqICAgICB2YXIgd29vZE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKCk7XHJcbiAgICAgKiAgICAgdmFyIGJveFNoYXBlID0gbmV3IEJveCh7XHJcbiAgICAgKiAgICAgICAgIG1hdGVyaWFsOiB3b29kTWF0ZXJpYWxcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKGJveFNoYXBlKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1hdGVyaWFsIGlkZW50aWZpZXIuIFJlYWQgb25seS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaWRcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSArK01hdGVyaWFsLmlkQ291bnRlcjtcclxuICAgIH1cclxuICAgIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XHJcbiAgICByZXR1cm4gTWF0ZXJpYWw7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1hdGVyaWFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWF0ZXJpYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9NYXRlcmlhbFwiKSk7XHJcbnZhciBFcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvRXF1YXRpb25cIikpO1xyXG52YXIgQ29udGFjdE1hdGVyaWFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLiBBbHNvIHNlZSB7eyNjcm9zc0xpbmsgXCJNYXRlcmlhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAqIEBjbGFzcyBDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXHJcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb249MC4zXSAgICAgICBGcmljdGlvbiBjb2VmZmljaWVudC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlbGF4YXRpb25dICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHJlbGF4YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wXSAgICAgIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGFrYSBcImJvdW5jaW5lc3NcIi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN0aWZmbmVzc10gICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHN0aWZmbmVzcy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN1cmZhY2VWZWxvY2l0eT0wXSAgU3VyZmFjZSB2ZWxvY2l0eS5cclxuICAgICAqIEBhdXRob3Igc2NodGVwcGVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGljZSA9IG5ldyBNYXRlcmlhbCgpO1xyXG4gICAgICogICAgIHZhciB3b29kID0gbmV3IE1hdGVyaWFsKCk7XHJcbiAgICAgKiAgICAgdmFyIGljZVdvb2RDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKGljZSwgd29vZCwge1xyXG4gICAgICogICAgICAgICBmcmljdGlvbjogMC4yLFxyXG4gICAgICogICAgICAgICByZXN0aXR1dGlvbjogMC4zXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKGljZVdvb2RDb250YWN0TWF0ZXJpYWwpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlIGluIHRoZSBjb250YWN0IG9mIHRoZXNlIHR3byBtYXRlcmlhbHMuIEZyaWN0aW9uID0gMCB3aWxsIG1ha2UgdGhlIGludm9sdmVkIG9iamVjdHMgc3VwZXIgc2xpcHBlcnksIGFuZCBmcmljdGlvbiA9IDEgd2lsbCBtYWtlIGl0IG11Y2ggbGVzcyBzbGlwcGVyeS4gQSBmcmljdGlvbiBjb2VmZmljaWVudCBsYXJnZXIgdGhhbiAxIHdpbGwgYWxsb3cgZm9yIHZlcnkgbGFyZ2UgZnJpY3Rpb24gZm9yY2VzLCB3aGljaCBjYW4gYmUgY29udmVuaWVudCBmb3IgcHJldmVudGluZyBjYXIgdGlyZXMgbm90IHNsaXAgb24gdGhlIGdyb3VuZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDAuM1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSAwLjM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdGl0dXRpb24sIG9yIFwiYm91bmNpbmVzc1wiIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzLiBBIHJlc3RpdHV0aW9uIG9mIDAgd2lsbCBtYWtlIG5vIGJvdW5jZSwgd2hpbGUgcmVzdGl0dXRpb249MSB3aWxsIGFwcHJveGltYXRlbHkgYm91bmNlIGJhY2sgd2l0aCB0aGUgc2FtZSB2ZWxvY2l0eSB0aGUgb2JqZWN0IGNhbWUgd2l0aC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYXJkbmVzcyBvZiB0aGUgY29udGFjdC4gTGVzcyBzdGlmZm5lc3Mgd2lsbCBtYWtlIHRoZSBvYmplY3RzIHBlbmV0cmF0ZSBtb3JlLCBhbmQgd2lsbCBtYWtlIHRoZSBjb250YWN0IGFjdCBtb3JlIGxpa2UgYSBzcHJpbmcgdGhhbiBhIGNvbnRhY3QgZm9yY2UuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9TVElGRk5FU1M6cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1N7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1NUSUZGTkVTUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGUuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSByZWxheGF0aW9uXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9SRUxBWEFUSU9OO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgcmVzdWx0aW5nIGZyaWN0aW9uIGZvcmNlLiBGb3IgbW9zdCBjYXNlcywgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGEgbGFyZ2UgbnVtYmVyLiBJIGNhbm5vdCB0aGluayBvZiBhbnkgY2FzZSB3aGVyZSB5b3Ugd291bGQgd2FudCBsZXNzIGZyaWN0aW9uU3RpZmZuZXNzLiBEZWZhdWx0IHZhbHVlIGlzIHt7I2Nyb3NzTGluayBcIkVxdWF0aW9uL0RFRkFVTFRfU1RJRkZORVNTOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTe3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gVGhlIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIGdvb2QgZm9yIG1vc3Qgc2ltdWxhdGlvbnMuIERlZmF1bHQgdmFsdWUgaXMge3sjY3Jvc3NMaW5rIFwiRXF1YXRpb24vREVGQVVMVF9SRUxBWEFUSU9OOnByb3BlcnR5XCJ9fUVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTnt7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaWxsIGFkZCBzdXJmYWNlIHZlbG9jaXR5IHRvIHRoaXMgbWF0ZXJpYWwuIElmIGJvZHlBIHJlc3RzIG9uIHRvcCBpZiBib2R5QiwgYW5kIHRoZSBzdXJmYWNlIHZlbG9jaXR5IGlzIHBvc2l0aXZlLCBib2R5QSB3aWxsIHNsaWRlIHRvIHRoZSByaWdodC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPZmZzZXQgdG8gYmUgc2V0IG9uIENvbnRhY3RFcXVhdGlvbnMuIEEgcG9zaXRpdmUgdmFsdWUgd2lsbCBtYWtlIHRoZSBib2RpZXMgcGVuZXRyYXRlIG1vcmUgaW50byBlYWNoIG90aGVyLiBDYW4gYmUgdXNlZnVsIGluIHNjZW5lcyB3aGVyZSBjb250YWN0cyBuZWVkIHRvIGJlIG1vcmUgcGVyc2lzdGVudCwgZm9yIGV4YW1wbGUgd2hlbiBzdGFja2luZy4gQWthIFwiY3VyZSBmb3IgbmVydm91cyBjb250YWN0c1wiLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb250YWN0U2tpblNpemVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMDU7XHJcbiAgICAgICAgaWYgKCEobWF0ZXJpYWxBIGluc3RhbmNlb2YgTWF0ZXJpYWxfMS5kZWZhdWx0KSB8fCAhKG1hdGVyaWFsQiBpbnN0YW5jZW9mIE1hdGVyaWFsXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgdHdvIGFyZ3VtZW50cyBtdXN0IGJlIE1hdGVyaWFsIGluc3RhbmNlcy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWQgPSArK0NvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXI7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcmljdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC4zO1xyXG4gICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RpZmZuZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBFcXVhdGlvbl8xLmRlZmF1bHQuREVGQVVMVF9TVElGRk5FU1M7XHJcbiAgICAgICAgdGhpcy5yZWxheGF0aW9uID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbGF4YXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IEVxdWF0aW9uXzEuZGVmYXVsdC5ERUZBVUxUX1JFTEFYQVRJT047XHJcbiAgICAgICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcmljdGlvblN0aWZmbmVzcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfU1RJRkZORVNTO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogRXF1YXRpb25fMS5kZWZhdWx0LkRFRkFVTFRfUkVMQVhBVElPTjtcclxuICAgICAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDA7XHJcbiAgICAgICAgdGhpcy5jb250YWN0U2tpblNpemUgPSAwLjAwNTtcclxuICAgIH1cclxuICAgIENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xyXG4gICAgcmV0dXJuIENvbnRhY3RNYXRlcmlhbDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFjdE1hdGVyaWFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbGluZUludFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcclxuICogQHBhcmFtICB7QXJyYXl9ICBsMiAgICAgICAgICBMaW5lIHZlY3RvciAyXHJcbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgUHJlY2lzaW9uIHRvIHVzZSB3aGVuIGNoZWNraW5nIGlmIHRoZSBsaW5lcyBhcmUgcGFyYWxsZWxcclxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxyXG4gKi9cclxuZnVuY3Rpb24gbGluZUludChsMSwgbDIsIHByZWNpc2lvbikge1xyXG4gICAgaWYgKHByZWNpc2lvbiA9PT0gdm9pZCAwKSB7IHByZWNpc2lvbiA9IDA7IH1cclxuICAgIHZhciBpID0gbmV3IEZsb2F0MzJBcnJheSgyKTsgLy8gcG9pbnRcclxuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyLCBkZXQ7IC8vIHNjYWxhcnNcclxuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcclxuICAgIGIxID0gbDFbMF1bMF0gLSBsMVsxXVswXTtcclxuICAgIGMxID0gYTEgKiBsMVswXVswXSArIGIxICogbDFbMF1bMV07XHJcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XHJcbiAgICBiMiA9IGwyWzBdWzBdIC0gbDJbMV1bMF07XHJcbiAgICBjMiA9IGEyICogbDJbMF1bMF0gKyBiMiAqIGwyWzBdWzFdO1xyXG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XHJcbiAgICBpZiAoIXNjYWxhcl9lcShkZXQsIDAsIHByZWNpc2lvbikpIHsgLy8gbGluZXMgYXJlIG5vdCBwYXJhbGxlbFxyXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xyXG4gICAgICAgIGlbMV0gPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxyXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHAxIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gcTIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxyXG4gKi9cclxuZnVuY3Rpb24gbGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKSB7XHJcbiAgICB2YXIgZHggPSBwMlswXSAtIHAxWzBdO1xyXG4gICAgdmFyIGR5ID0gcDJbMV0gLSBwMVsxXTtcclxuICAgIHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XHJcbiAgICB2YXIgZGIgPSBxMlsxXSAtIHExWzFdO1xyXG4gICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXHJcbiAgICBpZiAoKGRhICogZHkgLSBkYiAqIGR4KSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KTtcclxuICAgIHZhciB0ID0gKGRhICogKHAxWzFdIC0gcTFbMV0pICsgZGIgKiAocTFbMF0gLSBwMVswXSkpIC8gKGRiICogZHggLSBkYSAqIGR5KTtcclxuICAgIHJldHVybiAocyA+PSAwICYmIHMgPD0gMSAmJiB0ID49IDAgJiYgdCA8PSAxKTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBhcmVhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XHJcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSkgLSAoKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkpKTtcclxufVxyXG5mdW5jdGlvbiBpc0xlZnQoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA+IDA7XHJcbn1cclxuZnVuY3Rpb24gaXNMZWZ0T24oYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA+PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmlnaHQoYSwgYiwgYykge1xyXG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8IDA7XHJcbn1cclxuZnVuY3Rpb24gaXNSaWdodE9uKGEsIGIsIGMpIHtcclxuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSwgYiwgYykgPD0gMDtcclxufVxyXG52YXIgdG1wUG9pbnQxID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgdG1wUG9pbnQyID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXHJcbiAqIEBtZXRob2QgY29sbGluZWFyXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAqIEBwYXJhbSAge0FycmF5fSBjXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYywgdGhyZXNob2xkQW5nbGUpIHtcclxuICAgIGlmICghdGhyZXNob2xkQW5nbGUpIHtcclxuICAgICAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID09PSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGFiID0gdG1wUG9pbnQxLCBiYyA9IHRtcFBvaW50MjtcclxuICAgICAgICBhYlswXSA9IGJbMF0gLSBhWzBdO1xyXG4gICAgICAgIGFiWzFdID0gYlsxXSAtIGFbMV07XHJcbiAgICAgICAgYmNbMF0gPSBjWzBdIC0gYlswXTtcclxuICAgICAgICBiY1sxXSA9IGNbMV0gLSBiWzFdO1xyXG4gICAgICAgIHZhciBkb3QgPSBhYlswXSAqIGJjWzBdICsgYWJbMV0gKiBiY1sxXSwgbWFnQSA9IE1hdGguc3FydChhYlswXSAqIGFiWzBdICsgYWJbMV0gKiBhYlsxXSksIG1hZ0IgPSBNYXRoLnNxcnQoYmNbMF0gKiBiY1swXSArIGJjWzFdICogYmNbMV0pLCBhbmdsZSA9IE1hdGguYWNvcyhkb3QgLyAobWFnQSAqIG1hZ0IpKTtcclxuICAgICAgICByZXR1cm4gYW5nbGUgPCB0aHJlc2hvbGRBbmdsZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzcWRpc3QoYSwgYikge1xyXG4gICAgdmFyIGR4ID0gYlswXSAtIGFbMF07XHJcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcclxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG4vKipcclxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxyXG4gKiBAbWV0aG9kIGF0XHJcbiAqIEBwYXJhbSAge051bWJlcn0gaVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BdChwb2x5Z29uLCBpKSB7XHJcbiAgICB2YXIgcyA9IHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgcmV0dXJuIHBvbHlnb25baSA8IDAgPyBpICUgcyArIHMgOiBpICUgc107XHJcbn1cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBwb2x5Z29uIGRhdGFcclxuICogQG1ldGhvZCBjbGVhclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DbGVhcihwb2x5Z29uKSB7XHJcbiAgICBwb2x5Z29uLmxlbmd0aCA9IDA7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXHJcbiAqIEBtZXRob2QgYXBwZW5kXHJcbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seSBUaGUgcG9seWdvbiB0byBnZXQgcG9pbnRzIGZyb20uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25BcHBlbmQocG9seWdvbiwgcG9seSwgZnJvbSwgdG8pIHtcclxuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgIHBvbHlnb24ucHVzaChwb2x5W2ldKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFrZSBzdXJlIHRoYXQgdGhlIHBvbHlnb24gdmVydGljZXMgYXJlIG9yZGVyZWQgY291bnRlci1jbG9ja3dpc2UuXHJcbiAqIEBtZXRob2QgbWFrZUNDV1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbk1ha2VDQ1cocG9seWdvbikge1xyXG4gICAgdmFyIGJyID0gMCwgdiA9IHBvbHlnb247XHJcbiAgICAvLyBmaW5kIGJvdHRvbSByaWdodCBwb2ludFxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xyXG4gICAgICAgICAgICBiciA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxyXG4gICAgaWYgKCFpc0xlZnQocG9seWdvbkF0KHBvbHlnb24sIGJyIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBiciksIHBvbHlnb25BdChwb2x5Z29uLCBiciArIDEpKSkge1xyXG4gICAgICAgIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxyXG4gKiBAbWV0aG9kIHJldmVyc2VcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25SZXZlcnNlKHBvbHlnb24pIHtcclxuICAgIHZhciB0bXAgPSBbXTtcclxuICAgIHZhciBOID0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHAgPSBwb2x5Z29uLnBvcCgpO1xyXG4gICAgICAgIHRtcC5wdXNoKHApO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgIHBvbHlnb25baV0gPSB0bXBbaV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcG9pbnQgaW4gdGhlIHBvbHlnb24gaXMgYSByZWZsZXggcG9pbnRcclxuICogQG1ldGhvZCBpc1JlZmxleFxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkge1xyXG4gICAgcmV0dXJuIGlzUmlnaHQocG9seWdvbkF0KHBvbHlnb24sIGkgLSAxKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpKTtcclxufVxyXG52YXIgdG1wTGluZTEgPSBbXSwgdG1wTGluZTIgPSBbXTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWVcclxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkNhblNlZShwb2x5Z29uLCBhLCBiKSB7XHJcbiAgICB2YXIgcCwgZGlzdCwgbDEgPSB0bXBMaW5lMSwgbDIgPSB0bXBMaW5lMjtcclxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHBvbHlnb24ubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxyXG4gICAgICAgIGlmICgoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgeyAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSkpKSB7IC8vIGlmIGRpYWcgaW50ZXJzZWN0cyBhbiBlZGdlXHJcbiAgICAgICAgICAgIGwxWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGEpO1xyXG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcclxuICAgICAgICAgICAgbDJbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSk7XHJcbiAgICAgICAgICAgIGwyWzFdID0gcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKTtcclxuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsIGwyKTtcclxuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcclxuICogQG1ldGhvZCBjYW5TZWUyXHJcbiAqIEBwYXJhbSAge051bWJlcn0gYSBWZXJ0ZXggaW5kZXggMVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUyKHBvbHlnb24sIGEsIGIpIHtcclxuICAgIC8vIGZvciBlYWNoIGVkZ2VcclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXHJcbiAgICAgICAgaWYgKGkgPT09IGEgfHwgaSA9PT0gYiB8fCAoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGEgfHwgKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBiKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZVNlZ21lbnRzSW50ZXJzZWN0KHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpLCBwb2x5Z29uQXQocG9seWdvbiwgaSksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxyXG4gKiBAbWV0aG9kIGNvcHlcclxuICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAqIEBwYXJhbSAge051bWJlcn0galxyXG4gKiBAcGFyYW0gIHtQb2x5Z29ufSBbdGFyZ2V0UG9seV0gICBPcHRpb25hbCB0YXJnZXQgcG9seWdvbiB0byBzYXZlIGluLlxyXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uQ29weShwb2x5Z29uLCBpLCBqLCB0YXJnZXRQb2x5KSB7XHJcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgIT09IG51bGwgJiYgdGFyZ2V0UG9seSAhPT0gdm9pZCAwID8gdGFyZ2V0UG9seSA6IFtdO1xyXG4gICAgcG9seWdvbkNsZWFyKHApO1xyXG4gICAgaWYgKGkgPCBqKSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBmcm9tIGkgdG8galxyXG4gICAgICAgIGZvciAodmFyIGsgPSBpOyBrIDw9IGo7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDw9IGo7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxyXG4gICAgICAgIGZvciAodmFyIGsgPSBpOyBrIDwgcG9seWdvbi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuLyoqXHJcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxyXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pIHtcclxuICAgIHZhciBtaW4gPSBbXSwgdG1wMSA9IFtdLCB0bXAyID0gW10sIHRtcFBvbHkgPSBbXTtcclxuICAgIHZhciBuRGlhZ3MgPSBJbmZpbml0eTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seWdvbiwgaSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5Z29uLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNhblNlZShwb2x5Z29uLCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaSwgaiwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSwgdG1wUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdG1wMi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuRGlhZ3MgPSB0bXAxLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBbcG9seWdvbkF0KHBvbHlnb24sIGkpLCBwb2x5Z29uQXQocG9seWdvbiwgaildO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gb25lIG9yIG1vcmUgY29udmV4IHN1Yi1Qb2x5Z29ucy5cclxuICogQG1ldGhvZCBkZWNvbXBcclxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb25EZWNvbXAocG9seWdvbikge1xyXG4gICAgdmFyIGVkZ2VzID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb24pO1xyXG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gcG9seWdvblNsaWNlKHBvbHlnb24sIGVkZ2VzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbcG9seWdvbl07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cclxuICogQHdhcm5pbmcgVGhlIGlubmVyIHdvcmtpbmdzIG9mIHRoaXMgZnVuY3Rpb24gd2FzIG1hc3NpdmVseSBtb2RpZmllZCB3aGVuIHN3aXRjaGluZyB0byB0eXBlc2NyaXB0LiBOZWVkcyB0aG9yb3VnaCB0ZXN0aW5nLlxyXG4gKiBAbWV0aG9kIHNsaWNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uU2xpY2UocG9seWdvbiwgY3V0RWRnZXMpIHtcclxuICAgIGlmIChjdXRFZGdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gW3BvbHlnb25dO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1dEVkZ2VzWzBdLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHZhciBwb2x5cyA9IFtwb2x5Z29uXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXRFZGdlID0gW2N1dEVkZ2VzW2ldXTtcclxuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHlnb25TbGljZShwb2x5LCBjdXRFZGdlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBwb2x5ISBDdXQgYW5kIHF1aXRcclxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnB1c2gocmVzdWx0WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcclxuICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzO1xyXG4gICAgICAgIHZhciBpID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF1bMF0pO1xyXG4gICAgICAgIHZhciBqID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF1bMV0pO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSAmJiBqICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3BvbHlnb25Db3B5KHBvbHlnb24sIGksIGopLFxyXG4gICAgICAgICAgICAgICAgcG9seWdvbkNvcHkocG9seWdvbiwgaiwgaSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIGxpbmUgc2VnbWVudHMgb2YgdGhpcyBwb2x5Z29uIGRvIG5vdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cclxuICogQG1ldGhvZCBpc1NpbXBsZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvbklzU2ltcGxlKHBvbHlnb24pIHtcclxuICAgIHZhciBwYXRoID0gcG9seWdvbiwgaTtcclxuICAgIC8vIENoZWNrXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgLSAxOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2kgKyAxXSwgcGF0aFtqXSwgcGF0aFtqICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xyXG4gICAgZm9yIChpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGhbaV0sIHBhdGhbaSArIDFdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocDEsIHAyLCBxMSwgcTIsIGRlbHRhKSB7XHJcbiAgICBpZiAoZGVsdGEgPT09IHZvaWQgMCkgeyBkZWx0YSA9IDA7IH1cclxuICAgIHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XHJcbiAgICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xyXG4gICAgdmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xyXG4gICAgdmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcclxuICAgIHZhciBiMiA9IHExWzBdIC0gcTJbMF07XHJcbiAgICB2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XHJcbiAgICB2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xyXG4gICAgdmFyIHB0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgIGlmICghc2NhbGFyX2VxKGRldCwgMCwgZGVsdGEpKSB7XHJcbiAgICAgICAgcHRbMF0gPSAoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldDtcclxuICAgICAgICBwdFsxXSA9ICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0O1xyXG4gICAgICAgIHJldHVybiBwdDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB0WzBdID0gMDtcclxuICAgICAgICBwdFsxXSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHB0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXHJcbiAqIEBtZXRob2QgcXVpY2tEZWNvbXBcclxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxyXG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gW3N0ZWluZXJQb2ludHNdXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cclxuICogQHBhcmFtICB7TnVtYmVyfSBbbGV2ZWxdXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblF1aWNrRGVjb21wKHBvbHlnb24sIHJlc3VsdCwgcmVmbGV4VmVydGljZXMsIHN0ZWluZXJQb2ludHMsIGRlbHRhLCBtYXhsZXZlbCwgbGV2ZWwpIHtcclxuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBuZXcgQXJyYXkoKTsgfVxyXG4gICAgaWYgKHJlZmxleFZlcnRpY2VzID09PSB2b2lkIDApIHsgcmVmbGV4VmVydGljZXMgPSBbXTsgfVxyXG4gICAgaWYgKHN0ZWluZXJQb2ludHMgPT09IHZvaWQgMCkgeyBzdGVpbmVyUG9pbnRzID0gW107IH1cclxuICAgIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7IGRlbHRhID0gMjU7IH1cclxuICAgIGlmIChtYXhsZXZlbCA9PT0gdm9pZCAwKSB7IG1heGxldmVsID0gMTAwOyB9XHJcbiAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IDA7IH1cclxuICAgIC8vIFRPRE86IHNob3VsZCB1cHBlckludCByZWFsbHkgYmUgaW5pdGlhbGl6ZWQgaGVyZT8gSXQgbG9va3MgbGlrZSBpdCdzIG92ZXJ3cml0dGVuLlxyXG4gICAgdmFyIHVwcGVySW50ID0gbmV3IEZsb2F0MzJBcnJheSgyKSwgbG93ZXJJbnQgPSBuZXcgRmxvYXQzMkFycmF5KDIpLCBwID0gbmV3IEZsb2F0MzJBcnJheSgyKTsgLy8gUG9pbnRzXHJcbiAgICB1cHBlckludFswXSA9IDA7XHJcbiAgICB1cHBlckludFsxXSA9IDA7XHJcbiAgICBsb3dlckludFswXSA9IDA7XHJcbiAgICBsb3dlckludFsxXSA9IDA7XHJcbiAgICBwWzBdID0gMDtcclxuICAgIHBbMV0gPSAwO1xyXG4gICAgdmFyIHVwcGVyRGlzdCA9IDAsIGxvd2VyRGlzdCA9IDAsIGQgPSAwLCBjbG9zZXN0RGlzdCA9IDA7IC8vIHNjYWxhcnNcclxuICAgIHZhciB1cHBlckluZGV4ID0gMCwgbG93ZXJJbmRleCA9IDAsIGNsb3Nlc3RJbmRleCA9IDA7IC8vIEludGVnZXJzXHJcbiAgICB2YXIgbG93ZXJQb2x5ID0gbmV3IEFycmF5KCksIHVwcGVyUG9seSA9IG5ldyBBcnJheSgpOyAvLyBwb2x5Z29uc1xyXG4gICAgdmFyIHBvbHkgPSBwb2x5Z29uLCB2ID0gcG9seWdvbjtcclxuICAgIGlmICh2Lmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGV2ZWwrKztcclxuICAgIGlmIChsZXZlbCA+IG1heGxldmVsKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLndhcm4oXCJxdWlja0RlY29tcDogbWF4IGxldmVsIChcIittYXhsZXZlbCtcIikgcmVhY2hlZC5cIik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChwb2x5Z29uSXNSZWZsZXgocG9seSwgaSkpIHtcclxuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5W2ldKTtcclxuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seWdvbi5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckludCA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopLCBwb2x5Z29uQXQocG9seSwgaiArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5W2ldLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckludCA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxyXG4gICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PT0gKHVwcGVySW5kZXggKyAxKSAlIHBvbHlnb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FzZSAxOiBWZXJ0ZXgoXCIraStcIiksIGxvd2VySW5kZXgoXCIrbG93ZXJJbmRleCtcIiksIHVwcGVySW5kZXgoXCIrdXBwZXJJbmRleCtcIiksIHBvbHkuc2l6ZShcIitwb2x5Z29uLmxlbmd0aCtcIilcIik7XHJcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcclxuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgc3RlaW5lclBvaW50cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCB1cHBlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQobG93ZXJQb2x5LCBwb2x5LCBpLCB1cHBlckluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5lbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCBsb3dlckluZGV4LCBwb2x5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCAwLCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmVuZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIGksIHBvbHkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksIDAsIHVwcGVySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmJlZ2luKCkgKyBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksIGxvd2VySW5kZXgsIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVxcblwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggKz0gcG9seWdvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHVwcGVySW5kZXggPCBsb3dlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gc3FkaXN0KHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCAmJiBwb2x5Z29uQ2FuU2VlMihwb2x5LCBpLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gaiAlIHBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjbG9zZXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgY2xvc2VzdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwgY2xvc2VzdEluZGV4LCB2Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LCAwLCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgdi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgMCwgY2xvc2VzdEluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksIGNsb3Nlc3RJbmRleCwgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNvbHZlIHNtYWxsZXN0IHBvbHkgZmlyc3RcclxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS5sZW5ndGggPCB1cHBlclBvbHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25RdWlja0RlY29tcCh1cHBlclBvbHksIHJlc3VsdCwgcmVmbGV4VmVydGljZXMsIHN0ZWluZXJQb2ludHMsIGRlbHRhLCBtYXhsZXZlbCwgbGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSwgcmVzdWx0LCByZWZsZXhWZXJ0aWNlcywgc3RlaW5lclBvaW50cywgZGVsdGEsIG1heGxldmVsLCBsZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LCByZXN1bHQsIHJlZmxleFZlcnRpY2VzLCBzdGVpbmVyUG9pbnRzLCBkZWx0YSwgbWF4bGV2ZWwsIGxldmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC5wdXNoKHBvbHlnb24pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVtb3ZlZFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pIHtcclxuICAgIHZhciBudW0gPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgcG9seWdvbi5sZW5ndGggPiAzICYmIGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgaWYgKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaSAtIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgaSksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSksIHByZWNpc2lvbikpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcclxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSAlIHBvbHlnb24ubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgbnVtKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGR1cGxpY2F0ZSBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAqIEBtZXRob2QgcmVtb3ZlRHVwbGljYXRlUG9pbnRzXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBwb2ludHMgYXJlIHRoZSBzYW1lLiBVc2UgemVybyBmb3IgYmVzdCBwcmVjaXNpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvbHlnb24sIHByZWNpc2lvbikge1xyXG4gICAgZm9yICh2YXIgaSA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcclxuICAgICAgICB2YXIgcGkgPSBwb2x5Z29uW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyAtLWopIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50c19lcShwaSwgcG9seWdvbltqXSwgcHJlY2lzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBlcVxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcclxuICogQHBhcmFtICB7TnVtYmVyfSBiXHJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIHNjYWxhcl9lcShhLCBiLCBwcmVjaXNpb24pIHtcclxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBwcmVjaXNpb247XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBwb2ludHNfZXFcclxuICogQHBhcmFtICB7QXJyYXl9IGFcclxuICogQHBhcmFtICB7QXJyYXl9IGJcclxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gcG9pbnRzX2VxKGEsIGIsIHByZWNpc2lvbikge1xyXG4gICAgcmV0dXJuIHNjYWxhcl9lcShhWzBdLCBiWzBdLCBwcmVjaXNpb24pICYmIHNjYWxhcl9lcShhWzFdLCBiWzFdLCBwcmVjaXNpb24pO1xyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIGRlY29tcDogcG9seWdvbkRlY29tcCxcclxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXHJcbiAgICBpc1NpbXBsZTogcG9seWdvbklzU2ltcGxlLFxyXG4gICAgcmVtb3ZlQ29sbGluZWFyUG9pbnRzOiBwb2x5Z29uUmVtb3ZlQ29sbGluZWFyUG9pbnRzLFxyXG4gICAgcmVtb3ZlRHVwbGljYXRlUG9pbnRzOiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzLFxyXG4gICAgbWFrZUNDVzogcG9seWdvbk1ha2VDQ1dcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypcclxuICAgIFBvbHlLIGxpYnJhcnlcclxuICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxyXG4gICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXHJcblxyXG4gICAgQ29weXJpZ2h0IChjKSAyMDEyIEl2YW4gS3Vja2lyXHJcblxyXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbiAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4gICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuICAgIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxudmFyIFBvbHlLID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9seUsoKSB7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XHJcblxyXG4gICAgICAgIE8obl4yKVxyXG4gICAgKi9cclxuICAgIC8qXHJcbiAgICBJc1NpbXBsZShwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XHJcbiAgICAgICAgaWYobjw0KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgYTEgPSBuZXcgdGhpcy5fUCgpLCBhMiA9IG5ldyB0aGlzLl9QKCk7XHJcbiAgICAgICAgdmFyIGIxID0gbmV3IHRoaXMuX1AoKSwgYjIgPSBuZXcgdGhpcy5fUCgpO1xyXG4gICAgICAgIHZhciBjID0gbmV3IHRoaXMuX1AoKTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYTEueCA9IHBbMippICBdO1xyXG4gICAgICAgICAgICBhMS55ID0gcFsyKmkrMV07XHJcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XHJcbiAgICAgICAgICAgIGVsc2UgICAgICAgIHsgYTIueCA9IHBbMippKzJdOyAgYTIueSA9IHBbMippKzNdOyB9XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGktaikgPCAyKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmKGk9PW4tMSAmJiBqPT0wKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XHJcbiAgICAgICAgICAgICAgICBiMS55ID0gcFsyKmorMV07XHJcbiAgICAgICAgICAgICAgICBpZihqPT1uLTEpICB7IGIyLnggPSBwWzAgICAgXTsgIGIyLnkgPSBwWzEgICAgXTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBJc0NvbnZleChwKVxyXG4gICAge1xyXG4gICAgICAgIGlmKHAubGVuZ3RoPDYpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSA0O1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLl9jb252ZXgocFtpXSwgcFtpKzFdLCBwW2krMl0sIHBbaSszXSwgcFtpKzRdLCBwW2krNV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIXRoaXMuX2NvbnZleChwW2wgIF0sIHBbbCsxXSwgcFtsKzJdLCBwW2wrM10sIHBbMF0sIHBbMV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYoIXRoaXMuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLkdldEFyZWEgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmIChwLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKVxyXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSArIDJdIC0gcFtpXSkgKiAocFtpICsgMV0gKyBwW2kgKyAzXSk7XHJcbiAgICAgICAgc3VtICs9IChwWzBdIC0gcFtsXSkgKiAocFtsICsgMV0gKyBwWzFdKTtcclxuICAgICAgICByZXR1cm4gLXN1bSAqIDAuNTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgR2V0QUFCQihwKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBtaW54ID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbWF4eCA9IC1taW54O1xyXG4gICAgICAgIHZhciBtYXh5ID0gLW1pbnk7XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtaW54ID0gTWF0aC5taW4obWlueCwgcFtpICBdKTtcclxuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XHJcbiAgICAgICAgICAgIG1pbnkgPSBNYXRoLm1pbihtaW55LCBwW2krMV0pO1xyXG4gICAgICAgICAgICBtYXh5ID0gTWF0aC5tYXgobWF4eSwgcFtpKzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHt4Om1pbngsIHk6bWlueSwgd2lkdGg6bWF4eC1taW54LCBoZWlnaHQ6bWF4eS1taW55fTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBQb2x5Sy5wcm90b3R5cGUuVHJpYW5ndWxhdGUgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGggPj4gMTtcclxuICAgICAgICBpZiAobiA8IDMpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB2YXIgdGdzID0gW107XHJcbiAgICAgICAgdmFyIGF2bCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICBhdmwucHVzaChpKTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIGFsID0gbjtcclxuICAgICAgICB3aGlsZSAoYWwgPiAzKSB7XHJcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSArIDApICUgYWxdO1xyXG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkgKyAxKSAlIGFsXTtcclxuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpICsgMikgJSBhbF07XHJcbiAgICAgICAgICAgIHZhciBheCA9IHBbMiAqIGkwXSwgYXkgPSBwWzIgKiBpMCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgYnggPSBwWzIgKiBpMV0sIGJ5ID0gcFsyICogaTEgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGN4ID0gcFsyICogaTJdLCBjeSA9IHBbMiAqIGkyICsgMV07XHJcbiAgICAgICAgICAgIHZhciBlYXJGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7XHJcbiAgICAgICAgICAgICAgICBlYXJGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpID09IGkwIHx8IHZpID09IGkxIHx8IHZpID09IGkyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fUG9pbnRJblRyaWFuZ2xlKHBbMiAqIHZpXSwgcFsyICogdmkgKyAxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFyRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlYXJGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTApO1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTEpO1xyXG4gICAgICAgICAgICAgICAgdGdzLnB1c2goaTIpO1xyXG4gICAgICAgICAgICAgICAgYXZsLnNwbGljZSgoaSArIDEpICUgYWwsIDEpO1xyXG4gICAgICAgICAgICAgICAgYWwtLTtcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkrKyA+IDMgKiBhbClcclxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBubyBjb252ZXggYW5nbGVzIDooXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRncy5wdXNoKGF2bFswXSk7XHJcbiAgICAgICAgdGdzLnB1c2goYXZsWzFdKTtcclxuICAgICAgICB0Z3MucHVzaChhdmxbMl0pO1xyXG4gICAgICAgIHJldHVybiB0Z3M7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIENvbnRhaW5zUG9pbnQocCwgcHgsIHB5KVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XHJcbiAgICAgICAgdmFyIGF4LCBheSwgYnggPSBwWzIqbi0yXS1weCwgYnkgPSBwWzIqbi0xXS1weTtcclxuICAgICAgICB2YXIgZGVwdGggPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xyXG4gICAgICAgICAgICBieCA9IHBbMippICBdIC0gcHg7XHJcbiAgICAgICAgICAgIGJ5ID0gcFsyKmkrMV0gLSBweTtcclxuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXHJcbiAgICAgICAgICAgIGlmKGF5Pj0wICYmIGJ5Pj0wKSBjb250aW51ZTsgICAgLy8gYm90aCBcInVwXCIgb3IgYm90aCBcImRvbndcIlxyXG4gICAgICAgICAgICBpZihheDwgMCAmJiBieDwgMCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgbHggPSBheCArIChieC1heCkqKC1heSkvKGJ5LWF5KTtcclxuICAgICAgICAgICAgaWYobHg+MCkgZGVwdGgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkZXB0aCAmIDEpID09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgU2xpY2UocCwgYXgsIGF5LCBieCwgYnkpXHJcbiAgICB7XHJcbiAgICAgICAgaWYodGhpcy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgdGhpcy5Db250YWluc1BvaW50KHAsIGJ4LCBieSkpIHJldHVybiBbcC5zbGljZSgwKV07XHJcblxyXG4gICAgICAgIHZhciBhID0gbmV3IHRoaXMuX1AoYXgsIGF5KTtcclxuICAgICAgICB2YXIgYiA9IG5ldyB0aGlzLl9QKGJ4LCBieSk7XHJcbiAgICAgICAgdmFyIGlzY3MgPSBbXTsgIC8vIGludGVyc2VjdGlvbnNcclxuICAgICAgICB2YXIgcHMgPSBbXTsgICAgLy8gcG9pbnRzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IHRoaXMuX1AocFtpXSwgcFtpKzFdKSk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGlzYyA9IG5ldyB0aGlzLl9QKDAsMCk7XHJcbiAgICAgICAgICAgIGlzYyA9IHRoaXMuX0dldExpbmVJbnRlcnNlY3Rpb24oYSwgYiwgcHNbaV0sIHBzWyhpKzEpJXBzLmxlbmd0aF0sIGlzYyk7XHJcblxyXG4gICAgICAgICAgICBpZihpc2MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlzY3MucHVzaChpc2MpO1xyXG4gICAgICAgICAgICAgICAgcHMuc3BsaWNlKGkrMSwwLGlzYyk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcclxuICAgICAgICB2YXIgY29tcCh1LHYpIHtyZXR1cm4gdGhpcy5fUC5kaXN0KGEsdSkgLSB0aGlzLl9QLmRpc3QoYSx2KTsgfVxyXG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcclxuXHJcbiAgICAgICAgdmFyIHBncyA9IFtdO1xyXG4gICAgICAgIHZhciBkaXIgPSAwO1xyXG4gICAgICAgIHdoaWxlKGlzY3MubGVuZ3RoID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaTAgPSBpc2NzWzBdO1xyXG4gICAgICAgICAgICB2YXIgaTEgPSBpc2NzWzFdO1xyXG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xyXG4gICAgICAgICAgICB2YXIgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xyXG4gICAgICAgICAgICB2YXIgc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkwID0gaXNjc1sxXTtcclxuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcclxuICAgICAgICAgICAgICAgIGluZDAgPSBwcy5pbmRleE9mKGkwKTtcclxuICAgICAgICAgICAgICAgIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc29sdmVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaXItLTtcclxuICAgICAgICAgICAgICAgIHZhciBwZ24gPSB0aGlzLl9nZXRQb2ludHMocHMsIGluZDAsIGluZDEpO1xyXG4gICAgICAgICAgICAgICAgcGdzLnB1c2gocGduKTtcclxuICAgICAgICAgICAgICAgIHBzID0gdGhpcy5fZ2V0UG9pbnRzKHBzLCBpbmQxLCBpbmQwKTtcclxuICAgICAgICAgICAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xyXG4gICAgICAgICAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcGdzLnB1c2gocHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cclxuICAgICAgICAgICAgaWYoZGlyPjEpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cGdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbnBnID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBnLmxlbmd0aDsgaisrKSBucGcucHVzaChwZ1tqXS54LCBwZ1tqXS55KTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBSYXljYXN0KHAsIHgsIHksIGR4LCBkeSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xyXG4gICAgICAgIHZhciB0cCA9IHRoaXMuX3RwO1xyXG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxyXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcclxuICAgICAgICBhMS54ID0geDsgYTEueSA9IHk7XHJcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xyXG5cclxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19O1xyXG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiMS54ID0gcFtpICBdOyAgYjEueSA9IHBbaSsxXTtcclxuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XHJcbiAgICAgICAgICAgIHZhciBuaXNjID0gdGhpcy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XHJcbiAgICAgICAgICAgIGlmKG5pc2MpIHRoaXMuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYjEueCA9IGIyLng7ICBiMS55ID0gYjIueTtcclxuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xyXG4gICAgICAgIHZhciBuaXNjID0gdGhpcy5fUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XHJcbiAgICAgICAgaWYobmlzYykgdGhpcy5fdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgcC5sZW5ndGgvMiwgaXNjKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIENsb3Nlc3RFZGdlKHAsIHgsIHksIGlzYylcclxuICAgIHtcclxuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcclxuICAgICAgICB2YXIgdHAgPSB0aGlzLl90cDtcclxuICAgICAgICB2YXIgYTEgPSB0cFswXSxcclxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XHJcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xyXG5cclxuICAgICAgICBpZihpc2M9PW51bGwpIGlzYyA9IHtkaXN0OjAsIGVkZ2U6MCwgcG9pbnQ6e3g6MCwgeTowfSwgbm9ybTp7eDowLCB5OjB9fTtcclxuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxsOyBpKz0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XHJcbiAgICAgICAgICAgIGIyLnggPSBwW2krMl07ICBiMi55ID0gcFtpKzNdO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGk+PjEsIGlzYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XHJcbiAgICAgICAgYjIueCA9IHBbMF07ICBiMi55ID0gcFsxXTtcclxuICAgICAgICB0aGlzLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XHJcblxyXG4gICAgICAgIHZhciBpZHN0ID0gMS9pc2MuZGlzdDtcclxuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XHJcbiAgICAgICAgaXNjLm5vcm0ueSA9ICh5LWlzYy5wb2ludC55KSppZHN0O1xyXG4gICAgICAgIHJldHVybiBpc2M7XHJcbiAgICB9XHJcblxyXG4gICAgX3BvaW50TGluZURpc3QocCwgYSwgYiwgZWRnZSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcclxuXHJcbiAgICAgICAgdmFyIEEgPSB4IC0geDE7XHJcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XHJcbiAgICAgICAgdmFyIEMgPSB4MiAtIHgxO1xyXG4gICAgICAgIHZhciBEID0geTIgLSB5MTtcclxuXHJcbiAgICAgICAgdmFyIGRvdCA9IEEgKiBDICsgQiAqIEQ7XHJcbiAgICAgICAgdmFyIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQ7XHJcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xyXG5cclxuICAgICAgICB2YXIgeHgsIHl5O1xyXG5cclxuICAgICAgICBpZiAocGFyYW0gPCAwIHx8ICh4MSA9PSB4MiAmJiB5MSA9PSB5MikpIHtcclxuICAgICAgICAgICAgeHggPSB4MTtcclxuICAgICAgICAgICAgeXkgPSB5MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyYW0gPiAxKSB7XHJcbiAgICAgICAgICAgIHh4ID0geDI7XHJcbiAgICAgICAgICAgIHl5ID0geTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xyXG4gICAgICAgICAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGR4ID0geCAtIHh4O1xyXG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcclxuICAgICAgICB2YXIgZHN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICBpZihkc3Q8aXNjLmRpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpc2MuZGlzdCA9IGRzdDtcclxuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xyXG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xyXG4gICAgICAgICAgICBpc2MucG9pbnQueSA9IHl5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBucmwgPSB0aGlzLl9QLmRpc3QoYTEsIGMpO1xyXG4gICAgICAgIGlmKG5ybDxpc2MuZGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBpYmwgPSAxL3RoaXMuX1AuZGlzdChiMSwgYjIpO1xyXG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xyXG4gICAgICAgICAgICB2YXIgbnkgPSAgKGIyLngtYjEueCkqaWJsO1xyXG4gICAgICAgICAgICB2YXIgZGRvdCA9IDIqKGR4Km54K2R5Km55KTtcclxuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XHJcbiAgICAgICAgICAgIGlzYy5ub3JtLnggPSBueDtcclxuICAgICAgICAgICAgaXNjLm5vcm0ueSA9IG55O1xyXG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XHJcbiAgICAgICAgICAgIGlzYy5yZWZsLnkgPSAtZGRvdCpueStkeTtcclxuICAgICAgICAgICAgaXNjLmVkZ2UgPSBlZGdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBucHMgPSBbXTtcclxuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcclxuICAgICAgICBmb3IodmFyIGk9aW5kMDsgaTw9IGluZDE7IGkrKykgbnBzLnB1c2gocHNbaSVuXSk7XHJcbiAgICAgICAgcmV0dXJuIG5wcztcclxuICAgIH1cclxuXHJcbiAgICBfZmlyc3RXaXRoRmxhZyhwcywgaW5kKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKHRydWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XHJcbiAgICAgICAgICAgIGlmKHBzW2luZF0uZmxhZykgcmV0dXJuIGluZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLl9Qb2ludEluVHJpYW5nbGUgPSBmdW5jdGlvbiAocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XHJcbiAgICAgICAgdmFyIHYweCA9IGN4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYweSA9IGN5IC0gYXk7XHJcbiAgICAgICAgdmFyIHYxeCA9IGJ4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYxeSA9IGJ5IC0gYXk7XHJcbiAgICAgICAgdmFyIHYyeCA9IHB4IC0gYXg7XHJcbiAgICAgICAgdmFyIHYyeSA9IHB5IC0gYXk7XHJcbiAgICAgICAgdmFyIGRvdDAwID0gdjB4ICogdjB4ICsgdjB5ICogdjB5O1xyXG4gICAgICAgIHZhciBkb3QwMSA9IHYweCAqIHYxeCArIHYweSAqIHYxeTtcclxuICAgICAgICB2YXIgZG90MDIgPSB2MHggKiB2MnggKyB2MHkgKiB2Mnk7XHJcbiAgICAgICAgdmFyIGRvdDExID0gdjF4ICogdjF4ICsgdjF5ICogdjF5O1xyXG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCAqIHYyeCArIHYxeSAqIHYyeTtcclxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcclxuICAgICAgICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcclxuICAgICAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcclxuICAgICAgICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbiB0cmlhbmdsZVxyXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcclxuICAgICAgICB2YXIgZGF5ID0gKGExLnktYTIueSksIGRieSA9IChiMS55LWIyLnkpO1xyXG5cclxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XHJcbiAgICAgICAgaWYgKERlbiA9PSAwKSByZXR1cm4gbnVsbDsgIC8vIHBhcmFsbGVsXHJcblxyXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xyXG4gICAgICAgIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xyXG5cclxuICAgICAgICB2YXIgSSA9IGM7XHJcbiAgICAgICAgdmFyIGlEZW4gPSAxL0RlbjtcclxuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAqIGlEZW47XHJcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xyXG5cclxuICAgICAgICBpZighdGhpcy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmKChkYXk+MCAmJiBJLnk+YTEueSkgfHwgKGRheTwwICYmIEkueTxhMS55KSkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYoKGRheD4wICYmIEkueD5hMS54KSB8fCAoZGF4PDAgJiYgSS54PGExLngpKSByZXR1cm4gbnVsbDtcclxuICAgICAgICByZXR1cm4gSTtcclxuICAgIH1cclxuXHJcbiAgICBfR2V0TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYylcclxuICAgIHtcclxuICAgICAgICB2YXIgZGF4ID0gKGExLngtYTIueCksIGRieCA9IChiMS54LWIyLngpO1xyXG4gICAgICAgIHZhciBkYXkgPSAoYTEueS1hMi55KSwgZGJ5ID0gKGIxLnktYjIueSk7XHJcblxyXG4gICAgICAgIHZhciBEZW4gPSBkYXgqZGJ5IC0gZGF5KmRieDtcclxuICAgICAgICBpZiAoRGVuID09IDApIHJldHVybiBudWxsOyAgLy8gcGFyYWxsZWxcclxuXHJcbiAgICAgICAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XHJcbiAgICAgICAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XHJcblxyXG4gICAgICAgIHZhciBJID0gYztcclxuICAgICAgICBJLnggPSAoIEEqZGJ4IC0gZGF4KkIgKSAvIERlbjtcclxuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcclxuXHJcbiAgICAgICAgaWYodGhpcy5fSW5SZWN0KEksIGExLCBhMikgJiYgdGhpcy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBJO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9JblJlY3QoYSwgYiwgYylcclxuICAgIHtcclxuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xyXG4gICAgICAgIGlmICAoYi55ID09IGMueSkgcmV0dXJuIChhLng+PU1hdGgubWluKGIueCwgYy54KSAmJiBhLng8PU1hdGgubWF4KGIueCwgYy54KSk7XHJcblxyXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxyXG4gICAgICAgICYmIGEueSA+PSBNYXRoLm1pbihiLnksIGMueSkgJiYgYS55IDw9IE1hdGgubWF4KGIueSwgYy55KSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgUG9seUsucHJvdG90eXBlLl9jb252ZXggPSBmdW5jdGlvbiAoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xyXG4gICAgICAgIHJldHVybiAoYXkgLSBieSkgKiAoY3ggLSBieCkgKyAoYnggLSBheCkgKiAoY3kgLSBieSkgPj0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9seUs7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBQb2x5SygpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcclxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcclxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcbi8qKlxyXG4gKiBUaGUgdmVjMiBvYmplY3QgZnJvbSBnbE1hdHJpeCwgd2l0aCBzb21lIGV4dGVuc2lvbnMgYW5kIHNvbWUgcmVtb3ZlZCBtZXRob2RzLiBTZWUgaHR0cDovL2dsbWF0cml4Lm5ldC5cclxuICogQGNsYXNzIHZlYzJcclxuICovXHJcbnZhciBWZWMyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVjMigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBhIGNyb3NzIHByb2R1Y3QgYW5kIG9ubHkgcmV0dXJuIHRoZSB6IGNvbXBvbmVudFxyXG4gICAgICogQG1ldGhvZCBjcm9zc0xlbmd0aFxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNyb3NzTGVuZ3RoID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXHJcbiAgICAgKiBAbWV0aG9kIGNyb3NzVlpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB2ZWNcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jcm9zc1ZaID0gZnVuY3Rpb24gKG91dCwgdmVjLCB6Y29tcCkge1xyXG4gICAgICAgIHRoaXMucm90YXRlKG91dCwgdmVjLCAtTWF0aC5QSSAvIDIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCB6Y29tcCk7IC8vIFNjYWxlIHdpdGggelxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxyXG4gICAgICogQG1ldGhvZCBjcm9zc1pWXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdmVjXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY3Jvc3NaViA9IGZ1bmN0aW9uIChvdXQsIHpjb21wLCB2ZWMpIHtcclxuICAgICAgICB0aGlzLnJvdGF0ZShvdXQsIHZlYywgTWF0aC5QSSAvIDIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCB6Y29tcCk7IC8vIFNjYWxlIHdpdGggelxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgYSB2ZWN0b3IgYnkgYW4gYW5nbGVcclxuICAgICAqIEBtZXRob2Qgcm90YXRlXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIGFuZ2xlKSB7XHJcbiAgICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLCBzID0gTWF0aC5zaW4oYW5nbGUpLCB4ID0gYVswXSwgeSA9IGFbMV07XHJcbiAgICAgICAgICAgIG91dFswXSA9IGMgKiB4IC0gcyAqIHk7XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIGEgdmVjdG9yIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXHJcbiAgICAgKiBAbWV0aG9kIHJvdGF0ZTkwY3dcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUucm90YXRlOTBjdyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcclxuICAgICAgICB2YXIgeCA9IGFbMF07XHJcbiAgICAgICAgdmFyIHkgPSBhWzFdO1xyXG4gICAgICAgIG91dFswXSA9IHk7XHJcbiAgICAgICAgb3V0WzFdID0gLXg7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB0b0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKG91dCwgd29ybGRQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSkge1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoLWZyYW1lQW5nbGUpLCBzID0gTWF0aC5zaW4oLWZyYW1lQW5nbGUpLCB4ID0gd29ybGRQb2ludFswXSAtIGZyYW1lUG9zaXRpb25bMF0sIHkgPSB3b3JsZFBvaW50WzFdIC0gZnJhbWVQb3NpdGlvblsxXTtcclxuICAgICAgICBvdXRbMF0gPSBjICogeCAtIHMgKiB5O1xyXG4gICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGdsb2JhbCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdG9HbG9iYWxGcmFtZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudG9HbG9iYWxGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIGxvY2FsUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGZyYW1lQW5nbGUpLCBzID0gTWF0aC5zaW4oZnJhbWVBbmdsZSksIHggPSBsb2NhbFBvaW50WzBdLCB5ID0gbG9jYWxQb2ludFsxXSwgYWRkWCA9IGZyYW1lUG9zaXRpb25bMF0sIGFkZFkgPSBmcmFtZVBvc2l0aW9uWzFdO1xyXG4gICAgICAgIG91dFswXSA9IGMgKiB4IC0gcyAqIHkgKyBhZGRYO1xyXG4gICAgICAgIG91dFsxXSA9IHMgKiB4ICsgYyAqIHkgKyBhZGRZO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgdmVjdG9yIHRvIGxvY2FsIGZyYW1lLlxyXG4gICAgICogQG1ldGhvZCB2ZWN0b3JUb0xvY2FsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFZlY3RvclxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUudmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKG91dCwgd29ybGRWZWN0b3IsIGZyYW1lQW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKC1mcmFtZUFuZ2xlKSwgcyA9IE1hdGguc2luKC1mcmFtZUFuZ2xlKSwgeCA9IHdvcmxkVmVjdG9yWzBdLCB5ID0gd29ybGRWZWN0b3JbMV07XHJcbiAgICAgICAgb3V0WzBdID0gYyAqIHggLSBzICogeTtcclxuICAgICAgICBvdXRbMV0gPSBzICogeCArIGMgKiB5O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLypcclxuICAgICAqIFRyYW5zZm9ybSBhIHZlY3RvciB0byBnbG9iYWwgZnJhbWUuXHJcbiAgICAgKiBAbWV0aG9kIHZlY3RvclRvR2xvYmFsRnJhbWVcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFZlY3RvclxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXHJcbiAgICAgKi9cclxuICAgIC8vdmVjdG9yVG9HbG9iYWxGcmFtZSA9IHZlYzIucm90YXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcclxuICAgICAqIEBtZXRob2QgY2VudHJvaWRcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGNcclxuICAgICAqIEByZXR1cm4gIHtBcnJheX0gVGhlIFwib3V0XCIgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLmFkZChvdXQsIGEsIGIpO1xyXG4gICAgICAgIHRoaXMuYWRkKG91dCwgb3V0LCBjKTtcclxuICAgICAgICB0aGlzLnNjYWxlKG91dCwgb3V0LCAxIC8gMyk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuICAgICAgICBvdXRbMF0gPSAwO1xyXG4gICAgICAgIG91dFsxXSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBjbG9uZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBmcm9tVmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgb3V0WzBdID0geDtcclxuICAgICAgICBvdXRbMV0gPSB5O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGNvcHlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKG91dCwgYSkge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG91dCwgeCwgeSkge1xyXG4gICAgICAgIG91dFswXSA9IHg7XHJcbiAgICAgICAgb3V0WzFdID0geTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXSArIGJbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXSArIGJbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHN1YnRyYWN0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgbXVsdGlwbHlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGJbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERpdmlkZXMgdHdvIHZlYzInc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBkaXZpZGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvdXRcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzY2FsZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3V0XHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBiO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBiO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciB4ID0gYlswXSAtIGFbMF0sIHkgPSBiWzFdIC0gYVsxXTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLCB5ID0gYlsxXSAtIGFbMV07XHJcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGxlbmd0aFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV07XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdO1xyXG4gICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgbmVnYXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICAgICAgb3V0WzBdID0gLWFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gLWFbMV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXplXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IG91dFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXTtcclxuICAgICAgICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcclxuICAgICAgICBpZiAobGVuID4gMCkge1xyXG4gICAgICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xyXG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XHJcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGRvdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBzdHJcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIFZlYzIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdGhyb3cgXCJ2ZWMyLnN0ciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSB0eXBlc2NyaXB0IHZlcnNpb24gb2YgcDIuXCI7XHJcbiAgICAgICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZS9taXggdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGxlcnBcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYSBGaXJzdCB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGIgU2Vjb25kIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgTGVycCBmYWN0b3JcclxuICAgICAqIEByZXR1cm4ge2FycmF5fVxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xyXG4gICAgICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXTtcclxuICAgICAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcclxuICAgICAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVmbGVjdCBhIHZlY3RvciBhbG9uZyBhIG5vcm1hbC5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2QgcmVmbGVjdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3V0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5vcm1hbFxyXG4gICAgICovXHJcbiAgICBWZWMyLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKG91dCwgdmVjdG9yLCBub3JtYWwpIHtcclxuICAgICAgICB2YXIgZG90ID0gdmVjdG9yWzBdICogbm9ybWFsWzBdICsgdmVjdG9yWzFdICogbm9ybWFsWzFdO1xyXG4gICAgICAgIG91dFswXSA9IHZlY3RvclswXSAtIDIgKiBub3JtYWxbMF0gKiBkb3Q7XHJcbiAgICAgICAgb3V0WzFdID0gdmVjdG9yWzFdIC0gMiAqIG5vcm1hbFsxXSAqIGRvdDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKG91dCwgcDAsIHAxLCBwMiwgcDMpIHtcclxuICAgICAgICB2YXIgdCA9IHZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24ocDAsIHAxLCBwMiwgcDMpO1xyXG4gICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSBwMFswXSArICh0ICogKHAxWzBdIC0gcDBbMF0pKTtcclxuICAgICAgICAgICAgb3V0WzFdID0gcDBbMV0gKyAodCAqIChwMVsxXSAtIHAwWzFdKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW50ZXJzZWN0aW9uIGZyYWN0aW9uIGJldHdlZW4gdHdvIGxpbmUgc2VnbWVudHMuIElmIHN1Y2Nlc3NmdWwsIHRoZSBpbnRlcnNlY3Rpb24gaXMgYXQgcDAgKyB0ICogKHAxIC0gcDApXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIGdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDNcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGlmIHRoZXJlIHdhcyBhbiBpbnRlcnNlY3Rpb24sIG90aGVyd2lzZSAtMS5cclxuICAgICAqL1xyXG4gICAgVmVjMi5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24gPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcclxuICAgICAgICB2YXIgczFfeCA9IHAxWzBdIC0gcDBbMF07XHJcbiAgICAgICAgdmFyIHMxX3kgPSBwMVsxXSAtIHAwWzFdO1xyXG4gICAgICAgIHZhciBzMl94ID0gcDNbMF0gLSBwMlswXTtcclxuICAgICAgICB2YXIgczJfeSA9IHAzWzFdIC0gcDJbMV07XHJcbiAgICAgICAgdmFyIHMsIHQ7XHJcbiAgICAgICAgcyA9ICgtczFfeSAqIChwMFswXSAtIHAyWzBdKSArIHMxX3ggKiAocDBbMV0gLSBwMlsxXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcclxuICAgICAgICB0ID0gKHMyX3ggKiAocDBbMV0gLSBwMlsxXSkgLSBzMl95ICogKHAwWzBdIC0gcDJbMF0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XHJcbiAgICAgICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMSkgeyAvLyBDb2xsaXNpb24gZGV0ZWN0ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTsgLy8gTm8gY29sbGlzaW9uXHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFZlYzI7XHJcbn0oKSk7XHJcbnZhciB2ZWMyID0gbmV3IFZlYzIoKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdmVjMjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGFkZCA9IHZlYzJfMS5kZWZhdWx0LmFkZCwgc3ViID0gdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QsIHZlYzJjcmVhdGUgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGU7XHJcbnZhciBhYWJiXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9hYWJiXCIpKTtcclxudmFyIHBvbHlfZGVjb21wXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvcG9seS1kZWNvbXBcIikpO1xyXG52YXIgQ29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NoYXBlcy9Db252ZXhcIikpO1xyXG52YXIgcmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9yYXlcIikpO1xyXG52YXIgcmF5Y2FzdF9yZXN1bHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL3JheWNhc3QtcmVzdWx0XCIpKTtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG4vL2RlY29tcCA9IHJlcXVpcmUoJ3BvbHktZGVjb21wJylcclxudmFyIGludGVncmF0ZV9maE1pbnYgPSB2ZWMyY3JlYXRlKCk7XHJcbnZhciBpbnRlZ3JhdGVfdmVsb2R0ID0gdmVjMmNyZWF0ZSgpO1xyXG52YXIgX3RtcCA9IHZlYzJjcmVhdGUoKTtcclxudmFyIF9pZENvdW50ZXIgPSAwO1xyXG52YXIgQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCb2R5LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJpZ2lkIGJvZHkuIEhhcyBnb3QgYSBjZW50ZXIgb2YgbWFzcywgcG9zaXRpb24sIHZlbG9jaXR5IGFuZCBhIG51bWJlciBvZlxyXG4gICAgICogc2hhcGVzIHRoYXQgYXJlIHVzZWQgZm9yIGNvbGxpc2lvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIEJvZHlcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U2xlZXA9dHJ1ZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0wXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ3VsYXJEYW1waW5nPTAuMV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRm9yY2U9MF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyVmVsb2NpdHk9MF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jY2RJdGVyYXRpb25zPTEwXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkPS0xXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTAuMV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml4ZWRYPWZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maXhlZFk9ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mb3JjZV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ncmF2aXR5U2NhbGU9MV1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXNzPTBdIEEgbnVtYmVyID49IDAuIElmIHplcm8sIHRoZSAudHlwZSB3aWxsIGJlIHNldCB0byBCb2R5LlNUQVRJQy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50eXBlXSBTZWUge3sjY3Jvc3NMaW5rIFwiQm9keS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZWxvY2l0eV1cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSB0eXBpY2FsIGR5bmFtaWMgYm9keVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xyXG4gICAgICogICAgICAgICBtYXNzOiAxLCAvLyBub24temVybyBtYXNzIHdpbGwgc2V0IHR5cGUgdG8gQm9keS5EWU5BTUlDXHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgNV0sXHJcbiAgICAgKiAgICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICogICAgICAgICB2ZWxvY2l0eTogWzAsIDBdLFxyXG4gICAgICogICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDBcclxuICAgICAqICAgICB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIGEgY2lyY3VsYXIgc2hhcGUgdG8gdGhlIGJvZHlcclxuICAgICAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAwLjUgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSBhIHN0YXRpYyBwbGFuZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIHBsYW5lQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgbWFzczogMCwgLy8gemVybyBtYXNzIHdpbGwgc2V0IHR5cGUgdG8gQm9keS5TVEFUSUNcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IFswLCAwXVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciBwbGFuZVNoYXBlID0gbmV3IFBsYW5lKCk7XHJcbiAgICAgKiAgICAgcGxhbmVCb2R5LmFkZFNoYXBlKHBsYW5lU2hhcGUpO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkocGxhbmVCb2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSBtb3Zpbmcga2luZW1hdGljIGJveCBib2R5XHJcbiAgICAgKiAgICAgdmFyIHBsYXRmb3JtQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAqICAgICAgICAgdHlwZTogQm9keS5LSU5FTUFUSUMsXHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgM10sXHJcbiAgICAgKiAgICAgICAgIHZlbG9jaXR5OiBbMSwgMF1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHsgd2lkdGg6IDIsIGhlaWdodDogMC41IH0pO1xyXG4gICAgICogICAgIHBsYXRmb3JtQm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShwbGF0Zm9ybUJvZHkpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCb2R5KG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvZHkgaWRlbnRpZmllci4gUmVhZCBvbmx5IVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpZFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGV4IG9mIHRoZSBib2R5IGluIHRoZSBXb3JsZCAuYm9kaWVzIGFycmF5LiBJcyBzZXQgdG8gLTEgaWYgdGhlIGJvZHkgaXNuJ3QgYWRkZWQgdG8gYSBXb3JsZC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXhcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd29ybGQgdGhhdCB0aGlzIGJvZHkgaXMgYWRkZWQgdG8gKHJlYWQgb25seSkuIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIE5VTEwgaWYgdGhlIGJvZHkgaXMgbm90IGFkZGVkIHRvIGFueSB3b3JsZC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgd29ybGRcclxuICAgICAgICAgKiBAdHlwZSB7V29ybGR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMud29ybGQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaGFwZXMgb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgc2hhcGVzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXNzIG9mIHRoZSBib2R5LiBJZiB5b3UgY2hhbmdlIHRoaXMgbnVtYmVyLCB5b3Ugc2hvdWxkIGNhbGwge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVNYXNzUHJvcGVydGllczptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgbWFzc1xyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICBib2R5Lm1hc3MgPSAxO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubWFzcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBpbnZNYXNzXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5pbnZNYXNzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5lcnRpYSBvZiB0aGUgYm9keSBhcm91bmQgdGhlIFogYXhpcy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaW5lcnRpYSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludmVyc2UgaW5lcnRpYSBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW52SW5lcnRpYVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaW52SW5lcnRpYSA9IDA7XHJcbiAgICAgICAgX3RoaXMuaW52TWFzc1NvbHZlID0gMDtcclxuICAgICAgICBfdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgZml4ZWRSb3RhdGlvblxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IHJvdGF0aW9uIGR1cmluZyBydW50aW1lXHJcbiAgICAgICAgICogICAgIGJvZHkuZml4ZWRSb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5maXhlZFJvdGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIGJvZHkgbW92ZW1lbnQgYWxvbmcgdGhlIFggYXhpcy4gVGhlIGJvZHkgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIG1vdmUgYWxvbmcgWS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZpeGVkWFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IFggbW92ZW1lbnQgb24gYm9keSBjcmVhdGlvblxyXG4gICAgICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSwgZml4ZWRYOiB0cnVlIH0pO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gRml4IFggbW92ZW1lbnQgZHVyaW5nIHJ1bnRpbWVcclxuICAgICAgICAgKiAgICAgYm9keS5maXhlZFggPSB0cnVlO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZml4ZWRYID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSBib2R5IG1vdmVtZW50IGFsb25nIHRoZSBZIGF4aXMuIFRoZSBib2R5IHdpbGwgc3RpbGwgYmUgYWJsZSB0byBtb3ZlIGFsb25nIFguIFNlZSAuZml4ZWRYXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFlcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5maXhlZFkgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmd1bGFyIGNvbnN0cmFpbnQgdmVsb2NpdHkgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGJvZHkgZHVyaW5nIGxhc3Qgc3RlcC5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgd2xhbWJkYVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX0gLy8gVGhpcyB3YXMgYXJyYXkgYmVmb3JlIHRoZSBwb3J0LCBidXQgaHRlIGFzc2lnbm1lbnQgd2FzIGFsd2F5cyAwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLndsYW1iZGEgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIFRoZSBhbmdsZSBwcm9wZXJ0eSBpcyBub3Qgbm9ybWFsaXplZCB0byB0aGUgaW50ZXJ2YWwgMCB0byAyKnBpLCBpdCBjYW4gYmUgYW55IHZhbHVlLlxyXG4gICAgICAgICAqICAgICAvLyBJZiB5b3UgbmVlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMipwaSwgdXNlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGl0LlxyXG4gICAgICAgICAqICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSl7XHJcbiAgICAgICAgICogICAgICAgICBhbmdsZSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XHJcbiAgICAgICAgICogICAgICAgICBpZihhbmdsZSA8IDApe1xyXG4gICAgICAgICAqICAgICAgICAgICAgIGFuZ2xlICs9ICgyKk1hdGguUEkpO1xyXG4gICAgICAgICAqICAgICAgICAgfVxyXG4gICAgICAgICAqICAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBhbmdsZSBvZiB0aGUgYm9keS5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNBbmdsZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMucHJldmlvdXNBbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGludGVycG9sYXRlZCBhbmdsZSBvZiB0aGUgYm9keS4gVXNlIHRoaXMgZm9yIHJlbmRlcmluZy5cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkgaW50ZXJwb2xhdGVkQW5nbGVcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmludGVycG9sYXRlZEFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFuZ3VsYXIgZm9yY2UgYWN0aW5nIG9uIHRoZSBib2R5LiBTZWUge3sjY3Jvc3NMaW5rIFwiQm9keS9mb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYW5ndWxhckZvcmNlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbmd1bGFyRm9yY2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRGFtcGluZ1xyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYW5ndWxhckRhbXBpbmcgPSAwLjE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgbW90aW9uIHRoaXMgYm9keSBoYXMuIFNob3VsZCBiZSBvbmUgb2Y6IHt7I2Nyb3NzTGluayBcIkJvZHkvU1RBVElDOnByb3BlcnR5XCJ9fUJvZHkuU1RBVElDe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvRFlOQU1JQzpwcm9wZXJ0eVwifX1Cb2R5LkRZTkFNSUN7ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiQm9keS9LSU5FTUFUSUM6cHJvcGVydHlcIn19Qm9keS5LSU5FTUFUSUN7ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICogU3RhdGljIGJvZGllcyBkbyBub3QgbW92ZSwgYW5kIHRoZXkgZG8gbm90IHJlc3BvbmQgdG8gZm9yY2VzIG9yIGNvbGxpc2lvbi5cclxuICAgICAgICAgKiAqIER5bmFtaWMgYm9kaWVzIGJvZHkgY2FuIG1vdmUgYW5kIHJlc3BvbmQgdG8gY29sbGlzaW9ucyBhbmQgZm9yY2VzLlxyXG4gICAgICAgICAqICogS2luZW1hdGljIGJvZGllcyBvbmx5IG1vdmVzIGFjY29yZGluZyB0byBpdHMgLnZlbG9jaXR5LCBhbmQgZG9lcyBub3QgcmVzcG9uZCB0byBjb2xsaXNpb25zIG9yIGZvcmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHR5cGVcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gQm9kaWVzIGFyZSBzdGF0aWMgYnkgZGVmYXVsdC4gU3RhdGljIGJvZGllcyB3aWxsIG5ldmVyIG1vdmUuXHJcbiAgICAgICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS50eXBlID09IEJvZHkuU1RBVElDKTsgLy8gdHJ1ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gQnkgc2V0dGluZyB0aGUgbWFzcyBvZiBhIGJvZHkgdG8gYSBub256ZXJvIG51bWJlciwgdGhlIGJvZHlcclxuICAgICAgICAgKiAgICAgLy8gd2lsbCBiZWNvbWUgZHluYW1pYyBhbmQgd2lsbCBtb3ZlIGFuZCBpbnRlcmFjdCB3aXRoIG90aGVyIGJvZGllcy5cclxuICAgICAgICAgKiAgICAgdmFyIGR5bmFtaWNCb2R5ID0gbmV3IEJvZHkoe1xyXG4gICAgICAgICAqICAgICAgICAgbWFzcyA6IDFcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKGR5bmFtaWNCb2R5LnR5cGUgPT0gQm9keS5EWU5BTUlDKTsgLy8gdHJ1ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gS2luZW1hdGljIGJvZGllcyB3aWxsIG9ubHkgbW92ZSBpZiB5b3UgY2hhbmdlIHRoZWlyIHZlbG9jaXR5LlxyXG4gICAgICAgICAqICAgICB2YXIga2luZW1hdGljQm9keSA9IG5ldyBCb2R5KHtcclxuICAgICAgICAgKiAgICAgICAgIHR5cGU6IEJvZHkuS0lORU1BVElDIC8vIFR5cGUgY2FuIGJlIHNldCB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cy4gVXBkYXRlIHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVCb3VuZGluZ1JhZGl1czptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHVwZGF0ZS4gVXBkYXRlIGl0IHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVBQUJCOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQHNlZSB1cGRhdGVBQUJCXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAvLyBGb3JjZSB1cGRhdGUgdGhlIEFBQkJcclxuICAgICAgICAgKiAgICAgYm9keS5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAqICAgICBib2R5LnVwZGF0ZUFBQkIoKTtcclxuICAgICAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5hYWJiTmVlZHNVcGRhdGUpOyAvLyBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuIE5vdGUgdGhhdCB5b3UgbmVlZCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHt7I2Nyb3NzTGluayBcIldvcmxkXCJ9fXt7L2Nyb3NzTGlua319IGJlZm9yZSBhbnl0aGluZyB3aWxsIGhhcHBlbi5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYWxsb3dTbGVlcFxyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hbGxvd1NsZWVwID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBZOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBZe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBJTkc6cHJvcGVydHlcIn19Qm9keS5TTEVFUElOR3t7L2Nyb3NzTGlua319LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIGJvZHkgaXMgaW5pdGlhbGx5IEJvZHkuQVdBS0UuIElmIGl0cyB2ZWxvY2l0eSBub3JtIGlzIGJlbG93IC5zbGVlcFNwZWVkTGltaXQsIHRoZSBzbGVlcFN0YXRlIHdpbGwgYmVjb21lIEJvZHkuU0xFRVBZLiBJZiB0aGUgYm9keSBjb250aW51ZXMgdG8gYmUgQm9keS5TTEVFUFkgZm9yIC5zbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCB3aWxsIGZhbGwgYXNsZWVwIChCb2R5LlNMRUVQWSkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgQm9keS5BV0FLRVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBzcGVlZCAodGhlIG5vcm0gb2YgdGhlIHZlbG9jaXR5KSBpcyBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZSwgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcHkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNsZWVwU3BlZWRMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMC4yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuc2xlZXBTcGVlZExpbWl0ID0gMC4yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNsZWVwVGltZUxpbWl0ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmF2aXR5IHNjYWxpbmcgZmFjdG9yLiBJZiB5b3Ugd2FudCB0aGUgYm9keSB0byBpZ25vcmUgZ3Jhdml0eSwgc2V0IHRoaXMgdG8gemVyby4gSWYgeW91IHdhbnQgdG8gcmV2ZXJzZSBncmF2aXR5LCBzZXQgaXQgdG8gLTEuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGdyYXZpdHlTY2FsZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ncmF2aXR5U2NhbGUgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC4gVGhhdCBtZWFucyB0aGF0IHRoaXMgYm9keSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2RpZXMsIGJ1dCBpdCB3aWxsIHN0aWxsIHRyaWdnZXIgY29udGFjdCBldmVudHMsIGV0Yy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmlkbGVUaW1lID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCB0aW1lIHdoZW4gdGhlIGJvZHkgd2VudCB0byBTTEVFUFkgc3RhdGUuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbWVMYXN0U2xlZXB5XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGJvZHkgc3BlZWQgZXhjZWVkcyB0aGlzIHRocmVzaG9sZCwgQ0NEIChjb250aW51b3VzIGNvbGxpc2lvbiBkZXRlY3Rpb24pIHdpbGwgYmUgZW5hYmxlZC4gU2V0IGl0IHRvIGEgbmVnYXRpdmUgbnVtYmVyIHRvIGRpc2FibGUgQ0NEIGNvbXBsZXRlbHkgZm9yIHRoaXMgYm9keS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkU3BlZWRUaHJlc2hvbGRcclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNjZFNwZWVkVGhyZXNob2xkID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBzZWFyY2hpbmcgZm9yIHRoZSB0aW1lIG9mIGltcGFjdCBkdXJpbmcgQ0NELiBBIGxhcmdlciBudW1iZXIgd2lsbCBhc3N1cmUgdGhhdCB0aGVyZSdzIGEgc21hbGwgcGVuZXRyYXRpb24gb24gQ0NEIGNvbGxpc2lvbiwgYnV0IGEgc21hbGwgbnVtYmVyIHdpbGwgZ2l2ZSBtb3JlIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RJdGVyYXRpb25zXHJcbiAgICAgICAgICogQGRlZmF1bHQgMTBcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jY2RJdGVyYXRpb25zID0gMTA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlzbGFuZElkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaXNsYW5kSWQgPSAtMTtcclxuICAgICAgICBfdGhpcy5jb25jYXZlUGF0aCA9IG51bGw7XHJcbiAgICAgICAgLy8gU2hvdWxkIGJlIHByaXZhdGUsIGJ1dCB1c2VkIGJ5IHdvcmxkLlxyXG4gICAgICAgIF90aGlzLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuX3NoYXBlQUFCQiA9IG5ldyBhYWJiXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIF90aGlzLmlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiArK19pZENvdW50ZXI7XHJcbiAgICAgICAgX3RoaXMubWFzcyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIF90aGlzLmZpeGVkUm90YXRpb24gPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZml4ZWRSb3RhdGlvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZml4ZWRYID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpeGVkWCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZml4ZWRZID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpeGVkWSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubWFzc011bHRpcGxpZXIgPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMucG9zaXRpb24gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uKSA/IHZlYzJfMS5kZWZhdWx0LmNsb25lKG9wdGlvbnMucG9zaXRpb24pIDogdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY2xvbmUoX3RoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIF90aGlzLnByZXZpb3VzUG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jbG9uZShfdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgX3RoaXMudmVsb2NpdHkgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZlbG9jaXR5KSA/IHZlYzJfMS5kZWZhdWx0LmNsb25lKG9wdGlvbnMudmVsb2NpdHkpIDogdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIF90aGlzLnZsYW1iZGEgPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMuYW5nbGUgPSAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5nbGUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDA7XHJcbiAgICAgICAgX3RoaXMucHJldmlvdXNBbmdsZSA9IF90aGlzLmFuZ2xlO1xyXG4gICAgICAgIF90aGlzLmludGVycG9sYXRlZEFuZ2xlID0gX3RoaXMuYW5nbGU7XHJcbiAgICAgICAgX3RoaXMuYW5ndWxhclZlbG9jaXR5ID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMDtcclxuICAgICAgICBfdGhpcy5mb3JjZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UpID8gdmVjMl8xLmRlZmF1bHQuY2xvbmUob3B0aW9ucy5mb3JjZSkgOiB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMuYW5ndWxhckZvcmNlID0gKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuZ3VsYXJGb3JjZSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMDtcclxuICAgICAgICBfdGhpcy5kYW1waW5nID0gKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhbXBpbmcpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IDAuMTtcclxuICAgICAgICBfdGhpcy5hbmd1bGFyRGFtcGluZyA9IChfayA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmd1bGFyRGFtcGluZykgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogMC4xO1xyXG4gICAgICAgIF90aGlzLnNsZWVwVGltZUxpbWl0ID0gKF9sID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNsZWVwVGltZUxpbWl0KSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiAxO1xyXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3RoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFzcykpIHtcclxuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEJvZHkuRFlOQU1JQztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuYWFiYiA9IG5ldyBhYWJiXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIF90aGlzLmFsbG93U2xlZXAgPSAoX20gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zbGVlcFNwZWVkTGltaXQgPSAoX28gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiAwLjI7XHJcbiAgICAgICAgX3RoaXMuZ3Jhdml0eVNjYWxlID0gKF9wID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmdyYXZpdHlTY2FsZSkgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogMTtcclxuICAgICAgICBfdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IChfcSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogdHJ1ZTtcclxuICAgICAgICBfdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IChfciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jY2RTcGVlZFRocmVzaG9sZCkgIT09IG51bGwgJiYgX3IgIT09IHZvaWQgMCA/IF9yIDogLTE7XHJcbiAgICAgICAgX3RoaXMuY2NkSXRlcmF0aW9ucyA9IChfcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jY2RJdGVyYXRpb25zKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiAxMDtcclxuICAgICAgICBfdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykge1xyXG4gICAgICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gdGhpcy5pbnZNYXNzO1xyXG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IHRoaXMuaW52SW5lcnRpYTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRvdGFsIGRlbnNpdHkgb2YgdGhlIGJvZHlcclxuICAgICAqIEBtZXRob2Qgc2V0RGVuc2l0eVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uIChkZW5zaXR5KSB7XHJcbiAgICAgICAgdmFyIHRvdGFsQXJlYSA9IHRoaXMuZ2V0QXJlYSgpO1xyXG4gICAgICAgIHRoaXMubWFzcyA9IHRvdGFsQXJlYSAqIGRlbnNpdHk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0b3RhbCBhcmVhIG9mIGFsbCBzaGFwZXMgaW4gdGhlIGJvZHlcclxuICAgICAqIEBtZXRob2QgZ2V0QXJlYVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0b3RhbEFyZWEgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdG90YWxBcmVhICs9IHRoaXMuc2hhcGVzW2ldLmFyZWE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3RhbEFyZWE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIEFBQkIgZnJvbSB0aGUgYm9keS4gVGhlIEFBQkIgaXMgdXBkYXRlZCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKiBAbWV0aG9kIGdldEFBQkJcclxuICAgICAqIEByZXR1cm4ge0FBQkJ9IFRoZSBBQUJCIGluc3RhbmNlIGZyb20gdGhlIGJvZHkuXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmdldEFBQkIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWFiYk5lZWRzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hYWJiO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQUFCQiBvZiB0aGUgQm9keSwgYW5kIHNldCAuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2UuXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFBQkJcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsIE4gPSBzaGFwZXMubGVuZ3RoLCBvZmZzZXQgPSBfdG1wLCBib2R5QW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLCBhbmdsZSA9IHNoYXBlLmFuZ2xlICsgYm9keUFuZ2xlO1xyXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgb2Zmc2V0XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShvZmZzZXQsIHNoYXBlLnBvc2l0aW9uLCBib2R5QW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxyXG4gICAgICAgICAgICBzaGFwZS5jb21wdXRlQUFCQih0aGlzLl9zaGFwZUFBQkIsIG9mZnNldCwgYW5nbGUpO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiLmNvcHkodGhpcy5fc2hhcGVBQUJCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWFiYi5leHRlbmQodGhpcy5fc2hhcGVBQUJCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkgKHRoaXMuYm91bmRpbmdSYWRpdXMpLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIHNoYXBlIGRpbWVuc2lvbnMgb3IgcG9zaXRpb25zIGFyZSBjaGFuZ2VkLlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsIE4gPSBzaGFwZXMubGVuZ3RoLCByYWRpdXMgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLCBvZmZzZXQgPSB2ZWMyXzEuZGVmYXVsdC5sZW5ndGgoc2hhcGUucG9zaXRpb24pLCByID0gc2hhcGUuYm91bmRpbmdSYWRpdXM7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgKyByID4gcmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keS4gWW91IGNhbiBwYXNzIGEgbG9jYWwgdHJhbnNmb3JtIHdoZW4gYWRkaW5nIGEgc2hhcGUsXHJcbiAgICAgKiBzbyB0aGF0IHRoZSBzaGFwZSBnZXRzIGFuIG9mZnNldCBhbmQgYW5nbGUgcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBXaWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgYW5kIGJvdW5kaW5nIHJhZGl1cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZFNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICAgICAgICAgIHNoYXBlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gW29mZnNldF0gTG9jYWwgYm9keSBvZmZzZXQgb2YgdGhlIHNoYXBlLlxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICBbYW5nbGVdICBMb2NhbCBib2R5IGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpLFxyXG4gICAgICogICAgICAgICBzaGFwZSA9IG5ldyBDaXJjbGUoeyByYWRpdXM6IDEgfSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIEFkZCB0aGUgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgaW4gdGhlIGNlbnRlclxyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHgtYXhpcy5cclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLFsxLDBdKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIGFub3RoZXIgc2hhcGUgdG8gdGhlIGJvZHksIHBvc2l0aW9uZWQgMSB1bml0IGxlbmd0aCBmcm9tIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzIGFsb25nIHRoZSBsb2NhbCB5LWF4aXMsIGFuZCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXLlxyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzAsMV0sTWF0aC5QSS8yKTtcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUsIG9mZnNldCwgYW5nbGUpIHtcclxuICAgICAgICBpZiAoYW5nbGUgPT09IHZvaWQgMCkgeyBhbmdsZSA9IDA7IH1cclxuICAgICAgICBpZiAoc2hhcGUuYm9keSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2hhcGUgY2FuIG9ubHkgYmUgYWRkZWQgdG8gb25lIGJvZHkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XHJcbiAgICAgICAgaWYgKHdvcmxkICYmIHdvcmxkLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaGFwZSBjYW5ub3QgYmUgYWRkZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNoYXBlLmJvZHkgPSB0aGlzO1xyXG4gICAgICAgIC8vIENvcHkgdGhlIG9mZnNldCB2ZWN0b3JcclxuICAgICAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoc2hhcGUucG9zaXRpb24sIG9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoc2hhcGUucG9zaXRpb24sIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaGFwZS5hbmdsZSA9IGFuZ2xlIHx8IDA7XHJcbiAgICAgICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBzaGFwZS5cclxuICAgICAqIEBtZXRob2QgcmVtb3ZlU2hhcGVcclxuICAgICAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2hhcGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkLCBlbHNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSkge1xyXG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XHJcbiAgICAgICAgaWYgKHdvcmxkICYmIHdvcmxkLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaGFwZSBjYW5ub3QgYmUgcmVtb3ZlZCBkdXJpbmcgc3RlcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNoYXBlLmJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgLmluZXJ0aWEsIC5pbnZNYXNzLCAuaW52SW5lcnRpYSBmb3IgdGhpcyBCb2R5LiBTaG91bGQgYmUgY2FsbGVkIHdoZW4gY2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvciBtYXNzIG9mIHRoZSBCb2R5LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgdXBkYXRlTWFzc1Byb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIGJvZHkubWFzcyArPSAxO1xyXG4gICAgICogICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUudXBkYXRlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykge1xyXG4gICAgICAgICAgICAvLyBDb25zaWRlciBtYWtpbmcgaXQgaW5maW5pdHkuXHJcbiAgICAgICAgICAgIHRoaXMubWFzcyA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmludk1hc3MgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmluZXJ0aWEgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcywgTiA9IHNoYXBlcy5sZW5ndGgsIEkgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZml4ZWRSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sIHIyID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChzaGFwZS5wb3NpdGlvbiksIEljbSA9IHNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEoKTtcclxuICAgICAgICAgICAgICAgICAgICBJICs9IEljbSArIHIyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gdGhpcy5tYXNzICogSTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IEkgPiAwID8gMSAvIEkgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEludmVyc2UgbWFzcyBwcm9wZXJ0aWVzIGFyZSBlYXN5XHJcbiAgICAgICAgICAgIHRoaXMuaW52TWFzcyA9IDEgLyB0aGlzLm1hc3M7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldCh0aGlzLm1hc3NNdWx0aXBsaWVyLCB0aGlzLmZpeGVkWCA/IDAgOiAxLCB0aGlzLmZpeGVkWSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBmb3JjZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkuYW5ndWxhckZvcmNlLlxyXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhZGQsIG9yaWVudGVkIGluIHdvcmxkIHNwYWNlLlxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IFtyZWxhdGl2ZVBvaW50XSBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5IGluIHdvcmxkIHNwYWNlLiBJZiBub3QgZ2l2ZW4sIGl0IGlzIHNldCB0byB6ZXJvIGFuZCBhbGwgb2YgdGhlIGZvcmNlIHdpbGwgYmUgZXhlcnRlZCBvbiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciByZWxhdGl2ZVBvaW50ID0gWzEsIDBdOyAvLyBXaWxsIGFwcGx5IHRoZSBmb3JjZSBhdCBbYm9keS5wb3NpdGlvblswXSArIDEsIGJvZHkucG9zaXRpb25bMV1dXHJcbiAgICAgKiAgICAgdmFyIGZvcmNlID0gWzAsIDFdOyAvLyB1cFxyXG4gICAgICogICAgIGJvZHkuYXBwbHlGb3JjZShmb3JjZSwgcmVsYXRpdmVQb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5mb3JjZSk7IC8vIFswLCAxXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYW5ndWxhckZvcmNlKTsgLy8gMVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gKGZvcmNlLCByZWxhdGl2ZVBvaW50KSB7XHJcbiAgICAgICAgLy8gQWRkIGxpbmVhciBmb3JjZVxyXG4gICAgICAgIGFkZCh0aGlzLmZvcmNlLCB0aGlzLmZvcmNlLCBmb3JjZSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXHJcbiAgICAgICAgICAgIHZhciByb3RGb3JjZSA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJlbGF0aXZlUG9pbnQsIGZvcmNlKTtcclxuICAgICAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyRm9yY2UgKz0gcm90Rm9yY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgZm9yY2UgdG8gYSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LmFuZ3VsYXJGb3JjZS5cclxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZUxvY2FsXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxGb3JjZSBUaGUgZm9yY2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gbG9jYWwgYm9keSBzcGFjZS5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbbG9jYWxQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiBsb2NhbCBib2R5IHNwYWNlLiBJZiBub3QgZ2l2ZW4sIGl0IGlzIHNldCB0byB6ZXJvIGFuZCBhbGwgb2YgdGhlIGZvcmNlIHdpbGwgYmUgZXhlcnRlZCBvbiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciBsb2NhbFBvaW50ID0gWzEsIDBdOyAvLyB4PTEgbG9jYWxseSBpbiB0aGUgYm9keVxyXG4gICAgICogICAgIHZhciBsb2NhbEZvcmNlID0gWzAsIDFdOyAvLyB1cCwgbG9jYWxseSBpbiB0aGUgYm9keVxyXG4gICAgICogICAgIGJvZHkuYXBwbHlGb3JjZUxvY2FsKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpO1xyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuZm9yY2UpOyAvLyBbMCwgMV1cclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LmFuZ3VsYXJGb3JjZSk7IC8vIDFcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZUxvY2FsID0gZnVuY3Rpb24gKGxvY2FsRm9yY2UsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICAvLyBUaGVzZSAzIGxpbmVzIHdlcmUgb3JpZ2luYWxseSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uIE5vdCBzdXJlIHdoeS5cclxuICAgICAgICB2YXIgQm9keV9hcHBseUZvcmNlX2ZvcmNlV29ybGQgPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIEJvZHlfYXBwbHlGb3JjZV9wb2ludFdvcmxkID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRMb2NhbDtcclxuICAgICAgICB2YXIgd29ybGRGb3JjZSA9IEJvZHlfYXBwbHlGb3JjZV9mb3JjZVdvcmxkO1xyXG4gICAgICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUZvcmNlX3BvaW50V29ybGQ7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRGb3JjZSwgbG9jYWxGb3JjZSk7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRQb2ludCwgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHdvcmxkUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXHJcbiAgICAgKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGltcHVsc2VWZWN0b3IgVGhlIGltcHVsc2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gW3JlbGF0aXZlUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4ZXJ0ZWQgb24gdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgcmVsYXRpdmVQb2ludCA9IFswLCAwXTsgLy8gY2VudGVyIG9mIHRoZSBib2R5XHJcbiAgICAgKiAgICAgdmFyIGltcHVsc2VWZWN0b3IgPSBbMCwgMV07IC8vIHdvcmxkIHVwXHJcbiAgICAgKiAgICAgYm9keS5hcHBseUltcHVsc2UoaW1wdWxzZVZlY3RvciwgcmVsYXRpdmVQb2ludCk7XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmFwcGx5SW1wdWxzZSA9IGZ1bmN0aW9uIChpbXB1bHNlVmVjdG9yLCByZWxhdGl2ZVBvaW50KSB7XHJcbiAgICAgICAgdmFyIEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG8gPSB2ZWMyY3JlYXRlKCk7IC8vIFdhcyBvcmlnaW5hbGx5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi4gXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgICAgICB2YXIgdmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG87XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodmVsbywgaW1wdWxzZVZlY3RvciwgdGhpcy5pbnZNYXNzKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5tdWx0aXBseSh2ZWxvLCB0aGlzLm1hc3NNdWx0aXBsaWVyLCB2ZWxvKTtcclxuICAgICAgICAvLyBBZGQgbGluZWFyIGltcHVsc2VcclxuICAgICAgICBhZGQodGhpcy52ZWxvY2l0eSwgdmVsbywgdGhpcy52ZWxvY2l0eSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGltcHVsc2UgdmVsb2NpdHlcclxuICAgICAgICAgICAgdmFyIHJvdFZlbG8gPSB2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChyZWxhdGl2ZVBvaW50LCBpbXB1bHNlVmVjdG9yKTtcclxuICAgICAgICAgICAgcm90VmVsbyAqPSB0aGlzLmludkluZXJ0aWE7XHJcbiAgICAgICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2VcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gcm90VmVsbztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBpbXB1bHNlIHRvIGEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cclxuICAgICAqIEBtZXRob2QgYXBwbHlJbXB1bHNlTG9jYWxcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEltcHVsc2UgVGhlIGltcHVsc2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gbG9jYWwgYm9keSBzcGFjZS5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBbbG9jYWxQb2ludF0gQSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSBpbiBsb2NhbCBib2R5IHNwYWNlLiBJZiBub3QgZ2l2ZW4sIGl0IGlzIHNldCB0byB6ZXJvIGFuZCBhbGwgb2YgdGhlIGltcHVsc2Ugd2lsbCBiZSBleGVydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGxvY2FsUG9pbnQgPSBbMSwgMF07IC8vIHg9MSwgbG9jYWxseSBpbiB0aGUgYm9keVxyXG4gICAgICogICAgIHZhciBsb2NhbEltcHVsc2UgPSBbMCwgMV07IC8vIHVwLCBsb2NhbGx5IGluIHRoZSBib2R5XHJcbiAgICAgKiAgICAgYm9keS5hcHBseUltcHVsc2VMb2NhbChsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpO1xyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkudmVsb2NpdHkpOyAvLyBbMSwgMF1cclxuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LmFuZ3VsYXJWZWxvY2l0eSk7IC8vIDFcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlTG9jYWwgPSBmdW5jdGlvbiAobG9jYWxJbXB1bHNlLCBsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgLy8gT3JpZ2luYWxseSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXHJcbiAgICAgICAgdmFyIEJvZHlfYXBwbHlJbXB1bHNlX2ltcHVsc2VXb3JsZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfcG9pbnRXb3JsZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfcG9pbnRMb2NhbCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBsb2NhbFBvaW50ID0gbG9jYWxQb2ludCB8fCBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludExvY2FsO1xyXG4gICAgICAgIHZhciB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5SW1wdWxzZV9pbXB1bHNlV29ybGQ7XHJcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5SW1wdWxzZV9wb2ludFdvcmxkO1xyXG4gICAgICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkSW1wdWxzZSwgbG9jYWxJbXB1bHNlKTtcclxuICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZFBvaW50LCBsb2NhbFBvaW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHdvcmxkUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSBwb2ludCB0byBzdG9yZSB0aGUgcmVzdWx0IGluXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludCAgIFRoZSBpbnB1dCB3b3JsZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbiAob3V0LCB3b3JsZFBvaW50KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gYSBsb2NhbCBwb2ludCB0byB3b3JsZCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdG9Xb3JsZEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSBwb2ludCB0byBzdG9yZSB0aGUgcmVzdWx0IGluXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludCAgIFRoZSBpbnB1dCBsb2NhbCBwb2ludFxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbiAob3V0LCBsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXHJcbiAgICAgKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dCAgICAgICAgICBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFZlY3RvciAgVGhlIGlucHV0IHdvcmxkIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbiAob3V0LCB3b3JsZFZlY3Rvcikge1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnZlY3RvclRvTG9jYWxGcmFtZShvdXQsIHdvcmxkVmVjdG9yLCB0aGlzLmFuZ2xlKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhIGxvY2FsIHZlY3RvciB0byB3b3JsZCBmcmFtZS5cclxuICAgICAqIEBtZXRob2QgdmVjdG9yVG9Xb3JsZEZyYW1lXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsVmVjdG9yICBUaGUgaW5wdXQgbG9jYWwgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uIChvdXQsIGxvY2FsVmVjdG9yKSB7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKG91dCwgbG9jYWxWZWN0b3IsIHRoaXMuYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBwb2x5Z29uIHNoYXBlIHBhdGgsIGFuZCBhc3NlbWJsZXMgY29udmV4IHNoYXBlcyBmcm9tIHRoYXQgYW5kIHB1dHMgdGhlbSBhdCBwcm9wZXIgb2Zmc2V0IHBvaW50cy5cclxuICAgICAqIEBtZXRob2QgZnJvbVBvbHlnb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgMmQgdmVjdG9ycywgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXSB0aGF0IHJlc2VtYmxlcyBhIGNvbmNhdmUgb3IgY29udmV4IHBvbHlnb24uIFRoZSBzaGFwZSBtdXN0IGJlIHNpbXBsZSBhbmQgd2l0aG91dCBob2xlcy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3B0aW1hbERlY29tcD1mYWxzZV0gICBTZXQgdG8gdHJ1ZSBpZiB5b3UgbmVlZCBvcHRpbWFsIGRlY29tcG9zaXRpb24uIFdhcm5pbmc6IHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gMTAgdmVydGljZXMuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBTaW1wbGVDaGVjaz1mYWxzZV0gU2V0IHRvIHRydWUgaWYgeW91IGFscmVhZHkga25vdyB0aGF0IHRoZSBwYXRoIGlzIG5vdCBpbnRlcnNlY3RpbmcgaXRzZWxmLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbW92ZUNvbGxpbmVhclBvaW50cz0wXSBTZXQgdG8gYSBudW1iZXIgKGFuZ2xlIHRocmVzaG9sZCB2YWx1ZSkgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMsIG9yIDAgdG8ga2VlcCBhbGwgcG9pbnRzLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLCBlbHNlIGZhbHNlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgdmFyIHBhdGggPSBbXHJcbiAgICAgKiAgICAgICAgIFstMSwgMV0sXHJcbiAgICAgKiAgICAgICAgIFstMSwgMF0sXHJcbiAgICAgKiAgICAgICAgIFsxLCAwXSxcclxuICAgICAqICAgICAgICAgWzEsIDFdLFxyXG4gICAgICogICAgICAgICBbMC41LCAwLjVdXHJcbiAgICAgKiAgICAgXTtcclxuICAgICAqICAgICBib2R5LmZyb21Qb2x5Z29uKHBhdGgpO1xyXG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuc2hhcGVzKTsgLy8gW0NvbnZleCwgQ29udmV4LCAuLi5dXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmZyb21Qb2x5Z29uID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHNoYXBlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNoYXBlcy5sZW5ndGg7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2hhcGUodGhpcy5zaGFwZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb3B5IHRoZSBwYXRoXHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcFtpXSA9IHZlYzJfMS5kZWZhdWx0LmNsb25lKHBhdGhbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYWtlIGl0IGNvdW50ZXItY2xvY2t3aXNlXHJcbiAgICAgICAgcG9seV9kZWNvbXBfMS5kZWZhdWx0Lm1ha2VDQ1cocCk7XHJcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHBvbHlfZGVjb21wXzEuZGVmYXVsdC5yZW1vdmVDb2xsaW5lYXJQb2ludHMocCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbW92ZUNvbGxpbmVhclBvaW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgcGF0aCBpdHNlbGZcclxuICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcFNpbXBsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICBpZiAoIXBvbHlfZGVjb21wXzEuZGVmYXVsdC5pc1NpbXBsZShwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNhdmUgdGhpcyBwYXRoIGZvciBsYXRlclxyXG4gICAgICAgIHRoaXMuY29uY2F2ZVBhdGggPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jb25jYXZlUGF0aFtpXSA9IHZlYzJfMS5kZWZhdWx0LmNsb25lKHBbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTbG93IG9yIGZhc3QgZGVjb21wP1xyXG4gICAgICAgIHZhciBjb252ZXhlcztcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGltYWxEZWNvbXApIHtcclxuICAgICAgICAgICAgY29udmV4ZXMgPSAoX2IgPSBwb2x5X2RlY29tcF8xLmRlZmF1bHQuZGVjb21wKHApKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnZleGVzID0gKF9jID0gcG9seV9kZWNvbXBfMS5kZWZhdWx0LnF1aWNrRGVjb21wKHApKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNtID0gdmVjMmNyZWF0ZSgpO1xyXG4gICAgICAgIC8vIEFkZCBjb252ZXhlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBjb252ZXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgY29udmV4XHJcbiAgICAgICAgICAgIHZhciBjID0gbmV3IENvbnZleF8xLmRlZmF1bHQodW5kZWZpbmVkLCBjb252ZXhlc1tpXSk7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgYWxsIHZlcnRpY2VzIHNvIGl0cyBjZW50ZXIgb2YgbWFzcyBpcyBpbiB0aGUgbG9jYWwgY2VudGVyIG9mIHRoZSBjb252ZXhcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGMudmVydGljZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gYy52ZXJ0aWNlc1tqXTtcclxuICAgICAgICAgICAgICAgIHN1Yih2LCB2LCBjLmNlbnRlck9mTWFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShjbSwgYy5jZW50ZXJPZk1hc3MpO1xyXG4gICAgICAgICAgICBjID0gbmV3IENvbnZleF8xLmRlZmF1bHQodW5kZWZpbmVkLCBjLnZlcnRpY2VzKTtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBzaGFwZVxyXG4gICAgICAgICAgICB0aGlzLmFkZFNoYXBlKGMsIGNtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGp1c3RDZW50ZXJPZk1hc3MoKTtcclxuICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgc2hhcGUgb2Zmc2V0cyBzbyB0aGVpciBjZW50ZXIgb2YgbWFzcyBiZWNvbWVzIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICogQG1ldGhvZCBhZGp1c3RDZW50ZXJPZk1hc3NcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IHBvc2l0aW9uOiBbMCwgMF0gfSk7XHJcbiAgICAgKiAgICAgdmFyIHNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlLCBbMSwgMF0sIDApO1xyXG4gICAgICogICAgIGJvZHkuYWRqdXN0Q2VudGVyT2ZNYXNzKCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2coYm9keS5wb3NpdGlvbik7IC8vIFsxLCAwXVxyXG4gICAgICogICAgIGNvbnNvbGUubG9nKHNoYXBlLnBvc2l0aW9uKTsgLy8gWzAsIDBdXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmFkanVzdENlbnRlck9mTWFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDIgPSB2ZWMyY3JlYXRlKCksIGFkanVzdENlbnRlck9mTWFzc190bXAzID0gdmVjMmNyZWF0ZSgpLCBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgb2Zmc2V0X3RpbWVzX2FyZWEgPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiwgc3VtID0gYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMsIGNtID0gYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQsIHRvdGFsQXJlYSA9IDA7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHN1bSwgMCwgMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKG9mZnNldF90aW1lc19hcmVhLCBzLnBvc2l0aW9uLCBzLmFyZWEpO1xyXG4gICAgICAgICAgICBhZGQoc3VtLCBzdW0sIG9mZnNldF90aW1lc19hcmVhKTtcclxuICAgICAgICAgICAgdG90YWxBcmVhICs9IHMuYXJlYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoY20sIHN1bSwgMSAvIHRvdGFsQXJlYSk7XHJcbiAgICAgICAgLy8gTm93IG1vdmUgYWxsIHNoYXBlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSB0aGlzLnNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICBzdWIocy5wb3NpdGlvbiwgcy5wb3NpdGlvbiwgY20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNb3ZlIHRoZSBib2R5IHBvc2l0aW9uIHRvb1xyXG4gICAgICAgIGFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBjbSk7XHJcbiAgICAgICAgLy8gQW5kIGNvbmNhdmUgcGF0aFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLmNvbmNhdmVQYXRoICYmIGkgPCB0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1Yih0aGlzLmNvbmNhdmVQYXRoW2ldLCB0aGlzLmNvbmNhdmVQYXRoW2ldLCBjbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmb3JjZSBvbiB0aGUgYm9keSB0byB6ZXJvLlxyXG4gICAgICogQG1ldGhvZCBzZXRaZXJvRm9yY2VcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuc2V0WmVyb0ZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmID0gdGhpcy5mb3JjZTtcclxuICAgICAgICBmWzBdID0gZlsxXSA9IHRoaXMuYW5ndWxhckZvcmNlID0gMDtcclxuICAgIH07XHJcbiAgICBCb2R5LnByb3RvdHlwZS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYiA9IHRoaXMsIHZsYW1iZGEgPSBiLnZsYW1iZGE7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHZsYW1iZGEsIDAsIDApO1xyXG4gICAgICAgIGIud2xhbWJkYSA9IDA7XHJcbiAgICB9O1xyXG4gICAgQm9keS5wcm90b3R5cGUuYWRkQ29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiID0gdGhpcywgdiA9IGIudmVsb2NpdHk7XHJcbiAgICAgICAgYWRkKHYsIHYsIGIudmxhbWJkYSk7XHJcbiAgICAgICAgYi5hbmd1bGFyVmVsb2NpdHkgKz0gYi53bGFtYmRhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgZGFtcGluZywgc2VlIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzRcIj50aGlzPC9hPiBmb3IgZGV0YWlscy5cclxuICAgICAqIEBtZXRob2QgYXBwbHlEYW1waW5nXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR0IEN1cnJlbnQgdGltZSBzdGVwXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmFwcGx5RGFtcGluZyA9IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQykgeyAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllc1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudmVsb2NpdHk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKHYsIHYsIE1hdGgucG93KDEgLSB0aGlzLmRhbXBpbmcsIGR0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICo9IE1hdGgucG93KDEgLSB0aGlzLmFuZ3VsYXJEYW1waW5nLCBkdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FrZSB0aGUgYm9keSB1cC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgbmVlZCB0aGlzLCBhcyB0aGUgYm9keSBpcyBhdXRvbWF0aWNhbGx5IGF3b2tlbiBhdCBldmVudHMgc3VjaCBhcyBjb2xsaXNpb25zLlxyXG4gICAgICogU2V0cyB0aGUgc2xlZXBTdGF0ZSB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSBhbmQgZW1pdHMgdGhlIHdha2VVcCBldmVudCBpZiB0aGUgYm9keSB3YXNuJ3QgYXdha2UgYmVmb3JlLlxyXG4gICAgICogQG1ldGhvZCB3YWtlVXBcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5zbGVlcFN0YXRlO1xyXG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZSA9IDA7XHJcbiAgICAgICAgaWYgKHMgIT09IEJvZHkuQVdBS0UpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgd2FrZVVwRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlIGJvZHkgc2xlZXBcclxuICAgICAqIEBtZXRob2Qgc2xlZXBcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcclxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IHRoaXMuYW5ndWxhckZvcmNlID0gMDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQodGhpcy52ZWxvY2l0eSwgMCwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHRoaXMuZm9yY2UsIDAsIDApO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIHNsZWVwRXZlbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpbWVzdGVwIHRvIHVwZGF0ZSBpbnRlcm5hbCBzbGVlcCB0aW1lciBhbmQgY2hhbmdlIHNsZWVwIHN0YXRlIGlmIG5lZWRlZC5cclxuICAgICAqIEBtZXRob2Qgc2xlZXBUaWNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRTbGVlcFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR0XHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLnNsZWVwVGljayA9IGZ1bmN0aW9uICh0aW1lLCBkb250U2xlZXAsIGR0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93U2xlZXAgfHwgdGhpcy50eXBlID09PSBCb2R5LlNMRUVQSU5HKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcclxuICAgICAgICB2YXIgc3BlZWRTcXVhcmVkID0gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aCh0aGlzLnZlbG9jaXR5KSArIE1hdGgucG93KHRoaXMuYW5ndWxhclZlbG9jaXR5LCAyKSwgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwgMik7XHJcbiAgICAgICAgLy8gQWRkIHRvIGlkbGUgdGltZVxyXG4gICAgICAgIGlmIChzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pZGxlVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lICs9IGR0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBzbGVlcHlFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWUgPiB0aGlzLnNsZWVwVGltZUxpbWl0KSB7XHJcbiAgICAgICAgICAgIGlmICghZG9udFNsZWVwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsZWVwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgYm9keSBpcyBvdmVybGFwcGluZyBhbm90aGVyIGJvZHkuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBvbmx5IHdvcmtzIGlmIHRoZSBib2R5IHdhcyBhZGRlZCB0byBhIFdvcmxkIGFuZCBpZiBhdCBsZWFzdCBvbmUgc3RlcCB3YXMgdGFrZW4uXHJcbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBCb2R5LnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLndvcmxkKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQub3ZlcmxhcEtlZXBlci5ib2RpZXNBcmVPdmVybGFwcGluZyh0aGlzLCBib2R5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lIGdpdmVuIGl0cyBjdXJyZW50IHZlbG9jaXR5LlxyXG4gICAgICogQG1ldGhvZCBpbnRlZ3JhdGVcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZHRcclxuICAgICAqL1xyXG4gICAgQm9keS5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgdmFyIG1pbnYgPSB0aGlzLmludk1hc3MsIGYgPSB0aGlzLmZvcmNlLCBwb3MgPSB0aGlzLnBvc2l0aW9uLCB2ZWxvID0gdGhpcy52ZWxvY2l0eTtcclxuICAgICAgICAvLyBTYXZlIG9sZCBwb3NpdGlvblxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodGhpcy5wcmV2aW91c1Bvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG4gICAgICAgIC8vIFZlbG9jaXR5IHVwZGF0ZVxyXG4gICAgICAgIGlmICghdGhpcy5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuYW5ndWxhckZvcmNlICogdGhpcy5pbnZJbmVydGlhICogZHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGludGVncmF0ZV9maE1pbnYsIGYsIGR0ICogbWludik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubXVsdGlwbHkoaW50ZWdyYXRlX2ZoTWludiwgdGhpcy5tYXNzTXVsdGlwbGllciwgaW50ZWdyYXRlX2ZoTWludik7XHJcbiAgICAgICAgYWRkKHZlbG8sIGludGVncmF0ZV9maE1pbnYsIHZlbG8pO1xyXG4gICAgICAgIC8vIENDRFxyXG4gICAgICAgIGlmICghdGhpcy5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdChkdCkpIHtcclxuICAgICAgICAgICAgLy8gUmVndWxhciBwb3NpdGlvbiB1cGRhdGVcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgdmVsbywgZHQpO1xyXG4gICAgICAgICAgICBhZGQocG9zLCBwb3MsIGludGVncmF0ZV92ZWxvZHQpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZml4ZWRSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBCb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdCA9IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIXRoaXMud29ybGQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHJheWNhc3RfcmVzdWx0XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHZhciByYXkgPSBuZXcgcmF5XzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIG1vZGU6IHJheV8xLmRlZmF1bHQuQ0xPU0VTVCxcclxuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB2ZWMyY3JlYXRlKCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgc3RhcnRUb0VuZCA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICB2YXIgcmVtZW1iZXJQb3NpdGlvbiA9IHZlYzJjcmVhdGUoKTtcclxuICAgICAgICBpZiAodGhpcy5jY2RTcGVlZFRocmVzaG9sZCA8IDAgfHwgdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aCh0aGlzLnZlbG9jaXR5KSA8IE1hdGgucG93KHRoaXMuY2NkU3BlZWRUaHJlc2hvbGQsIDIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWdub3JlIGFsbCB0aGUgaWdub3JlZCBib2R5IHBhaXJzXHJcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBzb21ld2hlcmUgZWxzZSBmb3Igb3B0aW1pemF0aW9uXHJcbiAgICAgICAgdmFyIGlnbm9yZUJvZGllcyA9IFtdO1xyXG4gICAgICAgIHZhciBkaXNhYmxlZFBhaXJzID0gdGhpcy53b3JsZC5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc2FibGVkUGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlBID0gZGlzYWJsZWRQYWlyc1tpXTtcclxuICAgICAgICAgICAgdmFyIGJvZHlCID0gZGlzYWJsZWRQYWlyc1tpICsgMV07XHJcbiAgICAgICAgICAgIGlmIChib2R5QSA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgaWdub3JlQm9kaWVzLnB1c2goYm9keUIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvZHlCID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVCb2RpZXMucHVzaChib2R5QSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKGRpcmVjdGlvbiwgdGhpcy52ZWxvY2l0eSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoZW5kLCB0aGlzLnZlbG9jaXR5LCBkdCk7XHJcbiAgICAgICAgYWRkKGVuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBzdWIoc3RhcnRUb0VuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgc3RhcnRUb0VuZEFuZ2xlID0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcclxuICAgICAgICB2YXIgbGVuID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHN0YXJ0VG9FbmQpO1xyXG4gICAgICAgIHZhciB0aW1lT2ZJbXBhY3QgPSAxO1xyXG4gICAgICAgIHZhciBoaXRCb2R5ID0gbnVsbDtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHJheS5mcm9tLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHJheS50bywgZW5kKTtcclxuICAgICAgICByYXkudXBkYXRlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlc1tpXTtcclxuICAgICAgICAgICAgcmVzdWx0LnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHJheS5jb2xsaXNpb25Hcm91cCA9IHNoYXBlLmNvbGxpc2lvbkdyb3VwO1xyXG4gICAgICAgICAgICByYXkuY29sbGlzaW9uTWFzayA9IHNoYXBlLmNvbGxpc2lvbk1hc2s7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XHJcbiAgICAgICAgICAgIGhpdEJvZHkgPSAoX2EgPSByZXN1bHQuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFoaXRCb2R5KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChoaXRCb2R5ID09PSB0aGlzIHx8IGlnbm9yZUJvZGllcy5pbmRleE9mKGhpdEJvZHkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgaGl0Qm9keSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpdEJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGl0Qm9keSB8fCAhdGltZU9mSW1wYWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmdldEhpdFBvaW50KGVuZCwgcmF5KTtcclxuICAgICAgICBzdWIoc3RhcnRUb0VuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICB0aW1lT2ZJbXBhY3QgPSB2ZWMyXzEuZGVmYXVsdC5kaXN0YW5jZShlbmQsIHRoaXMucG9zaXRpb24pIC8gbGVuOyAvLyBndWVzc1xyXG4gICAgICAgIHZhciByZW1lbWJlckFuZ2xlID0gdGhpcy5hbmdsZTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHJlbWVtYmVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgIC8vIEdvdCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQuIEFwcHJveGltYXRlIHRpbWUgb2YgaW1wYWN0IHVzaW5nIGJpbmFyeSBzZWFyY2hcclxuICAgICAgICB2YXIgaXRlciA9IDA7XHJcbiAgICAgICAgdmFyIHRtaW4gPSAwO1xyXG4gICAgICAgIHZhciB0bWlkID0gdGltZU9mSW1wYWN0O1xyXG4gICAgICAgIHZhciB0bWF4ID0gMTtcclxuICAgICAgICB3aGlsZSAodG1heCA+PSB0bWluICYmIGl0ZXIgPCB0aGlzLmNjZEl0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgaXRlcisrO1xyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG1pZHBvaW50XHJcbiAgICAgICAgICAgIHRtaWQgPSAodG1heCArIHRtaW4pIC8gMjtcclxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgYm9keSB0byB0aGF0IHBvaW50XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRtaWQpO1xyXG4gICAgICAgICAgICBhZGQodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbiwgaW50ZWdyYXRlX3ZlbG9kdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgPSByZW1lbWJlckFuZ2xlICsgc3RhcnRUb0VuZEFuZ2xlICogdG1pZDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG92ZXJsYXBcclxuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gdGhpcy5hYWJiLm92ZXJsYXBzKGhpdEJvZHkuYWFiYikgJiYgdGhpcy53b3JsZC5uYXJyb3dwaGFzZS5ib2RpZXNPdmVybGFwKHRoaXMsIGhpdEJvZHksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBtYXggdG8gc2VhcmNoIGxvd2VyIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB0bWF4ID0gdG1pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBtaW4gdG8gc2VhcmNoIHVwcGVyIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB0bWluID0gdG1pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lT2ZJbXBhY3QgPSB0bWF4OyAvLyBOZWVkIHRvIGd1YXJhbnRlZSBvdmVybGFwIHRvIHJlc29sdmUgY29sbGlzaW9uc1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkodGhpcy5wb3NpdGlvbiwgcmVtZW1iZXJQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5hbmdsZSA9IHJlbWVtYmVyQW5nbGU7XHJcbiAgICAgICAgLy8gbW92ZSB0byBUT0lcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCBzdGFydFRvRW5kLCB0aW1lT2ZJbXBhY3QpO1xyXG4gICAgICAgIGFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBpbnRlZ3JhdGVfdmVsb2R0KTtcclxuICAgICAgICBpZiAoIXRoaXMuZml4ZWRSb3RhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmFuZ2xlICs9IHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cclxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFBvaW50XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0IEEgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIEBwYXJhbSAge0FycmF5fSByZWxhdGl2ZVBvaW50IEEgd29ybGQgb3JpZW50ZWQgdmVjdG9yLCBpbmRpY2F0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgdG8gZ2V0IHRoZSB2ZWxvY2l0eSBmcm9tXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdCB2ZWN0b3JcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7XHJcbiAgICAgKiAgICAgICAgIG1hc3M6IDEsXHJcbiAgICAgKiAgICAgICAgIHZlbG9jaXR5OiBbMSwgMF0sXHJcbiAgICAgKiAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAqICAgICB2YXIgcG9pbnQgPSBbMSwgMF07XHJcbiAgICAgKiAgICAgYm9keS5nZXRWZWxvY2l0eUF0UG9pbnQocmVzdWx0LCBwb2ludCk7XHJcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTsgLy8gWzEsIDFdXHJcbiAgICAgKi9cclxuICAgIEJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRQb2ludCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJlbGF0aXZlUG9pbnQpIHtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcm9zc1ZaKHJlc3VsdCwgcmVsYXRpdmVQb2ludCwgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJlc3VsdCwgdGhpcy52ZWxvY2l0eSwgcmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRHluYW1pYyBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IERZTkFNSUNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuRFlOQU1JQyA9IDE7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXRpYyBib2R5LlxyXG4gICAgICogQHByb3BlcnR5IFNUQVRJQ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5TVEFUSUMgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBLaW5lbWF0aWMgYm9keS5cclxuICAgICAqIEBwcm9wZXJ0eSBLSU5FTUFUSUNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuS0lORU1BVElDID0gNDtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IEFXQUtFXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBCb2R5LkFXQUtFID0gMDtcclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IFNMRUVQWVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgQm9keS5TTEVFUFkgPSAxO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkgU0xFRVBJTkdcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKi9cclxuICAgIEJvZHkuU0xFRVBJTkcgPSAyO1xyXG4gICAgcmV0dXJuIEJvZHk7XHJcbn0oZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm9keTtcclxuLyoqXHJcbiAqIEBldmVudCBzbGVlcHlcclxuICovXHJcbnZhciBzbGVlcHlFdmVudCA9IHtcclxuICAgIHR5cGU6IFwic2xlZXB5XCJcclxufTtcclxuLyoqXHJcbiAqIEBldmVudCBzbGVlcFxyXG4gKi9cclxudmFyIHNsZWVwRXZlbnQgPSB7XHJcbiAgICB0eXBlOiBcInNsZWVwXCJcclxufTtcclxuLyoqXHJcbiAqIEBldmVudCB3YWtldXBcclxuICovXHJcbnZhciB3YWtlVXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwid2FrZXVwXCJcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIHNwcmluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NwcmluZ1wiKSk7XHJcbnZhciBhcHBseUZvcmNlX3IgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV9yX3VuaXQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV91ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2VfZiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCBhcHBseUZvcmNlX3JpID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksIGFwcGx5Rm9yY2VfcmogPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgYXBwbHlGb3JjZV90bXAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIExpbmVhclNwcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaW5lYXJTcHJpbmcsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBMaW5lYXJTcHJpbmdcclxuICAgICAqIEBleHRlbmRzIFNwcmluZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHNwcmluZyA9IG5ldyBMaW5lYXJTcHJpbmcoYm9keUEsIGJvZHlCLCB7XHJcbiAgICAgKiAgICAgICAgIHN0aWZmbmVzczogMTAwLFxyXG4gICAgICogICAgICAgICBkYW1waW5nOiAxLFxyXG4gICAgICogICAgICAgICBsb2NhbEFuY2hvckE6IFswLDBdLCAvLyBjZW50ZXIgb2YgYm9keUFcclxuICAgICAqICAgICAgICAgbG9jYWxBbmNob3JCOiBbMCwwXSAvLyBjZW50ZXIgb2YgYm9keUJcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRTcHJpbmcoc3ByaW5nKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTGluZWFyU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JBID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgX3RoaXMubG9jYWxBbmNob3JCID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckEpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbEFuY2hvckIpIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShfdGhpcy5sb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JsZEFuY2hvckEpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0V29ybGRBbmNob3JBKG9wdGlvbnMud29ybGRBbmNob3JBKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JsZEFuY2hvckIpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcclxuICAgICAgICBfdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcclxuICAgICAgICB2YXIgd29ybGREaXN0YW5jZSA9IHZlYzJfMS5kZWZhdWx0LmRpc3RhbmNlKHdvcmxkQW5jaG9yQSwgd29ybGRBbmNob3JCKTtcclxuICAgICAgICBfdGhpcy5yZXN0TGVuZ3RoID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlc3RMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdvcmxkRGlzdGFuY2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQVxyXG4gICAgICovXHJcbiAgICBMaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uICh3b3JsZEFuY2hvckEpIHtcclxuICAgICAgICB0aGlzLmJvZHlBLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSwgd29ybGRBbmNob3JBKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JCXHJcbiAgICAgKi9cclxuICAgIExpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24gKHdvcmxkQW5jaG9yQikge1xyXG4gICAgICAgIHRoaXMuYm9keUIudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JCLCB3b3JsZEFuY2hvckIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBMaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmJvZHlBLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JBKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5ib2R5Qi50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gICAgICovXHJcbiAgICBMaW5lYXJTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcywgZCA9IHRoaXMuZGFtcGluZywgbCA9IHRoaXMucmVzdExlbmd0aCwgYm9keUEgPSB0aGlzLmJvZHlBLCBib2R5QiA9IHRoaXMuYm9keUIsIHIgPSBhcHBseUZvcmNlX3IsIHJfdW5pdCA9IGFwcGx5Rm9yY2Vfcl91bml0LCB1ID0gYXBwbHlGb3JjZV91LCBmID0gYXBwbHlGb3JjZV9mLCB0bXAgPSBhcHBseUZvcmNlX3RtcDtcclxuICAgICAgICB2YXIgd29ybGRBbmNob3JBID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckEsIHdvcmxkQW5jaG9yQiA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCLCByaSA9IGFwcGx5Rm9yY2VfcmksIHJqID0gYXBwbHlGb3JjZV9yajtcclxuICAgICAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xyXG4gICAgICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XHJcbiAgICAgICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcclxuICAgICAgICAvLyBHZXQgb2Zmc2V0IHBvaW50c1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KHJpLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChyaiwgd29ybGRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qociwgd29ybGRBbmNob3JCLCB3b3JsZEFuY2hvckEpO1xyXG4gICAgICAgIHZhciBybGVuID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKHIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShyX3VuaXQsIHIpO1xyXG4gICAgICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh1LCBib2R5Qi52ZWxvY2l0eSwgYm9keUEudmVsb2NpdHkpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyb3NzWlYodG1wLCBib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHJqKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQodSwgdSwgdG1wKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcm9zc1pWKHRtcCwgYm9keUEuYW5ndWxhclZlbG9jaXR5LCByaSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QodSwgdSwgdG1wKTtcclxuICAgICAgICAvLyBGID0gLSBrICogKCB4IC0gTCApIC0gRCAqICggdSApXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUoZiwgcl91bml0LCAtayAqIChybGVuIC0gbCkgLSBkICogdmVjMl8xLmRlZmF1bHQuZG90KHUsIHJfdW5pdCkpO1xyXG4gICAgICAgIC8vIEFkZCBmb3JjZXMgdG8gYm9kaWVzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QoYm9keUEuZm9yY2UsIGJvZHlBLmZvcmNlLCBmKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoYm9keUIuZm9yY2UsIGJvZHlCLmZvcmNlLCBmKTtcclxuICAgICAgICAvLyBBbmd1bGFyIGZvcmNlXHJcbiAgICAgICAgdmFyIHJpX3hfZiA9IHZlYzJfMS5kZWZhdWx0LmNyb3NzTGVuZ3RoKHJpLCBmKTtcclxuICAgICAgICB2YXIgcmpfeF9mID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocmosIGYpO1xyXG4gICAgICAgIGJvZHlBLmFuZ3VsYXJGb3JjZSAtPSByaV94X2Y7XHJcbiAgICAgICAgYm9keUIuYW5ndWxhckZvcmNlICs9IHJqX3hfZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGluZWFyU3ByaW5nO1xyXG59KHNwcmluZ18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGluZWFyU3ByaW5nO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgc3ByaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc3ByaW5nXCIpKTtcclxudmFyIFJvdGF0aW9uYWxTcHJpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm90YXRpb25hbFNwcmluZywgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXHJcbiAgICAgKiBAZXh0ZW5kcyBTcHJpbmdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBzcHJpbmcgPSBuZXcgUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIHtcclxuICAgICAqICAgICAgICAgc3RpZmZuZXNzOiAxMDAsXHJcbiAgICAgKiAgICAgICAgIGRhbXBpbmc6IDFcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB3b3JsZC5hZGRTcHJpbmcoc3ByaW5nKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5yZXN0QW5nbGUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdEFuZ2xlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cclxuICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxyXG4gICAgICovXHJcbiAgICBSb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsIGQgPSB0aGlzLmRhbXBpbmcsIGwgPSB0aGlzLnJlc3RBbmdsZSwgYm9keUEgPSB0aGlzLmJvZHlBLCBib2R5QiA9IHRoaXMuYm9keUIsIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLCB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgIHZhciB0b3JxdWUgPSAtayAqICh4IC0gbCkgLSBkICogdTtcclxuICAgICAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xyXG4gICAgICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFJvdGF0aW9uYWxTcHJpbmc7XHJcbn0oc3ByaW5nXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSb3RhdGlvbmFsU3ByaW5nO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3ByaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGNsYXNzIGZvciB7eyNjcm9zc0xpbmsgXCJMaW5lYXJTcHJpbmdcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlJvdGF0aW9uYWxTcHJpbmdcIn19e3svY3Jvc3NMaW5rfX0uIE5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGRpcmVjdGx5LlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBTcHJpbmdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuc3RpZmZuZXNzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0aWZmbmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTAwO1xyXG4gICAgICAgIHRoaXMuZGFtcGluZyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYW1waW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3ByaW5nO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTcHJpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBib2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYm9keVwiKSk7XHJcbnZhciBjb25zdHJhaW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbnN0cmFpbnRzL2NvbnN0cmFpbnRcIikpO1xyXG52YXIgZnJpY3Rpb25fZXF1YXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXF1YXRpb25zL2ZyaWN0aW9uLWVxdWF0aW9uXCIpKTtcclxudmFyIHdvcmxkVmVsb2NpdHkgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJlbGF0aXZlUG9pbnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHRtcFZlYyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgVG9wRG93blZlaGljbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBUb3BEb3duVmVoaWNsZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBjbGFzcyB3aWxsIGJlIG1vdmVkIG91dCBvZiB0aGUgY29yZSBsaWJyYXJ5IGluIGZ1dHVyZSB2ZXJzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGNoYXNzaXNCb2R5IEEgZHluYW1pYyBib2R5LCBhbHJlYWR5IGFkZGVkIHRvIHRoZSB3b3JsZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGUgYSBkeW5hbWljIGJvZHkgZm9yIHRoZSBjaGFzc2lzXHJcbiAgICAgKiAgICAgdmFyIGNoYXNzaXNCb2R5ID0gbmV3IEJvZHkoe1xyXG4gICAgICogICAgICAgICBtYXNzOiAxXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgdmFyIGJveFNoYXBlID0gbmV3IEJveCh7IHdpZHRoOiAwLjUsIGhlaWdodDogMSB9KTtcclxuICAgICAqICAgICBjaGFzc2lzQm9keS5hZGRTaGFwZShib3hTaGFwZSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShjaGFzc2lzQm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSB0aGUgdmVoaWNsZVxyXG4gICAgICogICAgIHZhciB2ZWhpY2xlID0gbmV3IFRvcERvd25WZWhpY2xlKGNoYXNzaXNCb2R5KTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gQWRkIG9uZSBmcm9udCB3aGVlbCBhbmQgb25lIGJhY2sgd2hlZWwgLSB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIGZvdXIgOilcclxuICAgICAqICAgICB2YXIgZnJvbnRXaGVlbCA9IHZlaGljbGUuYWRkV2hlZWwoe1xyXG4gICAgICogICAgICAgICBsb2NhbFBvc2l0aW9uOiBbMCwgMC41XSAvLyBmcm9udFxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGZyb250V2hlZWwuc2V0U2lkZUZyaWN0aW9uKDQpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBCYWNrIHdoZWVsXHJcbiAgICAgKiAgICAgdmFyIGJhY2tXaGVlbCA9IHZlaGljbGUuYWRkV2hlZWwoe1xyXG4gICAgICogICAgICAgICBsb2NhbFBvc2l0aW9uOiBbMCwgLTAuNV0gLy8gYmFja1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJhY2tXaGVlbC5zZXRTaWRlRnJpY3Rpb24oMyk7IC8vIExlc3Mgc2lkZSBmcmljdGlvbiBvbiBiYWNrIHdoZWVsIG1ha2VzIGl0IGVhc2llciB0byBkcmlmdFxyXG4gICAgICogICAgIHZlaGljbGUuYWRkVG9Xb3JsZCh3b3JsZCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIFN0ZWVyIHZhbHVlIHplcm8gbWVhbnMgc3RyYWlnaHQgZm9yd2FyZC4gUG9zaXRpdmUgaXMgbGVmdCBhbmQgbmVnYXRpdmUgcmlnaHQuXHJcbiAgICAgKiAgICAgZnJvbnRXaGVlbC5zdGVlclZhbHVlID0gTWF0aC5QSSAvIDE2O1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBFbmdpbmUgZm9yY2UgZm9yd2FyZFxyXG4gICAgICogICAgIGJhY2tXaGVlbC5lbmdpbmVGb3JjZSA9IDEwO1xyXG4gICAgICogICAgIGJhY2tXaGVlbC5zZXRCcmFrZUZvcmNlKDApO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUb3BEb3duVmVoaWNsZShjaGFzc2lzQm9keSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gQSBkdW1teSBib2R5IHRvIGNvbnN0cmFpbiB0aGUgY2hhc3NpcyB0b1xyXG4gICAgICAgIHRoaXMuZ3JvdW5kQm9keSA9IG5ldyBib2R5XzEuZGVmYXVsdCh7IG1hc3M6IDAgfSk7XHJcbiAgICAgICAgdGhpcy53aGVlbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmNoYXNzaXNCb2R5ID0gY2hhc3Npc0JvZHk7XHJcbiAgICAgICAgdGhpcy5wcmVTdGVwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYWRkVG9Xb3JsZFxyXG4gICAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcclxuICAgICAqL1xyXG4gICAgVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAod29ybGQpIHtcclxuICAgICAgICB0aGlzLndvcmxkID0gd29ybGQ7XHJcbiAgICAgICAgd29ybGQuYWRkQm9keSh0aGlzLmdyb3VuZEJvZHkpO1xyXG4gICAgICAgIHdvcmxkLm9uKFwicHJlU3RlcFwiLCB0aGlzLnByZVN0ZXBDYWxsYmFjaywgdGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgd2hlZWwgPSB0aGlzLndoZWVsc1tpXTtcclxuICAgICAgICAgICAgd29ybGQuYWRkQ29uc3RyYWludCh3aGVlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcclxuICAgICAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXHJcbiAgICAgKi9cclxuICAgIFRvcERvd25WZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcclxuICAgICAgICBpZiAod29ybGQpIHtcclxuICAgICAgICAgICAgd29ybGQucmVtb3ZlQm9keSh0aGlzLmdyb3VuZEJvZHkpO1xyXG4gICAgICAgICAgICB3b3JsZC5vZmYoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aGVlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludCh3aGVlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53b3JsZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGFkZFdoZWVsXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3doZWVsT3B0aW9uc11cclxuICAgICAqIEByZXR1cm4ge1doZWVsQ29uc3RyYWludH1cclxuICAgICAqL1xyXG4gICAgVG9wRG93blZlaGljbGUucHJvdG90eXBlLmFkZFdoZWVsID0gZnVuY3Rpb24gKHdoZWVsT3B0aW9ucykge1xyXG4gICAgICAgIHZhciB3aGVlbCA9IG5ldyBXaGVlbENvbnN0cmFpbnQodGhpcywgd2hlZWxPcHRpb25zKTtcclxuICAgICAgICB0aGlzLndoZWVscy5wdXNoKHdoZWVsKTtcclxuICAgICAgICByZXR1cm4gd2hlZWw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBUb3BEb3duVmVoaWNsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aGVlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy53aGVlbHNbaV0udXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBUb3BEb3duVmVoaWNsZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVG9wRG93blZlaGljbGU7XHJcbnZhciBXaGVlbENvbnN0cmFpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoV2hlZWxDb25zdHJhaW50LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgV2hlZWxDb25zdHJhaW50XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIHtDb25zdHJhaW50fVxyXG4gICAgICogQHBhcmFtIHtWZWhpY2xlfSB2ZWhpY2xlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3JdIFRoZSBsb2NhbCB3aGVlbCBmb3J3YXJkIHZlY3RvciBpbiBsb2NhbCBib2R5IHNwYWNlLiBEZWZhdWx0IGlzIHplcm8uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbFBvc2l0aW9uXSBUaGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIHdoZWVuIGluIHRoZSBjaGFzc2lzIGJvZHkuIERlZmF1bHQgaXMgemVybyAtIHRoZSBjZW50ZXIgb2YgdGhlIGJvZHkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5zaWRlRnJpY3Rpb249NV0gVGhlIG1heCBmcmljdGlvbiBmb3JjZSBpbiB0aGUgc2lkZXdheXMgZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBXaGVlbENvbnN0cmFpbnQodmVoaWNsZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBcclxuICAgICAgICAvLyBUT0RPOiBJIGhhdmUgbm8gaWRlYSB3aGF0IGtpbmQgb2YgY29uc3RyYWludCB0aGlzIGlzIHN1cHBvc2VkIHRvIGJlLiBJdCBzZWVtcyB0aGlzIHdhcyB1bmRlZmluZWQgaW4gdGhlIG9yaWdpbmFsIGNvZGUuXHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmVoaWNsZS5jaGFzc2lzQm9keSwgdmVoaWNsZS5ncm91bmRCb2R5LCAwKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnN0ZWVyVmFsdWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmdpbmVGb3JjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVuZ2luZUZvcmNlID0gMDtcclxuICAgICAgICBfdGhpcy52ZWhpY2xlID0gdmVoaWNsZTtcclxuICAgICAgICBfdGhpcy5mb3J3YXJkRXF1YXRpb24gPSBuZXcgZnJpY3Rpb25fZXF1YXRpb25fMS5kZWZhdWx0KHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XHJcbiAgICAgICAgX3RoaXMuc2lkZUVxdWF0aW9uID0gbmV3IGZyaWN0aW9uX2VxdWF0aW9uXzEuZGVmYXVsdCh2ZWhpY2xlLmNoYXNzaXNCb2R5LCB2ZWhpY2xlLmdyb3VuZEJvZHkpO1xyXG4gICAgICAgIF90aGlzLnNldFNpZGVGcmljdGlvbigoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lkZUZyaWN0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiA1KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbEZvcndhcmRWZWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IgPSB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKDAsIDEpO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWxGb3J3YXJkVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoX3RoaXMubG9jYWxGb3J3YXJkVmVjdG9yLCBvcHRpb25zLmxvY2FsRm9yd2FyZFZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxvY2FsUG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5sb2NhbFBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoX3RoaXMubG9jYWxQb3NpdGlvbiwgb3B0aW9ucy5sb2NhbFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zLnB1c2goX3RoaXMuZm9yd2FyZEVxdWF0aW9uKTtcclxuICAgICAgICBfdGhpcy5lcXVhdGlvbnMucHVzaChfdGhpcy5zaWRlRXF1YXRpb24pO1xyXG4gICAgICAgIF90aGlzLnNldEJyYWtlRm9yY2UoMCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldEJyYWtlRm9yY2VcclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5zZXRCcmFrZUZvcmNlID0gZnVuY3Rpb24gKGZvcmNlKSB7XHJcbiAgICAgICAgdGhpcy5mb3J3YXJkRXF1YXRpb24uc2V0U2xpcEZvcmNlKGZvcmNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2Qgc2V0U2lkZUZyaWN0aW9uXHJcbiAgICAgKi9cclxuICAgIFdoZWVsQ29uc3RyYWludC5wcm90b3R5cGUuc2V0U2lkZUZyaWN0aW9uID0gZnVuY3Rpb24gKGZvcmNlKSB7XHJcbiAgICAgICAgdGhpcy5zaWRlRXF1YXRpb24uc2V0U2xpcEZvcmNlKGZvcmNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZ2V0U3BlZWRcclxuICAgICAqL1xyXG4gICAgV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5nZXRTcGVlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYm9keSA9IHRoaXMudmVoaWNsZS5jaGFzc2lzQm9keTtcclxuICAgICAgICBib2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxhdGl2ZVBvaW50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XHJcbiAgICAgICAgYm9keS5nZXRWZWxvY2l0eUF0UG9pbnQod29ybGRWZWxvY2l0eSwgcmVsYXRpdmVQb2ludCk7XHJcbiAgICAgICAgcmV0dXJuIHZlYzJfMS5kZWZhdWx0LmRvdCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIFdoZWVsQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5O1xyXG4gICAgICAgIHZhciBmb3J3YXJkRXF1YXRpb24gPSB0aGlzLmZvcndhcmRFcXVhdGlvbjtcclxuICAgICAgICB2YXIgc2lkZUVxdWF0aW9uID0gdGhpcy5zaWRlRXF1YXRpb247XHJcbiAgICAgICAgdmFyIHN0ZWVyVmFsdWUgPSB0aGlzLnN0ZWVyVmFsdWU7XHJcbiAgICAgICAgLy8gRGlyZWN0aW9uYWxcclxuICAgICAgICBib2R5LnZlY3RvclRvV29ybGRGcmFtZShmb3J3YXJkRXF1YXRpb24udCwgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShzaWRlRXF1YXRpb24udCwgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIE1hdGguUEkgLyAyKTtcclxuICAgICAgICBib2R5LnZlY3RvclRvV29ybGRGcmFtZShzaWRlRXF1YXRpb24udCwgc2lkZUVxdWF0aW9uLnQpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShmb3J3YXJkRXF1YXRpb24udCwgZm9yd2FyZEVxdWF0aW9uLnQsIHN0ZWVyVmFsdWUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShzaWRlRXF1YXRpb24udCwgc2lkZUVxdWF0aW9uLnQsIHN0ZWVyVmFsdWUpO1xyXG4gICAgICAgIC8vIEF0dGFjaG1lbnQgcG9pbnRcclxuICAgICAgICBib2R5LnRvV29ybGRGcmFtZShmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QiwgdGhpcy5sb2NhbFBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jb3B5KHNpZGVFcXVhdGlvbi5jb250YWN0UG9pbnRCLCBmb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50Qik7XHJcbiAgICAgICAgYm9keS52ZWN0b3JUb1dvcmxkRnJhbWUoZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHRoaXMubG9jYWxQb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weShzaWRlRXF1YXRpb24uY29udGFjdFBvaW50QSwgZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEpO1xyXG4gICAgICAgIC8vIEFkZCBlbmdpbmUgZm9yY2VcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUodG1wVmVjLCBmb3J3YXJkRXF1YXRpb24udCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIHRoaXMuZW5naW5lRm9yY2UpO1xyXG4gICAgICAgIHRoaXMudmVoaWNsZS5jaGFzc2lzQm9keS5hcHBseUZvcmNlKHRtcFZlYywgZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXaGVlbENvbnN0cmFpbnQ7XHJcbn0oY29uc3RyYWludF8xLmRlZmF1bHQpKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxyXG4vLyAsICAgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcclxuLy8gLCAgIHNoYWxsb3dDbG9uZSA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJykuc2hhbGxvd0Nsb25lXHJcbi8vICwgICBDb252ZXggPSByZXF1aXJlKCcuL0NvbnZleCcpO1xyXG52YXIgQ29udmV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQ29udmV4XCIpKTtcclxudmFyIHNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJveCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQm94IHNoYXBlIGNsYXNzLlxyXG4gICAgICogQGNsYXNzIEJveFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTFdIFRvdGFsIHdpZHRoIG9mIHRoZSBib3hcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MV0gVG90YWwgaGVpZ2h0IG9mIHRoZSBib3hcclxuICAgICAqIEBleHRlbmRzIENvbnZleFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcclxuICAgICAqICAgICB2YXIgYm94U2hhcGUgPSBuZXcgQm94KHtcclxuICAgICAqICAgICAgICAgd2lkdGg6IDIsXHJcbiAgICAgKiAgICAgICAgIGhlaWdodDogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoYm94U2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCb3gob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgd2lkdGggPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xyXG4gICAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZV8xLmRlZmF1bHQuQk9YLCBbXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoLWh3LCAtaGgpLFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGh3LCAtaGgpLFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGh3LCBoaCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmZyb21WYWx1ZXMoLWh3LCBoaClcclxuICAgICAgICBdLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBfdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJveC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gKGggKiBoICsgdyAqIHcpIC8gMTI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xyXG4gICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xyXG4gICAgICovXHJcbiAgICBCb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQodyAqIHcgKyBoICogaCkgLyAyO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIEJveC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSksIHMgPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpLCB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSAodyAqIHMgKyBoICogYykgKiAwLjU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gKGggKiBzICsgdyAqIGMpICogMC41O1xyXG4gICAgICAgIHZhciBsID0gb3V0Lmxvd2VyQm91bmQ7XHJcbiAgICAgICAgdmFyIHUgPSBvdXQudXBwZXJCb3VuZDtcclxuICAgICAgICB2YXIgcHggPSBwb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgcHkgPSBwb3NpdGlvblsxXTtcclxuICAgICAgICBsWzBdID0gcHggLSB3aWR0aDtcclxuICAgICAgICBsWzFdID0gcHkgLSBoZWlnaHQ7XHJcbiAgICAgICAgdVswXSA9IHB4ICsgd2lkdGg7XHJcbiAgICAgICAgdVsxXSA9IHB5ICsgaGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEJveC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJlYTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBCb3gucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGxvY2FsUG9pbnRbMF0pIDw9IHRoaXMud2lkdGggKiAwLjUgJiYgTWF0aC5hYnMobG9jYWxQb2ludFsxXSkgPD0gdGhpcy5oZWlnaHQgKiAwLjU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEJveDtcclxufShDb252ZXhfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJveDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXHJcbi8vICwgICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmU7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBDaXJjbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2lyY2xlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaXJjbGUgc2hhcGUgY2xhc3MuXHJcbiAgICAgKiBAY2xhc3MgQ2lyY2xlXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV0gVGhlIHJhZGl1cyBvZiB0aGlzIGNpcmNsZVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XHJcbiAgICAgKiAgICAgdmFyIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZSh7XHJcbiAgICAgKiAgICAgICAgIHJhZGl1czogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoY2lyY2xlU2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDaXJjbGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTaGFwZV8xLmRlZmF1bHQuQ0lSQ0xFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgcmFkaXVzXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5yYWRpdXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIENpcmNsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiByICogciAvIDI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIENpcmNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVBcmVhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIENpcmNsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIENpcmNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAob3V0LCBwb3NpdGlvbiAvKiwgYW5nbGU6IGYzMiovKSB7XHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQob3V0LnVwcGVyQm91bmQsIHIsIHIpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChvdXQubG93ZXJCb3VuZCwgLXIsIC1yKTtcclxuICAgICAgICBpZiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuYWRkKG91dC5sb3dlckJvdW5kLCBvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcclxuICAgICAqIEBwYXJhbSAge1JheX0gcmF5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiAvKiwgYW5nbGU6IGYzMiovKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbSwgdG8gPSByYXkudG8sIHIgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICB2YXIgYSA9IE1hdGgucG93KHRvWzBdIC0gZnJvbVswXSwgMikgKyBNYXRoLnBvdyh0b1sxXSAtIGZyb21bMV0sIDIpO1xyXG4gICAgICAgIHZhciBiID0gMiAqICgodG9bMF0gLSBmcm9tWzBdKSAqIChmcm9tWzBdIC0gcG9zaXRpb25bMF0pICsgKHRvWzFdIC0gZnJvbVsxXSkgKiAoZnJvbVsxXSAtIHBvc2l0aW9uWzFdKSk7XHJcbiAgICAgICAgdmFyIGMgPSBNYXRoLnBvdyhmcm9tWzBdIC0gcG9zaXRpb25bMF0sIDIpICsgTWF0aC5wb3coZnJvbVsxXSAtIHBvc2l0aW9uWzFdLCAyKSAtIE1hdGgucG93KHIsIDIpO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsO1xyXG4gICAgICAgIGlmIChkZWx0YSA8IDApIHtcclxuICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZGVsdGEpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcclxuICAgICAgICAgICAgdmFyIGludjJhID0gMSAvICgyICogYSk7XHJcbiAgICAgICAgICAgIHZhciBkMSA9ICgtYiAtIHNxcnREZWx0YSkgKiBpbnYyYTtcclxuICAgICAgICAgICAgdmFyIGQyID0gKC1iICsgc3FydERlbHRhKSAqIGludjJhO1xyXG4gICAgICAgICAgICBpZiAoZDEgPj0gMCAmJiBkMSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDEpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMSwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNob3VsZFN0b3AocmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZDIgPj0gMCAmJiBkMiA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDIpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMiwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlLnByb3RvdHlwZS5wb2ludFRlc3QgPSBmdW5jdGlvbiAobG9jYWxQb2ludCkge1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICByZXR1cm4gdmVjMl8xLmRlZmF1bHQuc3F1YXJlZExlbmd0aChsb2NhbFBvaW50KSA8PSByYWRpdXMgKiByYWRpdXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENpcmNsZTtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TaGFwZVwiKSk7XHJcbnZhciBwb2x5a18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3BvbHlrXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGRvdCA9IHZlYzJfMS5kZWZhdWx0LmRvdDtcclxudmFyIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB1cGRhdGVDZW50ZXJPZk1hc3NfYSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB1cGRhdGVDZW50ZXJPZk1hc3NfYiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLCB1cGRhdGVDZW50ZXJPZk1hc3NfYyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdG1wVmVjMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q29udmV4X3JheVN0YXJ0ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5RW5kID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RDb252ZXhfbm9ybWFsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBwaWNfcjAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHBpY19yMSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgdG1wVmVjMiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgd29ybGRBeGlzID0gdG1wVmVjMjtcclxudmFyIENvbnZleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb252ZXgsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZleCBzaGFwZSBjbGFzcy5cclxuICAgICAqIEBjbGFzcyBDb252ZXhcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZXJ0aWNlc10gQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciB2ZXJ0aWNlcyA9IFtbLTEsLTFdLCBbMSwtMV0sIFsxLDFdLCBbLTEsMV1dO1xyXG4gICAgICogICAgIHZhciBjb252ZXhTaGFwZSA9IG5ldyBDb252ZXgoe1xyXG4gICAgICogICAgICAgICB2ZXJ0aWNlczogdmVydGljZXNcclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29udmV4KHR5cGUsIHZlcnRpY2VzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB2b2lkIDAgPyB0eXBlIDogU2hhcGVfMS5kZWZhdWx0LkNPTlZFWCwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICAvLyBUT0RPOiB0aGlzIHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIEkgZGlkbid0IHVzZSBmbG9hdDMyYXJyYXlbXXMuIEp1c3QgY29udmVydCB0byBhIGJpZyBmbG9hdDMyYXJyYXkgd2l0aCBkb3VibGUgdGhlIHNpemUuXHJcbiAgICAgICAgLy8gTGV0J3MgZ2V0IHRoaXMgd29ya2luZyBmaXJzdCB0aGVuIHN3aXRjaCBpdC5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJ0aWNlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudmVydGljZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFZGdlIG5vcm1hbHMgZGVmaW5lZCBpbiB0aGUgbG9jYWwgZnJhbWUsIHBvaW50aW5nIG91dCBvZiB0aGUgc2hhcGUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IG5vcm1hbHNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubm9ybWFscyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy50cmlhbmdsZXMgPSBbXTtcclxuICAgICAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xyXG4gICAgICAgIHZhciBuZXdWZXJ0aWNlcyA9IHZlcnRpY2VzICE9PSBudWxsICYmIHZlcnRpY2VzICE9PSB2b2lkIDAgPyB2ZXJ0aWNlcyA6IFtdO1xyXG4gICAgICAgIF90aGlzLnZlcnRpY2VzID0gW107XHJcbiAgICAgICAgX3RoaXMubm9ybWFscyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX3RoaXMudmVydGljZXMucHVzaCh2ZWMyXzEuZGVmYXVsdC5jbG9uZShuZXdWZXJ0aWNlc1tpXSkpO1xyXG4gICAgICAgICAgICBfdGhpcy5ub3JtYWxzLnB1c2godmVjMl8xLmRlZmF1bHQuY3JlYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSBhcmUgY2FsbGVkIGluIHRoZSBzaGFwZSBjb25zdHJ1Y3RvciwgYnV0IG5lZWQgdG8gY2FsbCBhZ2FpbiBoZXJlIGJlY2F1c2UgdmVydHMgd2VyZW4ndCBzZXQgdXAgeWV0IVxyXG4gICAgICAgIF90aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlQXJlYSgpO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZU5vcm1hbHMoKTtcclxuICAgICAgICBfdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICBfdGhpcy50cmlhbmdsZXMgPSBbXTtcclxuICAgICAgICBpZiAoX3RoaXMudmVydGljZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgY29udmV4XHJcbiAgICAgICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcclxuICAgICAgICBfdGhpcy51cGRhdGVBcmVhKCk7XHJcbiAgICAgICAgaWYgKF90aGlzLmFyZWEgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnZleCB2ZXJ0aWNlcyBtdXN0IGJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIHdpbmRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBDb252ZXgucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgbm9ybWFscyA9IHRoaXMubm9ybWFscztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YXIgd29ybGRQb2ludDEgPSB2ZXJ0aWNlc1soaSArIDEpICUgdmVydGljZXMubGVuZ3RoXTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IG5vcm1hbHNbaV07XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcclxuICAgICAgICAgICAgLy8gR2V0IG5vcm1hbCAtIGp1c3Qgcm90YXRlIDkwIGRlZ3JlZXMgc2luY2UgdmVydGljZXMgYXJlIGdpdmVuIGluIENDV1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGU5MGN3KG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXHJcbiAgICAgKiBAbWV0aG9kIHByb2plY3RPbnRvQXhpc1xyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IG9mZnNldFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGxvY2FsQXhpc1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLnByb2plY3RPbnRvTG9jYWxBeGlzID0gZnVuY3Rpb24gKGxvY2FsQXhpcywgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIG1heCA9IC1JbmZpbml0eSwgbWluID0gSW5maW5pdHksIHYsIHZhbHVlLCBsb2NhbEF4aXMgPSB0bXBWZWMxO1xyXG4gICAgICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGRvdCh2LCBsb2NhbEF4aXMpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbiA+IG1heCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IG1pbjtcclxuICAgICAgICAgICAgbWluID0gbWF4O1xyXG4gICAgICAgICAgICBtYXggPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocmVzdWx0LCBtaW4sIG1heCk7XHJcbiAgICB9O1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS5Db252ZXhwcm9qZWN0T250b1dvcmxkQXhpcyA9IGZ1bmN0aW9uIChsb2NhbEF4aXMsIHNoYXBlT2Zmc2V0LCBzaGFwZUFuZ2xlLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLnByb2plY3RPbnRvTG9jYWxBeGlzKGxvY2FsQXhpcywgcmVzdWx0KTtcclxuICAgICAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XHJcbiAgICAgICAgaWYgKHNoYXBlQW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQucm90YXRlKHdvcmxkQXhpcywgbG9jYWxBeGlzLCBzaGFwZUFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdvcmxkQXhpcyA9IGxvY2FsQXhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvdChzaGFwZU9mZnNldCwgd29ybGRBeGlzKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocmVzdWx0LCByZXN1bHRbMF0gKyBvZmZzZXQsIHJlc3VsdFsxXSArIG9mZnNldCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIC50cmlhbmdsZXMgcHJvcGVydHlcclxuICAgICAqIEBtZXRob2QgdXBkYXRlVHJpYW5nbGVzXHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUudXBkYXRlVHJpYW5nbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpYW5nbGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gUmV3cml0ZSBvbiBwb2x5ayBub3RhdGlvbiwgYXJyYXkgb2YgbnVtYmVyc1xyXG4gICAgICAgIHZhciBwb2x5a1ZlcnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgcG9seWtWZXJ0cy5wdXNoKHZbMF0pO1xyXG4gICAgICAgICAgICBwb2x5a1ZlcnRzLnB1c2godlsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaWFuZ3VsYXRlXHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IHBvbHlrXzEuZGVmYXVsdC5Ucmlhbmd1bGF0ZShwb2x5a1ZlcnRzKTtcclxuICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHRyaWFuZ2xlcywgYWRkIHRoZWlyIGluZXJ0aWEgY29udHJpYnV0aW9ucyB0byBJXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgdmFyIGlkMSA9IHRyaWFuZ2xlc1tpXSwgaWQyID0gdHJpYW5nbGVzW2kgKyAxXSwgaWQzID0gdHJpYW5nbGVzW2kgKyAyXTtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICB2YXIgVCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICAgICAgICAgIFRbMF0gPSBpZDE7XHJcbiAgICAgICAgICAgIFRbMV0gPSBpZDI7XHJcbiAgICAgICAgICAgIFRbMl0gPSBpZDM7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGVzLnB1c2goVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSAuY2VudGVyT2ZNYXNzIHByb3BlcnR5LlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVDZW50ZXJPZk1hc3NcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS51cGRhdGVDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLCB2ZXJ0cyA9IHRoaXMudmVydGljZXMsIGNtID0gdGhpcy5jZW50ZXJPZk1hc3MsIGNlbnRyb2lkID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkLCBhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2EsIGIgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYiwgYyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jLCBjZW50cm9pZF90aW1lc19tYXNzID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3M7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGNtLCAwLCAwKTtcclxuICAgICAgICB2YXIgdG90YWxBcmVhID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdHJpYW5nbGVzW2ldLCBhID0gdmVydHNbdFswXV0sIGIgPSB2ZXJ0c1t0WzFdXSwgYyA9IHZlcnRzW3RbMl1dO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jZW50cm9pZChjZW50cm9pZCwgYSwgYiwgYyk7XHJcbiAgICAgICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84MDE5OC9hcmVhLW9mLXRyaWFuZ2xlLXZpYS12ZWN0b3JzXHJcbiAgICAgICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLCBiLCBjKTtcclxuICAgICAgICAgICAgdG90YWxBcmVhICs9IG07XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBjZW50ZXIgb2YgbWFzc1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShjZW50cm9pZF90aW1lc19tYXNzLCBjZW50cm9pZCwgbSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChjbSwgY20sIGNlbnRyb2lkX3RpbWVzX21hc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShjbSwgY20sIDEgLyB0b3RhbEFyZWEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENvbnZleC5cclxuICAgICAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICogQHNlZSBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzM0MjgyMi1tb21lbnQtb2YtaW5lcnRpYS1vZi1hLXBvbHlnb24tMmQvXHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVub20gPSAwLjAsIG51bWVyID0gMC4wLCBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IE4gLSAxLCBpID0gMDsgaSA8IE47IGogPSBpLCBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAwID0gdGhpcy52ZXJ0aWNlc1tqXTtcclxuICAgICAgICAgICAgdmFyIHAxID0gdGhpcy52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLmFicyh2ZWMyXzEuZGVmYXVsdC5jcm9zc0xlbmd0aChwMCwgcDEpKTtcclxuICAgICAgICAgICAgdmFyIGIgPSBkb3QocDEsIHAxKSArIGRvdChwMSwgcDApICsgZG90KHAwLCBwMCk7XHJcbiAgICAgICAgICAgIGRlbm9tICs9IGEgKiBiO1xyXG4gICAgICAgICAgICBudW1lciArPSBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKDEuMCAvIDYuMCkgKiAoZGVub20gLyBudW1lcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSAuYm91bmRpbmdSYWRpdXMgcHJvcGVydHlcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLCByMiA9IDA7XHJcbiAgICAgICAgaWYgKCF2ZXJ0cyB8fCB2ZXJ0cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHZlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsMiA9IHZlYzJfMS5kZWZhdWx0LnNxdWFyZWRMZW5ndGgodmVydHNbaV0pO1xyXG4gICAgICAgICAgICBpZiAobDIgPiByMikge1xyXG4gICAgICAgICAgICAgICAgcjIgPSBsMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHIyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ1JhZGl1cztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgcG9pbnRzIGEsIGIsIGMuIFRoZSBhcmVhIGlzIHBvc2l0aXZlIGlmIHRoZSBwb2ludHMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLCBvdGhlcndpc2UgbmVnYXRpdmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kIHRyaWFuZ2xlQXJlYVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY1xyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnRyaWFuZ2xlQXJlYSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkpIC0gKChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pKSkgKiAwLjU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIC5hcmVhXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUFyZWFcclxuICAgICAqL1xyXG4gICAgQ29udmV4LnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy52ZXJ0aWNlcylcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcclxuICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcywgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSB0cmlhbmdsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sIGEgPSB2ZXJ0c1t0WzBdXSwgYiA9IHZlcnRzW3RbMV1dLCBjID0gdmVydHNbdFsyXV07XHJcbiAgICAgICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXHJcbiAgICAgICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLCBiLCBjKTtcclxuICAgICAgICAgICAgdGhpcy5hcmVhICs9IG07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmFyZWE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXHJcbiAgICAgKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHRvZG86IGFwcHJveGltYXRlIHdpdGggYSBsb2NhbCBBQUJCP1xyXG4gICAgICovXHJcbiAgICBDb252ZXgucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIENvbnZleC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHJheVN0YXJ0ID0gaW50ZXJzZWN0Q29udmV4X3JheVN0YXJ0O1xyXG4gICAgICAgIHZhciByYXlFbmQgPSBpbnRlcnNlY3RDb252ZXhfcmF5RW5kO1xyXG4gICAgICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIHRvIGxvY2FsIHNoYXBlIHNwYWNlXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKHJheVN0YXJ0LCByYXkuZnJvbSwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUocmF5RW5kLCByYXkudG8sIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgdmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICYmICFyZXN1bHQuc2hvdWxkU3RvcChyYXkpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHExID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBxMiA9IHZlcnRpY2VzWyhpICsgMSkgJSBuXTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gdmVjMl8xLmRlZmF1bHQuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24ocmF5U3RhcnQsIHJheUVuZCwgcTEsIHEyKTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgcTIsIHExKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgLU1hdGguUEkgLyAyICsgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb252ZXgucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHIwID0gcGljX3IwLCByMSA9IHBpY19yMSwgdmVydHMgPSB0aGlzLnZlcnRpY2VzLCBsYXN0Q3Jvc3MgPSBudWxsLCBudW1WZXJ0cyA9IHZlcnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZlcnRzICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2MCA9IHZlcnRzW2kgJSBudW1WZXJ0c10sIHYxID0gdmVydHNbKGkgKyAxKSAlIG51bVZlcnRzXTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocjAsIHYwLCBsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocjEsIHYxLCBsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgdmFyIGNyb3NzID0gdmVjMl8xLmRlZmF1bHQuY3Jvc3NMZW5ndGgocjAsIHIxKTtcclxuICAgICAgICAgICAgaWYgKGxhc3RDcm9zcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgZ290IGEgZGlmZmVyZW50IHNpZ24gb2YgdGhlIGRpc3RhbmNlIHZlY3RvciwgdGhlIHBvaW50IGlzIG91dCBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgICAgICBpZiAoY3Jvc3MgKiBsYXN0Q3Jvc3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb252ZXg7XHJcbn0oU2hhcGVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbnZleDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIFNoYXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMuIE5vdCB0byBiZSB1c2VkIGRpcmVjdGx5LlxyXG4gICAgICogQGNsYXNzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0wXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0xXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmlkXSBPcHRpb25hbCAtIHNwZWNpZnkgYW4gSUQgZm9yIHRoaXMgc2hhcGUuIFBvc3NpYmx5IHVzZWZ1bCBmb3IgcmVwbGFjaW5nIHNoYXBlcy4gQ2FyZWZ1bCB0byBhdm9pZCBkdXBsaWNhdGVzIVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZT10cnVlXVxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gW29wdGlvbnMubWF0ZXJpYWw9bnVsbF1cclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnBvc2l0aW9uXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5zb3I9ZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMudHlwZT0wXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTaGFwZSh0eXBlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQm9keS1sb2NhbCBwb3NpdGlvbiBvZiB0aGUgc2hhcGUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gcG9zaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQm9keS1sb2NhbCBhbmdsZSBvZiB0aGUgc2hhcGUuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlLiBPbmUgb2Y6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiA8dWw+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0NJUkNMRVwiPlNoYXBlLkNJUkNMRTwvYT48L2xpPlxyXG4gICAgICAgICAqIDxsaT48YSBocmVmPVwiU2hhcGUuaHRtbCNwcm9wZXJ0eV9QQVJUSUNMRVwiPlNoYXBlLlBBUlRJQ0xFPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X1BMQU5FXCI+U2hhcGUuUExBTkU8L2E+PC9saT5cclxuICAgICAgICAgKiA8bGk+PGEgaHJlZj1cIlNoYXBlLmh0bWwjcHJvcGVydHlfQ09OVkVYXCI+U2hhcGUuQ09OVkVYPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0xJTkVcIj5TaGFwZS5MSU5FPC9hPjwvbGk+XHJcbiAgICAgICAgICogPGxpPjxhIGhyZWY9XCJTaGFwZS5odG1sI3Byb3BlcnR5X0JPWFwiPlNoYXBlLkJPWDwvYT48L2xpPlxyXG4gICAgICAgICAqIDxsaT48YSBocmVmPVwiU2hhcGUuaHRtbCNwcm9wZXJ0eV9DQVBTVUxFXCI+U2hhcGUuQ0FQU1VMRTwvYT48L2xpPlxyXG4gICAgICAgICAqIDxsaT48YSBocmVmPVwiU2hhcGUuaHRtbCNwcm9wZXJ0eV9IRUlHSFRGSUVMRFwiPlNoYXBlLkhFSUdIVEZJRUxEPC9hPjwvbGk+XHJcbiAgICAgICAgICogPC91bD5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaGFwZSBvYmplY3QgaWRlbnRpZmllci4gUmVhZCBvbmx5LlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQHByb3BlcnR5IGlkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQm91bmRpbmcgY2lyY2xlIHJhZGl1cyBvZiB0aGlzIHNoYXBlXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsaXNpb24gZ3JvdXAgdGhhdCB0aGlzIHNoYXBlIGJlbG9uZ3MgdG8gKGJpdCBtYXNrKS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmF1cmVsaWVucmlib24uY29tL2Jsb2cvMjAxMS8wNy9ib3gyZC10dXRvcmlhbC1jb2xsaXNpb24tZmlsdGVyaW5nL1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25Hcm91cFxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgLy8gU2V0dXAgYml0cyBmb3IgZWFjaCBhdmFpbGFibGUgZ3JvdXBcclxuICAgICAgICAgKiAgICAgdmFyIFBMQVlFUiA9IE1hdGgucG93KDIsMCksXHJcbiAgICAgICAgICogICAgICAgICBFTkVNWSA9ICBNYXRoLnBvdygyLDEpLFxyXG4gICAgICAgICAqICAgICAgICAgR1JPVU5EID0gTWF0aC5wb3coMiwyKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIFB1dCBzaGFwZXMgaW50byB0aGVpciBncm91cHNcclxuICAgICAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xyXG4gICAgICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XHJcbiAgICAgICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25Hcm91cCA9IEVORU1ZO1xyXG4gICAgICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uR3JvdXAgPSBHUk9VTkQ7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gQXNzaWduIGdyb3VwcyB0aGF0IGVhY2ggc2hhcGUgY29sbGlkZSB3aXRoLlxyXG4gICAgICAgICAqICAgICAvLyBOb3RlIHRoYXQgdGhlIHBsYXllcnMgY2FuIGNvbGxpZGUgd2l0aCBncm91bmQgYW5kIGVuZW1pZXMsIGJ1dCBub3Qgd2l0aCBvdGhlciBwbGF5ZXJzLlxyXG4gICAgICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xyXG4gICAgICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xyXG4gICAgICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEdST1VORDtcclxuICAgICAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBFTkVNWTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgIC8vIEhvdyBjb2xsaXNpb24gY2hlY2sgaXMgZG9uZVxyXG4gICAgICAgICAqICAgICBpZihzaGFwZUEuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUIuY29sbGlzaW9uTWFzaykhPTAgJiYgKHNoYXBlQi5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQS5jb2xsaXNpb25NYXNrKSE9MCl7XHJcbiAgICAgICAgICogICAgICAgICAvLyBUaGUgc2hhcGVzIHdpbGwgY29sbGlkZVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJlYSBvZiB0aGlzIHNoYXBlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhcmVhXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFyZWEgPSAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY29weSh0aGlzLnBvc2l0aW9uLCBvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmdsZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuaWQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICsrU2hhcGUuaWRDb3VudGVyO1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29sbGlzaW9uR3JvdXApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDE7XHJcbiAgICAgICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29sbGlzaW9uTWFzaykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hdGVyaWFsO1xyXG4gICAgICAgIHRoaXMuc2Vuc29yID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlbnNvcikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXJlYSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgc2hhcGUuXHJcbiAgICAgKiBAbWV0aG9kIHBvaW50VGVzdFxyXG4gICAgICogQHBhcmFtIHthcnJheX0gbG9jYWxQb2ludFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgU2hhcGUucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgc2hhcGUgc3BhY2UgKGFzc3VtZWQgdGhlIHNoYXBlIGlzIHRyYW5zZm9ybWVkIGJ5IGJvdGggaXRzZWxmIGFuZCB0aGUgYm9keSkuXHJcbiAgICAgKiBAbWV0aG9kIHdvcmxkUG9pbnRUb0xvY2FsXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBvdXRcclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHdvcmxkUG9pbnRcclxuICAgICAqL1xyXG4gICAgU2hhcGUucHJvdG90eXBlLndvcmxkUG9pbnRUb0xvY2FsID0gZnVuY3Rpb24gKG91dCwgd29ybGRQb2ludCkge1xyXG4gICAgICAgIHZhciBzaGFwZVdvcmxkUG9zaXRpb24gPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcclxuICAgICAgICBpZiAoIWJvZHkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUoc2hhcGVXb3JsZFBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoc2hhcGVXb3JsZFBvc2l0aW9uLCBzaGFwZVdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvTG9jYWxGcmFtZShvdXQsIHdvcmxkUG9pbnQsIHNoYXBlV29ybGRQb3NpdGlvbiwgYm9keS5hbmdsZSArIHRoaXMuYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIFNoYXBlLmlkQ291bnRlciA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDSVJDTEVcclxuICAgICAqL1xyXG4gICAgU2hhcGUuQ0lSQ0xFID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFBBUlRJQ0xFXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLlBBUlRJQ0xFID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFBMQU5FXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLlBMQU5FID0gNDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IENPTlZFWFxyXG4gICAgICovXHJcbiAgICBTaGFwZS5DT05WRVggPSA4O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gTElORVxyXG4gICAgICovXHJcbiAgICBTaGFwZS5MSU5FID0gMTY7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1hcclxuICAgICAqL1xyXG4gICAgU2hhcGUuQk9YID0gMzI7XHJcbiAgICAvKipcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDQVBTVUxFXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkNBUFNVTEUgPSA2NDtcclxuICAgIC8qKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IEhFSUdIVEZJRUxEXHJcbiAgICAgKi9cclxuICAgIFNoYXBlLkhFSUdIVEZJRUxEID0gMTI4O1xyXG4gICAgcmV0dXJuIFNoYXBlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTaGFwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICBzaGFsbG93Q2xvbmUgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLnNoYWxsb3dDbG9uZVxyXG4vLyAsICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgdXRpbHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHNcIikpO1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZVwiKSk7XHJcbnZhciBzaGFsbG93Q2xvbmUgPSB1dGlsc18xLmRlZmF1bHQuc2hhbGxvd0Nsb25lO1xyXG5mdW5jdGlvbiBib3hJKHcsIGgpIHtcclxuICAgIHJldHVybiB3ICogaCAqIChNYXRoLnBvdyh3LCAyKSArIE1hdGgucG93KGgsIDIpKSAvIDEyO1xyXG59XHJcbmZ1bmN0aW9uIHNlbWlBKHIpIHtcclxuICAgIHJldHVybiBNYXRoLlBJICogTWF0aC5wb3cociwgMikgLyAyO1xyXG59XHJcbi8vIGh0dHA6Ly93d3cuZWZ1bmRhLmNvbS9tYXRoL2FyZWFzL0NpcmNsZUhhbGYuY2ZtXHJcbmZ1bmN0aW9uIHNlbWlJKHIpIHtcclxuICAgIHJldHVybiAoKE1hdGguUEkgLyA0KSAtICg4IC8gKDkgKiBNYXRoLlBJKSkpICogTWF0aC5wb3cociwgNCk7XHJcbn1cclxuZnVuY3Rpb24gc2VtaUMocikge1xyXG4gICAgcmV0dXJuICg0ICogcikgLyAoMyAqIE1hdGguUEkpO1xyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NlY29uZF9tb21lbnRfb2ZfYXJlYSNQYXJhbGxlbF9heGlzX3RoZW9yZW1cclxuZnVuY3Rpb24gY2Fwc3VsZUEobCwgcikge1xyXG4gICAgcmV0dXJuIGwgKiAyICogciArIE1hdGguUEkgKiBNYXRoLnBvdyhyLCAyKTtcclxufVxyXG5mdW5jdGlvbiBjYXBzdWxlSShsLCByKSB7XHJcbiAgICB2YXIgZCA9IGwgLyAyICsgc2VtaUMocik7XHJcbiAgICByZXR1cm4gYm94SShsLCAyICogcikgKyAyICogKHNlbWlJKHIpICsgc2VtaUEocikgKiBNYXRoLnBvdyhkLCAyKSk7XHJcbn1cclxudmFyIGludGVyc2VjdENhcHN1bGVfaGl0UG9pbnRXb3JsZCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENhcHN1bGVfbDAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENhcHN1bGVfbDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdENhcHN1bGVfdW5pdF95ID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIENhcHN1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2Fwc3VsZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2Fwc3VsZSBzaGFwZS5cclxuICAgICAqIEBjbGFzcyBDYXBzdWxlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0xXSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50cywgZXh0ZW5kcyBhbG9uZyB0aGUgWCBheGlzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXSBSYWRpdXMgb2YgdGhlIGNhcHN1bGUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHZhciBjYXBzdWxlU2hhcGUgPSBuZXcgQ2Fwc3VsZSh7XHJcbiAgICAgKiAgICAgICAgIGxlbmd0aDogMSxcclxuICAgICAqICAgICAgICAgcmFkaXVzOiAyXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShjYXBzdWxlU2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDYXBzdWxlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlXzEuZGVmYXVsdC5DQVBTVUxFLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlbmd0aCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgX3RoaXMucmFkaXVzID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJhZGl1cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIG1hc3MgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENhcHN1bGUuXHJcbiAgICAgKiBAbWV0aG9kIGNvbnB1dGVNb21lbnRPZkluZXJ0aWFcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqIEB0b2RvXHJcbiAgICAgKi9cclxuICAgIENhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gaHR0cDovL3d3dy5lZnVuZGEuY29tL21hdGgvYXJlYXMvcmVjdGFuZ2xlLmNmbVxyXG4gICAgICAgIHZhciByID0gdGhpcy5yYWRpdXMsIGwgPSB0aGlzLmxlbmd0aCwgYXJlYSA9IGNhcHN1bGVBKGwsIHIpO1xyXG4gICAgICAgIHJldHVybiAoYXJlYSA+IDApID8gY2Fwc3VsZUkobCwgcikgLyBhcmVhIDogMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcclxuICAgICAqL1xyXG4gICAgQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMucmFkaXVzICsgdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVBcmVhXHJcbiAgICAgKi9cclxuICAgIENhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKyB0aGlzLnJhZGl1cyAqIDIgKiB0aGlzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIENhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHIgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBjZW50ZXIgcG9zaXRpb24gb2Ygb25lIG9mIHRoZSB0aGUgY2lyY2xlcywgd29ybGQgb3JpZW50ZWQsIGJ1dCB3aXRoIGxvY2FsIG9mZnNldFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChyLCB0aGlzLmxlbmd0aCAvIDIsIDApO1xyXG4gICAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUociwgciwgYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgYm91bmRzXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KG91dC51cHBlckJvdW5kLCBNYXRoLm1heChyWzBdICsgcmFkaXVzLCAtclswXSArIHJhZGl1cyksIE1hdGgubWF4KHJbMV0gKyByYWRpdXMsIC1yWzFdICsgcmFkaXVzKSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KG91dC5sb3dlckJvdW5kLCBNYXRoLm1pbihyWzBdIC0gcmFkaXVzLCAtclswXSAtIHJhZGl1cyksIE1hdGgubWluKHJbMV0gLSByYWRpdXMsIC1yWzFdIC0gcmFkaXVzKSk7XHJcbiAgICAgICAgLy8gQWRkIG9mZnNldFxyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBDYXBzdWxlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xyXG4gICAgICAgIHZhciB0byA9IHJheS50bztcclxuICAgICAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IGludGVyc2VjdENhcHN1bGVfaGl0UG9pbnRXb3JsZDtcclxuICAgICAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q2Fwc3VsZV9ub3JtYWw7XHJcbiAgICAgICAgdmFyIGwwID0gaW50ZXJzZWN0Q2Fwc3VsZV9sMDtcclxuICAgICAgICB2YXIgbDEgPSBpbnRlcnNlY3RDYXBzdWxlX2wxO1xyXG4gICAgICAgIC8vIFRoZSBzaWRlc1xyXG4gICAgICAgIHZhciBoYWxmTGVuID0gdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGdldCBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXHJcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5yYWRpdXMgKiAoaSAqIDIgLSAxKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KGwwLCAtaGFsZkxlbiwgeSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChsMSwgaGFsZkxlbiwgeSk7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnRvR2xvYmFsRnJhbWUobDAsIGwwLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKGwxLCBsMSwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gdmVjMl8xLmRlZmF1bHQuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24oZnJvbSwgdG8sIGwwLCBsMSk7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobm9ybWFsLCBpbnRlcnNlY3RDYXBzdWxlX3VuaXRfeSwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2NhbGUobm9ybWFsLCBub3JtYWwsIChpICogMiAtIDEpKTtcclxuICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNob3VsZFN0b3AocmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaXJjbGVzXHJcbiAgICAgICAgdmFyIGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCA9IE1hdGgucG93KHRoaXMucmFkaXVzLCAyKSArIE1hdGgucG93KGhhbGZMZW4sIDIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChsMCwgaGFsZkxlbiAqIChpICogMiAtIDEpLCAwKTtcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShsMCwgbDAsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XHJcbiAgICAgICAgICAgIHZhciBiID0gMiAqICgodG9bMF0gLSBmcm9tWzBdKSAqIChmcm9tWzBdIC0gbDBbMF0pICsgKHRvWzFdIC0gZnJvbVsxXSkgKiAoZnJvbVsxXSAtIGwwWzFdKSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5wb3coZnJvbVswXSAtIGwwWzBdLCAyKSArIE1hdGgucG93KGZyb21bMV0gLSBsMFsxXSwgMikgLSBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMik7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKGhpdFBvaW50V29ybGQsIHBvc2l0aW9uKSA+IGRpYWdvbmFsTGVuZ3RoU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgbDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNob3VsZFN0b3AocmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcclxuICAgICAgICAgICAgICAgIHZhciBkMSA9ICgtYiAtIHNxcnREZWx0YSkgKiBpbnYyYTtcclxuICAgICAgICAgICAgICAgIHZhciBkMiA9ICgtYiArIHNxcnREZWx0YSkgKiBpbnYyYTtcclxuICAgICAgICAgICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShoaXRQb2ludFdvcmxkLCBwb3NpdGlvbikgPiBkaWFnb25hbExlbmd0aFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3Qobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0Lm5vcm1hbGl6ZShub3JtYWwsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMSwgbm9ybWFsLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZDIgPj0gMCAmJiBkMiA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubGVycChoaXRQb2ludFdvcmxkLCBmcm9tLCB0bywgZDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZWMyXzEuZGVmYXVsdC5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgbDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDIsIG5vcm1hbCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNob3VsZFN0b3AocmF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcHN1bGUucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0gdGhpcy5sZW5ndGggKiAwLjU7XHJcbiAgICAgICAgaWYgKChNYXRoLmFicyhsb2NhbFBvaW50WzBdKSA8PSBoYWxmTGVuZ3RoICYmIE1hdGguYWJzKGxvY2FsUG9pbnRbMV0pIDw9IHJhZGl1cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnBvdyhsb2NhbFBvaW50WzBdIC0gaGFsZkxlbmd0aCwgMikgKyBNYXRoLnBvdyhsb2NhbFBvaW50WzFdLCAyKSA8PSByYWRpdXMgKiByYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLnBvdyhsb2NhbFBvaW50WzBdICsgaGFsZkxlbmd0aCwgMikgKyBNYXRoLnBvdyhsb2NhbFBvaW50WzFdLCAyKSA8PSByYWRpdXMgKiByYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2Fwc3VsZTtcclxufShzaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ2Fwc3VsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gdmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXHJcbi8vICwgICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXHJcbi8vICwgICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmU7XHJcbnZhciBTaGFwZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1NoYXBlXCIpKTtcclxudmFyIHZlYzJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0aC92ZWMyXCIpKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX3dvcmxkTm9ybWFsID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMCA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsRnJvbSA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxUbyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgSGVpZ2h0ZmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSGVpZ2h0ZmllbGQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBkaXN0YW5jZSBcImVsZW1lbnRXaWR0aFwiLlxyXG4gICAgICogQGNsYXNzIEhlaWdodGZpZWxkXHJcbiAgICAgKiBAZXh0ZW5kcyBTaGFwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuaGVpZ2h0c10gQW4gYXJyYXkgb2YgWSB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSB0ZXJyYWluLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50V2lkdGg9MC4xXSBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgLy8gR2VuZXJhdGUgc29tZSBoZWlnaHQgZGF0YSAoeS12YWx1ZXMpLlxyXG4gICAgICogICAgIHZhciBoZWlnaHRzID0gW107XHJcbiAgICAgKiAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKyl7XHJcbiAgICAgKiAgICAgICAgIHZhciB5ID0gMC41ICogTWF0aC5jb3MoMC4yICogaSk7XHJcbiAgICAgKiAgICAgICAgIGhlaWdodHMucHVzaCh5KTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGVcclxuICAgICAqICAgICB2YXIgc2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoe1xyXG4gICAgICogICAgICAgICBoZWlnaHRzOiBoZWlnaHRzLFxyXG4gICAgICogICAgICAgICBlbGVtZW50V2lkdGg6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb25cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBAdG9kbyBTaG91bGQgdXNlIGEgc2NhbGUgcHJvcGVydHkgd2l0aCBYIGFuZCBZIGRpcmVjdGlvbiBpbnN0ZWFkIG9mIGp1c3QgZWxlbWVudFdpZHRoXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEhlaWdodGZpZWxkKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgU2hhcGVfMS5kZWZhdWx0LkhFSUdIVEZJRUxELCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGhlaWdodCB2YWx1ZXMsIHRoYXQgYXJlIHNwcmVhZCBvdXQgYWxvbmcgdGhlIHggYXhpcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge2FycmF5fSBoZWlnaHRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuaGVpZ2h0cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgaGVpZ2h0c1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhWYWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLm1heFZhbHVlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGhlaWdodHNcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5taW5WYWx1ZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50V2lkdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5lbGVtZW50V2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmhlaWdodHMgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodHMpID8gb3B0aW9ucy5oZWlnaHRzLnNsaWNlKDApIDogW107XHJcbiAgICAgICAgX3RoaXMuZWxlbWVudFdpZHRoID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVsZW1lbnRXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC4xO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZUFyZWEoKTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhWYWx1ZSkgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgX3RoaXMubWF4VmFsdWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4VmFsdWU7XHJcbiAgICAgICAgICAgIF90aGlzLm1pblZhbHVlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pblZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZU1heE1pblZhbHVlcygpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSAubWluVmFsdWUgYW5kIHRoZSAubWF4VmFsdWVcclxuICAgICAqIEBtZXRob2QgdXBkYXRlTWF4TWluVmFsdWVzXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVNYXhNaW5WYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHM7XHJcbiAgICAgICAgdmFyIG1heFZhbHVlID0gZGF0YVswXTtcclxuICAgICAgICB2YXIgbWluVmFsdWUgPSBkYXRhWzBdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKHYgPiBtYXhWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2IDwgbWluVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1heFZhbHVlID0gbWF4VmFsdWU7XHJcbiAgICAgICAgdGhpcy5taW5WYWx1ZSA9IG1pblZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH07XHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IEluZmluaXR5O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5oZWlnaHRzLCBhcmVhID0gMDtcclxuICAgICAgICBpZiAoIWRhdGEpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgYXJlYSArPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdKSAvIDIgKiB0aGlzLmVsZW1lbnRXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcmVhID0gYXJlYTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSxcclxuICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCksXHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocG9pbnRzWzBdLCAwLCB0aGlzLm1heFZhbHVlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocG9pbnRzWzFdLCB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuaGVpZ2h0cy5sZW5ndGgsIHRoaXMubWF4VmFsdWUpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMl0sIHRoaXMuZWxlbWVudFdpZHRoICogdGhpcy5oZWlnaHRzLmxlbmd0aCwgdGhpcy5taW5WYWx1ZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc2V0KHBvaW50c1szXSwgMCwgdGhpcy5taW5WYWx1ZSk7XHJcbiAgICAgICAgb3V0LnNldEZyb21Qb2ludHMocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbGluZSBzZWdtZW50IGluIHRoZSBoZWlnaHRmaWVsZFxyXG4gICAgICogQG1ldGhvZCBnZXRMaW5lU2VnbWVudFxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHN0YXJ0IFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc3RhcnQgcG9pbnRcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBlbmQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBlbmQgcG9pbnRcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gaVxyXG4gICAgICovXHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgaSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5oZWlnaHRzO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZWxlbWVudFdpZHRoO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChzdGFydCwgaSAqIHdpZHRoLCBkYXRhW2ldKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQoZW5kLCAoaSArIDEpICogd2lkdGgsIGRhdGFbaSArIDFdKTtcclxuICAgIH07XHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocG9zaXRpb25bMF0gLyB0aGlzLmVsZW1lbnRXaWR0aCk7XHJcbiAgICB9O1xyXG4gICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENsYW1wZWRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0U2VnbWVudEluZGV4KHBvc2l0aW9uKTtcclxuICAgICAgICBpID0gTWF0aC5taW4odGhpcy5oZWlnaHRzLmxlbmd0aCwgTWF0aC5tYXgoaSwgMCkpOyAvLyBjbGFtcFxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCByYXljYXN0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICovXHJcbiAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGZyb20gPSByYXkuZnJvbTtcclxuICAgICAgICB2YXIgdG8gPSByYXkudG87XHJcbiAgICAgICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfd29ybGROb3JtYWw7XHJcbiAgICAgICAgdmFyIGwwID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDA7XHJcbiAgICAgICAgdmFyIGwxID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbDE7XHJcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsRnJvbTtcclxuICAgICAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsVG87XHJcbiAgICAgICAgLy8gZ2V0IGxvY2FsIHJheSBzdGFydCBhbmQgZW5kXHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9Mb2NhbEZyYW1lKGxvY2FsRnJvbSwgZnJvbSwgcG9zaXRpb24sIGFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC50b0xvY2FsRnJhbWUobG9jYWxUbywgdG8sIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBzZWdtZW50IHJhbmdlXHJcbiAgICAgICAgdmFyIGkwID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsRnJvbSk7XHJcbiAgICAgICAgdmFyIGkxID0gdGhpcy5nZXRDbGFtcGVkU2VnbWVudEluZGV4KGxvY2FsVG8pO1xyXG4gICAgICAgIGlmIChpMCA+IGkxKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBpMDtcclxuICAgICAgICAgICAgaTAgPSBpMTtcclxuICAgICAgICAgICAgaTEgPSB0bXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBzZWdtZW50c1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oZWlnaHRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdldExpbmVTZWdtZW50KGwwLCBsMSwgaSk7XHJcbiAgICAgICAgICAgIHZhciB0ID0gdmVjMl8xLmRlZmF1bHQuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24obG9jYWxGcm9tLCBsb2NhbFRvLCBsMCwgbDEpO1xyXG4gICAgICAgICAgICBpZiAodCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdCh3b3JsZE5vcm1hbCwgbDEsIGwwKTtcclxuICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIGFuZ2xlICsgTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubm9ybWFsaXplKHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgdCwgd29ybGROb3JtYWwsIC0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2hvdWxkU3RvcChyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBIZWlnaHRmaWVsZDtcclxufShTaGFwZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGVpZ2h0ZmllbGQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxyXG4vLyAsICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmVcclxuLy8gLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcclxudmFyIFNoYXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhcGVcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgcmF5Y2FzdF9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJheWNhc3RfbDAgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJheWNhc3RfbDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIHJheWNhc3RfdW5pdF95ID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAxKTtcclxudmFyIExpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGluZSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogTGluZSBzaGFwZSBjbGFzcy4gVGhlIGxpbmUgc2hhcGUgaXMgYWxvbmcgdGhlIHggZGlyZWN0aW9uLCBhbmQgc3RyZXRjaGVzIGZyb20gWy1sZW5ndGgvMiwgMF0gdG8gW2xlbmd0aC8yLDBdLlxyXG4gICAgICogQGNsYXNzIExpbmVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVuZ3RoPTFdIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGxpbmVcclxuICAgICAqIEBleHRlbmRzIFNoYXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICogICAgIHZhciBsaW5lU2hhcGUgPSBuZXcgTGluZSh7XHJcbiAgICAgKiAgICAgICAgIGxlbmd0aDogMVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUobGluZVNoYXBlKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTGluZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNoYXBlXzEuZGVmYXVsdC5MSU5FLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoXHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxlbmd0aCA9IDE7XHJcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMaW5lLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh0aGlzLmxlbmd0aCwgMikgLyAxMjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBMaW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIExpbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFt2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCldO1xyXG4gICAgICAgIHZhciBsMiA9IHRoaXMubGVuZ3RoIC8gMjtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQocG9pbnRzWzBdLCAtbDIsIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChwb2ludHNbMV0sIGwyLCAwKTtcclxuICAgICAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMsIHBvc2l0aW9uLCBhbmdsZSwgMCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgTGluZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmF5Y2FzdFxyXG4gICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIExpbmUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciBmcm9tID0gcmF5LmZyb207XHJcbiAgICAgICAgdmFyIHRvID0gcmF5LnRvO1xyXG4gICAgICAgIHZhciBsMCA9IHJheWNhc3RfbDA7XHJcbiAgICAgICAgdmFyIGwxID0gcmF5Y2FzdF9sMTtcclxuICAgICAgICAvLyBnZXQgc3RhcnQgYW5kIGVuZCBvZiB0aGUgbGluZVxyXG4gICAgICAgIHZhciBoYWxmTGVuID0gdGhpcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChsMCwgLWhhbGZMZW4sIDApO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnNldChsMSwgaGFsZkxlbiwgMCk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShsMCwgbDAsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQudG9HbG9iYWxGcmFtZShsMSwgbDEsIHBvc2l0aW9uLCBhbmdsZSk7XHJcbiAgICAgICAgdmFyIGZyYWN0aW9uID0gdmVjMl8xLmRlZmF1bHQuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24obDAsIGwxLCBmcm9tLCB0byk7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDApIHtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHJheWNhc3Rfbm9ybWFsO1xyXG4gICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobm9ybWFsLCByYXljYXN0X3VuaXRfeSwgYW5nbGUpOyAvLyB0b2RvOiB0aGlzIHNob3VsZCBkZXBlbmQgb24gd2hpY2ggc2lkZSB0aGUgcmF5IGNvbWVzIGZyb21cclxuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGZyYWN0aW9uLCBub3JtYWwsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIExpbmU7XHJcbn0oU2hhcGVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpbmU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxyXG4vLyAsICAgc2hhbGxvd0Nsb25lID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKS5zaGFsbG93Q2xvbmVcclxuLy8gLCAgIGNvcHkgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKS5jb3B5O1xyXG52YXIgU2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBjb3B5ID0gdmVjMl8xLmRlZmF1bHQuY29weTtcclxudmFyIFBhcnRpY2xlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhcnRpY2xlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJ0aWNsZSBzaGFwZSBjbGFzcy5cclxuICAgICAqIEBjbGFzcyBQYXJ0aWNsZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICogICAgIHZhciBzaGFwZSA9IG5ldyBQYXJ0aWNsZSgpO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQYXJ0aWNsZShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFNoYXBlXzEuZGVmYXVsdC5QQVJUSUNMRSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAwOyAvLyBDYW4ndCByb3RhdGUgYSBwYXJ0aWNsZVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBQYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY29tcHV0ZUFBQkJcclxuICAgICAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIFBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uIChvdXQsIHBvc2l0aW9uIC8qLCBhbmdsZSovKSB7XHJcbiAgICAgICAgY29weShvdXQubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xyXG4gICAgICAgIGNvcHkob3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBQYXJ0aWNsZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKSB7IDE7IH07XHJcbiAgICByZXR1cm4gUGFydGljbGU7XHJcbn0oU2hhcGVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBhcnRpY2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zaGFwZVwiKSk7XHJcbnZhciB2ZWMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL21hdGgvdmVjMlwiKSk7XHJcbnZhciBpbnRlcnNlY3RQbGFuZV9wbGFuZVBvaW50VG9Gcm9tID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbnZhciBpbnRlcnNlY3RQbGFuZV9ub3JtYWwgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKTtcclxudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG52YXIgUGxhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGxhbmUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIFBsYW5lIHNoYXBlIGNsYXNzLiBUaGUgcGxhbmUgaXMgZmFjaW5nIGluIHRoZSBZIGRpcmVjdGlvbi5cclxuICAgICAqIEBjbGFzcyBQbGFuZVxyXG4gICAgICogQGV4dGVuZHMgU2hhcGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICogICAgIHZhciBzaGFwZSA9IG5ldyBQbGFuZSgpO1xyXG4gICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQbGFuZShvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlXzEuZGVmYXVsdC5QTEFORSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXHJcbiAgICAgKi9cclxuICAgIFBsYW5lLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIFBsYW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gSW5maW5pdHk7XHJcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjb21wdXRlQUFCQlxyXG4gICAgICogQHBhcmFtICB7QUFCQn0gICBvdXRcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcclxuICAgICAqL1xyXG4gICAgUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKG91dCwgcG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGEgPSBhbmdsZSAlICgyICogTWF0aC5QSSk7XHJcbiAgICAgICAgdmFyIHNldCA9IHZlYzJfMS5kZWZhdWx0LnNldDtcclxuICAgICAgICB2YXIgbWF4ID0gMWU3O1xyXG4gICAgICAgIHZhciBsb3dlckJvdW5kID0gb3V0Lmxvd2VyQm91bmQ7XHJcbiAgICAgICAgdmFyIHVwcGVyQm91bmQgPSBvdXQudXBwZXJCb3VuZDtcclxuICAgICAgICAvLyBTZXQgbWF4IGJvdW5kc1xyXG4gICAgICAgIHNldChsb3dlckJvdW5kLCAtbWF4LCAtbWF4KTtcclxuICAgICAgICBzZXQodXBwZXJCb3VuZCwgbWF4LCBtYXgpO1xyXG4gICAgICAgIGlmIChhID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHkgZ29lcyBmcm9tIC1pbmYgdG8gMFxyXG4gICAgICAgICAgICB1cHBlckJvdW5kWzFdID0gcG9zaXRpb25bMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGEgPT09IE1hdGguUEkgLyAyKSB7XHJcbiAgICAgICAgICAgIC8vIHggZ29lcyBmcm9tIDAgdG8gaW5mXHJcbiAgICAgICAgICAgIGxvd2VyQm91bmRbMF0gPSBwb3NpdGlvblswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gTWF0aC5QSSkge1xyXG4gICAgICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxyXG4gICAgICAgICAgICBsb3dlckJvdW5kWzFdID0gcG9zaXRpb25bMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGEgPT09IDMgKiBNYXRoLlBJIC8gMikge1xyXG4gICAgICAgICAgICAvLyB4IGdvZXMgZnJvbSAtaW5mIHRvIDBcclxuICAgICAgICAgICAgdXBwZXJCb3VuZFswXSA9IHBvc2l0aW9uWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQbGFuZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWEgPSBJbmZpbml0eTtcclxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheVJlc3VsdH0gcmVzdWx0XHJcbiAgICAgKiBAcGFyYW0gIHtSYXl9IHJheVxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIFBsYW5lLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24gKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xyXG4gICAgICAgIHZhciB0byA9IHJheS50bztcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgcGxhbmVQb2ludFRvRnJvbSA9IGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb207XHJcbiAgICAgICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdFBsYW5lX25vcm1hbDtcclxuICAgICAgICB2YXIgbGVuID0gaW50ZXJzZWN0UGxhbmVfbGVuO1xyXG4gICAgICAgIC8vIEdldCBwbGFuZSBub3JtYWxcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zZXQobm9ybWFsLCAwLCAxKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5yb3RhdGUobm9ybWFsLCBub3JtYWwsIGFuZ2xlKTtcclxuICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zdWJ0cmFjdChsZW4sIGZyb20sIHBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgcGxhbmVUb0Zyb20gPSB2ZWMyXzEuZGVmYXVsdC5kb3QobGVuLCBub3JtYWwpO1xyXG4gICAgICAgIHZlYzJfMS5kZWZhdWx0LnN1YnRyYWN0KGxlbiwgdG8sIHBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgcGxhbmVUb1RvID0gdmVjMl8xLmRlZmF1bHQuZG90KGxlbiwgbm9ybWFsKTtcclxuICAgICAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlYzJfMS5kZWZhdWx0LnNxdWFyZWREaXN0YW5jZShmcm9tLCB0bykgPCBwbGFuZVRvRnJvbSAqIHBsYW5lVG9Gcm9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5fZG90X2RpciA9IHZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgdmVjMl8xLmRlZmF1bHQuc3VidHJhY3QocGxhbmVQb2ludFRvRnJvbSwgZnJvbSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHZhciB0ID0gLXZlYzJfMS5kZWZhdWx0LmRvdChub3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyIC8gcmF5Lmxlbmd0aDtcclxuICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgdCwgbm9ybWFsLCAtMSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgUGxhbmUucHJvdG90eXBlLnBvaW50VGVzdCA9IGZ1bmN0aW9uIChsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsUG9pbnRbMV0gPD0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGxhbmU7XHJcbn0oc2hhcGVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBsYW5lO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc29sdmVyXCIpKTtcclxudmFyIGZyaWN0aW9uX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvblwiKSk7XHJcbi8vIFNldHMgdGhlIC5tdWx0aXBsaWVyIHByb3BlcnR5IG9mIGVhY2ggZXF1YXRpb25cclxuZnVuY3Rpb24gdXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCBpbnZEdCkge1xyXG4gICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgIHZhciBlcSA9IGVxdWF0aW9uc1tsXTtcclxuICAgICAgICBlcS5tdWx0aXBsaWVyID0gZXEubGFtYmRhICogaW52RHQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXRlcmF0ZUVxdWF0aW9uKGVxKSB7XHJcbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxyXG4gICAgdmFyIEIgPSBlcS5CLCBlcHMgPSBlcS5lcHNpbG9uLCBpbnZDID0gZXEuaW52QywgbGFtYmRhaiA9IGVxLmxhbWJkYSwgR1dsYW1iZGEgPSBlcS5jb21wdXRlR1dsYW1iZGEoKSwgbWF4Rm9yY2VfZHQgPSBlcS5tYXhGb3JjZUR0LCBtaW5Gb3JjZV9kdCA9IGVxLm1pbkZvcmNlRHQ7XHJcbiAgICB2YXIgZGVsdGFsYW1iZGEgPSBpbnZDICogKEIgLSBHV2xhbWJkYSAtIGVwcyAqIGxhbWJkYWopO1xyXG4gICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcclxuICAgIHZhciBsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPSBsYW1iZGFqICsgZGVsdGFsYW1iZGE7XHJcbiAgICBpZiAobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhIDwgbWluRm9yY2VfZHQpIHtcclxuICAgICAgICBkZWx0YWxhbWJkYSA9IG1pbkZvcmNlX2R0IC0gbGFtYmRhajtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA+IG1heEZvcmNlX2R0KSB7XHJcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtYXhGb3JjZV9kdCAtIGxhbWJkYWo7XHJcbiAgICB9XHJcbiAgICBlcS5sYW1iZGEgKz0gZGVsdGFsYW1iZGE7XHJcbiAgICBlcS5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xyXG4gICAgcmV0dXJuIGRlbHRhbGFtYmRhO1xyXG59XHJcbnZhciBHU1NvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhHU1NvbHZlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0aXZlIEdhdXNzLVNlaWRlbCBjb25zdHJhaW50IGVxdWF0aW9uIHNvbHZlci5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgR1NTb2x2ZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgU29sdmVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaXRlcmF0aW9ucz0xMF1cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b2xlcmFuY2U9MF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR1NTb2x2ZXIob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIHNvbHZlcl8xLmRlZmF1bHQuR1MpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgd2VyZSBtYWRlIGR1cmluZyB0aGUgbGFzdCBzb2x2ZS4gSWYgLnRvbGVyYW5jZSBpcyB6ZXJvLCB0aGlzIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGVxdWFsIHRvIC5pdGVyYXRpb25zLCBidXQgaWYgLnRvbGVyYW5jZSBpcyBsYXJnZXIgdGhhbiB6ZXJvLCBhbmQgdGhlIHNvbHZlciBjYW4gcXVpdCBlYXJseSwgdGhlbiB0aGlzIG51bWJlciB3aWxsIGJlIHNvbWV3aGVyZSBiZXR3ZWVuIDEgYW5kIC5pdGVyYXRpb25zLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1c2VkSXRlcmF0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcclxuICAgICAgICBfdGhpcy5pdGVyYXRpb25zID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLml0ZXJhdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwO1xyXG4gICAgICAgIF90aGlzLnRvbGVyYW5jZSA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2xlcmFuY2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDFlLTc7XHJcbiAgICAgICAgX3RoaXMuZnJpY3Rpb25JdGVyYXRpb25zID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZyaWN0aW9uSXRlcmF0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXHJcbiAgICAgKiBAbWV0aG9kIHNvbHZlXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgIFRpbWUgc3RlcFxyXG4gICAgICogQHBhcmFtICB7V29ybGR9ICAgd29ybGQgICAgV29ybGQgdG8gc29sdmVcclxuICAgICAqL1xyXG4gICAgR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKGgsIHdvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5zb3J0RXF1YXRpb25zKCk7XHJcbiAgICAgICAgdmFyIGl0ZXIgPSAwLCBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLCBtYXhGcmljdGlvbkl0ZXIgPSB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucywgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsIHRvbFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnRvbGVyYW5jZSAqIE5lcSwgMiksIGJvZGllcyA9IHdvcmxkLmJvZGllcywgTmJvZGllcyA9IGJvZGllcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XHJcbiAgICAgICAgaWYgKE5lcSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzb2x2ZSBtYXNzXHJcbiAgICAgICAgICAgICAgICBiLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpXzEgPSAwOyBpXzEgIT09IE5lcTsgaV8xKyspIHtcclxuICAgICAgICAgICAgdmFyIGNfMSA9IGVxdWF0aW9uc1tpXzFdO1xyXG4gICAgICAgICAgICBjXzEubGFtYmRhID0gMDtcclxuICAgICAgICAgICAgaWYgKGNfMS50aW1lU3RlcCAhPT0gaCB8fCBjXzEubmVlZHNVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNfMS50aW1lU3RlcCA9IGg7XHJcbiAgICAgICAgICAgICAgICBjXzEudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY18xLkIgPSBjXzEuY29tcHV0ZUIoY18xLmEsIGNfMS5iLCBoKTtcclxuICAgICAgICAgICAgY18xLmludkMgPSBjXzEuY29tcHV0ZUludkMoY18xLmVwc2lsb24pO1xyXG4gICAgICAgICAgICBjXzEubWF4Rm9yY2VEdCA9IGNfMS5tYXhGb3JjZSAqIGg7XHJcbiAgICAgICAgICAgIGNfMS5taW5Gb3JjZUR0ID0gY18xLm1pbkZvcmNlICogaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMsIGRlbHRhbGFtYmRhVG90LCBqO1xyXG4gICAgICAgIGlmIChOZXEgIT09IDApIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHZsYW1iZGFcclxuICAgICAgICAgICAgICAgIGIucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4RnJpY3Rpb25JdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgY29udGFjdCBlcXVhdGlvbnMgdG8gZ2V0IG5vcm1hbCBmb3JjZXNcclxuICAgICAgICAgICAgICAgIGZvciAoaXRlciA9IDA7IGl0ZXIgIT09IG1heEZyaWN0aW9uSXRlcjsgaXRlcisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogIT09IE5lcTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YWxhbWJkYSA9IGl0ZXJhdGVFcXVhdGlvbihjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZWRJdGVyYXRpb25zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YWxhbWJkYVRvdCAqIGRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCAxIC8gaCk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY29tcHV0ZWQgZnJpY3Rpb24gZm9yY2VcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogIT09IE5lcTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcSBpbnN0YW5jZW9mIGZyaWN0aW9uX2VxdWF0aW9uXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgIT09IGVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgKz0gZXEuY29udGFjdEVxdWF0aW9uc1trXS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgKj0gZXEuZnJpY3Rpb25Db2VmZmljaWVudCAvIGVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcS5tYXhGb3JjZSA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlRHQgPSBmICogaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXEubWluRm9yY2VEdCA9IC1mICogaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlcXVhdGlvbnNcclxuICAgICAgICAgICAgZm9yIChpdGVyID0gMDsgaXRlciAhPT0gbWF4SXRlcjsgaXRlcisrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogIT09IE5lcTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBpdGVyYXRlRXF1YXRpb24oYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhbGFtYmRhVG90ICogZGVsdGFsYW1iZGFUb3QgPCB0b2xTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIHJlc3VsdCB0byB2ZWxvY2l0eVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJvZGllc1tpXS5hZGRDb25zdHJhaW50VmVsb2NpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIDEgLyBoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEdTU29sdmVyO1xyXG59KHNvbHZlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR1NTb2x2ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2V2ZW50cy9ldmVudC1lbWl0dGVyXCIpKTtcclxudmFyIFNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTb2x2ZXIsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgc29sdmVycy5cclxuICAgICAqIEBjbGFzcyBTb2x2ZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNvbHZlcihvcHRpb25zLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBlcXVhdGlvbnMgaW4gdGhlIHNvbHZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZXF1YXRpb25zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNvcnQgYWxsIGVxdWF0aW9ucyBiZWZvcmUgZWFjaCBzb2x2ZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25Tb3J0RnVuY3Rpb25cclxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb258Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lcXVhdGlvblNvcnRGdW5jdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU29ydCBhbGwgZXF1YXRpb25zIHVzaW5nIHRoZSAuZXF1YXRpb25Tb3J0RnVuY3Rpb24uIFNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3NlcyBiZWZvcmUgc29sdmluZy5cclxuICAgICAqIEBtZXRob2Qgc29ydEVxdWF0aW9uc1xyXG4gICAgICovXHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnNvcnRFcXVhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5lcXVhdGlvbnMuc29ydCh0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gZXF1YXRpb24gdG8gYmUgc29sdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgYWRkRXF1YXRpb25cclxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxXHJcbiAgICAgKi9cclxuICAgIFNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb24gPSBmdW5jdGlvbiAoZXEpIHtcclxuICAgICAgICBpZiAoZXEuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgZXF1YXRpb25zLiBTYW1lIGFzIC5hZGRFcXVhdGlvbiwgYnV0IHRoaXMgdGltZSB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgRXF1YXRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRFcXVhdGlvbnNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVxc1xyXG4gICAgICovXHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9ucyA9IGZ1bmN0aW9uIChlcXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGVxcy5sZW5ndGg7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZXEgPSBlcXNbaV07XHJcbiAgICAgICAgICAgIGlmIChlcS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBlcXVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxyXG4gICAgICovXHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24gKGVxKSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKGVxKTtcclxuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgY3VycmVudGx5IGFkZGVkIGVxdWF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xyXG4gICAgICovXHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2F1c3MtU2VpZGVsIHNvbHZlci5cclxuICAgICAqIEBwcm9wZXJ0eSBHU1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgU29sdmVyLkdTID0gMTtcclxuICAgIHJldHVybiBTb2x2ZXI7XHJcbn0oZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU29sdmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2xcIikpO1xyXG52YXIgY29udGFjdF9lcXVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lcXVhdGlvbnMvY29udGFjdC1lcXVhdGlvblwiKSk7XHJcbnZhciBDb250YWN0RXF1YXRpb25Qb29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRhY3RFcXVhdGlvblBvb2wsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb250YWN0RXF1YXRpb25Qb29sKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cclxuICAgICAqL1xyXG4gICAgQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgY29udGFjdF9lcXVhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICogQHBhcmFtIHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb25Qb29sfVxyXG4gICAgICovXHJcbiAgICBDb250YWN0RXF1YXRpb25Qb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVxdWF0aW9uKSB7XHJcbiAgICAgICAgZXF1YXRpb24uYm9keUEgPSBlcXVhdGlvbi5ib2R5QiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnRhY3RFcXVhdGlvblBvb2w7XHJcbn0ocG9vbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGFjdEVxdWF0aW9uUG9vbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHBvb2xfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wb29sXCIpKTtcclxudmFyIGZyaWN0aW9uX2VxdWF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VxdWF0aW9ucy9mcmljdGlvbi1lcXVhdGlvblwiKSk7XHJcbnZhciBGcmljdGlvbkVxdWF0aW9uUG9vbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGcmljdGlvbkVxdWF0aW9uUG9vbCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb25Qb29sKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVcclxuICAgICAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XHJcbiAgICAgKi9cclxuICAgIEZyaWN0aW9uRXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBmcmljdGlvbl9lcXVhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICogQHBhcmFtIHtGcmljdGlvbkVxdWF0aW9ufSBlcXVhdGlvblxyXG4gICAgICogQHJldHVybiB7RnJpY3Rpb25FcXVhdGlvblBvb2x9XHJcbiAgICAgKi9cclxuICAgIEZyaWN0aW9uRXF1YXRpb25Qb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVxdWF0aW9uKSB7XHJcbiAgICAgICAgZXF1YXRpb24uYm9keUEgPSBlcXVhdGlvbi5ib2R5QiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIEZyaWN0aW9uRXF1YXRpb25Qb29sO1xyXG59KHBvb2xfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZyaWN0aW9uRXF1YXRpb25Qb29sO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Bvb2xcIikpO1xyXG52YXIgb3ZlcmxhcF9rZWVwZXJfcmVjb3JkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb3ZlcmxhcC1rZWVwZXItcmVjb3JkXCIpKTtcclxudmFyIE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZH1cclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IG92ZXJsYXBfa2VlcGVyX3JlY29yZF8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgZGVzdHJveVxyXG4gICAgICogQHBhcmFtIHtPdmVybGFwS2VlcGVyUmVjb3JkfSByZWNvcmRcclxuICAgICAqIEByZXR1cm4ge092ZXJsYXBLZWVwZXJSZWNvcmRQb29sfVxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICByZWNvcmQuc2V0KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xyXG59KHBvb2xfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcclxuICAgICAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQikge1xyXG4gICAgICAgIHRoaXMuc2V0KGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGRhdGEgZm9yIHRoZSByZWNvcmRcclxuICAgICAqIEBtZXRob2Qgc2V0XHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcclxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcclxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxyXG4gICAgICovXHJcbiAgICBPdmVybGFwS2VlcGVyUmVjb3JkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQikge1xyXG4gICAgICAgIHRoaXMuc2hhcGVBID0gc2hhcGVBO1xyXG4gICAgICAgIHRoaXMuc2hhcGVCID0gc2hhcGVCO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIE92ZXJsYXBLZWVwZXJSZWNvcmQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE92ZXJsYXBLZWVwZXJSZWNvcmQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0dXBsZV9kaWN0aW9uYXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHVwbGUtZGljdGlvbmFyeVwiKSk7XHJcbnZhciBvdmVybGFwX2tlZXBlcl9yZWNvcmRfcG9vbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL292ZXJsYXAta2VlcGVyLXJlY29yZC1wb29sXCIpKTtcclxudmFyIE92ZXJsYXBLZWVwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIG92ZXJsYXBzIGluIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGUgbGFzdCBzdGVwIHN0YXRlLlxyXG4gICAgICogQGNsYXNzIE92ZXJsYXBLZWVwZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBPdmVybGFwS2VlcGVyKCkge1xyXG4gICAgICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUgPSBuZXcgdHVwbGVfZGljdGlvbmFyeV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlID0gbmV3IHR1cGxlX2RpY3Rpb25hcnlfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRQb29sID0gbmV3IG92ZXJsYXBfa2VlcGVyX3JlY29yZF9wb29sXzEuZGVmYXVsdCh7IHNpemU6IDE2IH0pO1xyXG4gICAgICAgIHRoaXMudG1wRGljdCA9IG5ldyB0dXBsZV9kaWN0aW9uYXJ5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMudG1wQXJyYXkxID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRpY2tzIG9uZSBzdGVwIGZvcndhcmQgaW4gdGltZS4gVGhpcyB3aWxsIG1vdmUgdGhlIGN1cnJlbnQgb3ZlcmxhcCBzdGF0ZSB0byB0aGUgXCJvbGRcIiBvdmVybGFwIHN0YXRlLCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBhcyBjdXJyZW50LlxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcclxuICAgICAgICAvLyBTYXZlIG9sZCBvYmplY3RzIGludG8gcG9vbFxyXG4gICAgICAgIHZhciBsID0gbGFzdC5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBsYXN0LmtleXNbbF07XHJcbiAgICAgICAgICAgIHZhciBsYXN0T2JqZWN0ID0gbGFzdC5nZXRCeUtleShrZXkpO1xyXG4gICAgICAgICAgICBpZiAobGFzdE9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlY29yZCBpcyBvbmx5IHVzZWQgaW4gdGhlIFwibGFzdFwiIGRpY3QsIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFdlIG1pZ2h0IGFzIHdlbGwgcG9vbCBpdC5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkUG9vbC5yZWxlYXNlKGxhc3RPYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFyIGxhc3Qgb2JqZWN0XHJcbiAgICAgICAgbGFzdC5yZXNldCgpO1xyXG4gICAgICAgIC8vIFRyYW5zZmVyIGZyb20gbmV3IG9iamVjdCB0byBvbGRcclxuICAgICAgICBsYXN0LmNvcHkoY3VycmVudCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgY3VycmVudCBvYmplY3RcclxuICAgICAgICBjdXJyZW50LnJlc2V0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldE92ZXJsYXBwaW5nXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IHNoYXBlQVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBzaGFwZUJcclxuICAgICAqL1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0T3ZlcmxhcHBpbmcgPSBmdW5jdGlvbiAoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQikge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcclxuICAgICAgICAvLyBTdG9yZSBjdXJyZW50IGNvbnRhY3Qgc3RhdGVcclxuICAgICAgICBpZiAoIWN1cnJlbnQuZ2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkKSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVjb3JkUG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgZGF0YS5zZXQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQik7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuc2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3T3ZlcmxhcHMgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEVuZE92ZXJsYXBzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpZmYodGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSwgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSwgcmVzdWx0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0d28gYm9kaWVzIGFyZSBjdXJyZW50bHkgb3ZlcmxhcHBpbmcuXHJcbiAgICAgKiBAbWV0aG9kIGJvZGllc0FyZU92ZXJsYXBwaW5nXHJcbiAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtICB7Qm9keX0gYm9keUJcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmJvZGllc0FyZU92ZXJsYXBwaW5nID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5Qikge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcclxuICAgICAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoKGRhdGEuYm9keUEgPT09IGJvZHlBICYmIGRhdGEuYm9keUIgPT09IGJvZHlCKSB8fCBkYXRhLmJvZHlBID09PSBib2R5QiAmJiBkYXRhLmJvZHlCID09PSBib2R5QSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbiAoZGljdEEsIGRpY3RCLCByZXN1bHQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xyXG4gICAgICAgIHZhciBsYXN0ID0gZGljdEE7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBkaWN0QjtcclxuICAgICAgICByZXN1bHQubGVuZ3RoID0gMDtcclxuICAgICAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcgKyBrZXkgKyAnIGhhZCBubyBkYXRhIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsYXN0RGF0YSA9IGxhc3QuZGF0YVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIWxhc3REYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3Qgb3ZlcmxhcHBpbmcgaW4gbGFzdCBzdGF0ZSwgYnV0IGluIGN1cnJlbnQuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmlzTmV3T3ZlcmxhcCA9IGZ1bmN0aW9uIChzaGFwZUEsIHNoYXBlQikge1xyXG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XHJcbiAgICAgICAgLy8gTm90IGluIGxhc3QgYnV0IGluIG5ld1xyXG4gICAgICAgIHJldHVybiAhbGFzdC5nZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQpICYmICEhY3VycmVudC5nZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQpO1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld0JvZHlPdmVybGFwcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0TmV3T3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEVuZEJvZHlPdmVybGFwcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0RW5kT3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIE92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldEJvZHlEaWZmID0gZnVuY3Rpb24gKG92ZXJsYXBzLCByZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGFjY3VtdWxhdG9yID0gdGhpcy50bXBEaWN0O1xyXG4gICAgICAgIHZhciBsID0gb3ZlcmxhcHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBvdmVybGFwc1tsXTtcclxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgdXNlIGJvZHkgaWQncyBmb3IgdGhlIGFjY3VtdWxhdG9yLCB0aGVzZSB3aWxsIGJlIGEgc3Vic2V0IG9mIHRoZSBvcmlnaW5hbCBvbmVcclxuICAgICAgICAgICAgYWNjdW11bGF0b3Iuc2V0KGRhdGEuYm9keUEuaWQgfCAwLCBkYXRhLmJvZHlCLmlkIHwgMCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwgPSBhY2N1bXVsYXRvci5rZXlzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gYWNjdW11bGF0b3IuZ2V0QnlLZXkoYWNjdW11bGF0b3Iua2V5c1tsXSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhLmJvZHlBKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEuYm9keUIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjY3VtdWxhdG9yLnJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT3ZlcmxhcEtlZXBlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3ZlcmxhcEtlZXBlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCBwb29saW5nIHV0aWxpdHkuXHJcbiAgICAgKiBAY2xhc3MgUG9vbFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBvb2wob3B0aW9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYmplY3RzID0gW107XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaXplKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgcmVzaXplXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxyXG4gICAgICogQHJldHVybiB7UG9vbH0gU2VsZiwgZm9yIGNoYWluaW5nXHJcbiAgICAgKi9cclxuICAgIFBvb2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XHJcbiAgICAgICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoID4gc2l6ZSkge1xyXG4gICAgICAgICAgICBvYmplY3RzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPCBzaXplKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHMucHVzaCh0aGlzLmNyZWF0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYW4gb2JqZWN0IGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCBnZXRcclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgUG9vbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gdGhpcy5vYmplY3RzO1xyXG4gICAgICAgIHJldHVybiBvYmplY3RzLmxlbmd0aCA/IG9iamVjdHMucG9wKCkgOiB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW4gdXAgYW5kIHB1dCB0aGUgb2JqZWN0IGJhY2sgaW50byB0aGUgcG9vbCBmb3IgbGF0ZXIgdXNlLlxyXG4gICAgICogQG1ldGhvZCByZWxlYXNlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJuIHtQb29sfSBTZWxmIGZvciBjaGFpbmluZ1xyXG4gICAgICovXHJcbiAgICBQb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuZGVzdHJveShvYmplY3QpO1xyXG4gICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKG9iamVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvb2w7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBvb2w7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcclxudmFyIFR1cGxlRGljdGlvbmFyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGF0YSBzdG9yYWdlXHJcbiAgICAgICAgICogQHByb3BlcnR5IGRhdGFcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtleXMgdGhhdCBhcmUgY3VycmVudGx5IHVzZWQuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0ga2V5c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIGtleSBnaXZlbiB0d28gaW50ZWdlcnNcclxuICAgICAqIEBtZXRob2QgZ2V0S2V5XHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0galxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIChpZDEsIGlkMikge1xyXG4gICAgICAgIGlmICgoaWQxKSA9PT0gKGlkMikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2YWxpZCBmb3IgdmFsdWVzIDwgMl4xNlxyXG4gICAgICAgIHJldHVybiAoKGlkMSkgPiAoaWQyKSA/XHJcbiAgICAgICAgICAgIChpZDEgPDwgMTYpIHwgKGlkMiAmIDB4RkZGRikgOlxyXG4gICAgICAgICAgICAoaWQyIDw8IDE2KSB8IChpZDEgJiAweEZGRkYpKSB8IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGdldEJ5S2V5XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGtleVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGtleSA9IGtleTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRLZXkoaSwgaildO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgdmFsdWUuXHJcbiAgICAgKiBAbWV0aG9kIHNldFxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpXHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBqLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YSFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShpLCBqKTtcclxuICAgICAgICAvLyBDaGVjayBpZiBrZXkgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YVtrZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgZGF0YS5cclxuICAgICAqIEBtZXRob2QgcmVzZXRcclxuICAgICAqL1xyXG4gICAgVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSwga2V5cyA9IHRoaXMua2V5cztcclxuICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIGRhdGFba2V5c1tsXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleXMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvcHkgYW5vdGhlciBUdXBsZURpY3Rpb25hcnkuIE5vdGUgdGhhdCBhbGwgZGF0YSBpbiB0aGlzIGRpY3Rpb25hcnkgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICogQG1ldGhvZCBjb3B5XHJcbiAgICAgKiBAcGFyYW0ge1R1cGxlRGljdGlvbmFyeX0gZGljdCBUaGUgVHVwbGVEaWN0aW9uYXJ5IHRvIGNvcHkgaW50byB0aGlzIG9uZS5cclxuICAgICAqL1xyXG4gICAgVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKGRpY3QpIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KHRoaXMua2V5cywgZGljdC5rZXlzKTtcclxuICAgICAgICB2YXIgbCA9IGRpY3Qua2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGwtLSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gZGljdC5rZXlzW2xdO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFba2V5XSA9IGRpY3QuZGF0YVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gVHVwbGVEaWN0aW9uYXJ5O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUdXBsZURpY3Rpb25hcnk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXHJcbi8qKlxyXG4gKiBNaXNjIHV0aWxpdHkgZnVuY3Rpb25zXHJcbiAqL1xyXG52YXIgVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVdGlscygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cclxuICAgICAqIEBtZXRob2QgYXBwZW5kQXJyYXlcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYlxyXG4gICAgICovXHJcbiAgICBVdGlscy5wcm90b3R5cGUuYXBwZW5kQXJyYXkgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBiLmxlbmd0aDsgaSAhPT0gbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgYS5wdXNoKGJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXHJcbiAgICAgKiBAbWV0aG9kIHNwbGljZVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycmF5XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XHJcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcclxuICAgICAqL1xyXG4gICAgVXRpbHMucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgsIGhvd21hbnkpIHtcclxuICAgICAgICBob3dtYW55ID0gaG93bWFueSB8fCAxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCwgbGVuID0gYXJyYXkubGVuZ3RoIC0gaG93bWFueTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcnJheS5sZW5ndGggPSBsZW47XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGFuIGFycmF5LCBpZiB0aGUgYXJyYXkgY29udGFpbnMgdGhlIGVsZW1lbnQuXHJcbiAgICAgKiBAbWV0aG9kIGFycmF5UmVtb3ZlXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBVdGlscy5wcm90b3R5cGUuYXJyYXlSZW1vdmUgPSBmdW5jdGlvbiAoYXJyYXksIGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNwbGljZShhcnJheSwgaWR4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgb2YgYW5vdGhlclxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gYVxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBiXHJcbiAgICAgKi9cclxuICAgIFV0aWxzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBiKSB7XHJcbiAgICAgICAgICAgIGFba2V5XSA9IGJba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdC4gUmV0dXJucyBhIG5ldyBvYmplY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBpbnB1dCBpbnN0YW5jZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBtZXRob2Qgc2hhbGxvd0Nsb25lXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICBVdGlscy5wcm90b3R5cGUuc2hhbGxvd0Nsb25lID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBuZXdPYmogPSB7fTtcclxuICAgICAgICB0aGlzLmV4dGVuZChuZXdPYmosIG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG5ld09iajtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVXRpbHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBVdGlscygpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW5pb25GaW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXZWlnaHRlZCBRdWljayBVbmlvbi1GaW5kIHdpdGggUGF0aCBDb21wcmVzc2lvbi4gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2p1emVyYWxpL3VuaW9uZmluZCwgYnV0IG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICAgKiBAY2xhc3MgVW5pb25GaW5kXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFVuaW9uRmluZChzaXplKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3ogPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGRpc3RpbmN0IGdyb3Vwcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY291bnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvdW50ID0gc2l6ZTtcclxuICAgICAgICB0aGlzLnJlc2l6ZShzaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgVW5pb25GaW5kIGRhdGEgc3RydWN0dXJlIHdpdGggbnVtYmVyIG9mIGRpc3RpbmN0IGdyb3VwcyB0byBiZWdpbiB3aXRoLiBFYWNoIGdyb3VwIHdpbGwgYmUgcmVmZXJyZWQgdG8gYXMgaW5kZXggb2YgdGhlIGFycmF5IG9mIHNpemUgc2l6ZSBzdGFydGluZyBhdCAwLlxyXG4gICAgICogQG1ldGhvZCByZXNpemVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICAgKi9cclxuICAgIFVuaW9uRmluZC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICB2YXIgc3ogPSB0aGlzLnN6O1xyXG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgaWRbaV0gPSBpO1xyXG4gICAgICAgICAgICBzeltpXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByb290ICh2YWx1ZSkgb2YgdGhlIGdyb3VwIGluIHdoaWNoIHAgaXMuXHJcbiAgICAgKiBAbWV0aG9kIGZpbmRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXHJcbiAgICAgKi9cclxuICAgIFVuaW9uRmluZC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcclxuICAgICAgICB3aGlsZSAocCAhPT0gaWRbcF0pIHtcclxuICAgICAgICAgICAgaWRbcF0gPSBpZFtpZFtwXV07XHJcbiAgICAgICAgICAgIHAgPSBpZFtwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lIGVsZW1lbnRzIGluIGdyb3VwcyBwIGFuZCBxIGludG8gYSBzaW5nbGUgZ3JvdXAuIEluIG90aGVyIHdvcmRzIGNvbm5lY3QgdGhlIHR3byBncm91cHMuXHJcbiAgICAgKiBAbWV0aG9kIHVuaW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHFcclxuICAgICAqL1xyXG4gICAgVW5pb25GaW5kLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIChwLCBxKSB7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLmZpbmQocCksIGogPSB0aGlzLmZpbmQocSk7XHJcbiAgICAgICAgaWYgKGkgPT09IGopIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3ogPSB0aGlzLnN6O1xyXG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgaWYgKHN6W2ldIDwgc3pbal0pIHtcclxuICAgICAgICAgICAgaWRbaV0gPSBqO1xyXG4gICAgICAgICAgICBzeltqXSArPSBzeltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlkW2pdID0gaTtcclxuICAgICAgICAgICAgc3pbaV0gKz0gc3pbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVuaW9uRmluZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVW5pb25GaW5kO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZ3Nfc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NvbHZlci9ncy1zb2x2ZXJcIikpO1xyXG52YXIgdmVjMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRoL3ZlYzJcIikpO1xyXG52YXIgc2hhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcGVzL3NoYXBlXCIpKTtcclxudmFyIGV2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vZXZlbnRzL2V2ZW50LWVtaXR0ZXJcIikpO1xyXG52YXIgYm9keV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9vYmplY3RzL2JvZHlcIikpO1xyXG52YXIgbWF0ZXJpYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWF0ZXJpYWwvbWF0ZXJpYWxcIikpO1xyXG52YXIgY29udGFjdF9tYXRlcmlhbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9tYXRlcmlhbC9jb250YWN0LW1hdGVyaWFsXCIpKTtcclxudmFyIGFhYmJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL2FhYmJcIikpO1xyXG52YXIgc2FwX2Jyb2FkcGhhc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29sbGlzaW9uL3NhcC1icm9hZHBoYXNlXCIpKTtcclxudmFyIG5hcnJvd3BoYXNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbGxpc2lvbi9uYXJyb3dwaGFzZVwiKSk7XHJcbnZhciB1dGlsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy91dGlsc1wiKSk7XHJcbi8vaW1wb3J0IGFycmF5UmVtb3ZlIGZyb20gIFwiYXlSZW1vXCI7IC8vIEdldCByaWQgb2YgdGhpcyBkZXBlbmRlbmN5IVxyXG52YXIgb3ZlcmxhcF9rZWVwZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvb3ZlcmxhcC1rZWVwZXJcIikpO1xyXG52YXIgdW5pb25fZmluZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3VuaW9uLWZpbmRcIikpO1xyXG4vL2ltcG9ydCBmMzIgZnJvbSBcImYzMlwiO1xyXG4vKipcclxuICogRmlyZWQgYWZ0ZXIgdGhlIHN0ZXAoKS5cclxuICogQGV2ZW50IHBvc3RTdGVwXHJcbiAqL1xyXG52YXIgcG9zdFN0ZXBFdmVudCA9IHtcclxuICAgIHR5cGU6IFwicG9zdFN0ZXBcIlxyXG59O1xyXG4vKipcclxuICogRmlyZWQgd2hlbiBhIGJvZHkgaXMgYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gKiBAZXZlbnQgYWRkQm9keVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICovXHJcbnZhciBBZGRCb2R5RXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBZGRCb2R5RXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJhZGRCb2R5XCI7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBBZGRCb2R5RXZlbnQ7XHJcbn0oKSk7XHJcbnZhciBhZGRCb2R5RXZlbnQgPSBuZXcgQWRkQm9keUV2ZW50KCk7XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgYm9keSBpcyByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxyXG4gKiBAZXZlbnQgcmVtb3ZlQm9keVxyXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICovXHJcbnZhciBSZW1vdmVCb2R5RXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZW1vdmVCb2R5RXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJyZW1vdmVCb2R5XCI7XHJcbiAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBSZW1vdmVCb2R5RXZlbnQ7XHJcbn0oKSk7XHJcbnZhciByZW1vdmVCb2R5RXZlbnQgPSBuZXcgUmVtb3ZlQm9keUV2ZW50KCk7XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cclxuICogQGV2ZW50IGFkZFNwcmluZ1xyXG4gKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXHJcbiAqL1xyXG52YXIgQWRkU3ByaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBZGRTcHJpbmdFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImFkZFNwcmluZ1wiO1xyXG4gICAgICAgIHRoaXMuc3ByaW5nID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBBZGRTcHJpbmdFdmVudDtcclxufSgpKTtcclxudmFyIGFkZFNwcmluZ0V2ZW50ID0gbmV3IEFkZFNwcmluZ0V2ZW50KCk7XHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIGEgZmlyc3QgY29udGFjdCBpcyBjcmVhdGVkIGJldHdlZW4gdHdvIGJvZGllcy4gVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgc3RlcCBoYXMgYmVlbiBkb25lLlxyXG4gKiBAZXZlbnQgaW1wYWN0XHJcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcclxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gKiBAZGVwcmVjYXRlZCBJbXBhY3QgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBVc2UgYmVnaW5Db250YWN0IGluc3RlYWQuXHJcbiAqL1xyXG52YXIgSW1wYWN0RXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbXBhY3RFdmVudCgpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImltcGFjdFwiO1xyXG4gICAgICAgIHRoaXMuYm9keUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm9keUIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYXBlQiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEltcGFjdEV2ZW50O1xyXG59KCkpO1xyXG52YXIgaW1wYWN0RXZlbnQgPSBuZXcgSW1wYWN0RXZlbnQoKTtcclxuLyoqXHJcbiAqIEZpcmVkIGFmdGVyIHRoZSBCcm9hZHBoYXNlIGhhcyBjb2xsZWN0ZWQgY29sbGlzaW9uIHBhaXJzIGluIHRoZSB3b3JsZC5cclxuICogSW5zaWRlIHRoZSBldmVudCBoYW5kbGVyLCB5b3UgY2FuIG1vZGlmeSB0aGUgcGFpcnMgYXJyYXkgYXMgeW91IGxpa2UsIHRvXHJcbiAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIG9iamVjdHMgdGhhdCB5b3UgZG9uJ3Qgd2FudC5cclxuICogQGV2ZW50IHBvc3RCcm9hZHBoYXNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIGNvbGxpc2lvbiBwYWlycy4gSWYgdGhpcyBhcnJheSBpcyBbYm9keTEsYm9keTIsYm9keTMsYm9keTRdLCB0aGVuIHRoZSBib2R5IHBhaXJzIDEsMiBhbmQgMyw0IHdvdWxkIGFkdmFuY2UgdG8gbmFycm93cGhhc2UuXHJcbiAqL1xyXG52YXIgUG9zdEJyb2FkcGhhc2VFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvc3RCcm9hZHBoYXNlRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwb3N0QnJvYWRwaGFzZVwiO1xyXG4gICAgICAgIHRoaXMucGFpcnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFBvc3RCcm9hZHBoYXNlRXZlbnQ7XHJcbn0oKSk7XHJcbnZhciBwb3N0QnJvYWRwaGFzZUV2ZW50ID0gbmV3IFBvc3RCcm9hZHBoYXNlRXZlbnQ7XHJcbnZhciBCZWdpbkNvbnRhY3RFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJlZ2luQ29udGFjdEV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiYmVnaW5Db250YWN0XCI7XHJcbiAgICAgICAgdGhpcy5zaGFwZUEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvZHlBID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvZHlCID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBCZWdpbkNvbnRhY3RFdmVudDtcclxufSgpKTtcclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gdHdvIHNoYXBlcyBzdGFydHMgc3RhcnQgdG8gb3ZlcmxhcC4gRmlyZWQgaW4gdGhlIG5hcnJvd3BoYXNlLCBkdXJpbmcgc3RlcC5cclxuICogQGV2ZW50IGJlZ2luQ29udGFjdFxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXHJcbiAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnNcclxuICovXHJcbnZhciBiZWdpbkNvbnRhY3RFdmVudCA9IG5ldyBCZWdpbkNvbnRhY3RFdmVudCgpO1xyXG4vKipcclxuICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxyXG4gKiBAZXZlbnQgZW5kQ29udGFjdFxyXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcclxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXHJcbiAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXHJcbiAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXHJcbiAqL1xyXG52YXIgZW5kQ29udGFjdEV2ZW50ID0ge1xyXG4gICAgdHlwZTogXCJlbmRDb250YWN0XCIsXHJcbiAgICBzaGFwZUE6IG51bGwsXHJcbiAgICBzaGFwZUI6IG51bGwsXHJcbiAgICBib2R5QTogbnVsbCxcclxuICAgIGJvZHlCOiBudWxsXHJcbn07XHJcbnZhciBoaXRUZXN0X3RtcDEgPSB2ZWMyXzEuZGVmYXVsdC5jcmVhdGUoKSwgaGl0VGVzdF90bXAyID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbi8qKlxyXG4gKiBGaXJlZCBqdXN0IGJlZm9yZSBlcXVhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIgdG8gYmUgc29sdmVkLiBDYW4gYmUgdXNlZCB0byBjb250cm9sIHdoYXQgZXF1YXRpb25zIGdvZXMgaW50byB0aGUgc29sdmVyLlxyXG4gKiBAZXZlbnQgcHJlU29sdmVcclxuICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9ucyAgQW4gYXJyYXkgb2YgY29udGFjdHMgdG8gYmUgc29sdmVkLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBmcmljdGlvbkVxdWF0aW9ucyBBbiBhcnJheSBvZiBmcmljdGlvbiBlcXVhdGlvbnMgdG8gYmUgc29sdmVkLlxyXG4gKi9cclxudmFyIFByZVNvbHZlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVTb2x2ZUV2ZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJlU29sdmVcIjtcclxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByZVNvbHZlRXZlbnQ7XHJcbn0oKSk7XHJcbnZhciBwcmVTb2x2ZUV2ZW50ID0gbmV3IFByZVNvbHZlRXZlbnQoKTtcclxuZnVuY3Rpb24gc29ydEJvZGllc0J5SXNsYW5kKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmlzbGFuZElkIC0gYi5pc2xhbmRJZDtcclxufVxyXG5mdW5jdGlvbiBzb3J0RXF1YXRpb25zQnlJc2xhbmQoZXF1YXRpb25BLCBlcXVhdGlvbkIpIHtcclxuICAgIGlmICghKGVxdWF0aW9uQSA9PT0gbnVsbCB8fCBlcXVhdGlvbkEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVxdWF0aW9uQS5ib2R5QSkgfHwgIShlcXVhdGlvbkEgPT09IG51bGwgfHwgZXF1YXRpb25BID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcXVhdGlvbkEuYm9keUIpIHx8ICEoZXF1YXRpb25CID09PSBudWxsIHx8IGVxdWF0aW9uQiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXF1YXRpb25CLmJvZHlBKSB8fCAhKGVxdWF0aW9uQiA9PT0gbnVsbCB8fCBlcXVhdGlvbkIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVxdWF0aW9uQi5ib2R5QikpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgaXNsYW5kQSA9IGVxdWF0aW9uQS5ib2R5QS5pc2xhbmRJZCA+IDAgPyBlcXVhdGlvbkEuYm9keUEuaXNsYW5kSWQgOiBlcXVhdGlvbkEuYm9keUIuaXNsYW5kSWQ7XHJcbiAgICB2YXIgaXNsYW5kQiA9IGVxdWF0aW9uQi5ib2R5QS5pc2xhbmRJZCA+IDAgPyBlcXVhdGlvbkIuYm9keUEuaXNsYW5kSWQgOiBlcXVhdGlvbkIuYm9keUIuaXNsYW5kSWQ7XHJcbiAgICBpZiAoaXNsYW5kQSAhPT0gaXNsYW5kQikge1xyXG4gICAgICAgIHJldHVybiBpc2xhbmRBIC0gaXNsYW5kQjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNvcnQgYnkgZXF1YXRpb24gdHlwZSBpZiBzYW1lIGlzbGFuZFxyXG4gICAgICAgIHJldHVybiBlcXVhdGlvbkEuaW5kZXggLSBlcXVhdGlvbkIuaW5kZXg7XHJcbiAgICB9XHJcbn1cclxuLy8gV2h5IG5vdCBqdXN0IG1ha2UgdGhpcyBhIHByaXZhdGUgbWV0aG9kIGluIHdvcmxkP1xyXG4vLyBXaGF0IGFyZSBhbGwgdGhlc2UgcHJvcHM/Pz9cclxuZnVuY3Rpb24gcnVuTmFycm93cGhhc2Uod29ybGQsIG5wLCBiaSwgc2ksIHhpLCBhaSwgYmosIHNqLCB4aiwgYWosIGNtLCBnbGVuKSB7XHJcbiAgICB2YXIgeGl3ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICB2YXIgeGp3ID0gdmVjMl8xLmRlZmF1bHQuY3JlYXRlKCk7XHJcbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xyXG4gICAgaWYgKCEoKHNpLmNvbGxpc2lvbkdyb3VwICYgc2ouY29sbGlzaW9uTWFzaykgIT09IDAgJiYgKHNqLmNvbGxpc2lvbkdyb3VwICYgc2kuY29sbGlzaW9uTWFzaykgIT09IDApKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IHdvcmxkIHBvc2l0aW9uIGFuZCBhbmdsZSBvZiBlYWNoIHNoYXBlXHJcbiAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHhpdywgeGksIGJpLnBvc2l0aW9uLCBiaS5hbmdsZSk7XHJcbiAgICB2ZWMyXzEuZGVmYXVsdC50b0dsb2JhbEZyYW1lKHhqdywgeGosIGJqLnBvc2l0aW9uLCBiai5hbmdsZSk7XHJcbiAgICBpZiAodmVjMl8xLmRlZmF1bHQuZGlzdGFuY2UoeGl3LCB4ancpID4gc2kuYm91bmRpbmdSYWRpdXMgKyBzai5ib3VuZGluZ1JhZGl1cykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBhaXcgPSBhaSArIGJpLmFuZ2xlO1xyXG4gICAgdmFyIGFqdyA9IGFqICsgYmouYW5nbGU7XHJcbiAgICBucC5lbmFibGVGcmljdGlvbiA9IGNtLmZyaWN0aW9uID4gMDtcclxuICAgIHZhciByZWR1Y2VkTWFzcztcclxuICAgIGlmIChiaS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5TVEFUSUMgfHwgYmkudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuS0lORU1BVElDKSB7XHJcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiai5tYXNzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYmoudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuU1RBVElDIHx8IGJqLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LktJTkVNQVRJQykge1xyXG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmkubWFzcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlZHVjZWRNYXNzID0gKGJpLm1hc3MgKiBiai5tYXNzKSAvIChiaS5tYXNzICsgYmoubWFzcyk7XHJcbiAgICB9XHJcbiAgICBucC5zbGlwRm9yY2UgPSBjbS5mcmljdGlvbiAqIGdsZW4gKiByZWR1Y2VkTWFzcztcclxuICAgIG5wLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBjbTtcclxuICAgIG5wLmVuYWJsZWRFcXVhdGlvbnMgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcclxuICAgIHZhciBzZW5zb3IgPSBzaS5zZW5zb3IgfHwgc2ouc2Vuc29yO1xyXG4gICAgdmFyIG51bUZyaWN0aW9uQmVmb3JlID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xyXG4gICAgdmFyIG51bUNvbnRhY3RzID0gbnAudGVzdENvbnRhY3QoYmksIHNpLCB4aXcsIGJqLCBzaiwgeGp3LCBzZW5zb3IpO1xyXG4gICAgdmFyIG51bUZyaWN0aW9uRXF1YXRpb25zID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIC0gbnVtRnJpY3Rpb25CZWZvcmU7XHJcbiAgICBpZiAobnVtQ29udGFjdHMpIHtcclxuICAgICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJlxyXG4gICAgICAgICAgICBiaS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDICYmXHJcbiAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgPT09IGJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HICYmXHJcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgPT09IGJvZHlfMS5kZWZhdWx0LkFXQUtFICYmXHJcbiAgICAgICAgICAgIGJqLnR5cGUgIT09IGJvZHlfMS5kZWZhdWx0LlNUQVRJQykge1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQiA9IHZlYzJfMS5kZWZhdWx0LnNxdWFyZWRMZW5ndGgoYmoudmVsb2NpdHkpICsgTWF0aC5wb3coYmouYW5ndWxhclZlbG9jaXR5LCAyKTtcclxuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwgMik7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRCID49IHNwZWVkTGltaXRTcXVhcmVkQiAqIDIpIHtcclxuICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmouYWxsb3dTbGVlcCAmJlxyXG4gICAgICAgICAgICBiai50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDICYmXHJcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgPT09IGJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HICYmXHJcbiAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgPT09IGJvZHlfMS5kZWZhdWx0LkFXQUtFICYmXHJcbiAgICAgICAgICAgIGJpLnR5cGUgIT09IGJvZHlfMS5kZWZhdWx0LlNUQVRJQykge1xyXG4gICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IHZlYzJfMS5kZWZhdWx0LnNxdWFyZWRMZW5ndGgoYmkudmVsb2NpdHkpICsgTWF0aC5wb3coYmkuYW5ndWxhclZlbG9jaXR5LCAyKTtcclxuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwgMik7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSAqIDIpIHtcclxuICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3b3JsZC5vdmVybGFwS2VlcGVyLnNldE92ZXJsYXBwaW5nKGJpLCBzaSwgYmosIHNqKTtcclxuICAgICAgICBpZiAod29ybGQuaGFzKCdiZWdpbkNvbnRhY3QnKSAmJiB3b3JsZC5vdmVybGFwS2VlcGVyLmlzTmV3T3ZlcmxhcChzaSwgc2opKSB7XHJcbiAgICAgICAgICAgIC8vIFJlcG9ydCBuZXcgc2hhcGUgb3ZlcmxhcFxyXG4gICAgICAgICAgICB2YXIgZSA9IGJlZ2luQ29udGFjdEV2ZW50O1xyXG4gICAgICAgICAgICBlLnNoYXBlQSA9IHNpO1xyXG4gICAgICAgICAgICBlLnNoYXBlQiA9IHNqO1xyXG4gICAgICAgICAgICBlLmJvZHlBID0gYmk7XHJcbiAgICAgICAgICAgIGUuYm9keUIgPSBiajtcclxuICAgICAgICAgICAgLy8gUmVzZXQgY29udGFjdCBlcXVhdGlvbnNcclxuICAgICAgICAgICAgZS5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmICghc2Vuc29yKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSBudW1Db250YWN0czsgaSA8IG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMucHVzaChucC5jb250YWN0RXF1YXRpb25zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3b3JsZC5lbWl0KGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaXZpZGUgdGhlIG1heCBmcmljdGlvbiBmb3JjZSBieSB0aGUgbnVtYmVyIG9mIGNvbnRhY3RzXHJcbiAgICAgICAgaWYgKCFzZW5zb3IgJiYgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPiAxKSB7IC8vIFdoeSBkaXZpZGUgYnkgMT9cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCAtIG51bUZyaWN0aW9uRXF1YXRpb25zOyBpIDwgbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gbnAuZnJpY3Rpb25FcXVhdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICBmLnNldFNsaXBGb3JjZShmLmdldFNsaXBGb3JjZSgpIC8gbnVtRnJpY3Rpb25FcXVhdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEdsb2JhbEVxdWF0aW9uUGFyYW1zKHdvcmxkLCBwYXJhbXMpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgY29uc3RyYWludHMgPSB3b3JsZC5jb25zdHJhaW50cztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgdmFyIGVxcyA9IGMuZXF1YXRpb25zO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqICE9PSBlcXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gZXFzW2pdO1xyXG4gICAgICAgICAgICBlcS5yZWxheGF0aW9uID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnJlbGF4YXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVxLnJlbGF4YXRpb247XHJcbiAgICAgICAgICAgIGVxLnN0aWZmbmVzcyA9IChfYiA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5zdGlmZm5lc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVxLnN0aWZmbmVzcztcclxuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgV29ybGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoV29ybGQsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkeW5hbWljcyB3b3JsZCwgd2hlcmUgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMgbGl2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAY2xhc3MgV29ybGRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAgICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl0gRGVmYXVsdHMgdG8gR1NTb2x2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5ncmF2aXR5XSBEZWZhdWx0cyB0byB5PS05Ljc4LlxyXG4gICAgICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXSBEZWZhdWx0cyB0byBTQVBCcm9hZHBoYXNlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzbGFuZFNwbGl0PXRydWVdXHJcbiAgICAgKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XHJcbiAgICAgKiAgICAgICAgIGdyYXZpdHk6IFswLCAtMTBdLFxyXG4gICAgICogICAgICAgICBicm9hZHBoYXNlOiBuZXcgU0FQQnJvYWRwaGFzZSgpXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiAgICAgd29ybGQuYWRkQm9keShuZXcgQm9keSgpKTtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gV29ybGQob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbCBzcHJpbmdzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgc3ByaW5nIHRvIHRoZSB3b3JsZCwgdXNlIHt7I2Nyb3NzTGluayBcIldvcmxkL2FkZFNwcmluZzptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgc3ByaW5nc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zcHJpbmdzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsIGJvZGllcyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIGJvZHkgdG8gdGhlIHdvcmxkLCB1c2Uge3sjY3Jvc3NMaW5rIFwiV29ybGQvYWRkQm9keTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gYm9kaWVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYm9kaWVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBuYXJyb3dwaGFzZSB0byB1c2UgdG8gZ2VuZXJhdGUgY29udGFjdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgbmFycm93cGhhc2VcclxuICAgICAgICAgKiBAdHlwZSB7TmFycm93cGhhc2V9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMubmFycm93cGhhc2UgPSBuZXcgbmFycm93cGhhc2VfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5ncmF2aXR5ID0gdmVjMl8xLmRlZmF1bHQuZnJvbVZhbHVlcygwLCAtOS43OCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmZyaWN0aW9uR3Jhdml0eSA9IDEwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5IGlzIHplcm8sIGFuZCAudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHk9dHJ1ZSwgdGhlbiBzd2l0Y2ggdG8gdXNpbmcgLmZyaWN0aW9uR3Jhdml0eSBmb3IgZnJpY3Rpb24gaW5zdGVhZC4gVGhpcyBmYWxsYmFjayBpcyB1c2VmdWwgZm9yIGdyYXZpdHlsZXNzIGdhbWVzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VyLWFkZGVkIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvbnN0cmFpbnRzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHVtbXkgZGVmYXVsdCBtYXRlcmlhbCBpbiB0aGUgd29ybGQsIHVzZWQgaW4gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWxcclxuICAgICAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBkZWZhdWx0TWF0ZXJpYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCB0aW1lIHN0ZXAgc2l6ZSB3ZSB1c2VkIGxhc3Qgc3RlcFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBsYXN0VGltZVN0ZXBcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxhc3RUaW1lU3RlcCA9IDEgLyA2MDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBzcHJpbmcgZm9yY2VzIGVhY2ggc3RlcC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgYXBwbHlTcHJpbmdGb3JjZXNcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYXBwbHlTcHJpbmdGb3JjZXMgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGJvZHkgZGFtcGluZyBlYWNoIHN0ZXAuXHJcbiAgICAgICAgICogQHByb3BlcnR5IGFwcGx5RGFtcGluZ1xyXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5hcHBseURhbXBpbmcgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZSB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGdyYXZpdHkgZWFjaCBzdGVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhcHBseUdyYXZpdHlcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuYXBwbHlHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUvZGlzYWJsZSBjb25zdHJhaW50IHNvbHZpbmcgaW4gZWFjaCBzdGVwLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzb2x2ZUNvbnN0cmFpbnRzXHJcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLnNvbHZlQ29uc3RyYWludHMgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBDb250YWN0TWF0ZXJpYWxzIGFkZGVkIHRvIHRoZSBXb3JsZC5cclxuICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdE1hdGVyaWFsc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV29ybGQgdGltZS5cclxuICAgICAgICAgKiBAcHJvcGVydHkgdGltZVxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudGltZSA9IDAuMDtcclxuICAgICAgICBfdGhpcy5hY2N1bXVsYXRvciA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXMgdHJ1ZSBkdXJpbmcgc3RlcCgpLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3RlcHBpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zdGVwcGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGlzbGFuZCBzcGxpdHRpbmcuIElzbGFuZCBzcGxpdHRpbmcgY2FuIGJlIGFuIGFkdmFudGFnZSBmb3IgYm90aCBwcmVjaXNpb24gYW5kIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNsYW5kU3BsaXRcclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmlzbGFuZFNwbGl0ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcclxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW1wYWN0IGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC4gVXNlIGJlZ2luQ29udGFjdCBpbnN0ZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmVtaXRJbXBhY3RFdmVudCA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG93IHRvIGRlYWN0aXZhdGUgYm9kaWVzIGR1cmluZyBzaW11bGF0aW9uLiBQb3NzaWJsZSBtb2RlcyBhcmU6IHt7I2Nyb3NzTGluayBcIldvcmxkL05PX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLk5PX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIldvcmxkL0JPRFlfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuQk9EWV9TTEVFUElOR3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJXb3JsZC9JU0xBTkRfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuSVNMQU5EX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogSWYgc2xlZXBpbmcgaXMgZW5hYmxlZCwgeW91IG1pZ2h0IG5lZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS93YWtlVXA6bWV0aG9kXCJ9fXdha2UgdXB7ey9jcm9zc0xpbmt9fSB0aGUgYm9kaWVzIGlmIHRoZXkgZmFsbCBhc2xlZXAgd2hlbiB0aGV5IHNob3VsZG4ndC4gSWYgeW91IHdhbnQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB3b3JsZCwgYnV0IHdhbnQgdG8gZGlzYWJsZSBpdCBmb3IgYSBwYXJ0aWN1bGFyIGJvZHksIHNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2FsbG93U2xlZXA6cHJvcGVydHlcIn19Qm9keS5hbGxvd1NsZWVwe3svY3Jvc3NMaW5rfX0uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHNsZWVwTW9kZVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgV29ybGQuTk9fU0xFRVBJTkdcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5zbGVlcE1vZGUgPSBXb3JsZC5OT19TTEVFUElORztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge1VuaW9uRmluZH0gdW5pb25GaW5kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudW5pb25GaW5kID0gbmV3IHVuaW9uX2ZpbmRfMS5kZWZhdWx0KDEpO1xyXG4gICAgICAgIC8vIElkIGNvdW50ZXJzXHJcbiAgICAgICAgX3RoaXMuX2NvbnN0cmFpbnRJZENvdW50ZXIgPSAwO1xyXG4gICAgICAgIF90aGlzLl9ib2R5SWRDb3VudGVyID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJvcGVydHkge092ZXJsYXBLZWVwZXJ9IG92ZXJsYXBLZWVwZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IG92ZXJsYXBfa2VlcGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIF90aGlzLnNvbHZlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb2x2ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBnc19zb2x2ZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ncmF2aXR5KSB7XHJcbiAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LmNvcHkoX3RoaXMuZ3Jhdml0eSwgb3B0aW9ucy5ncmF2aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZnJpY3Rpb25HcmF2aXR5ID0gKF9iID0gdmVjMl8xLmRlZmF1bHQubGVuZ3RoKF90aGlzLmdyYXZpdHkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxMDtcclxuICAgICAgICBfdGhpcy5icm9hZHBoYXNlID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJyb2FkcGhhc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBzYXBfYnJvYWRwaGFzZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICBfdGhpcy5icm9hZHBoYXNlLnNldFdvcmxkKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IGNvbnRhY3RfbWF0ZXJpYWxfMS5kZWZhdWx0KF90aGlzLmRlZmF1bHRNYXRlcmlhbCwgX3RoaXMuZGVmYXVsdE1hdGVyaWFsKTtcclxuICAgICAgICBfdGhpcy5pc2xhbmRTcGxpdCA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pc2xhbmRTcGxpdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uIE5vdGUgdGhhdCBib3RoIGJvZGllcyBjb25uZWN0ZWQgdG8gdGhlIGNvbnN0cmFpbnQgbXVzdCBiZSBhZGRlZCB0byB0aGUgd29ybGQgZmlyc3QuIEFsc28gbm90ZSB0aGF0IHlvdSBjYW4ndCBydW4gdGhpcyBtZXRob2QgZHVyaW5nIHN0ZXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50cyBjYW5ub3QgYmUgYWRkZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgICAgICBpZiAoYm9kaWVzLmluZGV4T2YoY29uc3RyYWludC5ib2R5QSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBDb25zdHJhaW50OiBib2R5QSBpcyBub3QgYWRkZWQgdG8gdGhlIFdvcmxkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm9kaWVzLmluZGV4T2YoY29uc3RyYWludC5ib2R5QikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBDb25zdHJhaW50OiBib2R5QiBpcyBub3QgYWRkZWQgdG8gdGhlIFdvcmxkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBDb250YWN0TWF0ZXJpYWwgdG8gdGhlIHNpbXVsYXRpb24uXHJcbiAgICAgKiBAbWV0aG9kIGFkZENvbnRhY3RNYXRlcmlhbFxyXG4gICAgICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNvbnRhY3RNYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKGNvbnRhY3RNYXRlcmlhbCkge1xyXG4gICAgICAgIHRoaXMuY29udGFjdE1hdGVyaWFscy5wdXNoKGNvbnRhY3RNYXRlcmlhbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29udGFjdE1hdGVyaWFsXHJcbiAgICAgKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY21cclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgIHV0aWxzXzEuZGVmYXVsdC5hcnJheVJlbW92ZSh0aGlzLmNvbnRhY3RNYXRlcmlhbHMsIGNtKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGNvbnRhY3QgbWF0ZXJpYWwgZ2l2ZW4gdHdvIG1hdGVyaWFsc1xyXG4gICAgICogQG1ldGhvZCBnZXRDb250YWN0TWF0ZXJpYWxcclxuICAgICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxyXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXHJcbiAgICAgKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIG9yIGZhbHNlIG9uIGZhaWwuXHJcbiAgICAgKiBAdG9kbyBVc2UgZmFzdGVyIGhhc2ggbWFwIHRvIGxvb2t1cCBmcm9tIG1hdGVyaWFsIGlkJ3NcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uIChtYXRlcmlhbEEsIG1hdGVyaWFsQikge1xyXG4gICAgICAgIHZhciBjbWF0cyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGNtYXRzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjbSA9IGNtYXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoKGNtLm1hdGVyaWFsQSA9PT0gbWF0ZXJpYWxBICYmIGNtLm1hdGVyaWFsQiA9PT0gbWF0ZXJpYWxCKSB8fCAoY20ubWF0ZXJpYWxBID09PSBtYXRlcmlhbEIgJiYgY20ubWF0ZXJpYWxCID09PSBtYXRlcmlhbEEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29uc3RyYWludC4gTm90ZSB0aGF0IHlvdSBjYW4ndCBydW4gdGhpcyBtZXRob2QgZHVyaW5nIHN0ZXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoY29uc3RyYWludCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RyYWludHMgY2Fubm90IGJlIHJlbW92ZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxzXzEuZGVmYXVsdC5hcnJheVJlbW92ZSh0aGlzLmNvbnN0cmFpbnRzLCBjb25zdHJhaW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLlxyXG4gICAgICpcclxuICAgICAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2Qgc3RlcFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2luY2VMYXN0Q2FsbGVkPTBdICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCBjYWxsZWQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBTaW1wbGUgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxyXG4gICAgICogICAgIHZhciBmaXhlZFRpbWVTdGVwID0gMSAvIDYwO1xyXG4gICAgICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpO1xyXG4gICAgICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xyXG4gICAgICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIGZ1bmN0aW9uIGFuaW1hdGUoKXtcclxuICAgICAqICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXApO1xyXG4gICAgICogICAgICAgICByZW5kZXJCb2R5KGJvZHkucG9zaXRpb24sIGJvZHkuYW5nbGUpO1xyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIGxvb3BcclxuICAgICAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICAgICAvLyBGaXhlZCB0aW1lc3RlcHBpbmcgd2l0aCBpbnRlcnBvbGF0aW9uXHJcbiAgICAgKiAgICAgdmFyIG1heFN1YlN0ZXBzID0gMTA7XHJcbiAgICAgKiAgICAgdmFyIGxhc3RUaW1lU2Vjb25kcztcclxuICAgICAqXHJcbiAgICAgKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1lKXtcclxuICAgICAqICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gICAgICogICAgICAgICB2YXIgdGltZVNlY29uZHMgPSB0aW1lIC8gMTAwMDtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGlmKGxhc3RUaW1lU2Vjb25kcyl7XHJcbiAgICAgKiAgICAgICAgICAgICB2YXIgZGVsdGFUaW1lID0gdGltZVNlY29uZHMgLSBsYXN0VGltZVNlY29uZHM7XHJcbiAgICAgKiAgICAgICAgICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXAsIGRlbHRhVGltZSwgbWF4U3ViU3RlcHMpO1xyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBsYXN0VGltZVNlY29uZHMgPSB0aW1lU2Vjb25kcztcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5pbnRlcnBvbGF0ZWRQb3NpdGlvbiwgYm9keS5pbnRlcnBvbGF0ZWRBbmdsZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxyXG4gICAgICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAqXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpIHtcclxuICAgICAgICBtYXhTdWJTdGVwcyA9IG1heFN1YlN0ZXBzIHx8IDEwO1xyXG4gICAgICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQgPSB0aW1lU2luY2VMYXN0Q2FsbGVkIHx8IDA7XHJcbiAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApIHsgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZ1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XHJcbiAgICAgICAgICAgIC8vIEluY3JlbWVudCB0aW1lXHJcbiAgICAgICAgICAgIHRoaXMudGltZSArPSBkdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcclxuICAgICAgICAgICAgdmFyIHN1YnN0ZXBzID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuYWNjdW11bGF0b3IgPj0gZHQgJiYgc3Vic3RlcHMgPCBtYXhTdWJTdGVwcykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gZml4ZWQgc3RlcHMgdG8gY2F0Y2ggdXBcclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZSArPSBkdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0b3IgLT0gZHQ7XHJcbiAgICAgICAgICAgICAgICBzdWJzdGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IHRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmVjMl8xLmRlZmF1bHQubGVycChiLmludGVycG9sYXRlZFBvc2l0aW9uLCBiLnByZXZpb3VzUG9zaXRpb24sIGIucG9zaXRpb24sIHQpO1xyXG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIucHJldmlvdXNBbmdsZSArIHQgKiAoYi5hbmdsZSAtIGIucHJldmlvdXNBbmdsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIGEgZml4ZWQgc3RlcC5cclxuICAgICAqIEBtZXRob2QgaW50ZXJuYWxTdGVwXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICB2YXIgc3RlcF9tZyA9IHZlYzJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xyXG4gICAgICAgIHZhciBlbmRPdmVybGFwcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RlcHBpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBOc3ByaW5ncyA9IHRoaXMuc3ByaW5ncy5sZW5ndGgsIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3MsIGJvZGllcyA9IHRoaXMuYm9kaWVzLCBnID0gdGhpcy5ncmF2aXR5LCBzb2x2ZXIgPSB0aGlzLnNvbHZlciwgTmJvZGllcyA9IHRoaXMuYm9kaWVzLmxlbmd0aCwgYnJvYWRwaGFzZSA9IHRoaXMuYnJvYWRwaGFzZSwgbnAgPSB0aGlzLm5hcnJvd3BoYXNlLCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMsIG1nID0gc3RlcF9tZywgYWRkID0gdmVjMl8xLmRlZmF1bHQuYWRkO1xyXG4gICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci50aWNrKCk7XHJcbiAgICAgICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcclxuICAgICAgICAvLyBVcGRhdGUgYXBwcm94aW1hdGUgZnJpY3Rpb24gZ3Jhdml0eS5cclxuICAgICAgICBpZiAodGhpcy51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSkge1xyXG4gICAgICAgICAgICB2YXIgZ3Jhdml0eUxlbiA9IHZlYzJfMS5kZWZhdWx0Lmxlbmd0aCh0aGlzLmdyYXZpdHkpO1xyXG4gICAgICAgICAgICBpZiAoIShncmF2aXR5TGVuID09PSAwICYmIHRoaXMudXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vbnplcm8gZ3Jhdml0eS4gVXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSBncmF2aXR5TGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBncmF2aXR5IHRvIGJvZGllc1xyXG4gICAgICAgIGlmICh0aGlzLmFwcGx5R3Jhdml0eSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSwgZmkgPSBiLmZvcmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGIudHlwZSAhPT0gYm9keV8xLmRlZmF1bHQuRFlOQU1JQyB8fCBiLnNsZWVwU3RhdGUgPT09IGJvZHlfMS5kZWZhdWx0LlNMRUVQSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5zY2FsZShtZywgZywgYi5tYXNzICogYi5ncmF2aXR5U2NhbGUpOyAvLyBGPW0qZ1xyXG4gICAgICAgICAgICAgICAgYWRkKGZpLCBmaSwgbWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBzcHJpbmcgZm9yY2VzXHJcbiAgICAgICAgaWYgKHRoaXMuYXBwbHlTcHJpbmdGb3JjZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE5zcHJpbmdzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gc3ByaW5nc1tpXTtcclxuICAgICAgICAgICAgICAgIHMuYXBwbHlGb3JjZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmFwcGx5RGFtcGluZykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT09IGJvZHlfMS5kZWZhdWx0LkRZTkFNSUMpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmFwcGx5RGFtcGluZyhkdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnJvYWRwaGFzZVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBicm9hZHBoYXNlLmdldENvbGxpc2lvblBhaXJzKHRoaXMpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBpZ25vcmVkIGNvbGxpc2lvbiBwYWlyc1xyXG4gICAgICAgIHZhciBpZ25vcmVkUGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBpZ25vcmVkUGFpcnMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJlc3VsdC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKChpZ25vcmVkUGFpcnNbaV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaSArIDFdID09PSByZXN1bHRbaiArIDFdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpZ25vcmVkUGFpcnNbaSArIDFdID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2ldID09PSByZXN1bHRbaiArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwgMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGNvbnN0cmFpbmVkIHBhaXJzIHdpdGggY29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZVxyXG4gICAgICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmNvbnN0cmFpbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKCFjLmNvbGxpZGVDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSByZXN1bHQubGVuZ3RoIC0gMjsgaiA+PSAwOyBqIC09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGMuYm9keUEgPT09IHJlc3VsdFtqXSAmJiBjLmJvZHlCID09PSByZXN1bHRbaiArIDFdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUEgPT09IHJlc3VsdFtqICsgMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBvc3RCcm9hZHBoYXNlIGV2ZW50XHJcbiAgICAgICAgcG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IHJlc3VsdDtcclxuICAgICAgICB0aGlzLmVtaXQocG9zdEJyb2FkcGhhc2VFdmVudCk7XHJcbiAgICAgICAgcG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IG51bGw7XHJcbiAgICAgICAgLy8gTmFycm93cGhhc2VcclxuICAgICAgICBucC5yZXNldCgpO1xyXG4gICAgICAgIHZhciBkZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xyXG4gICAgICAgIHZhciBmcmljdGlvbkdyYXZpdHkgPSB0aGlzLmZyaWN0aW9uR3Jhdml0eTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTnJlc3VsdHMgPSByZXN1bHQubGVuZ3RoOyBpICE9PSBOcmVzdWx0czsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBiaSA9IHJlc3VsdFtpXSwgYmogPSByZXN1bHRbaSArIDFdO1xyXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHNoYXBlcyBvZiBib2R5IGlcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIE5zaGFwZXNpID0gYmkuc2hhcGVzLmxlbmd0aDsgayAhPT0gTnNoYXBlc2k7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpID0gYmkuc2hhcGVzW2tdLCB4aSA9IHNpLnBvc2l0aW9uLCBhaSA9IHNpLmFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwLCBOc2hhcGVzaiA9IGJqLnNoYXBlcy5sZW5ndGg7IGwgIT09IE5zaGFwZXNqOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbbF0sIHhqID0gc2oucG9zaXRpb24sIGFqID0gc2ouYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RNYXRlcmlhbCA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLCBzai5tYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bk5hcnJvd3BoYXNlKHRoaXMsIG5wLCBiaSwgc2ksIHhpLCBhaSwgYmosIHNqLCB4aiwgYWosIGNvbnRhY3RNYXRlcmlhbCAhPT0gbnVsbCAmJiBjb250YWN0TWF0ZXJpYWwgIT09IHZvaWQgMCA/IGNvbnRhY3RNYXRlcmlhbCA6IGRlZmF1bHRDb250YWN0TWF0ZXJpYWwsIGZyaWN0aW9uR3Jhdml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2FrZSB1cCBib2RpZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYm9keS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSkge1xyXG4gICAgICAgICAgICAgICAgYm9keS53YWtlVXAoKTtcclxuICAgICAgICAgICAgICAgIGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbWl0IGVuZCBvdmVybGFwIGV2ZW50c1xyXG4gICAgICAgIGlmIChfc3VwZXIucHJvdG90eXBlLmhhcy5jYWxsKHRoaXMsIFwiZW5kQ29udGFjdFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuZ2V0RW5kT3ZlcmxhcHMoZW5kT3ZlcmxhcHMpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IGVuZENvbnRhY3RFdmVudDtcclxuICAgICAgICAgICAgdmFyIGwgPSBlbmRPdmVybGFwcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChsLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZW5kT3ZlcmxhcHNbbF07XHJcbiAgICAgICAgICAgICAgICBlLnNoYXBlQSA9IGRhdGEuc2hhcGVBO1xyXG4gICAgICAgICAgICAgICAgZS5zaGFwZUIgPSBkYXRhLnNoYXBlQjtcclxuICAgICAgICAgICAgICAgIGUuYm9keUEgPSBkYXRhLmJvZHlBO1xyXG4gICAgICAgICAgICAgICAgZS5ib2R5QiA9IGRhdGEuYm9keUI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5kT3ZlcmxhcHMubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJlU29sdmVFdmVudC5jb250YWN0RXF1YXRpb25zID0gbnAuY29udGFjdEVxdWF0aW9ucztcclxuICAgICAgICBwcmVTb2x2ZUV2ZW50LmZyaWN0aW9uRXF1YXRpb25zID0gbnAuZnJpY3Rpb25FcXVhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5lbWl0KHByZVNvbHZlRXZlbnQpO1xyXG4gICAgICAgIHByZVNvbHZlRXZlbnQuY29udGFjdEVxdWF0aW9ucyA9IHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIC8vIHVwZGF0ZSBjb25zdHJhaW50IGVxdWF0aW9uc1xyXG4gICAgICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmNvbnN0cmFpbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3RyYWludHNbaV0udXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChucC5jb250YWN0RXF1YXRpb25zLmxlbmd0aCB8fCBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggfHwgTmNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBhbGwgZXF1YXRpb25zXHJcbiAgICAgICAgICAgIHZhciBlcXVhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFwcGVuZEFycmF5KGVxdWF0aW9ucywgbnAuY29udGFjdEVxdWF0aW9ucyk7XHJcbiAgICAgICAgICAgIHV0aWxzXzEuZGVmYXVsdC5hcHBlbmRBcnJheShlcXVhdGlvbnMsIG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTmNvbnN0cmFpbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHV0aWxzXzEuZGVmYXVsdC5hcHBlbmRBcnJheShlcXVhdGlvbnMsIGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNsYW5kU3BsaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIFVuaW9uRmluZFxyXG4gICAgICAgICAgICAgICAgdmFyIHVuaW9uRmluZCA9IHRoaXMudW5pb25GaW5kO1xyXG4gICAgICAgICAgICAgICAgdW5pb25GaW5kLnJlc2l6ZSh0aGlzLmJvZGllcy5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBlcXVhdGlvbiBpbmRleFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBlcXVhdGlvbnNbaV0uaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVW5pdGUgYm9kaWVzIGlmIHRoZXkgYXJlIGNvbm5lY3RlZCBieSBhbiBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcXVhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSBlcXVhdGlvbnNbaV0uYm9keUE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gZXF1YXRpb25zW2ldLmJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYm9keUEgfHwgIWJvZHlCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuRFlOQU1JQyAmJiBib2R5Qi50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uRmluZC51bmlvbihib2R5QS5pbmRleCwgYm9keUIuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJvZHkgaXNsYW5kc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LmlzbGFuZElkID0gYm9keS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDID8gdW5pb25GaW5kLmZpbmQoYm9keS5pbmRleCkgOiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNvcnQgZXF1YXRpb25zIGJ5IGlzbGFuZFxyXG4gICAgICAgICAgICAgICAgZXF1YXRpb25zID0gZXF1YXRpb25zLnNvcnQoc29ydEVxdWF0aW9uc0J5SXNsYW5kKTtcclxuICAgICAgICAgICAgICAgIHZhciBlcXVhdGlvbkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChlcXVhdGlvbkluZGV4IDwgZXF1YXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcXVhdGlvbiA9IGVxdWF0aW9uc1tlcXVhdGlvbkluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcXVhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhdGlvbi5ib2R5QSB8fCAhZXF1YXRpb24uYm9keUIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SXNsYW5kSWQgPSBlcXVhdGlvbi5ib2R5QS5pc2xhbmRJZCA+IDAgPyBlcXVhdGlvbi5ib2R5QS5pc2xhbmRJZCA6IGVxdWF0aW9uLmJvZHlCLmlzbGFuZElkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXNsYW5kSWQgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWkgPSBlcXVhdGlvbnNbZXF1YXRpb25JbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlaS5ib2R5QSAmJiBlaS5ib2R5QilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SXNsYW5kSWQgPSAoKF9iID0gKF9hID0gZWkuYm9keUEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc2xhbmRJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgPiAwID8gKF9kID0gKF9jID0gZWkuYm9keUEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pc2xhbmRJZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCA6IChfZiA9IChfZSA9IGVpLmJvZHlCKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaXNsYW5kSWQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SXNsYW5kSWQgIT09IGN1cnJlbnRJc2xhbmRJZCB8fCBlcXVhdGlvbkluZGV4ID09PSBlcXVhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbHZlIHRoaXMgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvbHZlQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIGFsbCBhcyBvbmUgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKGVxdWF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb2x2ZUNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLnNvbHZlKGR0LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGVwIGZvcndhcmRcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYm9keS50eXBlID09PSBib2R5XzEuZGVmYXVsdC5EWU5BTUlDIHx8IGJvZHkudHlwZSA9PT0gYm9keV8xLmRlZmF1bHQuS0lORU1BVElDKSB7XHJcbiAgICAgICAgICAgICAgICBib2R5LmludGVncmF0ZShkdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVzZXQgZm9yY2VcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvZGllc1tpXS5zZXRaZXJvRm9yY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5lbWl0SW1wYWN0RXZlbnQgJiYgdGhpcy5oYXMoJ2ltcGFjdCcpKSB7XHJcbiAgICAgICAgICAgIHZhciBldiA9IGltcGFjdEV2ZW50O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gbnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChlcS5maXJzdEltcGFjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LmJvZHlBID0gKF9nID0gZXEuYm9keUEpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuYm9keUIgPSAoX2ggPSBlcS5ib2R5QikgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBldi5zaGFwZUEgPSBlcS5zaGFwZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuc2hhcGVCID0gZXEuc2hhcGVCO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LmNvbnRhY3RFcXVhdGlvbiA9IGVxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2xlZXBpbmcgdXBkYXRlXHJcbiAgICAgICAgaWYgKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5CT0RZX1NMRUVQSU5HKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIGZhbHNlLCBkdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLklTTEFORF9TTEVFUElORyAmJiB0aGlzLmlzbGFuZFNwbGl0KSB7XHJcbiAgICAgICAgICAgIC8vIFRlbGwgYWxsIGJvZGllcyB0byBzbGVlcCB0aWNrIGJ1dCBkb250IHNsZWVwIHlldFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOYm9kaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCB0cnVlLCBkdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2xlZXAgaXNsYW5kc1xyXG4gICAgICAgICAgICB2YXIgYm9kaWVzU29ydGVkQnlJc2xhbmQgPSBib2RpZXMuc29ydChzb3J0Qm9kaWVzQnlJc2xhbmQpO1xyXG4gICAgICAgICAgICB2YXIgaXNsYW5kRW5kID0gMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaXNsYW5kU3RhcnQgPSAwOyBpc2xhbmRTdGFydCA8IGJvZGllc1NvcnRlZEJ5SXNsYW5kLmxlbmd0aDsgaXNsYW5kU3RhcnQgPSBpc2xhbmRFbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc2xhbmRJZCA9IGJvZGllc1NvcnRlZEJ5SXNsYW5kW2lzbGFuZFN0YXJ0XS5pc2xhbmRJZDtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBpc2xhbmRFbmQgaW5kZXhcclxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICAgICAgICAgICAgICAgIGZvciAoaXNsYW5kRW5kID0gaXNsYW5kU3RhcnQgKyAxOyBpc2xhbmRFbmQgPCBib2RpZXNTb3J0ZWRCeUlzbGFuZC5sZW5ndGggJiYgYm9kaWVzU29ydGVkQnlJc2xhbmRbaXNsYW5kRW5kXS5pc2xhbmRJZCA9PT0gaXNsYW5kSWQ7IGlzbGFuZEVuZCsrKSB7IH1cclxuICAgICAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayBzdGF0aWMgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzbGFuZElkID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZFNob3VsZFNsZWVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpc2xhbmRTdGFydDsgaSA8IGlzbGFuZEVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib2RpZXNTb3J0ZWRCeUlzbGFuZFtpXS53YW50c1RvU2xlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNsYW5kU2hvdWxkU2xlZXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzbGFuZFNob3VsZFNsZWVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlzbGFuZFN0YXJ0OyBpIDwgaXNsYW5kRW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9kaWVzU29ydGVkQnlJc2xhbmRbaV0uc2xlZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGVwcGluZyA9IGZhbHNlO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIHBvc3RTdGVwRXZlbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc3ByaW5nIHRvIHRoZSBzaW11bGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBvcGVyYXRpb24gY2FuJ3QgYmUgZG9uZSBkdXJpbmcgc3RlcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGFkZFNwcmluZ1xyXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuYWRkU3ByaW5nID0gZnVuY3Rpb24gKHNwcmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3ByaW5ncyBjYW5ub3QgYmUgYWRkZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ByaW5ncy5wdXNoKHNwcmluZyk7XHJcbiAgICAgICAgYWRkU3ByaW5nRXZlbnQuc3ByaW5nID0gc3ByaW5nO1xyXG4gICAgICAgIHRoaXMuZW1pdChhZGRTcHJpbmdFdmVudCk7XHJcbiAgICAgICAgYWRkU3ByaW5nRXZlbnQuc3ByaW5nID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHNwcmluZy4gTm90ZSB0aGF0IHRoaXMgb3BlcmF0aW9uIGNhbid0IGJlIGRvbmUgZHVyaW5nIHN0ZXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVTcHJpbmdcclxuICAgICAqIEBwYXJhbSB7U3ByaW5nfSBzcHJpbmdcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLnJlbW92ZVNwcmluZyA9IGZ1bmN0aW9uIChzcHJpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGVwcGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwcmluZ3MgY2Fubm90IGJlIHJlbW92ZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxzXzEuZGVmYXVsdC5hcnJheVJlbW92ZSh0aGlzLnNwcmluZ3MsIHNwcmluZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBib2R5IHRvIHRoZSBzaW11bGF0aW9uLiBOb3RlIHRoYXQgeW91IGNhbid0IGFkZCBhIGJvZHkgZHVyaW5nIHN0ZXA6IHlvdSBoYXZlIHRvIHdhaXQgdW50aWwgYWZ0ZXIgdGhlIHN0ZXAgKHNlZSB0aGUgcG9zdFN0ZXAgZXZlbnQpLlxyXG4gICAgICogQWxzbyBub3RlIHRoYXQgYm9kaWVzIGNhbiBvbmx5IGJlIGFkZGVkIHRvIG9uZSBXb3JsZCBhdCBhIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRCb2R5XHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpLFxyXG4gICAgICogICAgICAgICBib2R5ID0gbmV3IEJvZHkoKTtcclxuICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2RpZXMgY2Fubm90IGJlIGFkZGVkIGR1cmluZyBzdGVwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbHJlYWR5IGFkZGVkP1xyXG4gICAgICAgIGlmIChib2R5LndvcmxkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9keSBpcyBhbHJlYWR5IGFkZGVkIHRvIGEgV29ybGQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5ib2RpZXMucHVzaChib2R5KTtcclxuICAgICAgICBib2R5LndvcmxkID0gdGhpcztcclxuICAgICAgICBhZGRCb2R5RXZlbnQuYm9keSA9IGJvZHk7XHJcbiAgICAgICAgdGhpcy5lbWl0KGFkZEJvZHlFdmVudCk7XHJcbiAgICAgICAgYWRkQm9keUV2ZW50LmJvZHkgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLiBOb3RlIHRoYXQgYm9kaWVzIGNhbm5vdCBiZSByZW1vdmVkIGR1cmluZyBzdGVwIChmb3IgZXhhbXBsZSwgaW5zaWRlIHRoZSBiZWdpbkNvbnRhY3QgZXZlbnQpLiBJbiB0aGF0IGNhc2UgeW91IG5lZWQgdG8gd2FpdCB1bnRpbCB0aGUgc3RlcCBpcyBkb25lIChzZWUgdGhlIHBvc3RTdGVwIGV2ZW50KS5cclxuICAgICAqXHJcbiAgICAgKiBBbHNvIG5vdGUgdGhhdCBhbnkgY29uc3RyYWludHMgY29ubmVjdGVkIHRvIHRoZSBib2R5IG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgdGhlIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5XHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciByZW1vdmVCb2R5O1xyXG4gICAgICogICAgIHdvcmxkLm9uKFwiYmVnaW5Db250YWN0XCIsZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICogICAgICAgICAvLyBXZSBjYW5ub3QgcmVtb3ZlIHRoZSBib2R5IGhlcmUgc2luY2UgdGhlIHdvcmxkIGlzIHN0aWxsIHN0ZXBwaW5nLlxyXG4gICAgICogICAgICAgICAvLyBJbnN0ZWFkLCBzY2hlZHVsZSB0aGUgYm9keSB0byBiZSByZW1vdmVkIGFmdGVyIHRoZSBzdGVwIGlzIGRvbmUuXHJcbiAgICAgKiAgICAgICAgIHJlbW92ZUJvZHkgPSBib2R5O1xyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHdvcmxkLm9uKFwicG9zdFN0ZXBcIixmdW5jdGlvbihldmVudCl7XHJcbiAgICAgKiAgICAgICAgIGlmKHJlbW92ZUJvZHkpe1xyXG4gICAgICogICAgICAgICAgICAgLy8gU2FmZWx5IHJlbW92ZSB0aGUgYm9keSBmcm9tIHRoZSB3b3JsZC5cclxuICAgICAqICAgICAgICAgICAgIHdvcmxkLnJlbW92ZUJvZHkocmVtb3ZlQm9keSk7XHJcbiAgICAgKiAgICAgICAgICAgICByZW1vdmVCb2R5ID0gbnVsbDtcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlcHBpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb2RpZXMgY2Fubm90IGJlIHJlbW92ZWQgZHVyaW5nIHN0ZXAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHdvdWxkIGl0IGJlIHNtYXJ0IHRvIGhhdmUgYSAuY29uc3RyYWludHMgYXJyYXkgb24gdGhlIGJvZHk/XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcclxuICAgICAgICB2YXIgbCA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50c1tsXS5ib2R5QSA9PT0gYm9keSB8fCBjb25zdHJhaW50c1tsXS5ib2R5QiA9PT0gYm9keSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIEJvZHkgZnJvbSBXb3JsZDogaXQgc3RpbGwgaGFzIGNvbnN0cmFpbnRzIGNvbm5lY3RlZCB0byBpdC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBib2R5LndvcmxkID0gbnVsbDtcclxuICAgICAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XHJcbiAgICAgICAgdXRpbHNfMS5kZWZhdWx0LmFycmF5UmVtb3ZlKGJvZGllcywgYm9keSk7XHJcbiAgICAgICAgYm9keS5pbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobC0tKSB7XHJcbiAgICAgICAgICAgIGJvZGllc1tsXS5pbmRleCA9IGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVtaXQgcmVtb3ZlQm9keSBldmVudFxyXG4gICAgICAgIHJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcclxuICAgICAgICBib2R5LnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KHJlbW92ZUJvZHlFdmVudCk7XHJcbiAgICAgICAgcmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBudWxsO1xyXG4gICAgICAgIC8vIFJlbW92ZSBkaXNhYmxlZCBib2R5IGNvbGxpc2lvbiBwYWlycyB0aGF0IGludm9sdmUgYm9keVxyXG4gICAgICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgcGFpcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChwYWlyc1tpXSA9PT0gYm9keSB8fCBwYWlyc1tpICsgMV0gPT09IGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIHBhaXJzLnNwbGljZShpLCAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGJvZHkgYnkgaXRzIGlkLlxyXG4gICAgICogQG1ldGhvZCBnZXRCb2R5QnlJZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkXHJcbiAgICAgKiBAcmV0dXJuIHtCb2R5fSBUaGUgYm9keSwgb3IgZmFsc2UgaWYgaXQgd2FzIG5vdCBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLmdldEJvZHlCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYi5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzXHJcbiAgICAgKiBAbWV0aG9kIGRpc2FibGVCb2R5Q29sbGlzaW9uXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXHJcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLnByb3RvdHlwZS5kaXNhYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzLnB1c2goYm9keUEpO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnMucHVzaChib2R5Qik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgY29sbGlzaW9ucyBiZXR3ZWVuIHRoZSBnaXZlbiB0d28gYm9kaWVzLCBpZiB0aGV5IHdlcmUgcHJldmlvdXNseSBkaXNhYmxlZCB1c2luZyAuZGlzYWJsZUJvZHlDb2xsaXNpb24oKS5cclxuICAgICAqIEBtZXRob2QgZW5hYmxlQm9keUNvbGxpc2lvblxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxyXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuZW5hYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcclxuICAgICAgICB2YXIgcGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgaWYgKChwYWlyc1tpXSA9PT0gYm9keUEgJiYgcGFpcnNbaSArIDFdID09PSBib2R5QikgfHwgKHBhaXJzW2kgKyAxXSA9PT0gYm9keUEgJiYgcGFpcnNbaV0gPT09IGJvZHlCKSkge1xyXG4gICAgICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksIDIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgYm9kaWVzLCBjb25zdHJhaW50cywgc3ByaW5ncywgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzIGZyb20gdGhlIHdvcmxkLlxyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBzb2x2ZXIgZXF1YXRpb25zXHJcbiAgICAgICAgdGhpcy5zb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjb25zdHJhaW50c1xyXG4gICAgICAgIHZhciBjcyA9IHRoaXMuY29uc3RyYWludHM7XHJcbiAgICAgICAgdmFyIGkgPSBjcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnN0cmFpbnQoY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGJvZGllc1xyXG4gICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcclxuICAgICAgICBpID0gYm9kaWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keShib2RpZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHNwcmluZ3NcclxuICAgICAgICB2YXIgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncztcclxuICAgICAgICBpID0gc3ByaW5ncy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNwcmluZyhzcHJpbmdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjb250YWN0IG1hdGVyaWFsc1xyXG4gICAgICAgIHZhciBjbXMgPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHM7XHJcbiAgICAgICAgaSA9IGNtcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRhY3RNYXRlcmlhbChjbXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYSB3b3JsZCBwb2ludCBvdmVybGFwcyBib2RpZXNcclxuICAgICAqIEBtZXRob2QgaGl0VGVzdFxyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnQgUG9pbnQgdG8gdXNlIGZvciBpbnRlcnNlY3Rpb24gdGVzdHNcclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBib2RpZXMgQSBsaXN0IG9mIG9iamVjdHMgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvblxyXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gVXNlZCBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBwYXJ0aWNsZXMgYW5kIGxpbmVzLiBBZGRzIHNvbWUgbWFyZ2luIHRvIHRoZXNlIGluZmluaXRlc2ltYWwgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBib2RpZXMgdGhhdCBvdmVybGFwIHRoZSBwb2ludFxyXG4gICAgICogQHRvZG8gU2hvdWxkIHVzZSBhbiBhcGkgc2ltaWxhciB0byB0aGUgcmF5Y2FzdCBmdW5jdGlvblxyXG4gICAgICogQHRvZG8gU2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBhIC5jb250YWluc1BvaW50IG1ldGhvZCBmb3IgYWxsIHNoYXBlcy4gV291bGQgYmUgbW9yZSBlZmZpY2llbnRcclxuICAgICAqIEB0b2RvIFNob3VsZCB1c2UgdGhlIGJyb2FkcGhhc2VcclxuICAgICAqIEB0b2RvIFJldHVybmluZyB0aGUgaGl0IHNoYXBlIHdvdWxkIGJlIGZpbmUgLSBpdCBjYXJyaWVzIGEgcmVmZXJlbmNlIHRvIHRoZSBib2R5IG5vd1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50LCBib2RpZXMsIHByZWNpc2lvbikge1xyXG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IHBhcnRpY2xlIGJvZHkgd2l0aCBhIHBhcnRpY2xlIHNoYXBlIHRvIHRlc3QgYWdhaW5zdCB0aGUgYm9kaWVzXHJcbiAgICAgICAgdmFyIHNoYXBlV29ybGRQb3NpdGlvbiA9IGhpdFRlc3RfdG1wMSwgc2hhcGVMb2NhbFBvaW50ID0gaGl0VGVzdF90bXAyO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAvLyBDaGVjayBib2RpZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZGllcy5sZW5ndGg7IGkgIT09IE47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIE5TID0gYm9keS5zaGFwZXMubGVuZ3RoOyBqICE9PSBOUzsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tqXTtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBsb2NhbCBwb2ludCBwb3NpdGlvbiBpbiB0aGUgc2hhcGVcclxuICAgICAgICAgICAgICAgIHNoYXBlLndvcmxkUG9pbnRUb0xvY2FsKHNoYXBlTG9jYWxQb2ludCwgd29ybGRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUucG9pbnRUZXN0KHNoYXBlTG9jYWxQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzJfMS5kZWZhdWx0LnJvdGF0ZShzaGFwZVdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyXzEuZGVmYXVsdC5hZGQoc2hhcGVXb3JsZFBvc2l0aW9uLCBzaGFwZVdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZS50eXBlID09PSBzaGFwZV8xLmRlZmF1bHQuUEFSVElDTEUgJiYgdmVjMl8xLmRlZmF1bHQuc3F1YXJlZERpc3RhbmNlKHNoYXBlV29ybGRQb3NpdGlvbiwgd29ybGRQb2ludCkgPCBwcmVjaXNpb24gKiBwcmVjaXNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN0aWZmbmVzcyBmb3IgYWxsIGVxdWF0aW9ucyBhbmQgY29udGFjdCBtYXRlcmlhbHMuXHJcbiAgICAgKiBAbWV0aG9kIHNldEdsb2JhbFN0aWZmbmVzc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsU3RpZmZuZXNzID0gZnVuY3Rpb24gKHN0aWZmbmVzcykge1xyXG4gICAgICAgIHNldEdsb2JhbEVxdWF0aW9uUGFyYW1zKHRoaXMsIHsgc3RpZmZuZXNzOiBzdGlmZm5lc3MgfSk7XHJcbiAgICAgICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcclxuICAgICAgICB2YXIgY29udGFjdE1hdGVyaWFscyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGNvbnRhY3RNYXRlcmlhbHNbaV07XHJcbiAgICAgICAgICAgIGMuc3RpZmZuZXNzID0gYy5mcmljdGlvblN0aWZmbmVzcyA9IHN0aWZmbmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2V0IGZvciBkZWZhdWx0IGNvbnRhY3QgbWF0ZXJpYWxcclxuICAgICAgICB2YXIgYyA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcclxuICAgICAgICBjLnN0aWZmbmVzcyA9IGMuZnJpY3Rpb25TdGlmZm5lc3MgPSBzdGlmZm5lc3M7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHJlbGF4YXRpb24gZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxyXG4gICAgICogQG1ldGhvZCBzZXRHbG9iYWxSZWxheGF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxyXG4gICAgICovXHJcbiAgICBXb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsUmVsYXhhdGlvbiA9IGZ1bmN0aW9uIChyZWxheGF0aW9uKSB7XHJcbiAgICAgICAgc2V0R2xvYmFsRXF1YXRpb25QYXJhbXModGhpcywgeyByZWxheGF0aW9uOiByZWxheGF0aW9uIH0pO1xyXG4gICAgICAgIC8vIFNldCBmb3IgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMuY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdE1hdGVyaWFsc1tpXTtcclxuICAgICAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxyXG4gICAgICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xyXG4gICAgICAgIGMucmVsYXhhdGlvbiA9IGMuZnJpY3Rpb25SZWxheGF0aW9uID0gcmVsYXhhdGlvbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJheSBjYXN0IGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgd29ybGQuXHJcbiAgICAgKiBAbWV0aG9kIHJheWNhc3RcclxuICAgICAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxyXG4gICAgICogQHBhcmFtICB7UmF5fSByYXlcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogICAgIHZhciByYXkgPSBuZXcgUmF5KHtcclxuICAgICAqICAgICAgICAgbW9kZTogUmF5LkNMT1NFU1QsIC8vIG9yIEFOWVxyXG4gICAgICogICAgICAgICBmcm9tOiBbMCwgMF0sXHJcbiAgICAgKiAgICAgICAgIHRvOiBbMTAsIDBdLFxyXG4gICAgICogICAgIH0pO1xyXG4gICAgICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xyXG4gICAgICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xyXG4gICAgICpcclxuICAgICAqICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxyXG4gICAgICogICAgIHZhciBoaXRQb2ludCA9IHZlYzIuY3JlYXRlKCk7XHJcbiAgICAgKiAgICAgcmVzdWx0LmdldEhpdFBvaW50KGhpdFBvaW50LCByYXkpO1xyXG4gICAgICogICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xyXG4gICAgICogICAgICAgICBtb2RlOiBSYXkuQUxMLFxyXG4gICAgICogICAgICAgICBmcm9tOiBbMCwgMF0sXHJcbiAgICAgKiAgICAgICAgIHRvOiBbMTAsIDBdLFxyXG4gICAgICogICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24ocmVzdWx0KXtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAvLyBQcmludCBzb21lIGluZm8gYWJvdXQgdGhlIGhpdFxyXG4gICAgICogICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpdCBib2R5IGFuZCBzaGFwZTogJywgcmVzdWx0LmJvZHksIHJlc3VsdC5zaGFwZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgICAgLy8gR2V0IHRoZSBoaXQgcG9pbnRcclxuICAgICAqICAgICAgICAgICAgIHZhciBoaXRQb2ludCA9IHZlYzIuY3JlYXRlKCk7XHJcbiAgICAgKiAgICAgICAgICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XHJcbiAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IHBvaW50OiAnLCBoaXRQb2ludFswXSwgaGl0UG9pbnRbMV0sICcgYXQgZGlzdGFuY2UgJyArIHJlc3VsdC5nZXRIaXREaXN0YW5jZShyYXkpKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAvLyBJZiB5b3UgYXJlIGhhcHB5IHdpdGggdGhlIGhpdHMgeW91IGdvdCB0aGlzIGZhciwgeW91IGNhbiBzdG9wIHRoZSB0cmF2ZXJzYWwgaGVyZTpcclxuICAgICAqICAgICAgICAgICAgIHJlc3VsdC5zdG9wKCk7XHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICB9KTtcclxuICAgICAqICAgICB2YXIgcmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcclxuICAgICAqICAgICB3b3JsZC5yYXljYXN0KHJlc3VsdCwgcmF5KTtcclxuICAgICAqL1xyXG4gICAgV29ybGQucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbiAocmVzdWx0LCByYXkpIHtcclxuICAgICAgICB2YXIgdG1wQUFCQiA9IG5ldyBhYWJiXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHZhciB0bXBBcnJheSA9IFtdO1xyXG4gICAgICAgIC8vIEdldCBhbGwgYm9kaWVzIHdpdGhpbiB0aGUgcmF5IEFBQkJcclxuICAgICAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTtcclxuICAgICAgICB0aGlzLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHRoaXMsIHRtcEFBQkIsIHRtcEFycmF5KTtcclxuICAgICAgICByYXkuaW50ZXJzZWN0Qm9kaWVzKHJlc3VsdCwgdG1wQXJyYXkpO1xyXG4gICAgICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNIaXQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5ldmVyIGRlYWN0aXZhdGUgYm9kaWVzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IE5PX1NMRUVQSU5HXHJcbiAgICAgKi9cclxuICAgIFdvcmxkLk5PX1NMRUVQSU5HID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xyXG4gICAgICovXHJcbiAgICBXb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogRGVhY3RpdmF0ZXMgYm9kaWVzIHRoYXQgYXJlIGluIGNvbnRhY3QsIGlmIGFsbCBvZiB0aGVtIGFyZSBzbGVlcHkuIE5vdGUgdGhhdCB5b3UgbXVzdCBlbmFibGUge3sjY3Jvc3NMaW5rIFwiV29ybGQvaXNsYW5kU3BsaXQ6cHJvcGVydHlcIn19LmlzbGFuZFNwbGl0e3svY3Jvc3NMaW5rfX0gZm9yIHRoaXMgdG8gd29yay5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJU0xBTkRfU0xFRVBJTkdcclxuICAgICAqL1xyXG4gICAgV29ybGQuSVNMQU5EX1NMRUVQSU5HID0gNDtcclxuICAgIHJldHVybiBXb3JsZDtcclxufShldmVudF9lbWl0dGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JsZDtcclxuIl19
(22)
});
